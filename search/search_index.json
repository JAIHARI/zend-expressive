{
    "docs": [
        {
            "location": "/",
            "text": "",
            "title": "Home"
        },
        {
            "location": "/v3/getting-started/features/",
            "text": "Overview\n\n\nExpressive allows you to write \nPSR-15\n\nmiddleware applications for the web.\n\n\nPSR-15 consumes \nPSR-7\n HTTP Message\nInterfaces; these are the incoming request and outgoing response for your\napplication. By using both PSR-15 and PSR-7, we ensure that your applications\nwill work in other contexts that are compatible with these standards.\n\n\nMiddleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.\n\n\nPSR-15 also defines \nrequest handlers\n; these are classes that receive a\nrequest and return a response, without delegating to other layers of the\napplication. These are generally the inner-most layers of your application.\n\n\nMiddleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.\n\n\nWith Expressive, you can build middleware applications such as the following:\n\n\n\n\nAPIs\n\n\nWebsites\n\n\nSingle Page Applications\n\n\nand more.\n\n\n\n\nFeatures\n\n\nExpressive builds on \nzend-stratigility\n\nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:\n\n\n\n\nRouting\n\n\n\n\nStratigility provides limited, literal matching only via its\n  \nPathMiddlewareDecorator\n. Expressive allows you to utilize dynamic routing\n  capabilities from a variety of routers, providing much more fine-grained\n  matching capabilities. The routing layer also allows restricting matched\n  routes to specific HTTP methods, and will return \"405 Not Allowed\" responses\n  with an \"Allow\" HTTP header containing allowed HTTP methods for invalid\n  requests.\n\n\nRouting is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-router.\n\n\n\n\nPSR-11 Container\n\n\n\n\nExpressive encourages the use of Dependency Injection, and defines its\n  \nApplication\n class to compose a \nPSR-11\n\n  \nContainerInterface\n instance. The container is used to lazy-load middleware,\n  whether it is piped (Stratigility interface) or routed (Expressive).\n\n\n\n\nTemplating\n\n\n\n\nWhile Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.\n\n\n\n\nError Handling\n\n\n\n\nApplications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own \nErrorHandler\n implementation, providing\n  specialized error response generators that can perform templating or use\n  Whoops.\n\n\nFlow Overview\n\n\nBelow is a diagram detailing the workflow used by Expressive.\n\n\n\n\nThe \nApplication\n acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.\n\n\nThe \nApplication\n dispatches each middleware. Each middleware receives a request\nand a delegate for handing off processing of the request should the middleware\nnot be able to fully process it itself. Internally, the delegate composes a\nqueue of middleware, and invokes the next in the queue when invoked.\n\n\nAny given middleware can return a \nresponse\n, at which point execution winds\nits way back out the onion.\n\n\n\n\nPipelines\n\n\nThe terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a \nqueue\n, which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:\n\n\n\n\nIn most cases, the entire queue \nwill not\n be traversed.\n\n\nThe inner-most layer of the onion represents the last item in the queue, and\n  should be guaranteed to return a response; usually this is indicative of\n  a malformed request (HTTP 400 response status) and/or inability to route\n  the middleware to a handler (HTTP 404 response status).\n\n\nResponses are returned back \nthrough\n the pipeline, in reverse order of\n  traversal.\n\n\n\n\nDouble pass middleware\n\n\nThe system described above is what is known as \nlambda middleware\n. Each\nmiddleware receives the request and a handler, and you pass only the\nrequest to the handler when wanting to hand off processing:\n\n\nfunction (ServerRequestInterface $request, RequestHandlerInterface $handler)\n{\n    $response = $handler->handle($request);\n    return $response->withHeader('X-Test', time());\n}\n\n\n\nIn Expressive 1.X, the default middleware style was what is known as \ndouble\npass\n middleware. Double pass middleware receives both the request and a\nresponse in addition to the handler, and passes both the request and response\nto the handler when invoking it:\n\n\nfunction (ServerRequestInterface $request, ResponseInterface $response, callable $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Test', time());\n}\n\n\n\nIt is termed \"double pass\" because you pass both the request and response when\ndelegating to the next layer.\n\n\nExpressive 3 no longer supports double-pass middleware directly. However, if\nyou decorate it using \nZend\\Stratigility\\doublePassMiddleware()\n, we can\nconsume it. That function requires first the double-pass middleware, and then\na response prototype (which will be passed as the \n$response\n argument to the\nmiddleware):\n\n\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\n$app->pipe(doublePassMiddleware(function ($request, $response, $next) {\n    // ...\n}, new Response()));\n\n\n\nIf you use double-pass middleware, \ndo not\n use the \n$response\n instance\npassed to it unless you are returning it specifically (e.g., because you are not\ndelegating to another layer).\n\n\n\n\nThe \nApplication\n allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.\n\n\nThe middleware pipeline is executed in the order of attachment.\n\n\nExpressive provides default implementations of \"routing\" and \"dispatch\"\nmiddleware, which you will attach to the middleware pipeline.  These are\nimplemented as the classes \nZend\\Expressive\\Router\\Middleware\\RouteMiddleware\n\nand \nZend\\Expressive\\Router\\Middleware\\DispatchMiddleware\n, respectively.\n\n\nRouting within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:\n\n\n\n\nmap a GET request to the path \n/api/ping\n to the \nPingMiddleware\n\n\nmap a POST request to the path \n/contact/process\n to the \nHandleContactMiddleware\n\n\netc.\n\n\n\n\nDispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation, or, as we\nprovide by default, handling \nHEAD\n and \nOPTIONS\n requests, or providing \n405\nMethod Not Allowed\n responses.\n\n\nThe majority of your application will consist of routing rules that map to\nrouted middleware and request handlers.\n\n\nMiddleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:\n\n\n\n\nbootstrapping\n\n\nparsing of request body parameters\n\n\naddition of debugging tools\n\n\nembedded middleware pipelines/application that you want to match at a given\n  literal path\n\n\netc.\n\n\n\n\nSuch middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.\n\n\nMiddleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:\n\n\n\n\nrouting failed\n\n\nrouted middleware called on the next middleware instead of returning a response.\n\n\n\n\nAs such, the largest use case for such middleware is to provide a \"default\"\nerror response for your application, usually as an HTTP 404 Not Found response.\n\n\nThe main points to remember are:\n\n\n\n\nThe application is a queue, and operates in FIFO order.\n\n\nEach middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.\n\n\nMost of the time, you will be defining \nrouted middleware\n, and the routing\n  rules that map to them.\n\n\nYou\n get to control the workflow of your application by deciding the order in\n  which middleware is queued.",
            "title": "Overview and Features"
        },
        {
            "location": "/v3/getting-started/features/#overview",
            "text": "Expressive allows you to write  PSR-15 \nmiddleware applications for the web.  PSR-15 consumes  PSR-7  HTTP Message\nInterfaces; these are the incoming request and outgoing response for your\napplication. By using both PSR-15 and PSR-7, we ensure that your applications\nwill work in other contexts that are compatible with these standards.  Middleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.  PSR-15 also defines  request handlers ; these are classes that receive a\nrequest and return a response, without delegating to other layers of the\napplication. These are generally the inner-most layers of your application.  Middleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.  With Expressive, you can build middleware applications such as the following:   APIs  Websites  Single Page Applications  and more.",
            "title": "Overview"
        },
        {
            "location": "/v3/getting-started/features/#features",
            "text": "Expressive builds on  zend-stratigility \nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:   Routing   Stratigility provides limited, literal matching only via its\n   PathMiddlewareDecorator . Expressive allows you to utilize dynamic routing\n  capabilities from a variety of routers, providing much more fine-grained\n  matching capabilities. The routing layer also allows restricting matched\n  routes to specific HTTP methods, and will return \"405 Not Allowed\" responses\n  with an \"Allow\" HTTP header containing allowed HTTP methods for invalid\n  requests.  Routing is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-router.   PSR-11 Container   Expressive encourages the use of Dependency Injection, and defines its\n   Application  class to compose a  PSR-11 \n   ContainerInterface  instance. The container is used to lazy-load middleware,\n  whether it is piped (Stratigility interface) or routed (Expressive).   Templating   While Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.   Error Handling   Applications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own  ErrorHandler  implementation, providing\n  specialized error response generators that can perform templating or use\n  Whoops.",
            "title": "Features"
        },
        {
            "location": "/v3/getting-started/features/#flow-overview",
            "text": "Below is a diagram detailing the workflow used by Expressive.   The  Application  acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.  The  Application  dispatches each middleware. Each middleware receives a request\nand a delegate for handing off processing of the request should the middleware\nnot be able to fully process it itself. Internally, the delegate composes a\nqueue of middleware, and invokes the next in the queue when invoked.  Any given middleware can return a  response , at which point execution winds\nits way back out the onion.",
            "title": "Flow Overview"
        },
        {
            "location": "/v3/getting-started/features/#pipelines",
            "text": "The terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a  queue , which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:   In most cases, the entire queue  will not  be traversed.  The inner-most layer of the onion represents the last item in the queue, and\n  should be guaranteed to return a response; usually this is indicative of\n  a malformed request (HTTP 400 response status) and/or inability to route\n  the middleware to a handler (HTTP 404 response status).  Responses are returned back  through  the pipeline, in reverse order of\n  traversal.",
            "title": "Pipelines"
        },
        {
            "location": "/v3/getting-started/features/#double-pass-middleware",
            "text": "The system described above is what is known as  lambda middleware . Each\nmiddleware receives the request and a handler, and you pass only the\nrequest to the handler when wanting to hand off processing:  function (ServerRequestInterface $request, RequestHandlerInterface $handler)\n{\n    $response = $handler->handle($request);\n    return $response->withHeader('X-Test', time());\n}  In Expressive 1.X, the default middleware style was what is known as  double\npass  middleware. Double pass middleware receives both the request and a\nresponse in addition to the handler, and passes both the request and response\nto the handler when invoking it:  function (ServerRequestInterface $request, ResponseInterface $response, callable $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Test', time());\n}  It is termed \"double pass\" because you pass both the request and response when\ndelegating to the next layer.  Expressive 3 no longer supports double-pass middleware directly. However, if\nyou decorate it using  Zend\\Stratigility\\doublePassMiddleware() , we can\nconsume it. That function requires first the double-pass middleware, and then\na response prototype (which will be passed as the  $response  argument to the\nmiddleware):  use function Zend\\Stratigility\\doublePassMiddleware;\n\n$app->pipe(doublePassMiddleware(function ($request, $response, $next) {\n    // ...\n}, new Response()));  If you use double-pass middleware,  do not  use the  $response  instance\npassed to it unless you are returning it specifically (e.g., because you are not\ndelegating to another layer).   The  Application  allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.  The middleware pipeline is executed in the order of attachment.  Expressive provides default implementations of \"routing\" and \"dispatch\"\nmiddleware, which you will attach to the middleware pipeline.  These are\nimplemented as the classes  Zend\\Expressive\\Router\\Middleware\\RouteMiddleware \nand  Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware , respectively.  Routing within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:   map a GET request to the path  /api/ping  to the  PingMiddleware  map a POST request to the path  /contact/process  to the  HandleContactMiddleware  etc.   Dispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation, or, as we\nprovide by default, handling  HEAD  and  OPTIONS  requests, or providing  405\nMethod Not Allowed  responses.  The majority of your application will consist of routing rules that map to\nrouted middleware and request handlers.  Middleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:   bootstrapping  parsing of request body parameters  addition of debugging tools  embedded middleware pipelines/application that you want to match at a given\n  literal path  etc.   Such middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.  Middleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:   routing failed  routed middleware called on the next middleware instead of returning a response.   As such, the largest use case for such middleware is to provide a \"default\"\nerror response for your application, usually as an HTTP 404 Not Found response.  The main points to remember are:   The application is a queue, and operates in FIFO order.  Each middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.  Most of the time, you will be defining  routed middleware , and the routing\n  rules that map to them.  You  get to control the workflow of your application by deciding the order in\n  which middleware is queued.",
            "title": "Double pass middleware"
        },
        {
            "location": "/v3/getting-started/quick-start/",
            "text": "Quick Start\n\n\nThe easiest way to get started with Expressive is to use the \nskeleton\napplication and installer\n.\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.\n\n\nCreate a new project\n\n\nFirst, we'll create a new project, using Composer's \ncreate-project\n command:\n\n\n$ composer create-project zendframework/zend-expressive-skeleton expressive\n\n\n\nThis will prompt you to choose:\n\n\n\n\n\n\nWhether to install a minimal skeleton (no default middleware), a flat\n  application structure (all code under \nsrc/\n), or a modular structure\n  (directories under \nsrc/\n are modules, each with source code and potentially\n  templates, configuration, assets, etc.). The default is a \"flat\" structure;\n  you can always add modules to it later.\n\n\n\n\n\n\nA dependency injection container. We recommend using the default,\n  zend-servicemanager.\n\n\n\n\n\n\nA router. We recommend using the default, FastRoute.\n\n\n\n\n\n\nA template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.\n\n\n\n\n\n\nAn error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.\n\n\n\n\n\n\nStart a web server\n\n\nThe Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using \nbuilt-in web\nserver\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ composer run --timeout=0 serve\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\n\n\nSetting a timeout\n\n\nComposer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the \nphp -S\n command that \ncomposer serve\n spawns continues running\nas a background process, but on other systems halts when the timeout occurs.\n\n\nAs such, we recommend running the \nserve\n script using a timeout. This can\nbe done by using \ncomposer run\n to execute the \nserve\n script, with a\n\n--timeout\n option. When set to \n0\n, as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via\n\nCtrl-C\n). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:\n\n\n$ composer run --timeout=86400 serve\n\n\n\n\n\nDevelopment Tools\n\n\nWe ship tools in our skeleton application to make development easier.\n\n\nDevelopment Mode\n\n\nzf-development-mode\n allows\nyou to enable and disable development mode from your cli.\n\n\n$ composer development-enable  # enable development mode\n$ composer development-disable # disable development mode\n$ composer development-status  # show development status\n\n\n\nThe development configuration is set in \nconfig/autoload/development.local.php.dist\n.\nIt also allows you to specify configuration and modules that should only be enabled\nwhen in development, and not when in production.\n\n\nClear config cache\n\n\nProduction settings are the default, which means enabling the configuration cache.\nHowever, it must be easy for developers to clear the configuration cache. That's\nwhat this command does.\n\n\n$ composer clear-config-cache\n\n\n\nTesting Your Code\n\n\nPHPUnit\n and\n\nPHP_CodeSniffer\n are now\ninstalled by default. To execute tests and detect coding standards violations,\nrun the following command:\n\n\n$ composer check\n\n\n\nSecurity Advisories\n\n\nWe have included the \nsecurity-advisories\n\npackage to notify you about installed dependencies with known security\nvulnerabilities. Each time you run \ncomposer update\n, \ncomposer install\n, or\n\ncomposer require\n, it prevents installation of software with known and\ndocumented security issues.\n\n\nTooling integration\n\n\nThe skeleton ships with \nzend-expressive-tooling\n\nby default, and integrates with it by exposing it via composer:\n\n\n$ composer expressive\n\n\n\nThe tooling provides a number of commands; see the \nCLI tooling\nchapter\n for more details.\n\n\nModules\n\n\nComposer will prompt you during installation to ask if you want a minimal\napplication (no structure or default middleware provided), flat application (all\nsource code under the same tree, and the default selection), or modular\napplication. This latter option allows you to segregate discrete areas of\napplication functionality into \nmodules\n, which can contain source code,\ntemplates, assets, and more; these can later be repackaged for re-use if\ndesired.\n\n\nSupport for modules is available via the\n\nzend-component-installer\n\nand \nzend-config-aggregator\n\npackages; the \nzend-expressive-tooling\n.\npackage provides tools for creating and manipulating modules in your\napplication.\n\n\nComponent Installer\n\n\nWhenever you add a component or module that exposes itself as such, the\n\nzend-component-installer\n\ncomposer plugin will prompt you, asking if and where you want to inject its\nconfiguration. This ensures that components are wired automatically for you.\n\n\nIn most cases, you will choose to inject in the \nconfig/config.php\n file; for\ntools intended only for usage during development, choose\n\nconfig/development.config.php.dist\n.\n\n\nConfig Aggregator\n\n\nThe \nzend-config-aggregator\n\nlibrary collects and merges configuration from different sources. It also supports\nconfiguration caching.\n\n\nAs an example, your \nconfig/config.php\n file might read as follows in order to\naggregate configuration from development mode settings, application\nconfiguration, and theoretical \nUser\n, \nBlog\n, and \nApp\n modules:\n\n\n<?php // config/config.php\n\n$aggregator = new ConfigAggregator([\n    // Module configuration\n    App\\ConfigProvider::class,\n    BlogModule\\ConfigProvider::class,\n    UserModule\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], 'data/config-cache.php');\n\nreturn $aggregator->getMergedConfig();\n\n\n\nThe configuration is merged in the same order as it is passed, with later entries\nhaving precedence.\n\n\nConfig Providers\n\n\nConfigAggregator\n works by aggregating \"Config Providers\" passed to its\nconstructor. Each provider should be a callable class that requires no\nconstructor parameters, where invocation returns a configuration array (or a PHP\ngenerator) to be merged.\n\n\nLibraries or modules can have configuration providers that provide default values\nfor a library or module. For the \nUserModule\\ConfigProvider\n class loaded in the\n\nConfigAggregator\n above, the \nConfigProvider\n might look like this:\n\n\n<?php\n\nnamespace UserModule;\n\nclass ConfigProvider\n{\n    /**\n     * Returns the configuration array\n     *\n     * To add some sort of a structure, each section is defined in a separate\n     * method which returns an array with its configuration.\n     *\n     * @return array\n     */\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'users'        => $this->getConfig(),\n        ];\n    }\n\n    /**\n     * Returns the container dependencies\n     *\n     * @return array\n     */\n    public function getDependencies() : array\n    {\n        return [\n            'factories'  => [\n                Action\\LoginAction::class =>\n                    Factory\\Action\\LoginActionFactory::class,\n\n                Middleware\\AuthenticationMiddleware::class =>\n                    Factory\\Middleware\\AuthenticationMiddlewareFactory::class,\n            ],\n        ];\n    }\n\n    /**\n     * Returns the default module configuration\n     *\n     * @return array\n     */\n    public function getConfig() : array\n    {\n        return [\n            'paths' => [\n                'enable_registration' => true,\n                'enable_username'     => false,\n                'enable_display_name' => true,\n            ],\n        ];\n    }\n}\n\n\n\nexpressive module commands\n\n\nTo aid in the creation, registration, and deregistration of modules in your\napplication, you can use the CLI tooling provided by default. All commands are\nexposed via \ncomposer expressive\n, and include the following:\n\n\n\n\ncomposer expressive module:create <modulename>\n will create the default\n  directory structure for the named module, create a \nConfigProvider\n for the\n  module, add an autoloading rule to \ncomposer.json\n, and register the\n  \nConfigProvider\n with the application configuration.\n\n\ncomposer expressive module:register <modulename>\n will add an autoloading rule to\n  \ncomposer.json\n for the module, and register its \nConfigProvider\n, if found,\n  with the application configuration.\n\n\nexpressive module:deregister <modulename>\n will remove any autoloading rules\n  for the module from \ncomposer.json\n, and deregister its \nConfigProvider\n, if\n  found, from the application configuration.\n\n\n\n\nAdding Middleware\n\n\nThe skeleton makes the assumption that you will be writing your middleware as\nclasses, and uses \npiping and routing\n to add\nyour middleware.\n\n\nPiping\n\n\nPiping\n is a foundation feature of the\nunderlying \nzend-stratigility\n\nimplementation. You can setup the middleware pipeline in \nconfig/pipeline.php\n.\nIn this section, we'll demonstrate setting up a basic pipeline that includes\nerror handling, segregated applications, routing, middleware dispatch, and more.\n\n\nThe error handler should be the first (most outer) middleware to catch all\nexceptions.\n\n\n$app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);\n\n\n\nAfter the \nErrorHandler\n you can pipe more middleware that you want to execute\non every request, such as bootstrapping, pre-conditions, and modifications to\noutgoing responses:\n\n\n$app->pipe(ServerUrlMiddleware::class);\n\n\n\nPiped middleware may be callables, middleware instances, or service names.\nMiddleware may also be passed as an array; each item in the array must resolve\nto middleware eventually (i.e., callable or service name); underneath,\nExpressive creates \nZend\\Stratigility\\MiddlewarePipe\n instances with each of the\nmiddleware listed piped to it.\n\n\nMiddleware can be attached to specific paths, allowing you to mix and match\napplications under a common domain. The handlers in each middleware attached\nthis way will see a URI with the \nMATCHED PATH SEGMENT REMOVED!!!\n\n\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n\n\nNext, you should register the routing middleware in the middleware pipeline:\n\n\n$app->pipe(RouteMiddleware::class);\n\n\n\nAdd more middleware that needs to introspect the routing results; this might\ninclude:\n\n\n\n\nhandling for HTTP \nHEAD\n requests\n\n\nhandling for HTTP \nOPTIONS\n requests\n\n\nhandling for matched paths where the HTTP method is not allowed\n\n\nmiddleware for handling URI generation\n\n\nroute-based authentication\n\n\nroute-based validation\n\n\netc.\n\n\n\n\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(MethodNotAllowedMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n\n\n\nNext, register the dispatch middleware in the middleware pipeline:\n\n\n$app->pipe(DispatchMiddleware::class);\n\n\n\nAt this point, if no response is return by any middleware, we need to provide a\nway of notifying the user of this; by default, we use the \nNotFoundHandler\n, but\nyou can provide any other fallback middleware you wish:\n\n\n$app->pipe(NotFoundHandler::class);\n\n\n\nThe \npublic/index.php\n file will \nrequire\n the \nconfig/pipeline.php\n file, and\n\ninvoke\n the returned result. When it invokes it, it passes the application\ninstance, a \nZend\\Expressive\\MiddlewareFactory\n instance, and the PSR-11\ncontainer you are using.\n\n\nThe full example then looks something like this:\n\n\n// In config/pipeline.php:\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    $app->pipe(ErrorHandler::class);\n    $app->pipe(ServerUrlMiddleware::class);\n\n    // These assume that the variables listed are defined in this scope:\n    $app->pipe('/api', $apiMiddleware);\n    $app->pipe('/docs', $apiDocMiddleware);\n    $app->pipe('/files', $filesMiddleware);\n\n    $app->pipe(RouteMiddleware::class);\n    $app->pipe(ImplicitHeadMiddleware::class);\n    $app->pipe(ImplicitOptionsMiddleware::class);\n    $app->pipe(MethodNotAllowedMiddleware::class);\n    $app->pipe(UrlHelperMiddleware::class);\n    $app->pipe(DispatchMiddleware::class);\n\n    $app->pipe(NotFoundHandler::class);\n};\n\n\n\nRouting\n\n\nRouting\n is an additional feature\nprovided by Expressive. Routing is setup in \nconfig/routes.php\n.\n\n\nYou can setup routes with a single request method:\n\n\n$app->get('/', App\\Action\\HomePageAction::class, 'home');\n$app->post('/album', App\\Action\\AlbumCreateAction::class, 'album.create');\n$app->put('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.put');\n$app->patch('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.patch');\n$app->delete('/album/:id', App\\Action\\AlbumDeleteAction::class, 'album.delete');\n\n\n\nOr with multiple request methods:\n\n\n$app->route('/contact', App\\Action\\ContactAction::class, ['GET', 'POST', ...], 'contact');\n\n\n\nOr handling all request methods:\n\n\n$app->any('/contact', App\\Action\\ContactAction::class)->setName('contact');\n\n\n\nAlternately, to be explicit, the above could be written as:\n\n\n$app->route(\n  '/contact',\n  App\\Action\\ContactAction::class,\n  Zend\\Expressive\\Router\\Route::HTTP_METHOD_ANY,\n  'contact'\n);\n\n\n\nWe recommend a single middleware class per combination of route and request\nmethod.\n\n\nSimilar to the \nconfig/pipeline.php\n file, the \nconfig/routes.php\n file is\nexpected to return a callable:\n\n\n// In config/routes.php:\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    $app->get('/books', \\App\\Handler\\ListBooksHandler::class, 'books');\n};\n\n\n\nNext Steps\n\n\nThe skeleton provides a default structure for templates, if you choose to use them.\nLet's see how you can create your first vanilla middleware, and templated middleware.\n\n\nCreating middleware\n\n\nMiddleware must implement \nPsr\\Http\\Server\\MiddlewareInterface\n; this interface\ndefines a single method, \nprocess()\n, which accepts a\n\nPsr\\Http\\Message\\ServerRequestInterface\n instance and a\n\nPsr\\Http\\Server\\RequestHandlerInterface\n instance, and returns a\n\nPsr\\Http\\Message\\ResponseInterface\n instance. Write middleware when you may\nwant to delegate to another layer of the application in order to create a\nresponse; do this by calling the \nhandle()\n method of the handler passed to it.\n\nGenerally speaking, you will write middleware when you want to conditionally\nreturn a response based on the request, and/or alter the response returned by\nanother layer of the application\n.\n\n\nThe skeleton defines an \nApp\n namespace for you; you can place middleware\nanywhere within it.\n\n\nWe'll create a simple middleware here that will run on every request, and alter\nthe response to add a header.\n\n\nWe can use our tooling to create the middleware file:\n\n\n$ composer expressive middleware:create \"App\\XClacksOverheadMiddleware\"\n\n\n\nThis command will create a PSR-15 middleware implementation, a factory for it,\nand register the two in the application's container configuration. It tells you\nthe location of both files.\n\n\nNow let's edit the middleware class file. Replace the contents of the\n\nprocess()\n method with:\n\n\n$response = $handler->handle($request);\nreturn $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n\n\n\nNow that we've created our middleware, we still have to tell the pipeline about\nit. Open the file \nconfig/pipeline.php\n file, and find the line that read:\n\n\n$app->pipe(ErrorHandler::class);\n\n\n\nAdd the following line after it:\n\n\n$app->pipe(App\\XClacksOverheadMiddleware::class);\n\n\n\nIf you browse to the home page (or any other page, for that matter) and\nintrospect the headers returned with the response using your browser's\ndevelopment tools, you'll now see the following entry:\n\n\nX-Clacks-Overhead: GNU Terry Pratchett\n\n\n\nYou've created your first middleware!\n\n\nCreating request handlers\n\n\nYou may route to either middleware or request handlers. In this section, we'll\ndefine a request handler and route to it.\n\n\nRequest handlers must implement \nPsr\\Http\\Server\\RequestHandlerInterface\n; this\ninterface defines a single method, \nhandle()\n, which accepts a\n\nPsr\\Http\\Message\\ServerRequestInterface\n instance and returns a\n\nPsr\\Http\\Message\\ResponseInterface\n instance. Write request handlers when you\nwill \nnot\n be delegating to another layer of the application, and will be\ncreating and returning a response directly. \nGenerally speaking, you will route\nto request handlers\n.\n\n\nThe skeleton defines an \nApp\n namespace for you, and suggests placing request\nhandlers under the namespace \nApp\\Handler\n.\n\n\nLet's create a \"Hello\" request handler. We can use our tooling to create the\nfile:\n\n\n$ composer expressive handler:create \"App\\Handler\\HelloHandler\"\n\n\n\nThe command will tell you the location in the filesystem in which it created the\nnew class; it will also create a factory for you, and register that factory with\nthe container! Additionally, if you have a template renderer in place, it will\ncreate a template file for you. make a note of the locations of both the class\nfile and template file.\n\n\nOpen the class file, and now let's edit the \nhandle()\n contents to read as\nfollows:\n\n\n$target = $request->getQueryParams()['target'] ?? 'World';\n$target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\nreturn new HtmlResponse($this->renderer->render(\n    'app::hello',\n    ['target' => $target]\n));\n\n\n\n\n\nTemplateless handler\n\n\nIf you did not select a template engine when creating your application, the\ncontents of your \nhandle()\n method will be empty to begin.\n\n\nIn that case, alter the above example as follows:\n\n\n\n\nAdd the statement \nuse Zend\\Diactoros\\Response\\HtmlResponse;\n to the \nuse\n\n  statements at the top of the file.\n\n\nAlter the response creation to read:\n  \nreturn new HtmlResponse(sprintf(\n    '<h1>Hello %s</h1>',\n    $target\n));\n\n\n\n\nYou can also skip the next step below where we edit the template file.\n\n\n\n\nThe above looks for a query string parameter \"target\", and uses its value to\nprovide to the template, which is then rendered and returned in an HTML\nresponse.\n\n\nNow, let's edit the template file to have the one of the following header lines\n(use the one for your chosen template renderer):\n\n\n\n\n\n\nPlates\n  \n<!-- plates -->\n<h1>Hello <?= $this->e($target) ?></h1>\n\n\n\n\n\n\nzend-view\n  \n<!-- zend-view -->\n<h1>Hello <?= $this->target ?></h1>\n\n\n\n\n\n\nTwig\n  \n<!-- twig -->\n<h1>Hello {{ target }}</h1>\n\n\n\n\n\n\nWhile the handler is registered with the container, the application does not yet\nknow how to get to it. Let's fix that.\n\n\nOpen the file \nconfig/routes.php\n, and add the following at the bottom of\nthe function it exposes:\n\n\n$app->get('/hello', App\\Handler\\HelloHandler::class, 'hello');\n\n\n\nOnce you've completed the above, give it a try by going to each of the\nfollowing URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYou should see the message change as you go between the two URIs!\n\n\nCongratulations!\n\n\nCongratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:\n\n\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling",
            "title": "Quick Start"
        },
        {
            "location": "/v3/getting-started/quick-start/#quick-start",
            "text": "The easiest way to get started with Expressive is to use the  skeleton\napplication and installer .\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.",
            "title": "Quick Start"
        },
        {
            "location": "/v3/getting-started/quick-start/#create-a-new-project",
            "text": "First, we'll create a new project, using Composer's  create-project  command:  $ composer create-project zendframework/zend-expressive-skeleton expressive  This will prompt you to choose:    Whether to install a minimal skeleton (no default middleware), a flat\n  application structure (all code under  src/ ), or a modular structure\n  (directories under  src/  are modules, each with source code and potentially\n  templates, configuration, assets, etc.). The default is a \"flat\" structure;\n  you can always add modules to it later.    A dependency injection container. We recommend using the default,\n  zend-servicemanager.    A router. We recommend using the default, FastRoute.    A template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.    An error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.",
            "title": "Create a new project"
        },
        {
            "location": "/v3/getting-started/quick-start/#start-a-web-server",
            "text": "The Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using  built-in web\nserver .  From the project root directory, execute the following:  $ composer run --timeout=0 serve  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!",
            "title": "Start a web server"
        },
        {
            "location": "/v3/getting-started/quick-start/#setting-a-timeout",
            "text": "Composer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the  php -S  command that  composer serve  spawns continues running\nas a background process, but on other systems halts when the timeout occurs.  As such, we recommend running the  serve  script using a timeout. This can\nbe done by using  composer run  to execute the  serve  script, with a --timeout  option. When set to  0 , as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via Ctrl-C ). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:  $ composer run --timeout=86400 serve",
            "title": "Setting a timeout"
        },
        {
            "location": "/v3/getting-started/quick-start/#development-tools",
            "text": "We ship tools in our skeleton application to make development easier.",
            "title": "Development Tools"
        },
        {
            "location": "/v3/getting-started/quick-start/#development-mode",
            "text": "zf-development-mode  allows\nyou to enable and disable development mode from your cli.  $ composer development-enable  # enable development mode\n$ composer development-disable # disable development mode\n$ composer development-status  # show development status  The development configuration is set in  config/autoload/development.local.php.dist .\nIt also allows you to specify configuration and modules that should only be enabled\nwhen in development, and not when in production.",
            "title": "Development Mode"
        },
        {
            "location": "/v3/getting-started/quick-start/#clear-config-cache",
            "text": "Production settings are the default, which means enabling the configuration cache.\nHowever, it must be easy for developers to clear the configuration cache. That's\nwhat this command does.  $ composer clear-config-cache",
            "title": "Clear config cache"
        },
        {
            "location": "/v3/getting-started/quick-start/#testing-your-code",
            "text": "PHPUnit  and PHP_CodeSniffer  are now\ninstalled by default. To execute tests and detect coding standards violations,\nrun the following command:  $ composer check",
            "title": "Testing Your Code"
        },
        {
            "location": "/v3/getting-started/quick-start/#security-advisories",
            "text": "We have included the  security-advisories \npackage to notify you about installed dependencies with known security\nvulnerabilities. Each time you run  composer update ,  composer install , or composer require , it prevents installation of software with known and\ndocumented security issues.",
            "title": "Security Advisories"
        },
        {
            "location": "/v3/getting-started/quick-start/#tooling-integration",
            "text": "The skeleton ships with  zend-expressive-tooling \nby default, and integrates with it by exposing it via composer:  $ composer expressive  The tooling provides a number of commands; see the  CLI tooling\nchapter  for more details.",
            "title": "Tooling integration"
        },
        {
            "location": "/v3/getting-started/quick-start/#modules",
            "text": "Composer will prompt you during installation to ask if you want a minimal\napplication (no structure or default middleware provided), flat application (all\nsource code under the same tree, and the default selection), or modular\napplication. This latter option allows you to segregate discrete areas of\napplication functionality into  modules , which can contain source code,\ntemplates, assets, and more; these can later be repackaged for re-use if\ndesired.  Support for modules is available via the zend-component-installer \nand  zend-config-aggregator \npackages; the  zend-expressive-tooling .\npackage provides tools for creating and manipulating modules in your\napplication.",
            "title": "Modules"
        },
        {
            "location": "/v3/getting-started/quick-start/#component-installer",
            "text": "Whenever you add a component or module that exposes itself as such, the zend-component-installer \ncomposer plugin will prompt you, asking if and where you want to inject its\nconfiguration. This ensures that components are wired automatically for you.  In most cases, you will choose to inject in the  config/config.php  file; for\ntools intended only for usage during development, choose config/development.config.php.dist .",
            "title": "Component Installer"
        },
        {
            "location": "/v3/getting-started/quick-start/#config-aggregator",
            "text": "The  zend-config-aggregator \nlibrary collects and merges configuration from different sources. It also supports\nconfiguration caching.  As an example, your  config/config.php  file might read as follows in order to\naggregate configuration from development mode settings, application\nconfiguration, and theoretical  User ,  Blog , and  App  modules:  <?php // config/config.php\n\n$aggregator = new ConfigAggregator([\n    // Module configuration\n    App\\ConfigProvider::class,\n    BlogModule\\ConfigProvider::class,\n    UserModule\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], 'data/config-cache.php');\n\nreturn $aggregator->getMergedConfig();  The configuration is merged in the same order as it is passed, with later entries\nhaving precedence.",
            "title": "Config Aggregator"
        },
        {
            "location": "/v3/getting-started/quick-start/#config-providers",
            "text": "ConfigAggregator  works by aggregating \"Config Providers\" passed to its\nconstructor. Each provider should be a callable class that requires no\nconstructor parameters, where invocation returns a configuration array (or a PHP\ngenerator) to be merged.  Libraries or modules can have configuration providers that provide default values\nfor a library or module. For the  UserModule\\ConfigProvider  class loaded in the ConfigAggregator  above, the  ConfigProvider  might look like this:  <?php\n\nnamespace UserModule;\n\nclass ConfigProvider\n{\n    /**\n     * Returns the configuration array\n     *\n     * To add some sort of a structure, each section is defined in a separate\n     * method which returns an array with its configuration.\n     *\n     * @return array\n     */\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'users'        => $this->getConfig(),\n        ];\n    }\n\n    /**\n     * Returns the container dependencies\n     *\n     * @return array\n     */\n    public function getDependencies() : array\n    {\n        return [\n            'factories'  => [\n                Action\\LoginAction::class =>\n                    Factory\\Action\\LoginActionFactory::class,\n\n                Middleware\\AuthenticationMiddleware::class =>\n                    Factory\\Middleware\\AuthenticationMiddlewareFactory::class,\n            ],\n        ];\n    }\n\n    /**\n     * Returns the default module configuration\n     *\n     * @return array\n     */\n    public function getConfig() : array\n    {\n        return [\n            'paths' => [\n                'enable_registration' => true,\n                'enable_username'     => false,\n                'enable_display_name' => true,\n            ],\n        ];\n    }\n}",
            "title": "Config Providers"
        },
        {
            "location": "/v3/getting-started/quick-start/#expressive-module-commands",
            "text": "To aid in the creation, registration, and deregistration of modules in your\napplication, you can use the CLI tooling provided by default. All commands are\nexposed via  composer expressive , and include the following:   composer expressive module:create <modulename>  will create the default\n  directory structure for the named module, create a  ConfigProvider  for the\n  module, add an autoloading rule to  composer.json , and register the\n   ConfigProvider  with the application configuration.  composer expressive module:register <modulename>  will add an autoloading rule to\n   composer.json  for the module, and register its  ConfigProvider , if found,\n  with the application configuration.  expressive module:deregister <modulename>  will remove any autoloading rules\n  for the module from  composer.json , and deregister its  ConfigProvider , if\n  found, from the application configuration.",
            "title": "expressive module commands"
        },
        {
            "location": "/v3/getting-started/quick-start/#adding-middleware",
            "text": "The skeleton makes the assumption that you will be writing your middleware as\nclasses, and uses  piping and routing  to add\nyour middleware.",
            "title": "Adding Middleware"
        },
        {
            "location": "/v3/getting-started/quick-start/#piping",
            "text": "Piping  is a foundation feature of the\nunderlying  zend-stratigility \nimplementation. You can setup the middleware pipeline in  config/pipeline.php .\nIn this section, we'll demonstrate setting up a basic pipeline that includes\nerror handling, segregated applications, routing, middleware dispatch, and more.  The error handler should be the first (most outer) middleware to catch all\nexceptions.  $app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);  After the  ErrorHandler  you can pipe more middleware that you want to execute\non every request, such as bootstrapping, pre-conditions, and modifications to\noutgoing responses:  $app->pipe(ServerUrlMiddleware::class);  Piped middleware may be callables, middleware instances, or service names.\nMiddleware may also be passed as an array; each item in the array must resolve\nto middleware eventually (i.e., callable or service name); underneath,\nExpressive creates  Zend\\Stratigility\\MiddlewarePipe  instances with each of the\nmiddleware listed piped to it.  Middleware can be attached to specific paths, allowing you to mix and match\napplications under a common domain. The handlers in each middleware attached\nthis way will see a URI with the  MATCHED PATH SEGMENT REMOVED!!!  $app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);  Next, you should register the routing middleware in the middleware pipeline:  $app->pipe(RouteMiddleware::class);  Add more middleware that needs to introspect the routing results; this might\ninclude:   handling for HTTP  HEAD  requests  handling for HTTP  OPTIONS  requests  handling for matched paths where the HTTP method is not allowed  middleware for handling URI generation  route-based authentication  route-based validation  etc.   $app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(MethodNotAllowedMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);  Next, register the dispatch middleware in the middleware pipeline:  $app->pipe(DispatchMiddleware::class);  At this point, if no response is return by any middleware, we need to provide a\nway of notifying the user of this; by default, we use the  NotFoundHandler , but\nyou can provide any other fallback middleware you wish:  $app->pipe(NotFoundHandler::class);  The  public/index.php  file will  require  the  config/pipeline.php  file, and invoke  the returned result. When it invokes it, it passes the application\ninstance, a  Zend\\Expressive\\MiddlewareFactory  instance, and the PSR-11\ncontainer you are using.  The full example then looks something like this:  // In config/pipeline.php:\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    $app->pipe(ErrorHandler::class);\n    $app->pipe(ServerUrlMiddleware::class);\n\n    // These assume that the variables listed are defined in this scope:\n    $app->pipe('/api', $apiMiddleware);\n    $app->pipe('/docs', $apiDocMiddleware);\n    $app->pipe('/files', $filesMiddleware);\n\n    $app->pipe(RouteMiddleware::class);\n    $app->pipe(ImplicitHeadMiddleware::class);\n    $app->pipe(ImplicitOptionsMiddleware::class);\n    $app->pipe(MethodNotAllowedMiddleware::class);\n    $app->pipe(UrlHelperMiddleware::class);\n    $app->pipe(DispatchMiddleware::class);\n\n    $app->pipe(NotFoundHandler::class);\n};",
            "title": "Piping"
        },
        {
            "location": "/v3/getting-started/quick-start/#routing",
            "text": "Routing  is an additional feature\nprovided by Expressive. Routing is setup in  config/routes.php .  You can setup routes with a single request method:  $app->get('/', App\\Action\\HomePageAction::class, 'home');\n$app->post('/album', App\\Action\\AlbumCreateAction::class, 'album.create');\n$app->put('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.put');\n$app->patch('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.patch');\n$app->delete('/album/:id', App\\Action\\AlbumDeleteAction::class, 'album.delete');  Or with multiple request methods:  $app->route('/contact', App\\Action\\ContactAction::class, ['GET', 'POST', ...], 'contact');  Or handling all request methods:  $app->any('/contact', App\\Action\\ContactAction::class)->setName('contact');  Alternately, to be explicit, the above could be written as:  $app->route(\n  '/contact',\n  App\\Action\\ContactAction::class,\n  Zend\\Expressive\\Router\\Route::HTTP_METHOD_ANY,\n  'contact'\n);  We recommend a single middleware class per combination of route and request\nmethod.  Similar to the  config/pipeline.php  file, the  config/routes.php  file is\nexpected to return a callable:  // In config/routes.php:\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    $app->get('/books', \\App\\Handler\\ListBooksHandler::class, 'books');\n};",
            "title": "Routing"
        },
        {
            "location": "/v3/getting-started/quick-start/#next-steps",
            "text": "The skeleton provides a default structure for templates, if you choose to use them.\nLet's see how you can create your first vanilla middleware, and templated middleware.",
            "title": "Next Steps"
        },
        {
            "location": "/v3/getting-started/quick-start/#creating-middleware",
            "text": "Middleware must implement  Psr\\Http\\Server\\MiddlewareInterface ; this interface\ndefines a single method,  process() , which accepts a Psr\\Http\\Message\\ServerRequestInterface  instance and a Psr\\Http\\Server\\RequestHandlerInterface  instance, and returns a Psr\\Http\\Message\\ResponseInterface  instance. Write middleware when you may\nwant to delegate to another layer of the application in order to create a\nresponse; do this by calling the  handle()  method of the handler passed to it. Generally speaking, you will write middleware when you want to conditionally\nreturn a response based on the request, and/or alter the response returned by\nanother layer of the application .  The skeleton defines an  App  namespace for you; you can place middleware\nanywhere within it.  We'll create a simple middleware here that will run on every request, and alter\nthe response to add a header.  We can use our tooling to create the middleware file:  $ composer expressive middleware:create \"App\\XClacksOverheadMiddleware\"  This command will create a PSR-15 middleware implementation, a factory for it,\nand register the two in the application's container configuration. It tells you\nthe location of both files.  Now let's edit the middleware class file. Replace the contents of the process()  method with:  $response = $handler->handle($request);\nreturn $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');  Now that we've created our middleware, we still have to tell the pipeline about\nit. Open the file  config/pipeline.php  file, and find the line that read:  $app->pipe(ErrorHandler::class);  Add the following line after it:  $app->pipe(App\\XClacksOverheadMiddleware::class);  If you browse to the home page (or any other page, for that matter) and\nintrospect the headers returned with the response using your browser's\ndevelopment tools, you'll now see the following entry:  X-Clacks-Overhead: GNU Terry Pratchett  You've created your first middleware!",
            "title": "Creating middleware"
        },
        {
            "location": "/v3/getting-started/quick-start/#creating-request-handlers",
            "text": "You may route to either middleware or request handlers. In this section, we'll\ndefine a request handler and route to it.  Request handlers must implement  Psr\\Http\\Server\\RequestHandlerInterface ; this\ninterface defines a single method,  handle() , which accepts a Psr\\Http\\Message\\ServerRequestInterface  instance and returns a Psr\\Http\\Message\\ResponseInterface  instance. Write request handlers when you\nwill  not  be delegating to another layer of the application, and will be\ncreating and returning a response directly.  Generally speaking, you will route\nto request handlers .  The skeleton defines an  App  namespace for you, and suggests placing request\nhandlers under the namespace  App\\Handler .  Let's create a \"Hello\" request handler. We can use our tooling to create the\nfile:  $ composer expressive handler:create \"App\\Handler\\HelloHandler\"  The command will tell you the location in the filesystem in which it created the\nnew class; it will also create a factory for you, and register that factory with\nthe container! Additionally, if you have a template renderer in place, it will\ncreate a template file for you. make a note of the locations of both the class\nfile and template file.  Open the class file, and now let's edit the  handle()  contents to read as\nfollows:  $target = $request->getQueryParams()['target'] ?? 'World';\n$target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\nreturn new HtmlResponse($this->renderer->render(\n    'app::hello',\n    ['target' => $target]\n));",
            "title": "Creating request handlers"
        },
        {
            "location": "/v3/getting-started/quick-start/#templateless-handler",
            "text": "If you did not select a template engine when creating your application, the\ncontents of your  handle()  method will be empty to begin.  In that case, alter the above example as follows:   Add the statement  use Zend\\Diactoros\\Response\\HtmlResponse;  to the  use \n  statements at the top of the file.  Alter the response creation to read:\n   return new HtmlResponse(sprintf(\n    '<h1>Hello %s</h1>',\n    $target\n));   You can also skip the next step below where we edit the template file.   The above looks for a query string parameter \"target\", and uses its value to\nprovide to the template, which is then rendered and returned in an HTML\nresponse.  Now, let's edit the template file to have the one of the following header lines\n(use the one for your chosen template renderer):    Plates\n   <!-- plates -->\n<h1>Hello <?= $this->e($target) ?></h1>    zend-view\n   <!-- zend-view -->\n<h1>Hello <?= $this->target ?></h1>    Twig\n   <!-- twig -->\n<h1>Hello {{ target }}</h1>    While the handler is registered with the container, the application does not yet\nknow how to get to it. Let's fix that.  Open the file  config/routes.php , and add the following at the bottom of\nthe function it exposes:  $app->get('/hello', App\\Handler\\HelloHandler::class, 'hello');  Once you've completed the above, give it a try by going to each of the\nfollowing URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   You should see the message change as you go between the two URIs!",
            "title": "Templateless handler"
        },
        {
            "location": "/v3/getting-started/quick-start/#congratulations",
            "text": "Congratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:   Containers  Routing  Templating  Error Handling",
            "title": "Congratulations!"
        },
        {
            "location": "/v3/features/middleware-types/",
            "text": "Middleware Types\n\n\nExpressive allows you to compose applications out of \npipeline\n and \nrouted\n\nmiddleware.\n\n\nPipeline\n middleware is middleware that defines the workflow of your\napplication. These generally run on every execution of the application, and\ninclude such aspects as:\n\n\n\n\nError handling\n\n\nLocale detection\n\n\nSession setup\n\n\nAuthentication and authorization\n\n\n\n\nRouted\n middleware is middleware that responds only to specific URI paths and\nHTTP methods. As an example, you might want middleware that only responds to\nHTTP POST requests to the path \n/users\n.\n\n\nExpressive allows you to define middleware using any of the following:\n\n\n\n\nPSR-15 middleware\n instances.\n\n\nPSR-15 request handler\n instances.\n\n\nService names resolving to one of the above middleware types.\n\n\nCallable middleware that implements the PSR-15 \nMiddlewareInterface\n signature.\n\n\nMiddleware pipelines expressed as arrays of the above middleware types.\n\n\n\n\nPSR-15 middleware\n\n\nThe PSR-15 specification covers HTTP server middleware and request handlers that\nconsume \nPSR-7\n HTTP messages. Expressive\naccepts both middleware that implements the \nMiddlewareInterface\n and request\nhandlers that implement \nRequestHandlerInterface\n. As an example:\n\n\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass SomeMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // do something and return a response, or\n        // delegate to another request handler capable\n        // of returning a response via:\n        //\n        // return $handler->handle($request);\n    }\n}\n\n\n\nYou could also implement such middleware via an anonymous class.\n\n\nCallable middleware\n\n\nSometimes you may not want to create a class for one-off middleware. As such,\nExpressive allows you to provide a PHP callable that uses the same signature as\n\nPsr\\Http\\Server\\MiddlewareInterface\n:\n\n\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n{\n    // do something and return a response, or\n    // delegate to another request handler capable\n    // of returning a response via:\n    //\n    // return $handler->handle($request);\n}\n\n\n\nOne note: neither argument \nrequire\n a typehint, and examples throughout the\nmanual will omit the typehints when demonstrating callable middleware.\n\n\nService-based middleware\n\n\nWe encourage the use of a dependency injection container for providing your\nmiddleware. As such, Expressive also allows you to use \nservice names\n for both\npipeline and routed middleware. Generally, service names will be the specific\nmiddleware class names, but can be any valid string that resolves to a service.\n\n\nWhen Expressive is provided a service name for middleware, it internally\ndecorates the middleware in a \nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n\ninstance, allowing it to be loaded only when dispatched.\n\n\nMiddleware pipelines\n\n\nExpressive allows any pipeline or routed middleware to be self-contained\n\nmiddleware pipelines\n.\nTo prevent the need for instantiating a \nZend\\Stratigility\\MiddlewarePipe\n\ninstance when defining the pipeline, Expressive allows you to provide an array\nof middleware:\n\n\n// Pipeline middleware:\n$app->pipe([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n// Routed middleware:\n$app->get('/foo', [\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n\n\nThe values in these arrays may be any valid middleware type as defined in this\nchapter.",
            "title": "Middleware Types"
        },
        {
            "location": "/v3/features/middleware-types/#middleware-types",
            "text": "Expressive allows you to compose applications out of  pipeline  and  routed \nmiddleware.  Pipeline  middleware is middleware that defines the workflow of your\napplication. These generally run on every execution of the application, and\ninclude such aspects as:   Error handling  Locale detection  Session setup  Authentication and authorization   Routed  middleware is middleware that responds only to specific URI paths and\nHTTP methods. As an example, you might want middleware that only responds to\nHTTP POST requests to the path  /users .  Expressive allows you to define middleware using any of the following:   PSR-15 middleware  instances.  PSR-15 request handler  instances.  Service names resolving to one of the above middleware types.  Callable middleware that implements the PSR-15  MiddlewareInterface  signature.  Middleware pipelines expressed as arrays of the above middleware types.",
            "title": "Middleware Types"
        },
        {
            "location": "/v3/features/middleware-types/#psr-15-middleware",
            "text": "The PSR-15 specification covers HTTP server middleware and request handlers that\nconsume  PSR-7  HTTP messages. Expressive\naccepts both middleware that implements the  MiddlewareInterface  and request\nhandlers that implement  RequestHandlerInterface . As an example:  use Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass SomeMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // do something and return a response, or\n        // delegate to another request handler capable\n        // of returning a response via:\n        //\n        // return $handler->handle($request);\n    }\n}  You could also implement such middleware via an anonymous class.",
            "title": "PSR-15 middleware"
        },
        {
            "location": "/v3/features/middleware-types/#callable-middleware",
            "text": "Sometimes you may not want to create a class for one-off middleware. As such,\nExpressive allows you to provide a PHP callable that uses the same signature as Psr\\Http\\Server\\MiddlewareInterface :  use Psr\\Http\\Server\\RequestHandlerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n{\n    // do something and return a response, or\n    // delegate to another request handler capable\n    // of returning a response via:\n    //\n    // return $handler->handle($request);\n}  One note: neither argument  require  a typehint, and examples throughout the\nmanual will omit the typehints when demonstrating callable middleware.",
            "title": "Callable middleware"
        },
        {
            "location": "/v3/features/middleware-types/#service-based-middleware",
            "text": "We encourage the use of a dependency injection container for providing your\nmiddleware. As such, Expressive also allows you to use  service names  for both\npipeline and routed middleware. Generally, service names will be the specific\nmiddleware class names, but can be any valid string that resolves to a service.  When Expressive is provided a service name for middleware, it internally\ndecorates the middleware in a  Zend\\Expressive\\Middleware\\LazyLoadingMiddleware \ninstance, allowing it to be loaded only when dispatched.",
            "title": "Service-based middleware"
        },
        {
            "location": "/v3/features/middleware-types/#middleware-pipelines",
            "text": "Expressive allows any pipeline or routed middleware to be self-contained middleware pipelines .\nTo prevent the need for instantiating a  Zend\\Stratigility\\MiddlewarePipe \ninstance when defining the pipeline, Expressive allows you to provide an array\nof middleware:  // Pipeline middleware:\n$app->pipe([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n// Routed middleware:\n$app->get('/foo', [\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);  The values in these arrays may be any valid middleware type as defined in this\nchapter.",
            "title": "Middleware pipelines"
        },
        {
            "location": "/v3/features/application/",
            "text": "Applications\n\n\nIn zend-expressive, you define a \nZend\\Expressive\\Application\n instance and\nexecute it. The \nApplication\n instance is itself \nmiddleware\n\nthat composes:\n\n\n\n\na \nZend\\Expressive\\MiddlewareFactory\n instance, used to prepare middleware\n  arguments to pipe into:\n\n\na \nZend\\Stratigility\\MiddlewarePipe\n instance, representing the application\n  middleware pipeline.\n\n\na \nZend\\Expressive\\Router\\RouteCollector\n instance, used to create\n  \nZend\\Expressive\\Router\\Route\n instances based on a combination of paths and\n  HTTP methods, and which also injects created instances into the application's\n  router.\n\n\na \nZend\\HttpHandlerRunner\\RequestHandlerRunner\n instance which will ultimately\n  be responsible for marshaling the incoming request, passing it to the\n  \nMiddlewarePipe\n, and emitting the response.\n\n\n\n\nYou can define the \nApplication\n instance in two ways:\n\n\n\n\nDirect instantiation, which requires providing several dependencies.\n\n\nVia a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.\n\n\n\n\nRegardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.\n\n\nInstantiation\n\n\nConstructor\n\n\nIf you wish to manually instantiate the \nApplication\n instance, it has the\nfollowing constructor:\n\n\npublic function __construct(\n    Zend\\Expressive\\MiddlewareFactory $factory,\n    Zend\\Stratigility\\MiddlewarePipeInterface $pipeline,\n    Zend\\Expressive\\Router\\RouteCollector $routes,\n    Zend\\HttpHandlerRunner\\RequestHandlerRunner $runner\n) {\n\n\n\nContainer factory\n\n\nWe also provide a factory that can be consumed by a \nPSR-11\n\ndependency injection container; see the \ncontainer factories documentation\n\nfor details.\n\n\nAdding routable middleware\n\n\nWe \ndiscuss routing vs piping elsewhere\n; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.\n\n\nRegardless of which \nrouter implementation\n you use, you\ncan use the following \nApplication\n methods to provide routable middleware:\n\n\nroute()\n\n\nroute()\n has the following signature:\n\n\npublic function route(\n    string $path,\n    $middleware,\n    array $methods = null,\n    string $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nwhere:\n\n\n\n\n$path\n must be a string path to match.\n\n\n$middleware\n \nmust\n be:\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class that represents a\n  PSR-15 \nMiddlewareInterface\n or \nRequestHandlerInterface\n instance;\n\n\nan array of any of the above; these will be composed in order into a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\n\n\n$methods\n must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.\n\n\n$name\n is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on \nroute naming\n\n  for details.\n\n\n\n\nThis method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.\n\n\nget(), post(), put(), patch(), delete(), any()\n\n\nEach of the methods \nget()\n, \npost()\n, \nput()\n, \npatch()\n, \ndelete()\n, and \nany()\n\nproxies to \nroute()\n and has the signature:\n\n\nfunction (\n    string $path,\n    $middleware,\n    string $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nEssentially, each calls \nroute()\n and specifies an array consisting solely of\nthe corresponding HTTP method for the \n$methods\n argument.\n\n\nPiping\n\n\nBecause zend-expressive builds on \nzend-stratigility\n,\nand, more specifically, its \nMiddlewarePipe\n definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.\n\n\nThe signature of \npipe()\n is:\n\n\npublic function pipe($middlewareOrPath, $middleware = null)\n\n\n\nwhere:\n\n\n\n\n$middlewareOrPath\n is either a string URI path (for path segregation), PSR-15\n  \nMiddlewareInterface\n or \nRequestHandlerInterface\n, or the service name for a\n  middleware or request handler to fetch from the composed container.\n\n\n$middleware\n is required if \n$middlewareOrPath\n is a string URI path. It can\n  be one of:\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class that represents a\n  PSR-15 \nMiddlewareInterface\n or \nRequestHandlerInterface\n instance;\n\n\nan array of any of the above; these will be composed in order into a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\n\n\n\n\nUnlike \nZend\\Stratigility\\MiddlewarePipe\n, \nApplication::pipe()\n \nallows\nfetching middleware and request handlers by service name\n. This facility allows\nlazy-loading of middleware only when it is invoked. Internally, it wraps the\ncall to fetch and dispatch the middleware inside a\n\nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n instance.\n\n\nRead the section on \npiping vs routing\n for more information.\n\n\nRegistering routing and dispatch middleware\n\n\nRouting and dispatch middleware must be piped to the application like any other\nmiddleware. You can do so using the following:\n\n\n$app->pipe(Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class);\n$app->pipe(Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class);\n\n\n\nWe recommend piping the following middleware between the two as well:\n\n\n$app->pipe(Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::class);\n$app->pipe(Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware::class);\n$app->pipe(Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware::class);\n\n\n\nThese allow your application to return:\n\n\n\n\nHEAD\n requests for handlers that do not specifically allow \nHEAD\n; these will\n  return with a 200 status, and any headers normally returned with a \nGET\n\n  request.\n\n\nOPTIONS\n requests for handlers that do not specifically allow \nOPTIONS\n;\n  these will return with a 200 status, and an \nAllow\n header indicating all\n  allowed HTTP methods for the given route match.\n\n\n405 statuses when the route matches, but not the HTTP method; these will also\n  include an \nAllow\n header indicating all allowed HTTP methods.\n\n\n\n\nSee the section on \npiping\n to see how you can register\nnon-routed middleware and create layered middleware applications.\n\n\nExecuting the application: run()\n\n\nWhen the application is completely setup, you can execute it with the \nrun()\n\nmethod. The method proxies to the underlying \nRequestHandlerRunner\n, which will\ncreate a PSR-7 server request instance, pass it to the composed middleware\npipeline, and then emit the response returned.",
            "title": "Applications"
        },
        {
            "location": "/v3/features/application/#applications",
            "text": "In zend-expressive, you define a  Zend\\Expressive\\Application  instance and\nexecute it. The  Application  instance is itself  middleware \nthat composes:   a  Zend\\Expressive\\MiddlewareFactory  instance, used to prepare middleware\n  arguments to pipe into:  a  Zend\\Stratigility\\MiddlewarePipe  instance, representing the application\n  middleware pipeline.  a  Zend\\Expressive\\Router\\RouteCollector  instance, used to create\n   Zend\\Expressive\\Router\\Route  instances based on a combination of paths and\n  HTTP methods, and which also injects created instances into the application's\n  router.  a  Zend\\HttpHandlerRunner\\RequestHandlerRunner  instance which will ultimately\n  be responsible for marshaling the incoming request, passing it to the\n   MiddlewarePipe , and emitting the response.   You can define the  Application  instance in two ways:   Direct instantiation, which requires providing several dependencies.  Via a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.   Regardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.",
            "title": "Applications"
        },
        {
            "location": "/v3/features/application/#instantiation",
            "text": "",
            "title": "Instantiation"
        },
        {
            "location": "/v3/features/application/#constructor",
            "text": "If you wish to manually instantiate the  Application  instance, it has the\nfollowing constructor:  public function __construct(\n    Zend\\Expressive\\MiddlewareFactory $factory,\n    Zend\\Stratigility\\MiddlewarePipeInterface $pipeline,\n    Zend\\Expressive\\Router\\RouteCollector $routes,\n    Zend\\HttpHandlerRunner\\RequestHandlerRunner $runner\n) {",
            "title": "Constructor"
        },
        {
            "location": "/v3/features/application/#container-factory",
            "text": "We also provide a factory that can be consumed by a  PSR-11 \ndependency injection container; see the  container factories documentation \nfor details.",
            "title": "Container factory"
        },
        {
            "location": "/v3/features/application/#adding-routable-middleware",
            "text": "We  discuss routing vs piping elsewhere ; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.  Regardless of which  router implementation  you use, you\ncan use the following  Application  methods to provide routable middleware:",
            "title": "Adding routable middleware"
        },
        {
            "location": "/v3/features/application/#route",
            "text": "route()  has the following signature:  public function route(\n    string $path,\n    $middleware,\n    array $methods = null,\n    string $name = null\n) : Zend\\Expressive\\Router\\Route  where:   $path  must be a string path to match.  $middleware   must  be:  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class that represents a\n  PSR-15  MiddlewareInterface  or  RequestHandlerInterface  instance;  an array of any of the above; these will be composed in order into a\n   Zend\\Stratigility\\MiddlewarePipe  instance.    $methods  must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.  $name  is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on  route naming \n  for details.   This method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.",
            "title": "route()"
        },
        {
            "location": "/v3/features/application/#get-post-put-patch-delete-any",
            "text": "Each of the methods  get() ,  post() ,  put() ,  patch() ,  delete() , and  any() \nproxies to  route()  and has the signature:  function (\n    string $path,\n    $middleware,\n    string $name = null\n) : Zend\\Expressive\\Router\\Route  Essentially, each calls  route()  and specifies an array consisting solely of\nthe corresponding HTTP method for the  $methods  argument.",
            "title": "get(), post(), put(), patch(), delete(), any()"
        },
        {
            "location": "/v3/features/application/#piping",
            "text": "Because zend-expressive builds on  zend-stratigility ,\nand, more specifically, its  MiddlewarePipe  definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.  The signature of  pipe()  is:  public function pipe($middlewareOrPath, $middleware = null)  where:   $middlewareOrPath  is either a string URI path (for path segregation), PSR-15\n   MiddlewareInterface  or  RequestHandlerInterface , or the service name for a\n  middleware or request handler to fetch from the composed container.  $middleware  is required if  $middlewareOrPath  is a string URI path. It can\n  be one of:  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class that represents a\n  PSR-15  MiddlewareInterface  or  RequestHandlerInterface  instance;  an array of any of the above; these will be composed in order into a\n   Zend\\Stratigility\\MiddlewarePipe  instance.     Unlike  Zend\\Stratigility\\MiddlewarePipe ,  Application::pipe()   allows\nfetching middleware and request handlers by service name . This facility allows\nlazy-loading of middleware only when it is invoked. Internally, it wraps the\ncall to fetch and dispatch the middleware inside a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware  instance.  Read the section on  piping vs routing  for more information.",
            "title": "Piping"
        },
        {
            "location": "/v3/features/application/#registering-routing-and-dispatch-middleware",
            "text": "Routing and dispatch middleware must be piped to the application like any other\nmiddleware. You can do so using the following:  $app->pipe(Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class);\n$app->pipe(Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class);  We recommend piping the following middleware between the two as well:  $app->pipe(Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::class);\n$app->pipe(Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware::class);\n$app->pipe(Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware::class);  These allow your application to return:   HEAD  requests for handlers that do not specifically allow  HEAD ; these will\n  return with a 200 status, and any headers normally returned with a  GET \n  request.  OPTIONS  requests for handlers that do not specifically allow  OPTIONS ;\n  these will return with a 200 status, and an  Allow  header indicating all\n  allowed HTTP methods for the given route match.  405 statuses when the route matches, but not the HTTP method; these will also\n  include an  Allow  header indicating all allowed HTTP methods.   See the section on  piping  to see how you can register\nnon-routed middleware and create layered middleware applications.",
            "title": "Registering routing and dispatch middleware"
        },
        {
            "location": "/v3/features/application/#executing-the-application-run",
            "text": "When the application is completely setup, you can execute it with the  run() \nmethod. The method proxies to the underlying  RequestHandlerRunner , which will\ncreate a PSR-7 server request instance, pass it to the composed middleware\npipeline, and then emit the response returned.",
            "title": "Executing the application: run()"
        },
        {
            "location": "/v3/features/container/intro/",
            "text": "Containers\n\n\nExpressive promotes and advocates the usage of\n\nDependency Injection\n/\nInversion of Control\n\n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:\n\n\n\n\n\n\nDefining \napplication\n dependencies: routers, template engines, error\n  handlers, even the \nApplication\n instance itself.\n\n\n\n\n\n\nDefining \nmiddleware\n and related dependencies.\n\n\n\n\n\n\nThe application skeleton wires together dependency configuration, which is then\nused to create a container. This in turn is used to seed a\n\nZend\\Expressive\\MiddlewareContainer\n for purposes of retrieving middleware for\nthe \nApplication\n instance (via another intermediary,\n\nZend\\Expressive\\MiddlewareFactory\n). When the application is ready to execute\nmiddleware or a handler, it will fetch it from the container. This approach\nencourages the idea of defining middleware-specific dependencies, and factories\nfor ensuring they are injected.\n\n\nTo facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against \nPSR-11 Container\n,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.\n\n\nAt this time, we document support for the following specific containers:\n\n\n\n\nzend-servicemanager\n\n\npimple-interop\n\n\naura.di\n\n\n\n\n\n\nService Names\n\n\nWe recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.\n\n\nFollowing these practices encourages the following:\n\n\n\n\nConsumers have a reasonable idea of what the service should return.\n\n\nUsing interface names as service names promotes re-use and substitution.\n\n\n\n\nIn a few cases, we define \"virtual service\" names. These are cases where there is no\nclear typehint to follow. For example, we may want to imply specific\nconfiguration is necessary; \nWhoops\n requires\nspecific configuration to work correctly with Expressive, and thus we do not\nwant a generic service name for it. We try to keep these to a minimum, however.",
            "title": "Introduction"
        },
        {
            "location": "/v3/features/container/intro/#containers",
            "text": "Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control \n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:    Defining  application  dependencies: routers, template engines, error\n  handlers, even the  Application  instance itself.    Defining  middleware  and related dependencies.    The application skeleton wires together dependency configuration, which is then\nused to create a container. This in turn is used to seed a Zend\\Expressive\\MiddlewareContainer  for purposes of retrieving middleware for\nthe  Application  instance (via another intermediary, Zend\\Expressive\\MiddlewareFactory ). When the application is ready to execute\nmiddleware or a handler, it will fetch it from the container. This approach\nencourages the idea of defining middleware-specific dependencies, and factories\nfor ensuring they are injected.  To facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against  PSR-11 Container ,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.  At this time, we document support for the following specific containers:   zend-servicemanager  pimple-interop  aura.di",
            "title": "Containers"
        },
        {
            "location": "/v3/features/container/intro/#service-names",
            "text": "We recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.  Following these practices encourages the following:   Consumers have a reasonable idea of what the service should return.  Using interface names as service names promotes re-use and substitution.   In a few cases, we define \"virtual service\" names. These are cases where there is no\nclear typehint to follow. For example, we may want to imply specific\nconfiguration is necessary;  Whoops  requires\nspecific configuration to work correctly with Expressive, and thus we do not\nwant a generic service name for it. We try to keep these to a minimum, however.",
            "title": "Service Names"
        },
        {
            "location": "/v3/features/container/factories/",
            "text": "Provided Factories\n\n\nExpressive provides several factories compatible with\n\nPSR-11 Container\n to facilitate\nsetting up common dependencies. The following is a list of provided\nfactories, what they will create, the suggested service name, and any\nadditional dependencies they may require.\n\n\nzend-expressive\n\n\nThe zend-expressive package ships \nZend\\Expressive\\ConfigProvider\n, which\ndefines configuration that references each of these factories, using the\nsuggested names; this provider is registered by default when using the skeleton\napplication.\n\n\nAll factories, unless noted otherwise, are in the \nZend\\Expressive\\Container\n\nnamespace, and define an \n__invoke()\n method that accepts an\n\nPsr\\Container\\ContainerInterface\n instance as the sole argument.\n\n\nApplicationFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Application\n\n\nSuggested Name\n: \nZend\\Expressive\\Application\n\n\nRequires\n:\n\n\nZend\\Expressive\\MiddlewareFactory\n\n\nZend\\Expressive\\ApplicationPipeline\n, which should resolve to a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\nZend\\Expressive\\Router\\RouteCollector\n\n\nZend\\HttpHandlerRunner\\RequestHandlerRunner\n\n\n\n\n\n\nOptional\n: no optional services are used.\n\n\n\n\nApplicationPipelineFactory\n\n\n\n\nProvides\n: a \nZend\\Stratigility\\MiddlewarePipe\n for use with the\n  \nApplication\n instance.\n\n\nSuggested Name\n: \nZend\\Expressive\\ApplicationPipeline\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n: no optional services are used.\n\n\n\n\nEmitterFactory\n\n\n\n\nProvides\n: \nZend\\HttpHandlerRunner\\Emitter\\EmitterInterface\n\n\nSuggested Name\n: \nZend\\HttpHandlerRunner\\Emitter\\EmitterInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n: no optional services are used.\n\n\n\n\nThis factory creates an instance of\n\nZend\\HttpHandlerRunner\\Emitter\\EmitterStack\n, pushing a\n\nZend\\HttpHandlerRunner\\Emitter\\SapiEmitter\n to it.\n\n\nErrorHandlerFactory\n\n\n\n\nProvides\n: \nZend\\Stratigility\\Middleware\\ErrorHandler\n\n\nSuggested Name\n: \nZend\\Stratigility\\Middleware\\ErrorHandler\n\n\nRequires\n:\n\n\nPsr\\Http\\Message\\ResponseInterface\n, which should resolve to a \ncallable\n\n  capable of producing a \nResponseInterface\n instance (and not directly to an\n  instance itself)\n\n\n\n\n\n\nOptional\n:\n\n\nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n. If not provided, the error\n  handler will not compose an error response generator, making it largely\n  useless other than to provide an empty response.\n\n\n\n\n\n\n\n\nErrorResponseGeneratorFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n\n\nSuggested Name\n: \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nErrorResponseGenerator\n instance with a template name to use for errors (see\n  more below), and/or a \"debug\" flag value.\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the\n  error response generator will provide a plain text response instead of a\n  templated one.\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize two values:\n\n\n\n\ndebug\n, a flag indicating whether or not to provide debug information when\n  creating an error response.\n\n\nzend-expressive.error_handler.template_error\n, a name of an alternate\n  template to use (instead of the default represented in the\n  \nZend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT\n\n  constant, which evaluates to \nerror::error\n).\n\n\nSince 3.1.0\n: \nzend-expressive.error_handler.layout\n, a name of an\n  alternate layout to use (instead of the default represented in the\n  \nZend\\Expressive\\Middleware\\ErrorResponseGenerator::LAYOUT_DEFAULT\n constant,\n  which evaluates to \nlayout::default\n).\n\n\n\n\nAs an example:\n\n\n'debug' => true,\n'zend-expressive' => [\n    'error_handler' => [\n        'template_error' => 'name of error template',\n        'layout' => 'layout::alternate',\n    ],\n],\n\n\n\nMiddlewareContainerFactory\n\n\n\n\nProvides\n: a \nZend\\Expressive\\MiddlewareContainer\n\n\nSuggested Name\n: \nZend\\Expressive\\MiddlewareContainer\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n: no optional services are used.\n\n\n\n\nThis factory returns an instance of \nZend\\Expressive\\MiddlewareContainer\n\ninjected with the container instance itself.\n\n\nThe \nMiddlewareContainer\n is a PSR-11 container itself, but ensures that\ninstances pulled are PSR-15 \nMiddlewareInterface\n instances:\n\n\n\n\nIt decorates PSR-15 \nRequestHandlerInterface\n instances using \nZend\\Stratigility\\RequestHandlerMiddleware\n.\n\n\nIf a requested service is not in the underlying PSR-11 container, but the\n  class exists, it will attempt to instantiate it directly.\n\n\nAny service retrieved that is not a \nMiddlewareInterface\n instance will result\n  in an exception, ensuring that nothing invalid is piped or routed.\n\n\n\n\nMiddlewareFactoryFactory\n\n\n\n\nProvides\n: a \nZend\\Expressive\\MiddlewareFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\MiddlewareFactory\n\n\nRequires\n:\n\n\nZend\\Expressive\\MiddlewareContainer\n\n\n\n\n\n\nOptional\n: no optional services are used.\n\n\n\n\nThe \nMiddlewareFactory\n is used by \nZend\\Expressive\\Application\n to prepare\n\n$middleware\n arguments to \npipe()\n, \nroute()\n, et al, ensuring they are\n\nMiddlewareInterface\n implementations. It handles the following types:\n\n\n\n\nMiddlewareInterface\n types are considered valid always.\n\n\nRequestHandlerInterface\n types are decorated using \nZend\\Stratigility\\Middleware\\RequestHandlerMiddleware\n.\n\n\ncallable\n types are decorated using \nZend\\Stratigility\\middleware()\n.\n\n\nstring\n types are decorated using a \nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n\n  instance (which will also receive the \nMiddlewareContainer.\n)\n\n\nOr an \narray\n of any of the above types.\n\n\n\n\nNotFoundHandlerFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Handler\\NotFoundHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\Handler\\NotFoundHandler\n\n\nRequires\n:\n\n\nPsr\\Http\\Message\\ResponseInterface\n, which should resolve to a \ncallable\n\n  capable of producing a \nResponseInterface\n instance (and not directly to an\n  instance itself)\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nNotFoundHandler\n instance with a template name to use.\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the\n  handler will provide a plain text response instead of a templated one.\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize two values:\n\n\n\n\n\n\nzend-expressive.error_handler.template_404\n, a name of an alternate\n  template to use (instead of the default represented in the\n  \nZend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT\n constant, which\n  evaluates to \nerror::404\n).\n\n\n\n\n\n\nzend-expressive.error_handler.layout\n, a name of an alternate\n  template to use (instead of the default represented in the\n  \nZend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT\n constant, which\n  evaluates to \nlayout::default\n).\n\n\n\n\n\n\nAs an example:\n\n\n'zend-expressive' => [\n    'error_handler' => [\n        'template_404' => 'name of 404 template',\n        'layout' => 'layout::alternate',\n    ],\n],\n\n\n\nRequestHandlerRunnerFactory\n\n\n\n\nProvides\n: \nZend\\HttpHandler\\RequestHandlerRunner\n\n\nSuggested Name\n: \nZend\\HttpHandler\\RequestHandlerRunner\n\n\nRequires\n:\n\n\nZend\\Expressive\\ApplicationPipeline\n, which should resolve to the\n  \nZend\\Stratigility\\MiddlewarePipe\n instance the \nApplication\n will use.\n\n\nZend\\HttpHandlerRunner\\Emitter\\EmitterInterface\n\n\nPsr\\Http\\Message\\ServerRequestInterface\n,  which should resolve to a\n  \ncallable\n capable of producing a \nServerRequestInterface\n instance (and\n  not directly to an instance itself)\n\n\nZend\\Expressive\\Response\\ServerRequestErrorResponseGenerator\n\n\n\n\n\n\nOptional\n: no optional services are used.\n\n\n\n\nThis factory generates the \nRequestHandlerRunner\n instance used by the\n\nApplication\n instance to \"run\" the application. It marshals a request instance,\npasses it to the application pipeline to handle, and emits the returned\nresponse. If an error occurs during request generation, it uses the\n\nServerRequestErrorResponseGenerator\n to generate the response to emit.\n\n\nResponseFactoryFactory\n\n\n\n\nProvides\n: a PHP callable capable of producing\n  \nPsr\\Http\\Message\\ResponseInterface\n instances.\n\n\nSuggested Name\n: \nPsr\\Http\\Message\\ResponseInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n: no optional services are used.\n\n\n\n\nBy default, this uses zend-diactoros to produce a response, and will raise an\nexception if that package is not installed. You can provide an alternate factory\nif you want to use an alternate PSR-7 implementation.\n\n\nServerRequestErrorResponseGeneratorFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Response\\ServerRequestErrorResponseGenerator\n\n\nSuggested Name\n: \nZend\\Expressive\\Response\\ServerRequestErrorResponseGenerator\n\n\nRequires\n:\n\n\nPsr\\Http\\Message\\ResponseInterface\n, which should resolve to a \ncallable\n\n  capable of producing a \nResponseInterface\n instance (and not directly to an\n  instance itself)\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nErrorResponseGenerator\n instance with a template name to use for errors (see\n  more below), and/or a \"debug\" flag value.\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the\n  error response generator will provide a plain text response instead of a\n  templated one.\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize two values:\n\n\n\n\ndebug\n, a flag indicating whether or not to provide debug information when\n  creating an error response.\n\n\nzend-expressive.error_handler.template_error\n, a name of an alternate\n  template to use (instead of the default represented in the\n  \nZend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT\n\n  constant).\n\n\n\n\nAs an example:\n\n\n'debug' => true,\n'zend-expressive' => [\n    'error_handler' => [\n        'template_error' => 'name of error template',\n    ],\n],\n\n\n\nServerRequestFactoryFactory\n\n\n\n\nProvides\n: a PHP callable capable of producing\n  \nPsr\\Http\\Message\\ServerRequestInterface\n instances.\n\n\nSuggested Name\n: \nPsr\\Http\\Message\\ServerRequestInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n: no optional services are used.\n\n\n\n\nBy default, this uses zend-diactoros to produce a request, and will raise an\nexception if that package is not installed. You can provide an alternate factory\nif you want to use an alternate PSR-7 implementation.\n\n\nStreamFactoryFactory\n\n\n\n\nProvides\n: a PHP callable capable of producing\n  \nPsr\\Http\\Message\\StreamInterface\n instances.\n\n\nSuggested Name\n: \nPsr\\Http\\Message\\StreamInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n: no optional services are used.\n\n\n\n\nBy default, this uses zend-diactoros to produce a stream, and will raise an\nexception if that package is not installed. You can provide an alternate factory\nif you want to use an alternate PSR-7 implementation.\n\n\nWhoopsErrorResponseGeneratorFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator\n\n\nSuggested Name\n: \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n\n\nRequires\n: \nZend\\Expressive\\Whoops\n (see \nWhoopsFactory\n,\nbelow)\n\n\n\n\nWhoopsFactory\n\n\n\n\nProvides\n: \nWhoops\\Run\n\n\nSuggested Name\n: \nZend\\Expressive\\Whoops\n\n\nRequires\n:\n\n\nZend\\Expressive\\WhoopsPageHandler\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed\n  additional page handlers, specifically the \nJsonResponseHandler\n (see\n  more below).\n\n\n\n\n\n\n\n\nThis factory creates and configures a \nWhoops\\Run\n instance so that it will work\nproperly with \nZend\\Expressive\\Application\n; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The \nPrettyPageHandler\n returned\nfor the \nZend\\Expressive\\WhoopsPageHandler\n service will be injected.\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' => [\n    'json_exceptions' => [\n        'display'    => true,\n        'show_trace' => true,\n        'ajax_only'  => true,\n    ],\n],\n\n\n\nIf no \nwhoops\n top-level key is present in the configuration, a default instance\nwith no \nJsonResponseHandler\n composed will be created.\n\n\nWhoopsPageHandlerFactory\n\n\n\n\nProvides\n: \nWhoops\\Handler\\PrettyPageHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\WhoopsPageHandler\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPrettyPageHandler\n instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' => [\n    'editor' => 'editor name, editor service name, or callable',\n],\n\n\n\nThe \neditor\n value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.\n\n\nzend-expressive-router\n\n\nThe zend-expressive-router package ships \nZend\\Expressive\\Router\\ConfigProvider\n,\nwhich defines configuration that references each of these factories, using the\nsuggested names; this provider is registered by default when using the skeleton\napplication.\n\n\nIndividual router implementation packages are expected to provide the\n\nZend\\Expressive\\Router\\RouterInterface\n service.\n\n\nAll factories listed below are under the \nZend\\Expressive\\Router\\Middleware\n\nnamespace (unless otherwise specified), and define an \n__invoke()\n method that\naccepts a \nPsr\\Container\\ContainerInterface\n instance as the sole argument.\n\n\nDispatchMiddlewareFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Router\\Middleware\\DispatchMiddleware\n\n\nSuggested Name\n: \nZend\\Expressive\\Router\\Middleware\\DispatchMiddleware\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n: no optional services are used.\n\n\n\n\nImplicitHeadMiddlewareFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware\n\n\nSuggested Name\n: \nZend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware\n\n\nRequires\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n\n\nPsr\\Http\\Message\\StreamInterface\n, which should resolve to a \ncallable\n\n  capable of producing a \nStreamInterface\n instance (and not directly to an\n  instance itself)\n\n\n\n\n\n\nOptional\n: no optional services are used.\n\n\n\n\nImplicitOptionsMiddlewareFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware\n\n\nSuggested Name\n: \nZend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware\n\n\nRequires\n:\n\n\nPsr\\Http\\Message\\ResponseInterface\n, which should resolve to a \ncallable\n\n  capable of producing a \nResponseInterface\n instance (and not directly to an\n  instance itself)\n\n\n\n\n\n\nOptional\n: no optional services are used.\n\n\n\n\nMethodNotAllowedMiddlewareFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware\n\n\nSuggested Name\n: \nZend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware\n\n\nRequires\n:\n\n\nPsr\\Http\\Message\\ResponseInterface\n, which should resolve to a \ncallable\n\n  capable of producing a \nResponseInterface\n instance (and not directly to an\n  instance itself)\n\n\n\n\n\n\nOptional\n: no optional services are used.\n\n\n\n\nRouteCollectorFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Router\\RouteCollector\n\n\nSuggested Name\n: \nZend\\Expressive\\Router\\RouteCollector\n\n\nRequires\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n\n\n\n\n\n\nOptional\n: no optional services are used.\n\n\n\n\nRouteMiddlewareFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Router\\Middleware\\RouteMiddleware\n\n\nSuggested Name\n: \nZend\\Expressive\\Router\\Middleware\\RouteMiddleware\n\n\nRequires\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n\n\n\n\n\n\nOptional\n: no optional services are used.\n\n\n\n\nFactories provided by template engine packages\n\n\nThe following factories are provided by individual template engine packages.\nGenerally speaking, these will be provided to your container configuration\nduring installation.\n\n\nPlatesRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\PlatesRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Plates\\PlatesRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPlates\n instance, specifically with the filename extension\n  to use, and paths to inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' => [\n    'extension' => 'file extension used by templates; defaults to html',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nOne note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.\n\n\nTwigRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\TwigRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Twig\\TwigRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n; if found, it will be used to\n  seed a \nZend\\Expressive\\Twig\\TwigExtension\n instance for purposes\n  of rendering application URLs.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nTwig\n instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'debug' => boolean,\n'templates' => [\n    'cache_dir' => 'path to cached templates',\n    'assets_url' => 'base URL for assets',\n    'assets_version' => 'base version for assets',\n    'extension' => 'file extension used by templates; defaults to html.twig',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nWhen \ndebug\n is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The \nassets_*\n values are used to seed\nthe \nTwigExtension\n instance (assuming the router was found).\n\n\nZendViewRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\ZendViewRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\ZendView\\ZendViewRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nZendView\n instance, specifically with the layout template\n  name, entries for a \nTemplateMapResolver\n, and and template paths to\n  inject.\n\n\nZend\\View\\Renderer\\PhpRenderer\n, in order to allow providing custom\n  extensions and/or re-using an existing configuration; otherwise, a default\n  instance is created.\n\n\nZend\\View\\HelperPluginManager\n; if present, will be used to inject the\n  \nPhpRenderer\n instance; otherwise, a default instance is created.\n\n\nZend\\Expressive\\Helper\\UrlHelper\n, in order to provide a URL helper\n  compatible with zend-expressive-router. If you will not be generating\n  URLs, this can be omitted.\n\n\nZend\\Expressive\\Helper\\ServerUrlHelper\n, in order to provide a server URL\n  helper (which provides the scheme and authority for a generated URL)\n  compatible with zend-expressive-router. If you will not be generating\n  URLs, this can be omitted.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' => [\n    'layout' => 'name of layout view to use, if any',\n    'map'    => [\n        // template => filename pairs\n    ],\n    'paths'  => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nWhen creating the \nPhpRenderer\n instance, it will inject it with a\n\nZend\\View\\HelperPluginManager\n instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers, \nZend\\Expressive\\ZendView\\UrlHelper\n and\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n, respectively.",
            "title": "Container Factories"
        },
        {
            "location": "/v3/features/container/factories/#provided-factories",
            "text": "Expressive provides several factories compatible with PSR-11 Container  to facilitate\nsetting up common dependencies. The following is a list of provided\nfactories, what they will create, the suggested service name, and any\nadditional dependencies they may require.",
            "title": "Provided Factories"
        },
        {
            "location": "/v3/features/container/factories/#zend-expressive",
            "text": "The zend-expressive package ships  Zend\\Expressive\\ConfigProvider , which\ndefines configuration that references each of these factories, using the\nsuggested names; this provider is registered by default when using the skeleton\napplication.  All factories, unless noted otherwise, are in the  Zend\\Expressive\\Container \nnamespace, and define an  __invoke()  method that accepts an Psr\\Container\\ContainerInterface  instance as the sole argument.",
            "title": "zend-expressive"
        },
        {
            "location": "/v3/features/container/factories/#applicationfactory",
            "text": "Provides :  Zend\\Expressive\\Application  Suggested Name :  Zend\\Expressive\\Application  Requires :  Zend\\Expressive\\MiddlewareFactory  Zend\\Expressive\\ApplicationPipeline , which should resolve to a\n   Zend\\Stratigility\\MiddlewarePipe  instance.  Zend\\Expressive\\Router\\RouteCollector  Zend\\HttpHandlerRunner\\RequestHandlerRunner    Optional : no optional services are used.",
            "title": "ApplicationFactory"
        },
        {
            "location": "/v3/features/container/factories/#applicationpipelinefactory",
            "text": "Provides : a  Zend\\Stratigility\\MiddlewarePipe  for use with the\n   Application  instance.  Suggested Name :  Zend\\Expressive\\ApplicationPipeline  Requires : no additional services are required.  Optional : no optional services are used.",
            "title": "ApplicationPipelineFactory"
        },
        {
            "location": "/v3/features/container/factories/#emitterfactory",
            "text": "Provides :  Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface  Suggested Name :  Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface  Requires : no additional services are required.  Optional : no optional services are used.   This factory creates an instance of Zend\\HttpHandlerRunner\\Emitter\\EmitterStack , pushing a Zend\\HttpHandlerRunner\\Emitter\\SapiEmitter  to it.",
            "title": "EmitterFactory"
        },
        {
            "location": "/v3/features/container/factories/#errorhandlerfactory",
            "text": "Provides :  Zend\\Stratigility\\Middleware\\ErrorHandler  Suggested Name :  Zend\\Stratigility\\Middleware\\ErrorHandler  Requires :  Psr\\Http\\Message\\ResponseInterface , which should resolve to a  callable \n  capable of producing a  ResponseInterface  instance (and not directly to an\n  instance itself)    Optional :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator . If not provided, the error\n  handler will not compose an error response generator, making it largely\n  useless other than to provide an empty response.",
            "title": "ErrorHandlerFactory"
        },
        {
            "location": "/v3/features/container/factories/#errorresponsegeneratorfactory",
            "text": "Provides :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  Suggested Name :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  Requires : no additional services are required.  Optional :  config , an array or  ArrayAccess  instance. This will be used to seed the\n   ErrorResponseGenerator  instance with a template name to use for errors (see\n  more below), and/or a \"debug\" flag value.  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the\n  error response generator will provide a plain text response instead of a\n  templated one.     When the  config  service is present, the factory can utilize two values:   debug , a flag indicating whether or not to provide debug information when\n  creating an error response.  zend-expressive.error_handler.template_error , a name of an alternate\n  template to use (instead of the default represented in the\n   Zend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT \n  constant, which evaluates to  error::error ).  Since 3.1.0 :  zend-expressive.error_handler.layout , a name of an\n  alternate layout to use (instead of the default represented in the\n   Zend\\Expressive\\Middleware\\ErrorResponseGenerator::LAYOUT_DEFAULT  constant,\n  which evaluates to  layout::default ).   As an example:  'debug' => true,\n'zend-expressive' => [\n    'error_handler' => [\n        'template_error' => 'name of error template',\n        'layout' => 'layout::alternate',\n    ],\n],",
            "title": "ErrorResponseGeneratorFactory"
        },
        {
            "location": "/v3/features/container/factories/#middlewarecontainerfactory",
            "text": "Provides : a  Zend\\Expressive\\MiddlewareContainer  Suggested Name :  Zend\\Expressive\\MiddlewareContainer  Requires : no additional services are required.  Optional : no optional services are used.   This factory returns an instance of  Zend\\Expressive\\MiddlewareContainer \ninjected with the container instance itself.  The  MiddlewareContainer  is a PSR-11 container itself, but ensures that\ninstances pulled are PSR-15  MiddlewareInterface  instances:   It decorates PSR-15  RequestHandlerInterface  instances using  Zend\\Stratigility\\RequestHandlerMiddleware .  If a requested service is not in the underlying PSR-11 container, but the\n  class exists, it will attempt to instantiate it directly.  Any service retrieved that is not a  MiddlewareInterface  instance will result\n  in an exception, ensuring that nothing invalid is piped or routed.",
            "title": "MiddlewareContainerFactory"
        },
        {
            "location": "/v3/features/container/factories/#middlewarefactoryfactory",
            "text": "Provides : a  Zend\\Expressive\\MiddlewareFactory  Suggested Name :  Zend\\Expressive\\MiddlewareFactory  Requires :  Zend\\Expressive\\MiddlewareContainer    Optional : no optional services are used.   The  MiddlewareFactory  is used by  Zend\\Expressive\\Application  to prepare $middleware  arguments to  pipe() ,  route() , et al, ensuring they are MiddlewareInterface  implementations. It handles the following types:   MiddlewareInterface  types are considered valid always.  RequestHandlerInterface  types are decorated using  Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware .  callable  types are decorated using  Zend\\Stratigility\\middleware() .  string  types are decorated using a  Zend\\Expressive\\Middleware\\LazyLoadingMiddleware \n  instance (which will also receive the  MiddlewareContainer. )  Or an  array  of any of the above types.",
            "title": "MiddlewareFactoryFactory"
        },
        {
            "location": "/v3/features/container/factories/#notfoundhandlerfactory",
            "text": "Provides :  Zend\\Expressive\\Handler\\NotFoundHandler  Suggested Name :  Zend\\Expressive\\Handler\\NotFoundHandler  Requires :  Psr\\Http\\Message\\ResponseInterface , which should resolve to a  callable \n  capable of producing a  ResponseInterface  instance (and not directly to an\n  instance itself)    Optional :  config , an array or  ArrayAccess  instance. This will be used to seed the\n   NotFoundHandler  instance with a template name to use.  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the\n  handler will provide a plain text response instead of a templated one.     When the  config  service is present, the factory can utilize two values:    zend-expressive.error_handler.template_404 , a name of an alternate\n  template to use (instead of the default represented in the\n   Zend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT  constant, which\n  evaluates to  error::404 ).    zend-expressive.error_handler.layout , a name of an alternate\n  template to use (instead of the default represented in the\n   Zend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT  constant, which\n  evaluates to  layout::default ).    As an example:  'zend-expressive' => [\n    'error_handler' => [\n        'template_404' => 'name of 404 template',\n        'layout' => 'layout::alternate',\n    ],\n],",
            "title": "NotFoundHandlerFactory"
        },
        {
            "location": "/v3/features/container/factories/#requesthandlerrunnerfactory",
            "text": "Provides :  Zend\\HttpHandler\\RequestHandlerRunner  Suggested Name :  Zend\\HttpHandler\\RequestHandlerRunner  Requires :  Zend\\Expressive\\ApplicationPipeline , which should resolve to the\n   Zend\\Stratigility\\MiddlewarePipe  instance the  Application  will use.  Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface  Psr\\Http\\Message\\ServerRequestInterface ,  which should resolve to a\n   callable  capable of producing a  ServerRequestInterface  instance (and\n  not directly to an instance itself)  Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator    Optional : no optional services are used.   This factory generates the  RequestHandlerRunner  instance used by the Application  instance to \"run\" the application. It marshals a request instance,\npasses it to the application pipeline to handle, and emits the returned\nresponse. If an error occurs during request generation, it uses the ServerRequestErrorResponseGenerator  to generate the response to emit.",
            "title": "RequestHandlerRunnerFactory"
        },
        {
            "location": "/v3/features/container/factories/#responsefactoryfactory",
            "text": "Provides : a PHP callable capable of producing\n   Psr\\Http\\Message\\ResponseInterface  instances.  Suggested Name :  Psr\\Http\\Message\\ResponseInterface  Requires : no additional services are required.  Optional : no optional services are used.   By default, this uses zend-diactoros to produce a response, and will raise an\nexception if that package is not installed. You can provide an alternate factory\nif you want to use an alternate PSR-7 implementation.",
            "title": "ResponseFactoryFactory"
        },
        {
            "location": "/v3/features/container/factories/#serverrequesterrorresponsegeneratorfactory",
            "text": "Provides :  Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator  Suggested Name :  Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator  Requires :  Psr\\Http\\Message\\ResponseInterface , which should resolve to a  callable \n  capable of producing a  ResponseInterface  instance (and not directly to an\n  instance itself)    Optional :  config , an array or  ArrayAccess  instance. This will be used to seed the\n   ErrorResponseGenerator  instance with a template name to use for errors (see\n  more below), and/or a \"debug\" flag value.  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the\n  error response generator will provide a plain text response instead of a\n  templated one.     When the  config  service is present, the factory can utilize two values:   debug , a flag indicating whether or not to provide debug information when\n  creating an error response.  zend-expressive.error_handler.template_error , a name of an alternate\n  template to use (instead of the default represented in the\n   Zend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT \n  constant).   As an example:  'debug' => true,\n'zend-expressive' => [\n    'error_handler' => [\n        'template_error' => 'name of error template',\n    ],\n],",
            "title": "ServerRequestErrorResponseGeneratorFactory"
        },
        {
            "location": "/v3/features/container/factories/#serverrequestfactoryfactory",
            "text": "Provides : a PHP callable capable of producing\n   Psr\\Http\\Message\\ServerRequestInterface  instances.  Suggested Name :  Psr\\Http\\Message\\ServerRequestInterface  Requires : no additional services are required.  Optional : no optional services are used.   By default, this uses zend-diactoros to produce a request, and will raise an\nexception if that package is not installed. You can provide an alternate factory\nif you want to use an alternate PSR-7 implementation.",
            "title": "ServerRequestFactoryFactory"
        },
        {
            "location": "/v3/features/container/factories/#streamfactoryfactory",
            "text": "Provides : a PHP callable capable of producing\n   Psr\\Http\\Message\\StreamInterface  instances.  Suggested Name :  Psr\\Http\\Message\\StreamInterface  Requires : no additional services are required.  Optional : no optional services are used.   By default, this uses zend-diactoros to produce a stream, and will raise an\nexception if that package is not installed. You can provide an alternate factory\nif you want to use an alternate PSR-7 implementation.",
            "title": "StreamFactoryFactory"
        },
        {
            "location": "/v3/features/container/factories/#whoopserrorresponsegeneratorfactory",
            "text": "Provides :  Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator  Suggested Name :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  Requires :  Zend\\Expressive\\Whoops  (see  WhoopsFactory ,\nbelow)",
            "title": "WhoopsErrorResponseGeneratorFactory"
        },
        {
            "location": "/v3/features/container/factories/#whoopsfactory",
            "text": "Provides :  Whoops\\Run  Suggested Name :  Zend\\Expressive\\Whoops  Requires :  Zend\\Expressive\\WhoopsPageHandler    Optional :  config , an array or  ArrayAccess  instance. This will be used to seed\n  additional page handlers, specifically the  JsonResponseHandler  (see\n  more below).     This factory creates and configures a  Whoops\\Run  instance so that it will work\nproperly with  Zend\\Expressive\\Application ; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The  PrettyPageHandler  returned\nfor the  Zend\\Expressive\\WhoopsPageHandler  service will be injected.  It consumes the following  config  structure:  'whoops' => [\n    'json_exceptions' => [\n        'display'    => true,\n        'show_trace' => true,\n        'ajax_only'  => true,\n    ],\n],  If no  whoops  top-level key is present in the configuration, a default instance\nwith no  JsonResponseHandler  composed will be created.",
            "title": "WhoopsFactory"
        },
        {
            "location": "/v3/features/container/factories/#whoopspagehandlerfactory",
            "text": "Provides :  Whoops\\Handler\\PrettyPageHandler  Suggested Name :  Zend\\Expressive\\WhoopsPageHandler  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  PrettyPageHandler  instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).     It consumes the following  config  structure:  'whoops' => [\n    'editor' => 'editor name, editor service name, or callable',\n],  The  editor  value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.",
            "title": "WhoopsPageHandlerFactory"
        },
        {
            "location": "/v3/features/container/factories/#zend-expressive-router",
            "text": "The zend-expressive-router package ships  Zend\\Expressive\\Router\\ConfigProvider ,\nwhich defines configuration that references each of these factories, using the\nsuggested names; this provider is registered by default when using the skeleton\napplication.  Individual router implementation packages are expected to provide the Zend\\Expressive\\Router\\RouterInterface  service.  All factories listed below are under the  Zend\\Expressive\\Router\\Middleware \nnamespace (unless otherwise specified), and define an  __invoke()  method that\naccepts a  Psr\\Container\\ContainerInterface  instance as the sole argument.",
            "title": "zend-expressive-router"
        },
        {
            "location": "/v3/features/container/factories/#dispatchmiddlewarefactory",
            "text": "Provides :  Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware  Suggested Name :  Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware  Requires : no additional services are required.  Optional : no optional services are used.",
            "title": "DispatchMiddlewareFactory"
        },
        {
            "location": "/v3/features/container/factories/#implicitheadmiddlewarefactory",
            "text": "Provides :  Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware  Suggested Name :  Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware  Requires :  Zend\\Expressive\\Router\\RouterInterface  Psr\\Http\\Message\\StreamInterface , which should resolve to a  callable \n  capable of producing a  StreamInterface  instance (and not directly to an\n  instance itself)    Optional : no optional services are used.",
            "title": "ImplicitHeadMiddlewareFactory"
        },
        {
            "location": "/v3/features/container/factories/#implicitoptionsmiddlewarefactory",
            "text": "Provides :  Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware  Suggested Name :  Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware  Requires :  Psr\\Http\\Message\\ResponseInterface , which should resolve to a  callable \n  capable of producing a  ResponseInterface  instance (and not directly to an\n  instance itself)    Optional : no optional services are used.",
            "title": "ImplicitOptionsMiddlewareFactory"
        },
        {
            "location": "/v3/features/container/factories/#methodnotallowedmiddlewarefactory",
            "text": "Provides :  Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware  Suggested Name :  Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware  Requires :  Psr\\Http\\Message\\ResponseInterface , which should resolve to a  callable \n  capable of producing a  ResponseInterface  instance (and not directly to an\n  instance itself)    Optional : no optional services are used.",
            "title": "MethodNotAllowedMiddlewareFactory"
        },
        {
            "location": "/v3/features/container/factories/#routecollectorfactory",
            "text": "Provides :  Zend\\Expressive\\Router\\RouteCollector  Suggested Name :  Zend\\Expressive\\Router\\RouteCollector  Requires :  Zend\\Expressive\\Router\\RouterInterface    Optional : no optional services are used.",
            "title": "RouteCollectorFactory"
        },
        {
            "location": "/v3/features/container/factories/#routemiddlewarefactory",
            "text": "Provides :  Zend\\Expressive\\Router\\Middleware\\RouteMiddleware  Suggested Name :  Zend\\Expressive\\Router\\Middleware\\RouteMiddleware  Requires :  Zend\\Expressive\\Router\\RouterInterface    Optional : no optional services are used.",
            "title": "RouteMiddlewareFactory"
        },
        {
            "location": "/v3/features/container/factories/#factories-provided-by-template-engine-packages",
            "text": "The following factories are provided by individual template engine packages.\nGenerally speaking, these will be provided to your container configuration\nduring installation.",
            "title": "Factories provided by template engine packages"
        },
        {
            "location": "/v3/features/container/factories/#platesrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\PlatesRenderer  FactoryName :  Zend\\Expressive\\Plates\\PlatesRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Plates  instance, specifically with the filename extension\n  to use, and paths to inject.     It consumes the following  config  structure:  'templates' => [\n    'extension' => 'file extension used by templates; defaults to html',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  One note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.",
            "title": "PlatesRendererFactory"
        },
        {
            "location": "/v3/features/container/factories/#twigrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\TwigRenderer  FactoryName :  Zend\\Expressive\\Twig\\TwigRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to\n  seed a  Zend\\Expressive\\Twig\\TwigExtension  instance for purposes\n  of rendering application URLs.  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Twig  instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.     It consumes the following  config  structure:  'debug' => boolean,\n'templates' => [\n    'cache_dir' => 'path to cached templates',\n    'assets_url' => 'base URL for assets',\n    'assets_version' => 'base version for assets',\n    'extension' => 'file extension used by templates; defaults to html.twig',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When  debug  is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The  assets_*  values are used to seed\nthe  TwigExtension  instance (assuming the router was found).",
            "title": "TwigRendererFactory"
        },
        {
            "location": "/v3/features/container/factories/#zendviewrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\ZendViewRenderer  FactoryName :  Zend\\Expressive\\ZendView\\ZendViewRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  ZendView  instance, specifically with the layout template\n  name, entries for a  TemplateMapResolver , and and template paths to\n  inject.  Zend\\View\\Renderer\\PhpRenderer , in order to allow providing custom\n  extensions and/or re-using an existing configuration; otherwise, a default\n  instance is created.  Zend\\View\\HelperPluginManager ; if present, will be used to inject the\n   PhpRenderer  instance; otherwise, a default instance is created.  Zend\\Expressive\\Helper\\UrlHelper , in order to provide a URL helper\n  compatible with zend-expressive-router. If you will not be generating\n  URLs, this can be omitted.  Zend\\Expressive\\Helper\\ServerUrlHelper , in order to provide a server URL\n  helper (which provides the scheme and authority for a generated URL)\n  compatible with zend-expressive-router. If you will not be generating\n  URLs, this can be omitted.     It consumes the following  config  structure:  'templates' => [\n    'layout' => 'name of layout view to use, if any',\n    'map'    => [\n        // template => filename pairs\n    ],\n    'paths'  => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When creating the  PhpRenderer  instance, it will inject it with a Zend\\View\\HelperPluginManager  instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers,  Zend\\Expressive\\ZendView\\UrlHelper  and Zend\\Expressive\\ZendView\\ServerUrlHelper , respectively.",
            "title": "ZendViewRendererFactory"
        },
        {
            "location": "/v3/features/container/delegator-factories/",
            "text": "Delegator Factories\n\n\nExpressive supports the concept of \ndelegator factories\n, which allow decoration\nof services created by your dependency injection container, across all\ndependency injection containers supported by Expressive.\n\n\nDelegator factories\n accept the following arguments:\n\n\n\n\nThe container itself;\n\n\nThe name of the service whose creation is being decorated;\n\n\nA callback that will produce the service being decorated.\n\n\n\n\nAs an example, let's say we have a \nUserRepository\n class that composes some sort of\nevent manager. We might want to attach listeners to that event manager, but not\nwish to alter the basic creation logic for the repository itself. As such, we\nmight write a \ndelegator factory\n as follows:\n\n\nnamespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass UserRepositoryListenerDelegatorFactory\n{\n    public function __invoke(ContainerInterface $container, string $name, callable $callback) : UserRepository\n    {\n        $listener = new LoggerListener($container->get(LoggerInterface::class));\n        $repository = $callback();\n        $repository->getEventManager()->attach($listener);\n        return $repository;\n    }\n}\n\n\n\nTo notify the container about this delegator factory, we would add the following\nconfiguration to our application:\n\n\n'dependencies' => [\n    'delegators' => [\n        Acme\\UserRepository::class => [\n            Acme\\UserRepositoryListenerDelegatorFactory::class,\n        ],\n    ],\n],\n\n\n\nNote that you specify delegator factories using the service name being decorated\nas the key, with an \narray\n of delegator factories as a value. \nYou may attach\nmultiple delegator factories to any given service\n, which can be a very\npowerful feature.\n\n\nAt the time of writing, this feature works for each of the Aura.Di, Pimple, and\nzend-servicemanager container implementations.",
            "title": "Delegator Factories"
        },
        {
            "location": "/v3/features/container/delegator-factories/#delegator-factories",
            "text": "Expressive supports the concept of  delegator factories , which allow decoration\nof services created by your dependency injection container, across all\ndependency injection containers supported by Expressive.  Delegator factories  accept the following arguments:   The container itself;  The name of the service whose creation is being decorated;  A callback that will produce the service being decorated.   As an example, let's say we have a  UserRepository  class that composes some sort of\nevent manager. We might want to attach listeners to that event manager, but not\nwish to alter the basic creation logic for the repository itself. As such, we\nmight write a  delegator factory  as follows:  namespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass UserRepositoryListenerDelegatorFactory\n{\n    public function __invoke(ContainerInterface $container, string $name, callable $callback) : UserRepository\n    {\n        $listener = new LoggerListener($container->get(LoggerInterface::class));\n        $repository = $callback();\n        $repository->getEventManager()->attach($listener);\n        return $repository;\n    }\n}  To notify the container about this delegator factory, we would add the following\nconfiguration to our application:  'dependencies' => [\n    'delegators' => [\n        Acme\\UserRepository::class => [\n            Acme\\UserRepositoryListenerDelegatorFactory::class,\n        ],\n    ],\n],  Note that you specify delegator factories using the service name being decorated\nas the key, with an  array  of delegator factories as a value.  You may attach\nmultiple delegator factories to any given service , which can be a very\npowerful feature.  At the time of writing, this feature works for each of the Aura.Di, Pimple, and\nzend-servicemanager container implementations.",
            "title": "Delegator Factories"
        },
        {
            "location": "/v3/features/container/middleware-container/",
            "text": "The Middleware Container\n\n\nWhile the skeleton creates a general\n\nPSR-11\n container in which to map all of\nyour dependencies, this can pose problems when you are attempting to pull\nmiddleware and request handlers; you could potentially, accidentally, pull\nsomething of an entire type entirely, which may not work in either context!\n\n\nTo prevent this from happening, we provide\n\nZend\\Expressive\\MiddlewareContainer\n. It decorates your application container,\nand adds the following behavior:\n\n\n\n\nhas()\n will return \ntrue\n if a service does not exist in the container, but\n  is a class that exists.\n\n\nget()\n:\n\n\nwill instantiate a class directly if the service does not exist, but is a\n  class that exists.\n\n\ndecorate PSR-15 \nRequestHandlerInterface\n implementations using\n  \nZend\\Stratigiliity\\RequestHandlerMiddleware\n.\n\n\nraise an exception of the instance to return is no a PSR-15\n  \nMiddlewareInterface\n implementation.\n\n\n\n\n\n\n\n\nInternally, this class is used by the \nMiddlewareFactory\n\nand the \nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n class; you should\nnever need to interact with it directly, unless the above features are of\ninterest to you.",
            "title": "The Middleware Container"
        },
        {
            "location": "/v3/features/container/middleware-container/#the-middleware-container",
            "text": "While the skeleton creates a general PSR-11  container in which to map all of\nyour dependencies, this can pose problems when you are attempting to pull\nmiddleware and request handlers; you could potentially, accidentally, pull\nsomething of an entire type entirely, which may not work in either context!  To prevent this from happening, we provide Zend\\Expressive\\MiddlewareContainer . It decorates your application container,\nand adds the following behavior:   has()  will return  true  if a service does not exist in the container, but\n  is a class that exists.  get() :  will instantiate a class directly if the service does not exist, but is a\n  class that exists.  decorate PSR-15  RequestHandlerInterface  implementations using\n   Zend\\Stratigiliity\\RequestHandlerMiddleware .  raise an exception of the instance to return is no a PSR-15\n   MiddlewareInterface  implementation.     Internally, this class is used by the  MiddlewareFactory \nand the  Zend\\Expressive\\Middleware\\LazyLoadingMiddleware  class; you should\nnever need to interact with it directly, unless the above features are of\ninterest to you.",
            "title": "The Middleware Container"
        },
        {
            "location": "/v3/features/container/middleware-factory/",
            "text": "The Middleware Factory\n\n\nWith version 3, we made a conscious choice to use strong type-hinting wherever\npossible. However, we also recognize that doing so can sometimes be an\ninconvenience to the user and lead to an explosion in code verbosity.\n\n\nOne area in particular that concerned us was the \nApplication\n instance itself,\nand the various methods it exposes for piping and routing middleware. If we made\neach of these strictly typed, users would be forced to write code that looks\nlike the following:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Middleware\\LazyLoadingMiddleware;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nuse function Zend\\Stratigility\\middleware;\nuse function Zend\\Stratigility\\path;\n\nreturn function (Application $app, ContainerInterface $container) : void {\n    $app->pipe(path(\n        '/foo',\n        new LazyLoadingMiddleware(App\\FooMiddleware::class, $container)\n    ));\n\n    $app->pipe(middleware(function ($request, $handler) {\n        // ...\n    }));\n\n    $booksPipeline = new MiddlewarePipe();\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        Zend\\ProblemDetails\\ProblemDetailsMiddleware::class,\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\SessionMiddleware::class,\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\AuthenticationMiddleware::class,\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\AuthorizationMiddleware::class,\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware::class\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\ValidationMiddleware::class\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\Handler\\CreateBookHandler::class\n        $container\n    ));\n    $app->post('/books/{id:\\d+}', $booksPipeline);\n};\n\n\n\nAdditionally, this would pose an enormous burden when migrating to version 3.\n\n\nFor these reasons, we developed the class \nZend\\Expressive\\MiddlewareFactory\n.\nIt composes a \nMiddlewareContainer\n in order to back\nthe following operations.\n\n\ncallable\n\n\n$middleware = $factory->callable(function ($request, $handler) {\n});\n\n\n\nThis method takes a callable middleware, and decorates it as a\n\nZend\\Stratigility\\Middleware\\CallableMiddlewareDecorator\n instance.\n\n\nhandler\n\n\n$middleware = $factory->handler($requestHandler);\n\n\n\nThis method takes a PSR-15 request handler instance and decorates it as a\n\nZend\\Stratigility\\Middleware\\RequestHandlerMiddleware\n instance.\n\n\nlazy\n\n\n$middleware = $factory->lazy(App\\Middleware\\FooMiddleware::class);\n\n\n\nThis method decorates the service name using\n\nZend\\Expressive\\Middlware\\LazyLoadingMiddleware\n, passing the composed\n\nMiddlewareContainer\n to the instance during instantiation.\n\n\npipeline\n\n\n$pipeline = $factory->pipeline(\n    $middlewareInstance,\n    'MiddlewareServiceName',\n    function ($request, $handler) {\n    },\n    $requestHandlerInstance\n);\n\n\n\nCreates and returns a \nZend\\Stratigility\\MiddlewarePipe\n, after passing each\nargument to \nprepare()\n first.\n\n\n(You may pass an array of values instead of individual arguments as well.)\n\n\nprepare\n\n\n$middleware = $factory->prepare($middleware);\n\n\n\nInspects the provided middleware argument, with the following behavior:\n\n\n\n\nMiddlewareInterface\n instances are returned verbatim.\n\n\nRequestHandlerInterface\n instances are decorated using \nhandler()\n.\n\n\ncallable\n arguments are decorated using \ncallable()\n.\n\n\nstring\n arguments are decorated using \nlazy()\n.\n\n\narray\n arguments are decorated using \npipeline()\n.\n\n\n\n\nUsage in bootstrapping\n\n\nThe skeleton defines two files \nconfig/pipeline.php\n and \nconfig/routes.php\n.\nThese are expected to return a callable with the following signature:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n};\n\n\n\nNote that the \nMiddlewareFactory\n is passed to these callables; this gives you\nthe ability to use it for more complex piping and routing needs, including\ncreating nested pipelines.\n\n\nAs an example, we'll rewrite our initial example to use the \nMiddlewareFactory\n:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\nuse function Zend\\Stratigility\\path;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    $app->pipe(path('/foo', $factory->prepare(App\\FooMiddleware::class)));\n\n    $app->pipe($factory->prepare(function ($request, $handler) {\n        // ...\n    }));\n\n    $app->post('/books/{id:\\d+}', $factory->pipeline(\n        ProblemDetailsMiddleware::class,\n        App\\SessionMiddleware::class,\n        App\\AuthenticationMiddleware::class,\n        App\\AuthorizationMiddleware::class,\n        Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware::class,\n        App\\ValidationMiddleware::class,\n        App\\Handler\\CreateBookHandler::class\n    ));\n};\n\n\n\n\n\nFurther simplifications\n\n\nInternally, \nApplication\n's \npipe()\n and various routing methods make use of\nthe \nMiddlewareFactory\n already; \npipe()\n also already makes use of \npath()\n\nas well. As such, usage of the \nMiddlewareFactory\n is not strictly necessary\nin the above example; it is used for illustrative purposes only.",
            "title": "The Middleware Factory"
        },
        {
            "location": "/v3/features/container/middleware-factory/#the-middleware-factory",
            "text": "With version 3, we made a conscious choice to use strong type-hinting wherever\npossible. However, we also recognize that doing so can sometimes be an\ninconvenience to the user and lead to an explosion in code verbosity.  One area in particular that concerned us was the  Application  instance itself,\nand the various methods it exposes for piping and routing middleware. If we made\neach of these strictly typed, users would be forced to write code that looks\nlike the following:  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Middleware\\LazyLoadingMiddleware;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nuse function Zend\\Stratigility\\middleware;\nuse function Zend\\Stratigility\\path;\n\nreturn function (Application $app, ContainerInterface $container) : void {\n    $app->pipe(path(\n        '/foo',\n        new LazyLoadingMiddleware(App\\FooMiddleware::class, $container)\n    ));\n\n    $app->pipe(middleware(function ($request, $handler) {\n        // ...\n    }));\n\n    $booksPipeline = new MiddlewarePipe();\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        Zend\\ProblemDetails\\ProblemDetailsMiddleware::class,\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\SessionMiddleware::class,\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\AuthenticationMiddleware::class,\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\AuthorizationMiddleware::class,\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware::class\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\ValidationMiddleware::class\n        $container\n    ));\n    $booksPipeline->pipe(new LazyLoadingMiddleware(\n        App\\Handler\\CreateBookHandler::class\n        $container\n    ));\n    $app->post('/books/{id:\\d+}', $booksPipeline);\n};  Additionally, this would pose an enormous burden when migrating to version 3.  For these reasons, we developed the class  Zend\\Expressive\\MiddlewareFactory .\nIt composes a  MiddlewareContainer  in order to back\nthe following operations.",
            "title": "The Middleware Factory"
        },
        {
            "location": "/v3/features/container/middleware-factory/#callable",
            "text": "$middleware = $factory->callable(function ($request, $handler) {\n});  This method takes a callable middleware, and decorates it as a Zend\\Stratigility\\Middleware\\CallableMiddlewareDecorator  instance.",
            "title": "callable"
        },
        {
            "location": "/v3/features/container/middleware-factory/#handler",
            "text": "$middleware = $factory->handler($requestHandler);  This method takes a PSR-15 request handler instance and decorates it as a Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware  instance.",
            "title": "handler"
        },
        {
            "location": "/v3/features/container/middleware-factory/#lazy",
            "text": "$middleware = $factory->lazy(App\\Middleware\\FooMiddleware::class);  This method decorates the service name using Zend\\Expressive\\Middlware\\LazyLoadingMiddleware , passing the composed MiddlewareContainer  to the instance during instantiation.",
            "title": "lazy"
        },
        {
            "location": "/v3/features/container/middleware-factory/#pipeline",
            "text": "$pipeline = $factory->pipeline(\n    $middlewareInstance,\n    'MiddlewareServiceName',\n    function ($request, $handler) {\n    },\n    $requestHandlerInstance\n);  Creates and returns a  Zend\\Stratigility\\MiddlewarePipe , after passing each\nargument to  prepare()  first.  (You may pass an array of values instead of individual arguments as well.)",
            "title": "pipeline"
        },
        {
            "location": "/v3/features/container/middleware-factory/#prepare",
            "text": "$middleware = $factory->prepare($middleware);  Inspects the provided middleware argument, with the following behavior:   MiddlewareInterface  instances are returned verbatim.  RequestHandlerInterface  instances are decorated using  handler() .  callable  arguments are decorated using  callable() .  string  arguments are decorated using  lazy() .  array  arguments are decorated using  pipeline() .",
            "title": "prepare"
        },
        {
            "location": "/v3/features/container/middleware-factory/#usage-in-bootstrapping",
            "text": "The skeleton defines two files  config/pipeline.php  and  config/routes.php .\nThese are expected to return a callable with the following signature:  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n};  Note that the  MiddlewareFactory  is passed to these callables; this gives you\nthe ability to use it for more complex piping and routing needs, including\ncreating nested pipelines.  As an example, we'll rewrite our initial example to use the  MiddlewareFactory :  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\nuse function Zend\\Stratigility\\path;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    $app->pipe(path('/foo', $factory->prepare(App\\FooMiddleware::class)));\n\n    $app->pipe($factory->prepare(function ($request, $handler) {\n        // ...\n    }));\n\n    $app->post('/books/{id:\\d+}', $factory->pipeline(\n        ProblemDetailsMiddleware::class,\n        App\\SessionMiddleware::class,\n        App\\AuthenticationMiddleware::class,\n        App\\AuthorizationMiddleware::class,\n        Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware::class,\n        App\\ValidationMiddleware::class,\n        App\\Handler\\CreateBookHandler::class\n    ));\n};",
            "title": "Usage in bootstrapping"
        },
        {
            "location": "/v3/features/container/middleware-factory/#further-simplifications",
            "text": "Internally,  Application 's  pipe()  and various routing methods make use of\nthe  MiddlewareFactory  already;  pipe()  also already makes use of  path() \nas well. As such, usage of the  MiddlewareFactory  is not strictly necessary\nin the above example; it is used for illustrative purposes only.",
            "title": "Further simplifications"
        },
        {
            "location": "/v3/features/container/zend-servicemanager/",
            "text": "Using zend-servicemanager\n\n\nzend-servicemanager\n is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:\n\n\n\n\nlazy-loading of invokable (constructor-less) classes.\n\n\nability to define factories for specific classes.\n\n\nability to define generalized factories for classes with identical\n  construction patterns (aka \nabstract factories\n).\n\n\nability to create lazy-loading proxies.\n\n\nability to intercept before or after instantiation to alter the construction\n  workflow (aka \ndelegator factories\n).\n\n\ninterface injection (via \ninitializers\n).\n\n\n\n\nzend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:\n\n\n[\n    'services' => [\n        'service name' => $serviceInstance,\n    ],\n    'invokables' => [\n        'service name' => 'class to instantiate',\n    ],\n    'factories' => [\n        'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' => [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' => [\n        'service name' => [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' => [\n        'class_map' => [\n            'service name' => 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' => [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]\n\n\n\nRead more about zend-servicemanager in \nits documentation\n.\n\n\nInstalling zend-servicemanager\n\n\nTo use zend-servicemanager with zend-expressive, you can install it via\ncomposer:\n\n\n$ composer require zendframework/zend-servicemanager\n\n\n\nConfiguring zend-servicemanager\n\n\nYou can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.\n\n\nProgrammatically\n\n\nTo use zend-servicemanager programatically, you'll need to create a\n\nZend\\ServiceManager\\ServiceManager\n instance, and then start populating it.\n\n\nFor this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in \nconfig/config.php\n, and that that file\nreturns an array.\n\n\nWe'll create a \nconfig/container.php\n file that creates and returns a\n\nZend\\ServiceManager\\ServiceManager\n instance as follows:\n\n\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container->setService('config', include 'config/config.php');\n$container->setFactory(\n    Zend\\Expressive\\Application::class,\n    Zend\\Expressive\\Container\\ApplicationFactory::class\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Template\\TemplateRendererInterface::class,\n    Zend\\Expressive\\Plates\\PlatesRenderer::class\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator\n// implementation:\n$container->setFactory(\n    'Zend\\Expressive\\Whoops',\n    Zend\\Expressive\\Container\\WhoopsFactory::class\n);\n$container->setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class\n);\n\n// Error Handling\n\n// All environments:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorHandler::class,\n    Zend\\Expressive\\Container\\ErrorHandlerFactory::class\n);\n\n// If in development:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n);\n\n// If in production:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n);\n\nreturn $container;\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(\\Zend\\Expressive\\Application::class);\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();\n\n\n\nConfiguration-Driven Container\n\n\nAlternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in \nconfig/config.php\n, and our\n\nconfig/container.php\n file will still return our service manager instance; we'll\ndefine the service configuration in \nconfig/dependencies.php\n:\n\n\nreturn [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => 'Zend\\Expressive\\Delegate\\NotFoundDelegate',\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        Zend\\Expressive\\Delegate\\NotFoundDelegate::class  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];\n\n\n\nconfig/container.php\n becomes:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));\n\n\n\nThere is one problem, however: you may want to vary error handling strategies\nbased on whether or not you're in production: You have two choices on how to\napproach this:\n\n\n\n\nSelectively inject the factory in the bootstrap.\n\n\nDefine the final handler service in an environment specific file and use file\n  globbing to merge files.\n\n\n\n\nIn the first case, you would change the \nconfig/container.php\n example to look\nlike this:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/container.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n        );\n        break;\n    case 'production':\n    default:\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n        );\n}\nreturn $container;\n\n\n\nIn the second case, you will need to install zend-config:\n\n\n$ composer require zendframework/zend-config\n\n\n\nThen, create the directory \nconfig/autoload/\n, and create two files,\n\ndependencies.global.php\n and \ndependencies.local.php\n. In your \n.gitignore\n,\nadd an entry for \nconfig/autoload/*local.php\n to ensure \"local\"\n(environment-specific) files are excluded from the repository.\n\n\nconfig/dependencies.php\n will look like this:\n\n\nuse Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);\n\n\n\nconfig/autoload/dependencies.global.php\n will look like this:\n\n\nreturn [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => Zend\\Expressive\\Delegate\\NotFoundDelegate::class,\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class,\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        'Zend\\Expressive\\Delegate\\NotFoundDelegate'  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];\n\n\n\nconfig/autoload/dependencies.local.php\n on your development machine can look\nlike this:\n\n\nreturn [\n    'factories' => [\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class,\n    ],\n];\n\n\n\nUsing the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)",
            "title": "Using zend-servicemanager"
        },
        {
            "location": "/v3/features/container/zend-servicemanager/#using-zend-servicemanager",
            "text": "zend-servicemanager  is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:   lazy-loading of invokable (constructor-less) classes.  ability to define factories for specific classes.  ability to define generalized factories for classes with identical\n  construction patterns (aka  abstract factories ).  ability to create lazy-loading proxies.  ability to intercept before or after instantiation to alter the construction\n  workflow (aka  delegator factories ).  interface injection (via  initializers ).   zend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:  [\n    'services' => [\n        'service name' => $serviceInstance,\n    ],\n    'invokables' => [\n        'service name' => 'class to instantiate',\n    ],\n    'factories' => [\n        'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' => [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' => [\n        'service name' => [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' => [\n        'class_map' => [\n            'service name' => 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' => [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]  Read more about zend-servicemanager in  its documentation .",
            "title": "Using zend-servicemanager"
        },
        {
            "location": "/v3/features/container/zend-servicemanager/#installing-zend-servicemanager",
            "text": "To use zend-servicemanager with zend-expressive, you can install it via\ncomposer:  $ composer require zendframework/zend-servicemanager",
            "title": "Installing zend-servicemanager"
        },
        {
            "location": "/v3/features/container/zend-servicemanager/#configuring-zend-servicemanager",
            "text": "You can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.",
            "title": "Configuring zend-servicemanager"
        },
        {
            "location": "/v3/features/container/zend-servicemanager/#programmatically",
            "text": "To use zend-servicemanager programatically, you'll need to create a Zend\\ServiceManager\\ServiceManager  instance, and then start populating it.  For this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in  config/config.php , and that that file\nreturns an array.  We'll create a  config/container.php  file that creates and returns a Zend\\ServiceManager\\ServiceManager  instance as follows:  use Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container->setService('config', include 'config/config.php');\n$container->setFactory(\n    Zend\\Expressive\\Application::class,\n    Zend\\Expressive\\Container\\ApplicationFactory::class\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Template\\TemplateRendererInterface::class,\n    Zend\\Expressive\\Plates\\PlatesRenderer::class\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator\n// implementation:\n$container->setFactory(\n    'Zend\\Expressive\\Whoops',\n    Zend\\Expressive\\Container\\WhoopsFactory::class\n);\n$container->setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class\n);\n\n// Error Handling\n\n// All environments:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorHandler::class,\n    Zend\\Expressive\\Container\\ErrorHandlerFactory::class\n);\n\n// If in development:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n);\n\n// If in production:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n);\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(\\Zend\\Expressive\\Application::class);\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();",
            "title": "Programmatically"
        },
        {
            "location": "/v3/features/container/zend-servicemanager/#configuration-driven-container",
            "text": "Alternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in  config/config.php , and our config/container.php  file will still return our service manager instance; we'll\ndefine the service configuration in  config/dependencies.php :  return [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => 'Zend\\Expressive\\Delegate\\NotFoundDelegate',\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        Zend\\Expressive\\Delegate\\NotFoundDelegate::class  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];  config/container.php  becomes:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));  There is one problem, however: you may want to vary error handling strategies\nbased on whether or not you're in production: You have two choices on how to\napproach this:   Selectively inject the factory in the bootstrap.  Define the final handler service in an environment specific file and use file\n  globbing to merge files.   In the first case, you would change the  config/container.php  example to look\nlike this:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/container.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n        );\n        break;\n    case 'production':\n    default:\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n        );\n}\nreturn $container;  In the second case, you will need to install zend-config:  $ composer require zendframework/zend-config  Then, create the directory  config/autoload/ , and create two files, dependencies.global.php  and  dependencies.local.php . In your  .gitignore ,\nadd an entry for  config/autoload/*local.php  to ensure \"local\"\n(environment-specific) files are excluded from the repository.  config/dependencies.php  will look like this:  use Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);  config/autoload/dependencies.global.php  will look like this:  return [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => Zend\\Expressive\\Delegate\\NotFoundDelegate::class,\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class,\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        'Zend\\Expressive\\Delegate\\NotFoundDelegate'  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];  config/autoload/dependencies.local.php  on your development machine can look\nlike this:  return [\n    'factories' => [\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class,\n    ],\n];  Using the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)",
            "title": "Configuration-Driven Container"
        },
        {
            "location": "/v3/features/container/pimple/",
            "text": "Using Pimple\n\n\nPimple\n is a widely used, code-driven,\ndependency injection container provided as a standalone component by SensioLabs.\nIt features:\n\n\n\n\ncombined parameter and service storage.\n\n\nability to define factories for specific classes.\n\n\nlazy-loading via factories.\n\n\n\n\nPimple only supports programmatic creation at this time.\n\n\nInstalling and configuring Pimple\n\n\nPimple implements \nPSR-11 Container\n\nas of version 3.2. To use Pimple as a dependency injection container, we\nrecommend using \nzendframework/zend-pimple-config\n,\nwhich helps you to configure the PSR-11 container. First install the package:\n\n\n$ composer require zendframework/zend-pimple-config\n\n\n\nNow, create the file \nconfig/container.php\n with the following contents:\n\n\n<?php\nuse Zend\\Pimple\\Config\\Config;\nuse Zend\\Pimple\\Config\\ContainerFactory;\n\n$config  = require __DIR__ . '/config.php';\n$factory = new ContainerFactory();\n\nreturn $factory(new Config($config));\n\n\n\nFor more information, please see the\n\nzend-pimple-config documentation\n.\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n$app->run();",
            "title": "Using Pimple"
        },
        {
            "location": "/v3/features/container/pimple/#using-pimple",
            "text": "Pimple  is a widely used, code-driven,\ndependency injection container provided as a standalone component by SensioLabs.\nIt features:   combined parameter and service storage.  ability to define factories for specific classes.  lazy-loading via factories.   Pimple only supports programmatic creation at this time.",
            "title": "Using Pimple"
        },
        {
            "location": "/v3/features/container/pimple/#installing-and-configuring-pimple",
            "text": "Pimple implements  PSR-11 Container \nas of version 3.2. To use Pimple as a dependency injection container, we\nrecommend using  zendframework/zend-pimple-config ,\nwhich helps you to configure the PSR-11 container. First install the package:  $ composer require zendframework/zend-pimple-config  Now, create the file  config/container.php  with the following contents:  <?php\nuse Zend\\Pimple\\Config\\Config;\nuse Zend\\Pimple\\Config\\ContainerFactory;\n\n$config  = require __DIR__ . '/config.php';\n$factory = new ContainerFactory();\n\nreturn $factory(new Config($config));  For more information, please see the zend-pimple-config documentation .  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n$app->run();",
            "title": "Installing and configuring Pimple"
        },
        {
            "location": "/v3/features/container/aura-di/",
            "text": "Using Aura.Di\n\n\nAura.Di\n provides a serializable dependency\ninjection container with the following features:\n\n\n\n\nconstructor and setter injection.\n\n\ninheritance of constructor parameter and setter method values from parent\n  classes.\n\n\ninheritance of setter method values from interfaces and traits.\n\n\nlazy-loaded instances, services, includes/requires, and values.\n\n\ninstance factories.\n\n\noptional auto-resolution of typehinted constructor parameter values.\n\n\n\n\nInstalling Aura.Di\n\n\nAura.Di implements \nPSR-11\n as of\nversion 3. To use Aura.Di as a dependency injection container, we recommend using\n\nzendframework/zend-auradi-config\n,\nwhich helps you to configure its container. First, install the package:\n\n\n$ composer require zendframework/zend-auradi-config\n\n\n\nConfiguration\n\n\nTo configure Aura.Di, create the file \nconfig/container.php\n with the following\ncontents:\n\n\n<?php\nuse Zend\\AuraDi\\Config\\Config;\nuse Zend\\AuraDi\\Config\\ContainerFactory;\n\n$config = require __DIR__ . '/config.php';\n$factory = new ContainerFactory();\nreturn $factory(new Config($config));\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();\n\n\n\nFor more information, please see the\n\nzend-auradi-config documentation",
            "title": "Using Aura.Di"
        },
        {
            "location": "/v3/features/container/aura-di/#using-auradi",
            "text": "Aura.Di  provides a serializable dependency\ninjection container with the following features:   constructor and setter injection.  inheritance of constructor parameter and setter method values from parent\n  classes.  inheritance of setter method values from interfaces and traits.  lazy-loaded instances, services, includes/requires, and values.  instance factories.  optional auto-resolution of typehinted constructor parameter values.",
            "title": "Using Aura.Di"
        },
        {
            "location": "/v3/features/container/aura-di/#installing-auradi",
            "text": "Aura.Di implements  PSR-11  as of\nversion 3. To use Aura.Di as a dependency injection container, we recommend using zendframework/zend-auradi-config ,\nwhich helps you to configure its container. First, install the package:  $ composer require zendframework/zend-auradi-config",
            "title": "Installing Aura.Di"
        },
        {
            "location": "/v3/features/container/aura-di/#configuration",
            "text": "To configure Aura.Di, create the file  config/container.php  with the following\ncontents:  <?php\nuse Zend\\AuraDi\\Config\\Config;\nuse Zend\\AuraDi\\Config\\ContainerFactory;\n\n$config = require __DIR__ . '/config.php';\n$factory = new ContainerFactory();\nreturn $factory(new Config($config));  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();  For more information, please see the zend-auradi-config documentation",
            "title": "Configuration"
        },
        {
            "location": "/v3/features/container/config/",
            "text": "Container configuration\n\n\n\n\nThis chapter is primarily written for container providers, so that they know\nwhat configuration features must be compatible, and what compatibility\nultimately means within the project.\n\n\n\n\nPSR-11\n defines an interface for\ndependency injection containers, and that interface is geared towards\n\nconsumption\n of the container \u2014 not \npopulation\n of it.\n\n\nExpressive \nconsumes\n a PSR-11 container, but also provides \nconfiguration\n for\na container: it defines what services it needs, and how to create them.\n\n\nAs such, any container consumed by Expressive must also understand its\nconfiguration format, and deliver consistent understanding of that format when\nproviding services based on it.\n\n\nThis document describes the configuration format, and details expectations for\nimplementations.\n\n\nThe format\n\n\nContainer configuration is provided within the \ndependencies\n key of\nconfiguration. That key is structured as follows:\n\n\nreturn [\n    'dependencies' => [\n        'services' => [\n            // name => instance pairs\n            'config' => $config,\n        ],\n        'aliases' => [\n            // alias => target pairs\n            'page-handler' => SomePageHandler::class,\n        ],\n        'factories' => [\n            // service => factory pairs\n            SomePageHandler::class => SomePageHandlerFactory::class,\n        ],\n        'invokables' => [\n            // service => instantiable class pairs\n            SomeInstantiableClass::class => SomeInstantiableClass::class,\n            'an-alias-for' => SomeInstantiableClass::class,\n        ],\n        'delegators' => [\n            // service => array of delegator factory pairs\n            SomeInstantiableClass::class => [\n                InjectListenersDelegator::class,\n                InjectLoggerDelegator::class,\n            ],\n        ],\n    ],\n];\n\n\n\nServices\n\n\nServices\n are actual instances you want to retrieve later from the container.\nThese are generally provided at initial creation; the \nconfig\n service is\npopulated in this way.\n\n\nWhen retrieving a service mapped in this way, you will always receive the\ninitial instance.\n\n\nAliases\n\n\nAliases\n map a service \nalias\n to another service, and are provided as\nkey/value pairs. As an example:\n\n\n'aliases' => [\n    'Zend\\Expressive\\Delegate\\DefaultDelegate' => \\Zend\\Expressive\\Handler\\NotFoundHandler::class,\n],\n\n\n\nIn this case, if the service named \"Zend\\Expressive\\Delegate\\DefaultDelegate\"\nis requested, the container should resolve that to the service\n\nZend\\Expressive\\Handler\\NotFoundHandler\n and return that instead.\n\n\nAliases may reference any other service defined in the container. These include\nservices defined under the keys:\n\n\n\n\nservices\n\n\nfactories\n\n\ninvokables\n\n\nor even other \naliases\n\n\n\n\nWhen returning an aliased service, the container MUST return the same instance\nas if the target service were retrieved. When aliases may reference other\naliases, the rule applies to the final resolved service, and not any\nintermediary aliases.\n\n\nFactories\n\n\nFactories\n map a service name to the factory capable of producing the instance.\n\n\nA \nfactory\n is any PHP callable capable of producing the instance:\n\n\n\n\nFunction names\n\n\nClosures\n\n\nClass instances that define the method \n__invoke()\n\n\nCallable references to static methods\n\n\nArray callables referencing static or instance methods\n\n\n\n\nThey may also be the \nclass name\n of a directly instantiable class (no\nconstructor arguments) that defines \n__invoke()\n. Generally, this latter\nconvention is used, as class names are serializable, while closures, objects,\nand array callables often are not.\n\n\nFactories are guaranteed to receive the PSR-11 container as an argument,\nallowing you to pull other services from the container as necessary to fulfill\ndependencies of the class being created and returned. Additionally, containers\nSHOULD pass the service name requested as the second argument; factories can\ndetermine whether that argument is necessary.\n\n\nA typical factory will generally ignore the second argument:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomePageHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SomePageHandler(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}\n\n\n\nYou can, however, re-use a factory for multiple services by accepting the second\nargument and varying creation based on it:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass PageFactory\n{\n    public function __invoke(ContainerInterface $container, string $serviceName)\n    {\n        $name = strtolower($serviceName);\n        return new PageHandler(\n            $container->get(TemplateRendererInterface::class),\n            $name\n        );\n    };\n}\n\n\n\nThe above could be mapped for several services:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            'hello-world' => PageFactory::class,\n            'about'       => PageFactory::class,\n        ],\n    ],\n];\n\n\n\nIn general, services should be cached by the container after initial creation;\nfactories should only be called once for any given service name.\n\n\nInvokables\n\n\nInvokables\n refer to any class that may be instantiated without any constructor\narguments. In other words, one should be able to create an instance solely be\ncalling \nnew $className()\n.\n\n\nConfiguration for invokables looks verbose; it's a map of the service name to\nthe class name to instantiate, and, generally, these are the same values.\n\n\nHowever, you can \nalso\n provide a different service name. In those situations,\ncontainers MUST treat the service name as an alias to the final class name, and\nallow retrieving the service by EITHER the alias OR the class name.\n\n\nAs an example, given the following configuration:\n\n\n'dependencies' => [\n    'invokables' => [\n        'HelloWorld' => PageAction::class,\n    ],\n],\n\n\n\nthe container should allow retrieval of both the services \"HelloWorld\" as well\nas the \"PageAction\" class.\n\n\nDelegator Factories\n\n\nDelegator factories are factories that may be used to \ndecorate\n or \nmanipulate\n\na service before returning it from the container. They are covered in detail \nin\nanother chapter\n, and delegator factories have the\nfollowing signature:\n\n\nuse Psr\\Container\\ContainerInterface;\n\nfunction (\n    ContainerInterface $container,\n    string $serviceName,\n    callable $callback\n)\n\n\n\nConfiguration for delegator factories is using the \"delegators\" sub-key of the\n\"dependencies\" configuration. Each entry is a service name pointing to an\n\narray\n of delegator factories.\n\n\nDelegator factories are called in the order they appear in configuration. For\nthe first delegator factory, the \n$callback\n argument will be essentially the\nreturn value of \n$container->get()\n for the given service \nif there were no\ndelegator factories attached to it\n; in other words, it would be the\n\ninvokable\n or service returned by a \nfactory\n, after\n\nalias\n resolution.\n\n\n\n\nDelegators \nDO NOT\n operate on items in the \nservices\n configuration!\nAll items in the \nservices\n configuration are considered complete, and will\nalways be served as-is.\n\n\n\n\nEach delegator then returns a value, and that value will be what \n$callback\n\nreturns for the next delegator. If the delegator is the last in the list, then\nwhat it returns becomes the final value for the service in the container;\nsubsequent calls to \n$container->get()\n for that service will return that value.\nDelegators MUST return a value!\n\n\nFor container implementors, delegators MUST only be called when initially\ncreating the service, and not each time a service is retrieved.\n\n\nCommon use cases for delegators include:\n\n\n\n\nDecorating an instance so that it may be used in another context (e.g.,\n  decorating a PHP \ncallable\n to be used as PSR-15 middleware).\n\n\nInjecting collaborators (e.g., adding listeners to the \nErrorHandler\n).\n\n\nConditionally replacing an instance based on configuration (e.g., swapping\n  debug-enabled middleware for production middleware).\n\n\n\n\nOther capabilities\n\n\nSelection of a dependency injection container should be based on capabilities\nthat implementation provides. This may be performance, or it may be additional\nfeatures beyond those specified here. We encourage \napplication developers\n to\nmake full use of the container they select. The only caveat is that the above\nfeatures MUST be supported by implementations for compatibility purposes, and\nthe above are the only features \npackage providers\n may count on when providing\ncontainer configuration.\n\n\nExamples of how the above capabilities may be implemented include:\n\n\n\n\nzendframework/zend-auradi-config\n\n\nzendframework/zend-pimple-config\n\n\njsoumelidis/zend-sf-di-config",
            "title": "Container configuration"
        },
        {
            "location": "/v3/features/container/config/#container-configuration",
            "text": "This chapter is primarily written for container providers, so that they know\nwhat configuration features must be compatible, and what compatibility\nultimately means within the project.   PSR-11  defines an interface for\ndependency injection containers, and that interface is geared towards consumption  of the container \u2014 not  population  of it.  Expressive  consumes  a PSR-11 container, but also provides  configuration  for\na container: it defines what services it needs, and how to create them.  As such, any container consumed by Expressive must also understand its\nconfiguration format, and deliver consistent understanding of that format when\nproviding services based on it.  This document describes the configuration format, and details expectations for\nimplementations.",
            "title": "Container configuration"
        },
        {
            "location": "/v3/features/container/config/#the-format",
            "text": "Container configuration is provided within the  dependencies  key of\nconfiguration. That key is structured as follows:  return [\n    'dependencies' => [\n        'services' => [\n            // name => instance pairs\n            'config' => $config,\n        ],\n        'aliases' => [\n            // alias => target pairs\n            'page-handler' => SomePageHandler::class,\n        ],\n        'factories' => [\n            // service => factory pairs\n            SomePageHandler::class => SomePageHandlerFactory::class,\n        ],\n        'invokables' => [\n            // service => instantiable class pairs\n            SomeInstantiableClass::class => SomeInstantiableClass::class,\n            'an-alias-for' => SomeInstantiableClass::class,\n        ],\n        'delegators' => [\n            // service => array of delegator factory pairs\n            SomeInstantiableClass::class => [\n                InjectListenersDelegator::class,\n                InjectLoggerDelegator::class,\n            ],\n        ],\n    ],\n];",
            "title": "The format"
        },
        {
            "location": "/v3/features/container/config/#services",
            "text": "Services  are actual instances you want to retrieve later from the container.\nThese are generally provided at initial creation; the  config  service is\npopulated in this way.  When retrieving a service mapped in this way, you will always receive the\ninitial instance.",
            "title": "Services"
        },
        {
            "location": "/v3/features/container/config/#aliases",
            "text": "Aliases  map a service  alias  to another service, and are provided as\nkey/value pairs. As an example:  'aliases' => [\n    'Zend\\Expressive\\Delegate\\DefaultDelegate' => \\Zend\\Expressive\\Handler\\NotFoundHandler::class,\n],  In this case, if the service named \"Zend\\Expressive\\Delegate\\DefaultDelegate\"\nis requested, the container should resolve that to the service Zend\\Expressive\\Handler\\NotFoundHandler  and return that instead.  Aliases may reference any other service defined in the container. These include\nservices defined under the keys:   services  factories  invokables  or even other  aliases   When returning an aliased service, the container MUST return the same instance\nas if the target service were retrieved. When aliases may reference other\naliases, the rule applies to the final resolved service, and not any\nintermediary aliases.",
            "title": "Aliases"
        },
        {
            "location": "/v3/features/container/config/#factories",
            "text": "Factories  map a service name to the factory capable of producing the instance.  A  factory  is any PHP callable capable of producing the instance:   Function names  Closures  Class instances that define the method  __invoke()  Callable references to static methods  Array callables referencing static or instance methods   They may also be the  class name  of a directly instantiable class (no\nconstructor arguments) that defines  __invoke() . Generally, this latter\nconvention is used, as class names are serializable, while closures, objects,\nand array callables often are not.  Factories are guaranteed to receive the PSR-11 container as an argument,\nallowing you to pull other services from the container as necessary to fulfill\ndependencies of the class being created and returned. Additionally, containers\nSHOULD pass the service name requested as the second argument; factories can\ndetermine whether that argument is necessary.  A typical factory will generally ignore the second argument:  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomePageHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SomePageHandler(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}  You can, however, re-use a factory for multiple services by accepting the second\nargument and varying creation based on it:  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass PageFactory\n{\n    public function __invoke(ContainerInterface $container, string $serviceName)\n    {\n        $name = strtolower($serviceName);\n        return new PageHandler(\n            $container->get(TemplateRendererInterface::class),\n            $name\n        );\n    };\n}  The above could be mapped for several services:  return [\n    'dependencies' => [\n        'factories' => [\n            'hello-world' => PageFactory::class,\n            'about'       => PageFactory::class,\n        ],\n    ],\n];  In general, services should be cached by the container after initial creation;\nfactories should only be called once for any given service name.",
            "title": "Factories"
        },
        {
            "location": "/v3/features/container/config/#invokables",
            "text": "Invokables  refer to any class that may be instantiated without any constructor\narguments. In other words, one should be able to create an instance solely be\ncalling  new $className() .  Configuration for invokables looks verbose; it's a map of the service name to\nthe class name to instantiate, and, generally, these are the same values.  However, you can  also  provide a different service name. In those situations,\ncontainers MUST treat the service name as an alias to the final class name, and\nallow retrieving the service by EITHER the alias OR the class name.  As an example, given the following configuration:  'dependencies' => [\n    'invokables' => [\n        'HelloWorld' => PageAction::class,\n    ],\n],  the container should allow retrieval of both the services \"HelloWorld\" as well\nas the \"PageAction\" class.",
            "title": "Invokables"
        },
        {
            "location": "/v3/features/container/config/#delegator-factories",
            "text": "Delegator factories are factories that may be used to  decorate  or  manipulate \na service before returning it from the container. They are covered in detail  in\nanother chapter , and delegator factories have the\nfollowing signature:  use Psr\\Container\\ContainerInterface;\n\nfunction (\n    ContainerInterface $container,\n    string $serviceName,\n    callable $callback\n)  Configuration for delegator factories is using the \"delegators\" sub-key of the\n\"dependencies\" configuration. Each entry is a service name pointing to an array  of delegator factories.  Delegator factories are called in the order they appear in configuration. For\nthe first delegator factory, the  $callback  argument will be essentially the\nreturn value of  $container->get()  for the given service  if there were no\ndelegator factories attached to it ; in other words, it would be the invokable  or service returned by a  factory , after alias  resolution.   Delegators  DO NOT  operate on items in the  services  configuration!\nAll items in the  services  configuration are considered complete, and will\nalways be served as-is.   Each delegator then returns a value, and that value will be what  $callback \nreturns for the next delegator. If the delegator is the last in the list, then\nwhat it returns becomes the final value for the service in the container;\nsubsequent calls to  $container->get()  for that service will return that value.\nDelegators MUST return a value!  For container implementors, delegators MUST only be called when initially\ncreating the service, and not each time a service is retrieved.  Common use cases for delegators include:   Decorating an instance so that it may be used in another context (e.g.,\n  decorating a PHP  callable  to be used as PSR-15 middleware).  Injecting collaborators (e.g., adding listeners to the  ErrorHandler ).  Conditionally replacing an instance based on configuration (e.g., swapping\n  debug-enabled middleware for production middleware).",
            "title": "Delegator Factories"
        },
        {
            "location": "/v3/features/container/config/#other-capabilities",
            "text": "Selection of a dependency injection container should be based on capabilities\nthat implementation provides. This may be performance, or it may be additional\nfeatures beyond those specified here. We encourage  application developers  to\nmake full use of the container they select. The only caveat is that the above\nfeatures MUST be supported by implementations for compatibility purposes, and\nthe above are the only features  package providers  may count on when providing\ncontainer configuration.  Examples of how the above capabilities may be implemented include:   zendframework/zend-auradi-config  zendframework/zend-pimple-config  jsoumelidis/zend-sf-di-config",
            "title": "Other capabilities"
        },
        {
            "location": "/v3/features/router/intro/",
            "text": "Routing\n\n\nOne fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:\n\n\n\n\n/books\n might return a collection of books\n\n\n/books/zend-expressive\n might return the individual book identified by\n  \"zend-expressive\".\n\n\n\n\nExpressive does not provide routing on its own; you must choose a routing\nadapter that implements \nZend\\Expressive\\Router\\RouterInterface\n. The router is\nconsumed by \nZend\\Expressive\\Router\\Middleware\\RouteMiddleware\n as well as\n\nZend\\Expressive\\Router\\RouteCollector\n, the latter of which is composed in the\n\nApplication\n instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.\n\n\nRetrieving matched parameters\n\n\nRouting enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as \nattributes\n.\n\n\nIn the example above, let's assume the route was defined as \n/books/:id\n, where\n\nid\n is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the \nid\n attribute to discover what was\nmatched:\n\n\n$id = $request->getAttribute('id');\n\n\n\nRetrieving the matched route\n\n\nWhen routing is complete, the routing middleware injects a\n\nZend\\Expressive\\Router\\RouteResult\n instance as a request attribute, using that\nclass name as the attribute name. The \nRouteResult\n instance provides you access\nto the following:\n\n\n\n\nMatching status via the methods \n$result->isSuccess()\n,\n  \n$result->isFailure()\n, and \n$result->isMethodFailure()\n (indicating a\n  path-based match that did not match an allowed HTTP method).\n\n\nAllowed HTTP methods, via \n$result->getAllowedMethods()\n (for either success\n  or failure).\n\n\nThe matched \nZend\\Expressive\\Router\\Route\n instance, via\n  \n$result->getMatchedRoute()\n (successful matches only).\n\n\nThe matched route name, via \n$result->getMatchedRouteName()\n (or via\n  \n$result->getMatchedRoute()->getName()\n; successful matches only).\n\n\nMatched parameters, via \n$result->getMatchedParams()\n (as noted above, these\n  are also each injected as discrete request attributes; successful matches only).\n\n\n\n\nAs an example, you could use middleware similar to the following to return a 403\nresponse if routing was successful, but no \nAuthorization\n header is present:\n\n\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nfunction ($request, RequestHandlerInterface $handler) use ($routesRequiringAuthorization, $validator) {\n    if (! ($result = $request->getAttribute(RouteResult::class, false))) {\n        // No route result present; delegate to next middleware\n        return $handler->handle($request);\n    }\n\n    if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) {\n        // Not a route requiring authorization\n        return $handler->handle($request);\n    }\n\n    $header = $request->getHeaderLine('Authorization');\n    if (! $validator($header)) {\n        return new EmptyResponse(403);\n    }\n\n    return $handler->handle($request);\n}\n\n\n\nNote that the first step is to determine if we have a \nRouteResult\n; if we do\nnot have one, we should either delegate to the next middleware, or return some\nsort of response (generally a 404). In the case of Expressive, a later\nmiddleware will generate the 404 response for us, so we can safely delegate.\n\n\nURI generation\n\n\nBecause routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the \nRouterInterface\n,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.\n\n\nAt it's most basic level, you call the \ngenerateUri()\n method with a route name\nand any substitutions you want to make:\n\n\n$uri = $router->generateUri('book', ['id' => 'zend-expressive']);\n\n\n\nSome routers may support providing \noptions\n during URI generation. Starting in\nzend-expressive-router 2.0, which ships with Expressive starting with version\n2.0, you may also pass a third argument to \ngenerateUri()\n, an array of router\noptions:\n\n\n$uri = $router->generateUri('book', ['id' => 'zend-expressive'], [\n    'translator'  => $translator,\n    'text_domain' => $currentLocale,\n]);\n\n\n\nSupported implementations\n\n\nExpressive currently ships with adapters for the following routers:\n\n\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-mvc Router",
            "title": "Introduction"
        },
        {
            "location": "/v3/features/router/intro/#routing",
            "text": "One fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:   /books  might return a collection of books  /books/zend-expressive  might return the individual book identified by\n  \"zend-expressive\".   Expressive does not provide routing on its own; you must choose a routing\nadapter that implements  Zend\\Expressive\\Router\\RouterInterface . The router is\nconsumed by  Zend\\Expressive\\Router\\Middleware\\RouteMiddleware  as well as Zend\\Expressive\\Router\\RouteCollector , the latter of which is composed in the Application  instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.",
            "title": "Routing"
        },
        {
            "location": "/v3/features/router/intro/#retrieving-matched-parameters",
            "text": "Routing enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as  attributes .  In the example above, let's assume the route was defined as  /books/:id , where id  is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the  id  attribute to discover what was\nmatched:  $id = $request->getAttribute('id');",
            "title": "Retrieving matched parameters"
        },
        {
            "location": "/v3/features/router/intro/#retrieving-the-matched-route",
            "text": "When routing is complete, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult  instance as a request attribute, using that\nclass name as the attribute name. The  RouteResult  instance provides you access\nto the following:   Matching status via the methods  $result->isSuccess() ,\n   $result->isFailure() , and  $result->isMethodFailure()  (indicating a\n  path-based match that did not match an allowed HTTP method).  Allowed HTTP methods, via  $result->getAllowedMethods()  (for either success\n  or failure).  The matched  Zend\\Expressive\\Router\\Route  instance, via\n   $result->getMatchedRoute()  (successful matches only).  The matched route name, via  $result->getMatchedRouteName()  (or via\n   $result->getMatchedRoute()->getName() ; successful matches only).  Matched parameters, via  $result->getMatchedParams()  (as noted above, these\n  are also each injected as discrete request attributes; successful matches only).   As an example, you could use middleware similar to the following to return a 403\nresponse if routing was successful, but no  Authorization  header is present:  use Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nfunction ($request, RequestHandlerInterface $handler) use ($routesRequiringAuthorization, $validator) {\n    if (! ($result = $request->getAttribute(RouteResult::class, false))) {\n        // No route result present; delegate to next middleware\n        return $handler->handle($request);\n    }\n\n    if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) {\n        // Not a route requiring authorization\n        return $handler->handle($request);\n    }\n\n    $header = $request->getHeaderLine('Authorization');\n    if (! $validator($header)) {\n        return new EmptyResponse(403);\n    }\n\n    return $handler->handle($request);\n}  Note that the first step is to determine if we have a  RouteResult ; if we do\nnot have one, we should either delegate to the next middleware, or return some\nsort of response (generally a 404). In the case of Expressive, a later\nmiddleware will generate the 404 response for us, so we can safely delegate.",
            "title": "Retrieving the matched route"
        },
        {
            "location": "/v3/features/router/intro/#uri-generation",
            "text": "Because routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the  RouterInterface ,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.  At it's most basic level, you call the  generateUri()  method with a route name\nand any substitutions you want to make:  $uri = $router->generateUri('book', ['id' => 'zend-expressive']);  Some routers may support providing  options  during URI generation. Starting in\nzend-expressive-router 2.0, which ships with Expressive starting with version\n2.0, you may also pass a third argument to  generateUri() , an array of router\noptions:  $uri = $router->generateUri('book', ['id' => 'zend-expressive'], [\n    'translator'  => $translator,\n    'text_domain' => $currentLocale,\n]);",
            "title": "URI generation"
        },
        {
            "location": "/v3/features/router/intro/#supported-implementations",
            "text": "Expressive currently ships with adapters for the following routers:   Aura.Router  FastRoute  zend-mvc Router",
            "title": "Supported implementations"
        },
        {
            "location": "/v3/features/router/interface/",
            "text": "Routing Interface\n\n\nExpressive defines \nZend\\Expressive\\Router\\RouterInterface\n, which is used by\nthe \nZend\\Expressive\\Router\\RouteMiddleware\n \u2014 as well as the\n\nZend\\Expressive\\Router\\RouteCollector\n consumed by\n\nZend\\Expressive\\Application\n \u2014 in order to provide dynamic routing\ncapabilities to middleware. The interface serves as an abstraction to allow\nrouters with varying capabilities to be used with an application.\n\n\nThe interface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\n/**\n * Interface defining required router capabilities.\n */\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route) : void;\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     */\n    public function match(Request $request) : RouteResult;\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it. Additional router-dependent options may be passed.\n     *\n     * The URI generated MUST NOT be escaped. If you wish to escape any part of\n     * the URI, this should be performed afterwards; consider passing the URI\n     * to league/uri to encode it.\n     *\n     * @see https://github.com/auraphp/Aura.Router/blob/3.x/docs/generating-paths.md\n     * @see https://docs.zendframework.com/zend-router/routing/\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri(string $name, array $substitutions = [], array $options = []) : string;\n}\n\n\n\nDevelopers may create and use their own implementations. We recommend\nregistering your implementation as the service\n\nZend\\Expressive\\Router\\RouterInterface\n in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.\n\n\nImplementors should also read the following sections detailing the \nRoute\n and\n\nRouteResult\n classes, to ensure that their implementations interoperate\ncorrectly.\n\n\nRoutes\n\n\nRoutes are defined via \nZend\\Expressive\\Router\\Route\n, and aggregate the\nfollowing information:\n\n\n\n\nPath to match.\n\n\nMiddleware to use when the route is matched. The value \nmust\n implement\n  \nPsr\\Http\\Server\\MiddlewareInterface\n.\n\n\nHTTP methods allowed for the route; if none are provided, all are assumed.\n\n\nOptionally, a name by which to reference the route.\n\n\n\n\nThe \nRoute\n class has the following signature:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Fig\\Http\\Message\\RequestMethodInterface as RequestMethod;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass Route implements MiddlewareInterface\n{\n    public const HTTP_METHOD_ANY = null;\n    public const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param MiddlewareInterface $middleware Middleware to use when this route is matched.\n     * @param null|string[] $methods Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param null|string $name the route name\n     */\n    public function __construct(\n        string $path,\n        MiddlewareInterface $middleware,\n        array $methods = self::HTTP_METHOD_ANY,\n        string $name = null\n    );\n\n    /**\n     * Proxies to the middleware composed during instantiation.\n     */\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface;\n\n    public function getPath() : string;\n\n    /**\n     * Set the route name.\n     */\n    public function setName(string $name) : void;\n\n    public function getName() : string;\n\n    public function getMiddleware() : MiddlewareInterface;\n\n    /**\n     * @return null|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods() : ?array;\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     */\n    public function allowsMethod(string $method) : bool;\n\n    public function setOptions(array $options) : void;\n\n    public function getOptions() : array;\n}\n\n\n\nTypically, developers will use the \nroute()\n method of either\n\nZend\\Expressive\\Router\\PathBasedRoutingMiddleware\n or\n\nZend\\Expressive\\Application\n (or one of the HTTP-specific routing methods of\neither class) to create routes, and will not need to interact with \nRoute\n\ninstances.  Additionally, when working with \nRouteResult\n instances, you may\npull the \nRoute\n instance from that in order to obtain data about the matched\nroute.\n\n\nMatching and RouteResults\n\n\nInternally, routing middleware calls on \nRouterInterface::match()\n,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the\n\nHTTPS\n server variable, etc.\n\n\nImplementations are expected to return a \nZend\\Expressive\\Router\\RouteResult\n\ninstance, which is then injected as a request attribute under the name\n\nZend\\Expressive\\Router\\RouteResult\n when passing processing of the request to\nthe provided handler. Additionally, in the event of success, it will pull any\nmatched parameters from the result and inject them as request attributes as\nwell.\n\n\nDispatch middleware can then retrieve the route result from the request and\nprocess it, passing the route result its own request and handler.\n\n\nThe zend-expressive-router package also provides a number of middleware geared\ntowards handling failed results which can be placed between routing and dispatch\nmiddleware:\n\n\n\n\n\n\nZend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware\n checks to see\n  if the route failures was due to the HTTP method, and, if so, return a 405\n  response with an appropriate \nAllow\n header.\n  (\nread more\n)\n\n\n\n\n\n\nZend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware\n checks to see if a\n  routing failure was due to a route match using a \nHEAD\n request, and will then\n  dispatch the appropriate route via \nGET\n request, and inject an empty body\n  into the returned response.\n  (\nread more\n)\n\n\n\n\n\n\nZend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware\n checks to see if a\n  routing failure was due to a route match using a \nOPTIONS\n request; if so, it\n  will return a 200 response with an appropriate \nAllow\nheader.\n  (\nread more\n)\n\n\n\n\n\n\nThe \nRouteResult\n signature is as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass RouteResult implements MiddlewareInterface\n{\n    /**\n     * Create an instance representing a route succes from the matching route.\n     *\n     * @param array $params Parameters associated with the matched route, if any.\n     */\n    public static function fromRoute(Route $route, array $params = []) : self;\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|array $methods HTTP methods allowed for the current URI, if any.\n     *     null is equivalent to allowing any HTTP method; empty array means none.\n     */\n    public static function fromRouteFailure(?array $methods) : self;\n\n    /**\n     * Process the result as middleware.\n     *\n     * If the result represents a failure, it passes handling to the handler.\n     *\n     * Otherwise, it processes the composed middleware using the provide request\n     * and handler.\n     */\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface;\n\n    /**\n     * Does the result represent successful routing?\n     */\n    public function isSuccess() : bool;\n\n    /**\n     * Retrieve the route that resulted in the route match.\n     *\n     * @return false|null|Route false if representing a routing failure;\n     *     null if not created via fromRoute(); Route instance otherwise.\n     */\n    public function getMatchedRoute();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return false|string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Returns the matched params.\n     */\n    public function getMatchedParams() : array;\n\n    /**\n     * Is this a routing failure result?\n     */\n    public function isFailure() : bool;\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     */\n    public function isMethodFailure() : bool;\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods() : array;\n}\n\n\n\nTypically, only those implementing routers will interact with this class.",
            "title": "Routing Interface"
        },
        {
            "location": "/v3/features/router/interface/#routing-interface",
            "text": "Expressive defines  Zend\\Expressive\\Router\\RouterInterface , which is used by\nthe  Zend\\Expressive\\Router\\RouteMiddleware  \u2014 as well as the Zend\\Expressive\\Router\\RouteCollector  consumed by Zend\\Expressive\\Application  \u2014 in order to provide dynamic routing\ncapabilities to middleware. The interface serves as an abstraction to allow\nrouters with varying capabilities to be used with an application.  The interface is defined as follows:  namespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\n/**\n * Interface defining required router capabilities.\n */\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route) : void;\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     */\n    public function match(Request $request) : RouteResult;\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it. Additional router-dependent options may be passed.\n     *\n     * The URI generated MUST NOT be escaped. If you wish to escape any part of\n     * the URI, this should be performed afterwards; consider passing the URI\n     * to league/uri to encode it.\n     *\n     * @see https://github.com/auraphp/Aura.Router/blob/3.x/docs/generating-paths.md\n     * @see https://docs.zendframework.com/zend-router/routing/\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri(string $name, array $substitutions = [], array $options = []) : string;\n}  Developers may create and use their own implementations. We recommend\nregistering your implementation as the service Zend\\Expressive\\Router\\RouterInterface  in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.  Implementors should also read the following sections detailing the  Route  and RouteResult  classes, to ensure that their implementations interoperate\ncorrectly.",
            "title": "Routing Interface"
        },
        {
            "location": "/v3/features/router/interface/#routes",
            "text": "Routes are defined via  Zend\\Expressive\\Router\\Route , and aggregate the\nfollowing information:   Path to match.  Middleware to use when the route is matched. The value  must  implement\n   Psr\\Http\\Server\\MiddlewareInterface .  HTTP methods allowed for the route; if none are provided, all are assumed.  Optionally, a name by which to reference the route.   The  Route  class has the following signature:  namespace Zend\\Expressive\\Router;\n\nuse Fig\\Http\\Message\\RequestMethodInterface as RequestMethod;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass Route implements MiddlewareInterface\n{\n    public const HTTP_METHOD_ANY = null;\n    public const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param MiddlewareInterface $middleware Middleware to use when this route is matched.\n     * @param null|string[] $methods Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param null|string $name the route name\n     */\n    public function __construct(\n        string $path,\n        MiddlewareInterface $middleware,\n        array $methods = self::HTTP_METHOD_ANY,\n        string $name = null\n    );\n\n    /**\n     * Proxies to the middleware composed during instantiation.\n     */\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface;\n\n    public function getPath() : string;\n\n    /**\n     * Set the route name.\n     */\n    public function setName(string $name) : void;\n\n    public function getName() : string;\n\n    public function getMiddleware() : MiddlewareInterface;\n\n    /**\n     * @return null|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods() : ?array;\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     */\n    public function allowsMethod(string $method) : bool;\n\n    public function setOptions(array $options) : void;\n\n    public function getOptions() : array;\n}  Typically, developers will use the  route()  method of either Zend\\Expressive\\Router\\PathBasedRoutingMiddleware  or Zend\\Expressive\\Application  (or one of the HTTP-specific routing methods of\neither class) to create routes, and will not need to interact with  Route \ninstances.  Additionally, when working with  RouteResult  instances, you may\npull the  Route  instance from that in order to obtain data about the matched\nroute.",
            "title": "Routes"
        },
        {
            "location": "/v3/features/router/interface/#matching-and-routeresults",
            "text": "Internally, routing middleware calls on  RouterInterface::match() ,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the HTTPS  server variable, etc.  Implementations are expected to return a  Zend\\Expressive\\Router\\RouteResult \ninstance, which is then injected as a request attribute under the name Zend\\Expressive\\Router\\RouteResult  when passing processing of the request to\nthe provided handler. Additionally, in the event of success, it will pull any\nmatched parameters from the result and inject them as request attributes as\nwell.  Dispatch middleware can then retrieve the route result from the request and\nprocess it, passing the route result its own request and handler.  The zend-expressive-router package also provides a number of middleware geared\ntowards handling failed results which can be placed between routing and dispatch\nmiddleware:    Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware  checks to see\n  if the route failures was due to the HTTP method, and, if so, return a 405\n  response with an appropriate  Allow  header.\n  ( read more )    Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware  checks to see if a\n  routing failure was due to a route match using a  HEAD  request, and will then\n  dispatch the appropriate route via  GET  request, and inject an empty body\n  into the returned response.\n  ( read more )    Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware  checks to see if a\n  routing failure was due to a route match using a  OPTIONS  request; if so, it\n  will return a 200 response with an appropriate  Allow header.\n  ( read more )    The  RouteResult  signature is as follows:  namespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass RouteResult implements MiddlewareInterface\n{\n    /**\n     * Create an instance representing a route succes from the matching route.\n     *\n     * @param array $params Parameters associated with the matched route, if any.\n     */\n    public static function fromRoute(Route $route, array $params = []) : self;\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|array $methods HTTP methods allowed for the current URI, if any.\n     *     null is equivalent to allowing any HTTP method; empty array means none.\n     */\n    public static function fromRouteFailure(?array $methods) : self;\n\n    /**\n     * Process the result as middleware.\n     *\n     * If the result represents a failure, it passes handling to the handler.\n     *\n     * Otherwise, it processes the composed middleware using the provide request\n     * and handler.\n     */\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface;\n\n    /**\n     * Does the result represent successful routing?\n     */\n    public function isSuccess() : bool;\n\n    /**\n     * Retrieve the route that resulted in the route match.\n     *\n     * @return false|null|Route false if representing a routing failure;\n     *     null if not created via fromRoute(); Route instance otherwise.\n     */\n    public function getMatchedRoute();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return false|string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Returns the matched params.\n     */\n    public function getMatchedParams() : array;\n\n    /**\n     * Is this a routing failure result?\n     */\n    public function isFailure() : bool;\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     */\n    public function isMethodFailure() : bool;\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods() : array;\n}  Typically, only those implementing routers will interact with this class.",
            "title": "Matching and RouteResults"
        },
        {
            "location": "/v3/features/router/route-collector/",
            "text": "The Route Collector\n\n\nZend\\Expressive\\Router\\RouteCollector\n is a class that exists to help you\n\ncreate\n path-based routes, while simultaneously injecting them into a router\ninstance.\n\n\nIt composes a \nZend\\Expressive\\Router\\RouterInterface\n instance via its\nconstructor, and provides the following methods:\n\n\n\n\nroute()\n\n\nany()\n\n\ndelete()\n\n\nget()\n\n\npatch()\n\n\npost()\n\n\nput()\n\n\n\n\nThese methods allow you to add routes to the underlying router. The last five\nall reference the HTTP method the generated route will answer to, and each have\nthe same signature:\n\n\npublic function {method}(\n    string $path,\n    Psr\\Http\\Server\\MiddlewareInterface $middleware,\n    string $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nThe \nany()\n method has the same signature, but indicates that it will answer to\n\nany\n HTTP method.\n\n\nFinally, \nroute()\n has the following signature:\n\n\npublic function route(\n    string $path,\n    Psr\\Http\\Server\\MiddlewareInterface $middleware,\n    array $methods = null,\n    string $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nA \nnull\n value for the \n$methods\n indicates any HTTP method is allowed.\n\n\nZend\\Expressive\\Application\n composes an instance of this class\nand proxies to it when any of the above methods are called.\n\nZend\\Expressive\\Router\\Middleware\\RouteMiddleware\n, by default, composes the\nsame router instance, allowing it to honor the definitions created.",
            "title": "The Route Collector"
        },
        {
            "location": "/v3/features/router/route-collector/#the-route-collector",
            "text": "Zend\\Expressive\\Router\\RouteCollector  is a class that exists to help you create  path-based routes, while simultaneously injecting them into a router\ninstance.  It composes a  Zend\\Expressive\\Router\\RouterInterface  instance via its\nconstructor, and provides the following methods:   route()  any()  delete()  get()  patch()  post()  put()   These methods allow you to add routes to the underlying router. The last five\nall reference the HTTP method the generated route will answer to, and each have\nthe same signature:  public function {method}(\n    string $path,\n    Psr\\Http\\Server\\MiddlewareInterface $middleware,\n    string $name = null\n) : Zend\\Expressive\\Router\\Route  The  any()  method has the same signature, but indicates that it will answer to any  HTTP method.  Finally,  route()  has the following signature:  public function route(\n    string $path,\n    Psr\\Http\\Server\\MiddlewareInterface $middleware,\n    array $methods = null,\n    string $name = null\n) : Zend\\Expressive\\Router\\Route  A  null  value for the  $methods  indicates any HTTP method is allowed.  Zend\\Expressive\\Application  composes an instance of this class\nand proxies to it when any of the above methods are called. Zend\\Expressive\\Router\\Middleware\\RouteMiddleware , by default, composes the\nsame router instance, allowing it to honor the definitions created.",
            "title": "The Route Collector"
        },
        {
            "location": "/v3/features/router/uri-generation/",
            "text": "URI Generation\n\n\nOne aspect of the \nZend\\Expressive\\Router\\RouterInterface\n is that it provides a\n\ngenerateUri()\n method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders). You may also pass router-specific options to use\nduring URI generation as a third argument.\n\n\nNaming routes\n\n\nBy default, routes use a combination of the path and HTTP methods supported as\nthe name:\n\n\n\n\nIf you call \nroute()\n with no HTTP methods, the name is the literal path with\n  no changes.\n\n\n\n\n$app->route('/foo', $middleware); // \"foo\"\n\n\n\n\n\nIf you call \nget()\n, \npost()\n, \nput()\n, \npatch()\n, or \ndelete()\n, the name\n  will be the literal path, followed by a caret (\n^\n), followed by the\n  uppercase HTTP method name:\n\n\n\n\n$app->get('/foo', $middleware); // \"foo^GET\"\n\n\n\nAlternately, these methods return a \nRoute\n instance, and you can set the\n  name on it:\n\n\n$app->get('/foo', $middleware)->setName('foo'); // \"foo\"\n\n\n\n\n\nIf you call \nroute()\n and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret (\n^\n), followed by a colon\n  (\n:\n)-separated list of the uppercase HTTP method names, in the order in which\n  they were added.\n\n\n\n\n$app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n\n\n\nLike the HTTP-specific methods, \nroute()\n also returns a \nRoute\n instance,\n  and you can set the name on it:\n\n\n$route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n$route->setName('foo'); // \"foo\"\n\n\n\nClearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:\n\n\n$app->route('/foo', $middleware, 'foo'); // 'foo'\n$app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'\n\n\n\nAs noted above, these methods also return \nRoute\n instances, allowing you to\nset the name after-the-fact; this is particularly useful with the \nroute()\n\nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:\n\n\n$app->route('/foo', $middleware)->setName('foo'); // 'foo'\n\n\n\nWe recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.\n\n\n\n\nNames must be unique\n\n\nIn order for the URI generation functionality to work, routes must be uniquely\nnamed. This can be tricky when you use the same route path for multiple\nroutes:\n\n\n$app->get('/books', ListBooksHandler::class, 'books');\n$app->post('/books', CreateBookHandler::class, 'books'); // oops!\n\n\n\nYou could, of course, name the second route \"create-book\" or similar, but you\nthen have multiple names capable of generating the same URI.\n\n\nSince URIs do not have a concept of HTTP method built in, we recommend naming\neither the route matching \nGET\n or the first route in the sequence:\n\n\n$app->get('/books', ListBooksHandler::class, 'books');\n$app->post('/books', CreateBookHandler::class); // no name\n\n\n\n\n\nGenerating URIs\n\n\nOnce you know the name of a URI you wish to generate, you can do so from the\nrouter instance:\n\n\n$uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\"\n\n\n\nYou can omit the second argument if no substitutions are necessary.\n\n\n\n\nCompose the router\n\n\nFor this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the\n\nZend\\Expressive\\Router\\RouterInterface\n service in these situations.\n\n\nAlternately, use the \nUrlHelper\n instead.",
            "title": "URI Generation"
        },
        {
            "location": "/v3/features/router/uri-generation/#uri-generation",
            "text": "One aspect of the  Zend\\Expressive\\Router\\RouterInterface  is that it provides a generateUri()  method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders). You may also pass router-specific options to use\nduring URI generation as a third argument.",
            "title": "URI Generation"
        },
        {
            "location": "/v3/features/router/uri-generation/#naming-routes",
            "text": "By default, routes use a combination of the path and HTTP methods supported as\nthe name:   If you call  route()  with no HTTP methods, the name is the literal path with\n  no changes.   $app->route('/foo', $middleware); // \"foo\"   If you call  get() ,  post() ,  put() ,  patch() , or  delete() , the name\n  will be the literal path, followed by a caret ( ^ ), followed by the\n  uppercase HTTP method name:   $app->get('/foo', $middleware); // \"foo^GET\"  Alternately, these methods return a  Route  instance, and you can set the\n  name on it:  $app->get('/foo', $middleware)->setName('foo'); // \"foo\"   If you call  route()  and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret ( ^ ), followed by a colon\n  ( : )-separated list of the uppercase HTTP method names, in the order in which\n  they were added.   $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"  Like the HTTP-specific methods,  route()  also returns a  Route  instance,\n  and you can set the name on it:  $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n$route->setName('foo'); // \"foo\"  Clearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:  $app->route('/foo', $middleware, 'foo'); // 'foo'\n$app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'  As noted above, these methods also return  Route  instances, allowing you to\nset the name after-the-fact; this is particularly useful with the  route() \nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:  $app->route('/foo', $middleware)->setName('foo'); // 'foo'  We recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.",
            "title": "Naming routes"
        },
        {
            "location": "/v3/features/router/uri-generation/#names-must-be-unique",
            "text": "In order for the URI generation functionality to work, routes must be uniquely\nnamed. This can be tricky when you use the same route path for multiple\nroutes:  $app->get('/books', ListBooksHandler::class, 'books');\n$app->post('/books', CreateBookHandler::class, 'books'); // oops!  You could, of course, name the second route \"create-book\" or similar, but you\nthen have multiple names capable of generating the same URI.  Since URIs do not have a concept of HTTP method built in, we recommend naming\neither the route matching  GET  or the first route in the sequence:  $app->get('/books', ListBooksHandler::class, 'books');\n$app->post('/books', CreateBookHandler::class); // no name",
            "title": "Names must be unique"
        },
        {
            "location": "/v3/features/router/uri-generation/#generating-uris",
            "text": "Once you know the name of a URI you wish to generate, you can do so from the\nrouter instance:  $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\"  You can omit the second argument if no substitutions are necessary.",
            "title": "Generating URIs"
        },
        {
            "location": "/v3/features/router/uri-generation/#compose-the-router",
            "text": "For this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the Zend\\Expressive\\Router\\RouterInterface  service in these situations.  Alternately, use the  UrlHelper  instead.",
            "title": "Compose the router"
        },
        {
            "location": "/v3/features/router/piping/",
            "text": "Routing vs Piping\n\n\nExpressive provides two mechanisms for adding middleware to your\napplication:\n\n\n\n\npiping, which is a foundation feature of the underlying\n  \nzend-stratigility\n\n  implementation.\n\n\nrouting, which is an additional feature provided by zend-expressive.\n\n\n\n\nPiping\n\n\nzend-stratigility provides a mechanism termed \npiping\n for composing middleware\nin an application. When you \npipe\n middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\n\n\nExpressive adds the ability to segregate middleware to a specific path; as an\nexample:\n\n\n$app->pipe('/api', $apiMiddleware);\n\n\n\nwill execute \n$apiMiddleware\n only if the path matches \n/api\n; otherwise, it\nwill skip over that middleware.\n\n\nThis path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.\n\n\n\n\nPath segregation\n\n\nInternally, when \nApplication::pipe()\n detects two arguments, it calls\n\nZend\\Stratigility\\path()\n using the two arguments in order to create a\n\nZend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n instance; this latter is\nwhat performs the actual path checking.\n\n\n\n\nExpressive uses and exposes piping to users, with one addition: \nmiddleware may\nbe specified by service name or an array of service names, and zend-expressive\nwill lazy-load the service only when the middleware is invoked\n.\n\n\nIn order to accomplish the lazy-loading, zend-expressive wraps the calls to\nfetch and dispatch the middleware inside a\n\nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n instance; as such, there is\nno overhead to utilizing service-based middleware \nuntil it is dispatched\n.\n\n\nRouting\n\n\nRouting is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:\n\n\n\n\n/book/:id\n (ZF2)\n\n\n/book/{id}\n (Aura.Router)\n\n\n/book/{id:\\d+}\n (FastRoute)\n\n\n\n\nIn each of the above, if the router determines that the request matches the\ncriteria, it will indicate:\n\n\n\n\nthe route that matched\n\n\nthe \nid\n parameter was matched, and the value matched\n\n\n\n\nMost routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:\n\n\n\n\ndefault values for unmatched parameters\n\n\ncriteria for evaluating a match (such as a regular expression)\n\n\nadditional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)\n\n\n\n\nAs such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).\n\n\nWhen to Pipe\n\n\nIn Expressive, we recommend that you pipe middleware in the following\ncircumstances:\n\n\n\n\nIt should (potentially) run on every execution. Examples for such usage\n  include:\n\n\nLogging requests\n\n\nPerforming content negotiation\n\n\nHandling cookies\n\n\n\n\n\n\nError handling.\n\n\nApplication segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.\n\n\n\n\nWhen to Route\n\n\nUse routing when:\n\n\n\n\nYour middleware is reacting to a given path.\n\n\nYou want to use dynamic routing.\n\n\nYou want to restrict usage of middleware to specific HTTP methods.\n\n\nYou want to be able to generate URIs to your middleware.\n\n\n\n\nThe above cover most use cases; \nin other words, most middleware should be added\nto the application as routed middleware\n.\n\n\nControlling middleware execution order\n\n\nAs noted in the earlier section on piping, piped middleware is \nqueued\n, meaning\nit has a FIFO (\"first in, first out\") execution order.\n\n\nAdditionally, zend-expressive's routing and dispatch capabilities are themselves\nimplemented as piped middleware.\n\n\nTo ensure your middleware is piped correctly, keep in mind the following:\n\n\n\n\nIf middleware should execute on \nevery request\n, pipe it early.\n\n\nPipe routing and dispatch middleware using their dedicated application methods\n  (more on this below), optionally with middleware between them to further shape\n  application flow.\n\n\nPipe middleware guaranteed to return a response (such as a \"not found\" handler\n  or similar) \nlast\n.\n\n\n\n\nAs an example:\n\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipe(XClacksOverhead::class);\n$app->pipe(ErrorHandler::class);\n$app->pipe(RouteMiddleware::class);\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(MethodNotAllowedMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipe(AuthorizationCheck::class);\n$app->pipe(DispatchMiddleware::class);\n$app->pipe(NotFoundHandler::class);",
            "title": "Routing vs Piping"
        },
        {
            "location": "/v3/features/router/piping/#routing-vs-piping",
            "text": "Expressive provides two mechanisms for adding middleware to your\napplication:   piping, which is a foundation feature of the underlying\n   zend-stratigility \n  implementation.  routing, which is an additional feature provided by zend-expressive.",
            "title": "Routing vs Piping"
        },
        {
            "location": "/v3/features/router/piping/#piping",
            "text": "zend-stratigility provides a mechanism termed  piping  for composing middleware\nin an application. When you  pipe  middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.  Expressive adds the ability to segregate middleware to a specific path; as an\nexample:  $app->pipe('/api', $apiMiddleware);  will execute  $apiMiddleware  only if the path matches  /api ; otherwise, it\nwill skip over that middleware.  This path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.",
            "title": "Piping"
        },
        {
            "location": "/v3/features/router/piping/#path-segregation",
            "text": "Internally, when  Application::pipe()  detects two arguments, it calls Zend\\Stratigility\\path()  using the two arguments in order to create a Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator  instance; this latter is\nwhat performs the actual path checking.   Expressive uses and exposes piping to users, with one addition:  middleware may\nbe specified by service name or an array of service names, and zend-expressive\nwill lazy-load the service only when the middleware is invoked .  In order to accomplish the lazy-loading, zend-expressive wraps the calls to\nfetch and dispatch the middleware inside a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware  instance; as such, there is\nno overhead to utilizing service-based middleware  until it is dispatched .",
            "title": "Path segregation"
        },
        {
            "location": "/v3/features/router/piping/#routing",
            "text": "Routing is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:   /book/:id  (ZF2)  /book/{id}  (Aura.Router)  /book/{id:\\d+}  (FastRoute)   In each of the above, if the router determines that the request matches the\ncriteria, it will indicate:   the route that matched  the  id  parameter was matched, and the value matched   Most routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:   default values for unmatched parameters  criteria for evaluating a match (such as a regular expression)  additional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)   As such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).",
            "title": "Routing"
        },
        {
            "location": "/v3/features/router/piping/#when-to-pipe",
            "text": "In Expressive, we recommend that you pipe middleware in the following\ncircumstances:   It should (potentially) run on every execution. Examples for such usage\n  include:  Logging requests  Performing content negotiation  Handling cookies    Error handling.  Application segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.",
            "title": "When to Pipe"
        },
        {
            "location": "/v3/features/router/piping/#when-to-route",
            "text": "Use routing when:   Your middleware is reacting to a given path.  You want to use dynamic routing.  You want to restrict usage of middleware to specific HTTP methods.  You want to be able to generate URIs to your middleware.   The above cover most use cases;  in other words, most middleware should be added\nto the application as routed middleware .",
            "title": "When to Route"
        },
        {
            "location": "/v3/features/router/piping/#controlling-middleware-execution-order",
            "text": "As noted in the earlier section on piping, piped middleware is  queued , meaning\nit has a FIFO (\"first in, first out\") execution order.  Additionally, zend-expressive's routing and dispatch capabilities are themselves\nimplemented as piped middleware.  To ensure your middleware is piped correctly, keep in mind the following:   If middleware should execute on  every request , pipe it early.  Pipe routing and dispatch middleware using their dedicated application methods\n  (more on this below), optionally with middleware between them to further shape\n  application flow.  Pipe middleware guaranteed to return a response (such as a \"not found\" handler\n  or similar)  last .   As an example:  $app->pipe(OriginalMessages::class);\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipe(XClacksOverhead::class);\n$app->pipe(ErrorHandler::class);\n$app->pipe(RouteMiddleware::class);\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(MethodNotAllowedMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipe(AuthorizationCheck::class);\n$app->pipe(DispatchMiddleware::class);\n$app->pipe(NotFoundHandler::class);",
            "title": "Controlling middleware execution order"
        },
        {
            "location": "/v3/features/router/aura/",
            "text": "Using Aura.Router\n\n\nAura.Router\n provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:\n\n\n\n\nA regular expression that applies the same for a given routing match:\n\n\n\n\n// Parameters named \"id\" will only match digits by default:\n$router->addTokens([\n  'id' => '\\d+',\n]);\n\n\n\n\n\nA default parameter and/or its default value to always provide:\n\n\n\n\n// mediatype defaults to \"application/xhtml+xml\" and will be available in all\n// requests:\n$router->addValues([\n  'mediatype' => 'application/xhtml+xml',\n]);\n\n\n\n\n\nOnly match if secure (i.e., under HTTPS):\n\n\n\n\n$router->setSecure(true);\n\n\n\nIn order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling Aura.Router\n\n\nTo use Aura.Router, you will first need to install the Aura.Router integration:\n\n\n$ composer require zendframework/zend-expressive-aurarouter\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\AuraRouter\n instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\AuraRouter\n during instantiation.\n\n\n<?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())->newInstance();\n$auraRouter->setSecure(true);\n$auraRouter->addValues([\n    'mediatype' => 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe provide and enable a factory for generating your Aura.Router instance when\nyou install the zend-expressive-aurarouter package. This will generally serve\nyour needs.\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nAura\\Router\\Router\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\AuraRouter\n instance composing the\n  \nAura\\Router\\Router\n instance.\n\n\n\n\nThe factory might look like this:\n\n\n// in src/App/Container/AuraRouterFactory.php:\nnamespace App\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Psr\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())->newInstance();\n        $router->setSecure(true);\n        $router->addValues([\n            'mediatype' => 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container->get('Aura\\Router\\Router'));\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container:\n\n\n// in a config/autoload/ file, or within a ConfigProvider class:\nreturn [\n    'factories' => [\n        \\Aura\\Router\\Router::class => \\App\\Container\\AuraRouterFactory::class,\n        \\Zend\\Expressive\\Router\\RouterInterface::class => \\App\\Container\\RouterFactory::class,\n    ],\n];",
            "title": "Using Aura"
        },
        {
            "location": "/v3/features/router/aura/#using-aurarouter",
            "text": "Aura.Router  provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:   A regular expression that applies the same for a given routing match:   // Parameters named \"id\" will only match digits by default:\n$router->addTokens([\n  'id' => '\\d+',\n]);   A default parameter and/or its default value to always provide:   // mediatype defaults to \"application/xhtml+xml\" and will be available in all\n// requests:\n$router->addValues([\n  'mediatype' => 'application/xhtml+xml',\n]);   Only match if secure (i.e., under HTTPS):   $router->setSecure(true);  In order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.",
            "title": "Using Aura.Router"
        },
        {
            "location": "/v3/features/router/aura/#installing-aurarouter",
            "text": "To use Aura.Router, you will first need to install the Aura.Router integration:  $ composer require zendframework/zend-expressive-aurarouter",
            "title": "Installing Aura.Router"
        },
        {
            "location": "/v3/features/router/aura/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\AuraRouter  instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:  use Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/v3/features/router/aura/#programmatic-creation",
            "text": "If you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter  during instantiation.  <?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())->newInstance();\n$auraRouter->setSecure(true);\n$auraRouter->addValues([\n    'mediatype' => 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/v3/features/router/aura/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/v3/features/router/aura/#factory-driven-creation",
            "text": "We provide and enable a factory for generating your Aura.Router instance when\nyou install the zend-expressive-aurarouter package. This will generally serve\nyour needs.  If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Aura\\Router\\Router  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\AuraRouter  instance composing the\n   Aura\\Router\\Router  instance.   The factory might look like this:  // in src/App/Container/AuraRouterFactory.php:\nnamespace App\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Psr\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())->newInstance();\n        $router->setSecure(true);\n        $router->addValues([\n            'mediatype' => 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container->get('Aura\\Router\\Router'));\n    }\n}  From here, you will need to register your factories with your IoC container:  // in a config/autoload/ file, or within a ConfigProvider class:\nreturn [\n    'factories' => [\n        \\Aura\\Router\\Router::class => \\App\\Container\\AuraRouterFactory::class,\n        \\Zend\\Expressive\\Router\\RouterInterface::class => \\App\\Container\\RouterFactory::class,\n    ],\n];",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/v3/features/router/fast-route/",
            "text": "Using FastRoute\n\n\nFastRoute\n provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.\n\n\nInternally, we use the standard route parser (\nFastRoute\\RouterParser\\Std\n) to\nparse routes, a \nRouteCollector\n to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.\n\n\nIf you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the \nZend\\Expressive\\Router\\FastRouteRouter\n class, at instantiation.\n\n\nThe \nFastRouteRouter\n bridge class accepts two arguments at instantiation:\n\n\n\n\nA \nFastRoute\\RouteCollector\n instance\n\n\nA callable that will return a \nFastRoute\\Dispatcher\\RegexBasedAbstract\n\n  instance.\n\n\n\n\nInjection can be done either programmatically or via a factory to use in\nconjunction with your container instance.\n\n\nInstalling FastRoute\n\n\nTo use FastRoute, you will first need to install the FastRoute integration:\n\n\n$ composer require zendframework/zend-expressive-fastroute\n\n\n\nThe package provides a factory for the router, and wires it to your container by\ndefault. This will serve the majority of use cases.\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:\n\n\n\n\nA factory to register as and generate a \nFastRoute\\RouteCollector\n instance.\n\n\nA factory to register as \nFastRoute\\DispatcherFactory\n and return a callable\n  factory that returns a \nRegexBasedAbstract\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\FastRouteRouter\n instance\n  composing the two services.\n\n\n\n\nThe factories might look like the following:\n\n\n<?php\n// in src/App/Container/FastRouteCollectorFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/App/Container/FastRouteDispatcherFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container->get(FastRoute\\RouteCollector::class),\n            $container->get(FastRoute\\DispatcherFactory::class)\n        );\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\n// in a config/autoload/ file, or within a ConfigProvider class:\nreturn [\n    'factories' => [\n        \\FastRoute\\RouteCollector::class => \\App\\Container\\FastRouteCollectorFactory::class,\n        \\FastRoute\\DispatcherFactory::class => \\App\\Container\\FastRouteDispatcherFactory::class,\n        \\Zend\\Expressive\\Router\\RouterInterface::class => \\App\\Container\\RouterFactory::class,\n    ],\n];\n\n\n\nFastRoute caching support\n\n\nzend-expressive-fastroute comes with support for FastRoute native dispatch data\ncaching.\n\n\nEnabling this feature requires changes to your configuration. Typically, router\nconfiguration occurs in \nconfig/autoload/routes.global.php\n; as such, we will\nreference that file when indicating configuration changes.\n\n\nThe changes required are:\n\n\n\n\n\n\nYou will need to delegate creation of the router instance to a new factory.\n\n\n\n\n\n\nYou will need to add a new configuration entry, \n$config['router']['fastroute']\n.\n  The options in this entry will be used by the factory to build the router\n  instance in order to toggle caching support and to specify a custom cache\n  file.\n\n\n\n\n\n\nAs an example:\n\n\n// File config/autoload/routes.global.php\n\nreturn [\n    'dependencies' => [\n        //..\n        'invokables' => [\n            /* ... */\n            // Comment out or remove the following line:\n            // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n            // Add this line; the specified factory now creates the router instance:\n            Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class,\n            /* ... */\n        ],\n    ],\n\n    // Add the following to enable caching support:\n    'router' => [\n        'fastroute' => [\n             // Enable caching support:\n            'cache_enabled' => true,\n             // Optional (but recommended) cache file path:\n            'cache_file'    => 'data/cache/fastroute.php.cache',\n        ],\n    ],\n\n    'routes' => [ /* ... */ ],\n]\n\n\n\nThe FastRoute-specific caching options are as follows:\n\n\n\n\n\n\ncache_enabled\n (bool) is used to toggle caching support. It's advisable to enable\n  caching in a production environment and leave it disabled for the development\n  environment. Commenting or omitting this option is equivalent to having it set\n  to \nfalse\n. We recommend enabling it in \nconfig/autoload/routes.global.php\n,\n  and, in development, disabling it within \nconfig/autoload/routes.local.php\n or\n  \nconfig/autoload/local.php\n.\n\n\n\n\n\n\ncache_file\n (string) is an optional parameter that represents the path of\n  the dispatch data cache file. It can be provided as an absolute file path or\n  as a path relative to the zend-expressive working directory.\n\n\n\n\n\n\nIt defaults to \ndata/cache/fastroute.php.cache\n, where \ndata/cache/\n is the\n  cache directory defined within the zend-expressive skeleton application.  An\n  explicit absolute file path is recommended since the php \ninclude\n construct\n  will skip searching the \ninclude_path\n and the current directory.\n\n\nIf you choose a custom path, make sure that the directory exists and is\n  writable by the owner of the PHP process. As with any other zend-expressive\n  cached configuration, you will need to purge this file in order to enable any\n  newly added route when FastRoute caching is enabled.",
            "title": "Using FastRoute"
        },
        {
            "location": "/v3/features/router/fast-route/#using-fastroute",
            "text": "FastRoute  provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.  Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to\nparse routes, a  RouteCollector  to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.  If you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the  Zend\\Expressive\\Router\\FastRouteRouter  class, at instantiation.  The  FastRouteRouter  bridge class accepts two arguments at instantiation:   A  FastRoute\\RouteCollector  instance  A callable that will return a  FastRoute\\Dispatcher\\RegexBasedAbstract \n  instance.   Injection can be done either programmatically or via a factory to use in\nconjunction with your container instance.",
            "title": "Using FastRoute"
        },
        {
            "location": "/v3/features/router/fast-route/#installing-fastroute",
            "text": "To use FastRoute, you will first need to install the FastRoute integration:  $ composer require zendframework/zend-expressive-fastroute  The package provides a factory for the router, and wires it to your container by\ndefault. This will serve the majority of use cases.  If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:   A factory to register as and generate a  FastRoute\\RouteCollector  instance.  A factory to register as  FastRoute\\DispatcherFactory  and return a callable\n  factory that returns a  RegexBasedAbstract  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\FastRouteRouter  instance\n  composing the two services.   The factories might look like the following:  <?php\n// in src/App/Container/FastRouteCollectorFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/App/Container/FastRouteDispatcherFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container->get(FastRoute\\RouteCollector::class),\n            $container->get(FastRoute\\DispatcherFactory::class)\n        );\n    }\n}  From here, you will need to register your factories with your IoC container.  // in a config/autoload/ file, or within a ConfigProvider class:\nreturn [\n    'factories' => [\n        \\FastRoute\\RouteCollector::class => \\App\\Container\\FastRouteCollectorFactory::class,\n        \\FastRoute\\DispatcherFactory::class => \\App\\Container\\FastRouteDispatcherFactory::class,\n        \\Zend\\Expressive\\Router\\RouterInterface::class => \\App\\Container\\RouterFactory::class,\n    ],\n];",
            "title": "Installing FastRoute"
        },
        {
            "location": "/v3/features/router/fast-route/#fastroute-caching-support",
            "text": "zend-expressive-fastroute comes with support for FastRoute native dispatch data\ncaching.  Enabling this feature requires changes to your configuration. Typically, router\nconfiguration occurs in  config/autoload/routes.global.php ; as such, we will\nreference that file when indicating configuration changes.  The changes required are:    You will need to delegate creation of the router instance to a new factory.    You will need to add a new configuration entry,  $config['router']['fastroute'] .\n  The options in this entry will be used by the factory to build the router\n  instance in order to toggle caching support and to specify a custom cache\n  file.    As an example:  // File config/autoload/routes.global.php\n\nreturn [\n    'dependencies' => [\n        //..\n        'invokables' => [\n            /* ... */\n            // Comment out or remove the following line:\n            // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n            // Add this line; the specified factory now creates the router instance:\n            Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class,\n            /* ... */\n        ],\n    ],\n\n    // Add the following to enable caching support:\n    'router' => [\n        'fastroute' => [\n             // Enable caching support:\n            'cache_enabled' => true,\n             // Optional (but recommended) cache file path:\n            'cache_file'    => 'data/cache/fastroute.php.cache',\n        ],\n    ],\n\n    'routes' => [ /* ... */ ],\n]  The FastRoute-specific caching options are as follows:    cache_enabled  (bool) is used to toggle caching support. It's advisable to enable\n  caching in a production environment and leave it disabled for the development\n  environment. Commenting or omitting this option is equivalent to having it set\n  to  false . We recommend enabling it in  config/autoload/routes.global.php ,\n  and, in development, disabling it within  config/autoload/routes.local.php  or\n   config/autoload/local.php .    cache_file  (string) is an optional parameter that represents the path of\n  the dispatch data cache file. It can be provided as an absolute file path or\n  as a path relative to the zend-expressive working directory.    It defaults to  data/cache/fastroute.php.cache , where  data/cache/  is the\n  cache directory defined within the zend-expressive skeleton application.  An\n  explicit absolute file path is recommended since the php  include  construct\n  will skip searching the  include_path  and the current directory.  If you choose a custom path, make sure that the directory exists and is\n  writable by the owner of the PHP process. As with any other zend-expressive\n  cached configuration, you will need to purge this file in order to enable any\n  newly added route when FastRoute caching is enabled.",
            "title": "FastRoute caching support"
        },
        {
            "location": "/v3/features/router/zf2/",
            "text": "Using zend-router\n\n\nzend-router\n provides several\nrouter implementations used for ZF2+ applications; the default is\n\nZend\\Router\\Http\\TreeRouteStack\n, which can compose a number of different\nroutes of differing types in order to perform routing.\n\n\nThe ZF2 bridge we provide, \nZend\\Expressive\\Router\\ZendRouter\n, uses the\n\nTreeRouteStack\n, and injects \nSegment\n routes to it; these are in turn injected\nwith \nMethod\n routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.\n\n\nThe \nTreeRouteStack\n offers some unique features:\n\n\n\n\nRoute \"prototypes\". These are essentially like child routes that must \nalso\n\n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.\n\n\nBase URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.\n\n\n\n\nTo specify these, you need access to the underlying \nTreeRouteStack\n\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling the ZF2 Router\n\n\nTo use the ZF2 router, you will need to install the zend-mvc router integration:\n\n\n$ composer require zendframework/zend-expressive-zendrouter\n\n\n\nThe package provides both a factory for the router, and a \nConfigProvider\n that\nwires the router with your application.\n\n\nAdvanced configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nZend\\Router\\Http\\TreeRouteStack\n\n  instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\ZendRouter\n instance composing the\n  \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n instance.\n\n\n\n\nThe factories might look like the following:\n\n\n// in src/App/Container/TreeRouteStackFactory.php:\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Http\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router->addPrototypes(/* ... */);\n        $router->setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class));\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\n// in a config/autoload/ file, or within a ConfigProvider class:\nreturn [\n    'factories' => [\n        \\Zend\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class,\n        \\Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];",
            "title": "Using zend-router"
        },
        {
            "location": "/v3/features/router/zf2/#using-zend-router",
            "text": "zend-router  provides several\nrouter implementations used for ZF2+ applications; the default is Zend\\Router\\Http\\TreeRouteStack , which can compose a number of different\nroutes of differing types in order to perform routing.  The ZF2 bridge we provide,  Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects  Segment  routes to it; these are in turn injected\nwith  Method  routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.  The  TreeRouteStack  offers some unique features:   Route \"prototypes\". These are essentially like child routes that must  also \n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.  Base URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.   To specify these, you need access to the underlying  TreeRouteStack \ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.",
            "title": "Using zend-router"
        },
        {
            "location": "/v3/features/router/zf2/#installing-the-zf2-router",
            "text": "To use the ZF2 router, you will need to install the zend-mvc router integration:  $ composer require zendframework/zend-expressive-zendrouter  The package provides both a factory for the router, and a  ConfigProvider  that\nwires the router with your application.",
            "title": "Installing the ZF2 Router"
        },
        {
            "location": "/v3/features/router/zf2/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Zend\\Router\\Http\\TreeRouteStack \n  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\ZendRouter  instance composing the\n   Zend\\Mvc\\Router\\Http\\TreeRouteStack  instance.   The factories might look like the following:  // in src/App/Container/TreeRouteStackFactory.php:\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Http\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router->addPrototypes(/* ... */);\n        $router->setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class));\n    }\n}  From here, you will need to register your factories with your IoC container.  // in a config/autoload/ file, or within a ConfigProvider class:\nreturn [\n    'factories' => [\n        \\Zend\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class,\n        \\Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];",
            "title": "Advanced configuration"
        },
        {
            "location": "/v3/features/template/intro/",
            "text": "Templating\n\n\nBy default, no middleware or handlers in Expressive are templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.\n\n\nWe do, however, provide abstraction for templating via the interface\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n, which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:\n\n\n\n\nAll adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation \nnamespace::template\n when rendering.\n\n\nAdapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).\n\n\nAdapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.\n\n\nAdapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.\n\n\n\n\nIn this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.\n\n\nWe currently support:\n\n\n\n\nPlates\n\n\nTwig\n\n\nzend-view\n\n\n\n\nEach has an associated container factory; details are found in the\n\nfactories documentation\n.",
            "title": "Introduction"
        },
        {
            "location": "/v3/features/template/intro/#templating",
            "text": "By default, no middleware or handlers in Expressive are templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.  We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:   All adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation  namespace::template  when rendering.  Adapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).  Adapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.  Adapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.   In this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.  We currently support:   Plates  Twig  zend-view   Each has an associated container factory; details are found in the factories documentation .",
            "title": "Templating"
        },
        {
            "location": "/v3/features/template/interface/",
            "text": "The Template Renderer Interface\n\n\nExpressive defines \nZend\\Expressive\\Template\\TemplateRendererInterface\n, which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    public const TEMPLATE_ALL = '*';\n\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param array|object $params\n     */\n    public function render(string $name, $params = []) : string;\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     */\n    public function addPath(string $path, string $namespace = null) : void;\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths() : array;\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param mixed $value\n     */\n    public function addDefaultParam(string $templateName, string $param, $value) : void;\n}\n\n\n\n\n\nNamespaces\n\n\nUnfortunately, namespace syntax varies between different template engine\nimplementations. As an example:\n\n\n\n\nPlates uses the syntax \nnamespace::template\n.\n\n\nTwig uses the syntax \n@namespace/template\n.\n\n\nzend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.\n\n\n\n\nTo make different engines compatible, we require implementations to support\nthe syntax \nnamespace::template\n (where \nnamespace::\n is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.\n\n\nWhen using a \nTemplateRendererInterface\n implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.\n\n\n\n\nPaths\n\n\nMost template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the \naddPath()\n method to do so:\n\n\n$renderer->addPath('templates');\n\n\n\nTemplate engines adapted for zend-expressive are also required to allow\n\nnamespacing\n templates; when adding a path, you specify the template\n\nnamespace\n that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.\n\n\n// Resolves to a path registered with the namespace \"error\";\n// this example is specific to the Plates engine.\n$content = $renderer->render('error::404');\n\n\n\nYou can provide a namespace when registering a path via an optional second\nargument:\n\n\n// Registers the \"error\" namespace to the path \"templates/error/\"\n$renderer->addPath('templates/error/', 'error');\n\n\n\nRendering\n\n\nTo render a template, call the \nrender()\n method. This method requires the name\nof a template as the first argument:\n\n\n$content = $renderer->render('foo');\n\n\n\nYou can specify a namespaced template using the syntax \nnamespace::template\n;\nthe \ntemplate\n segment of the template name may use additional directory\nseparators when necessary.\n\n\nOne key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to \nrender()\n:\n\n\n$content = $renderer->render('message', [\n    'greeting'  => 'Hello',\n    'recipient' => 'World',\n]);\n\n\n\nIt is up to the underlying template engine to determine how to perform the\ninjections.\n\n\nDefault params\n\n\nThe \nTemplateRendererInterface\n defines the method \naddDefaultParam()\n. This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:\n\n\npublic function addDefaultParam($templateName, $param, $value)\n\n\n\nIf you want a parameter to be used for \nevery\n template, you can specify the\nconstant \nTemplateRendererInterface::TEMPLATE_ALL\n for the \n$templateName\n\nparameter.\n\n\nWhen rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:\n\n\n\n\nDefault parameters specified for all templates.\n\n\nDefault parameters specified for the template specified at rendering.\n\n\nParameters specified when rendering.\n\n\n\n\nAs an example, if we did the following:\n\n\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer->addDefaultParam('example', 'foo', 'template default foo');\n$renderer->addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer->render('example', [\n    'foo' => 'override',\n]);\n\n\n\nThen we can expect the following substitutions will occur when rendering:\n\n\n\n\nReferences to the \"foo\" variable will contain \"override\".\n\n\nReferences to the \"bar\" variable will contain \"template default bar\".\n\n\nReferences to the \"baz\" variable will contain \"bat\".\n\n\n\n\n\n\nSupport for default params\n\n\nThe support for default params will often be renderer-specific. The reason is\nbecause the \nrender()\n signature does not specify a type for \n$params\n, in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given \n$params\n argument does not support it.\n\n\nAt the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.",
            "title": "Template Renderer Interface"
        },
        {
            "location": "/v3/features/template/interface/#the-template-renderer-interface",
            "text": "Expressive defines  Zend\\Expressive\\Template\\TemplateRendererInterface , which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:  namespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    public const TEMPLATE_ALL = '*';\n\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param array|object $params\n     */\n    public function render(string $name, $params = []) : string;\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     */\n    public function addPath(string $path, string $namespace = null) : void;\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths() : array;\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param mixed $value\n     */\n    public function addDefaultParam(string $templateName, string $param, $value) : void;\n}",
            "title": "The Template Renderer Interface"
        },
        {
            "location": "/v3/features/template/interface/#namespaces",
            "text": "Unfortunately, namespace syntax varies between different template engine\nimplementations. As an example:   Plates uses the syntax  namespace::template .  Twig uses the syntax  @namespace/template .  zend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.   To make different engines compatible, we require implementations to support\nthe syntax  namespace::template  (where  namespace::  is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.  When using a  TemplateRendererInterface  implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.",
            "title": "Namespaces"
        },
        {
            "location": "/v3/features/template/interface/#paths",
            "text": "Most template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the  addPath()  method to do so:  $renderer->addPath('templates');  Template engines adapted for zend-expressive are also required to allow namespacing  templates; when adding a path, you specify the template namespace  that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.  // Resolves to a path registered with the namespace \"error\";\n// this example is specific to the Plates engine.\n$content = $renderer->render('error::404');  You can provide a namespace when registering a path via an optional second\nargument:  // Registers the \"error\" namespace to the path \"templates/error/\"\n$renderer->addPath('templates/error/', 'error');",
            "title": "Paths"
        },
        {
            "location": "/v3/features/template/interface/#rendering",
            "text": "To render a template, call the  render()  method. This method requires the name\nof a template as the first argument:  $content = $renderer->render('foo');  You can specify a namespaced template using the syntax  namespace::template ;\nthe  template  segment of the template name may use additional directory\nseparators when necessary.  One key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to  render() :  $content = $renderer->render('message', [\n    'greeting'  => 'Hello',\n    'recipient' => 'World',\n]);  It is up to the underlying template engine to determine how to perform the\ninjections.",
            "title": "Rendering"
        },
        {
            "location": "/v3/features/template/interface/#default-params",
            "text": "The  TemplateRendererInterface  defines the method  addDefaultParam() . This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:  public function addDefaultParam($templateName, $param, $value)  If you want a parameter to be used for  every  template, you can specify the\nconstant  TemplateRendererInterface::TEMPLATE_ALL  for the  $templateName \nparameter.  When rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:   Default parameters specified for all templates.  Default parameters specified for the template specified at rendering.  Parameters specified when rendering.   As an example, if we did the following:  $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer->addDefaultParam('example', 'foo', 'template default foo');\n$renderer->addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer->render('example', [\n    'foo' => 'override',\n]);  Then we can expect the following substitutions will occur when rendering:   References to the \"foo\" variable will contain \"override\".  References to the \"bar\" variable will contain \"template default bar\".  References to the \"baz\" variable will contain \"bat\".",
            "title": "Default params"
        },
        {
            "location": "/v3/features/template/interface/#support-for-default-params",
            "text": "The support for default params will often be renderer-specific. The reason is\nbecause the  render()  signature does not specify a type for  $params , in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given  $params  argument does not support it.  At the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.",
            "title": "Support for default params"
        },
        {
            "location": "/v3/features/template/request-handlers/",
            "text": "Templated request handlers\n\n\nThe primary use case for templating is within request handlers, to provide templated\nresponses. To do this, you will:\n\n\n\n\nInject an instance of \nZend\\Expressive\\Template\\TemplateRendererInterface\n into your\n  request handler.\n\n\nPotentially add paths to the templating instance.\n\n\nRender a template.\n\n\nAdd the results of rendering to your response.\n\n\n\n\nInjecting a TemplateRendererInterface\n\n\nWe encourage the use of dependency injection. As such, we recommend writing your\nrequest handler to accept the \nTemplateRendererInterface\n via either the constructor or a\nsetter. As an example:\n\n\nnamespace Acme\\Blog;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryHandler implements RequestHandlerInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function handler(ServerRequestInterface $request) : ResponseInterface\n    {\n        // ...\n    }\n}\n\n\n\nThis will necessitate having a factory for your request handler:\n\n\nnamespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryHandler;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryHandler(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}\n\n\n\nAnd, of course, you'll need to tell your container to use the factory; see the\n\ncontainer documentation\n for more information on how you\nmight accomplish that.\n\n\nConsuming templates\n\n\nNow that we have the templating engine injected into our request handler, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:\n\n\nnamespace Acme\\Blog;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryHandler implements RequestHandlerInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'entry' => $entry,\n            ])\n        );\n    }\n}",
            "title": "Templated Request Handlers"
        },
        {
            "location": "/v3/features/template/request-handlers/#templated-request-handlers",
            "text": "The primary use case for templating is within request handlers, to provide templated\nresponses. To do this, you will:   Inject an instance of  Zend\\Expressive\\Template\\TemplateRendererInterface  into your\n  request handler.  Potentially add paths to the templating instance.  Render a template.  Add the results of rendering to your response.",
            "title": "Templated request handlers"
        },
        {
            "location": "/v3/features/template/request-handlers/#injecting-a-templaterendererinterface",
            "text": "We encourage the use of dependency injection. As such, we recommend writing your\nrequest handler to accept the  TemplateRendererInterface  via either the constructor or a\nsetter. As an example:  namespace Acme\\Blog;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryHandler implements RequestHandlerInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function handler(ServerRequestInterface $request) : ResponseInterface\n    {\n        // ...\n    }\n}  This will necessitate having a factory for your request handler:  namespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryHandler;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryHandler(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}  And, of course, you'll need to tell your container to use the factory; see the container documentation  for more information on how you\nmight accomplish that.",
            "title": "Injecting a TemplateRendererInterface"
        },
        {
            "location": "/v3/features/template/request-handlers/#consuming-templates",
            "text": "Now that we have the templating engine injected into our request handler, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:  namespace Acme\\Blog;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryHandler implements RequestHandlerInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'entry' => $entry,\n            ])\n        );\n    }\n}",
            "title": "Consuming templates"
        },
        {
            "location": "/v3/features/template/plates/",
            "text": "Using Plates\n\n\nPlates\n is a native PHP template system\nmaintained by \nThe League of Extraordinary Packages\n.\nit provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Plates via\n\nZend\\Expressive\\Plates\\PlatesRenderer\n.\n\n\nInstalling Plates\n\n\nTo use the Plates wrapper, you must install the Plates integration:\n\n\n$ composer require zendframework/zend-expressive-platesrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Plates\\PlatesRenderer\n will create\nan instance of the Plates engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Plates\\PlatesRenderer\n constructor:\n\n\nuse League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates->addFolder('error', 'templates/error/');\n$plates->loadExtension(new CustomExtension());\n\n// Inject:\n$renderer = new PlatesRenderer($plates);\n\n\n\nConfiguration and Factory\n\n\nzend-expressive-platesrenderer ships with the factory\n\nZend\\Expressive\\Plates\\PlatesRendererFactory\n, which will both create the\nPlates engine instance, and the \nPlatesRenderer\n instance. If you are using\n\nzend-component-installer\n,\nthis will be automatically wired for you during installation.\n\n\nThe factory looks for the following configuration in the \nconfig\n service, using\nany it finds:\n\n\n// In config/autoload/templates.global.php:\n\nreturn [\n    'plates' => [\n        'extensions' => [\n            // string service names or class names of Plates extensions\n        ],\n    ],\n    'templates' => [\n        'extension' => 'phtml', // change this if you use a different file\n                                // extension for templates\n        'paths' => [\n            // namespace => [paths] pairs\n        ],\n    ],\n];\n\n\n\nThe factory will also inject two extensions by default,\n\nZend\\Expressive\\Plates\\Extension\\UrlExtension\n and\n\nZend\\Expressive\\Plates\\Extension\\EscaperExtension\n, both listed in more detail\nbelow.\n\n\nShipped Extensions\n\n\nzend-expressive-plates provides the following extensions.\n\n\nUrlExtension\n\n\nZend\\Expressive\\Plates\\Extension\\UrlExtension\n composes each of the\n\nUrlHelper\n and \nServerUrlHelper\n,\nand provides the following template methods:\n\n\npublic function url(\n   string $routeName = null,\n   array $routeParams = [],\n   array $queryParams = [],\n   ?string $fragmentIdentifier = null,\n   array $options = []\n) : string;\n\npublic function serverurl(string $path = null) : string;\n\n// Since zend-expressive-platesrender 2.1.0:\npublic function route() : ?Zend\\Expressive\\Router\\RouteResult\n\n\n\nAs an example:\n\n\n<a href=\"<?= $this->url('blog', ['stub' => $this->stub]) ?>\">A blog post on this</a>\n\n<?php\n$routing        = $this->route();\n$routingIsValid = $routing && $routing->isSuccess();\n$route       = $routingIsValid ? $routing->getMatchedRouteName() : 'blog';\n$routeParams = $routingIsValid ? $routing->getMatchedParams() : [];\n?>\n<a href=\"<?= $this->url($route, $routeParams) ?>\">For more information</a>\n\n\n\nEscaperExtension\n\n\nZend\\Expressive\\Plates\\Extension\\EscaperExtension\n proxies to functionality\nprovided in the \nzend-escaper\n\npackage. It looks for the following configuration in the \nconfig\n service:\n\n\n// In config/autoload/templates.global.php:\n\nreturn [\n    'plates' => [\n        'encoding' => ?string, // character encoding of generated content\n    ],\n];\n\n\n\nBy default it assumes UTF-8 for the encoding.\n\n\nThe extension registers the following template methods:\n\n\npublic function escapeHtml(string $html) : string;\npublic function escapeHtmlAttr(string $attribute) : string;\npublic function escapeJs(string $js) : string;\npublic function escapeCss(string $css) : string;\npublic function escapeUrl(string $url) : string;\n\n\n\nAs examples:\n\n\n<html>\n  <head>\n    <meta name=\"author\" content=\"<?= $this->escapeHmtmlAttr($this->author) ?>\">\n    <link rel=\"alternative\" href=\"<?= $this->escapeUrl($this->alternative) ?>\">\n    <style><?= $this->escapeCss($this->styles) ?></style>\n    <script><?= $this->escapeJs($this->script) ?></script>\n  </head>\n\n  <body>\n    <?= $this->escapeHtml($this->content) ?>\n  </body>\n</html>",
            "title": "Using Plates"
        },
        {
            "location": "/v3/features/template/plates/#using-plates",
            "text": "Plates  is a native PHP template system\nmaintained by  The League of Extraordinary Packages .\nit provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer .",
            "title": "Using Plates"
        },
        {
            "location": "/v3/features/template/plates/#installing-plates",
            "text": "To use the Plates wrapper, you must install the Plates integration:  $ composer require zendframework/zend-expressive-platesrenderer",
            "title": "Installing Plates"
        },
        {
            "location": "/v3/features/template/plates/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\Plates\\PlatesRenderer  will create\nan instance of the Plates engine, which it will then proxy to.  use Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Plates\\PlatesRenderer  constructor:  use League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates->addFolder('error', 'templates/error/');\n$plates->loadExtension(new CustomExtension());\n\n// Inject:\n$renderer = new PlatesRenderer($plates);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v3/features/template/plates/#configuration-and-factory",
            "text": "zend-expressive-platesrenderer ships with the factory Zend\\Expressive\\Plates\\PlatesRendererFactory , which will both create the\nPlates engine instance, and the  PlatesRenderer  instance. If you are using zend-component-installer ,\nthis will be automatically wired for you during installation.  The factory looks for the following configuration in the  config  service, using\nany it finds:  // In config/autoload/templates.global.php:\n\nreturn [\n    'plates' => [\n        'extensions' => [\n            // string service names or class names of Plates extensions\n        ],\n    ],\n    'templates' => [\n        'extension' => 'phtml', // change this if you use a different file\n                                // extension for templates\n        'paths' => [\n            // namespace => [paths] pairs\n        ],\n    ],\n];  The factory will also inject two extensions by default, Zend\\Expressive\\Plates\\Extension\\UrlExtension  and Zend\\Expressive\\Plates\\Extension\\EscaperExtension , both listed in more detail\nbelow.",
            "title": "Configuration and Factory"
        },
        {
            "location": "/v3/features/template/plates/#shipped-extensions",
            "text": "zend-expressive-plates provides the following extensions.",
            "title": "Shipped Extensions"
        },
        {
            "location": "/v3/features/template/plates/#urlextension",
            "text": "Zend\\Expressive\\Plates\\Extension\\UrlExtension  composes each of the UrlHelper  and  ServerUrlHelper ,\nand provides the following template methods:  public function url(\n   string $routeName = null,\n   array $routeParams = [],\n   array $queryParams = [],\n   ?string $fragmentIdentifier = null,\n   array $options = []\n) : string;\n\npublic function serverurl(string $path = null) : string;\n\n// Since zend-expressive-platesrender 2.1.0:\npublic function route() : ?Zend\\Expressive\\Router\\RouteResult  As an example:  <a href=\"<?= $this->url('blog', ['stub' => $this->stub]) ?>\">A blog post on this</a>\n\n<?php\n$routing        = $this->route();\n$routingIsValid = $routing && $routing->isSuccess();\n$route       = $routingIsValid ? $routing->getMatchedRouteName() : 'blog';\n$routeParams = $routingIsValid ? $routing->getMatchedParams() : [];\n?>\n<a href=\"<?= $this->url($route, $routeParams) ?>\">For more information</a>",
            "title": "UrlExtension"
        },
        {
            "location": "/v3/features/template/plates/#escaperextension",
            "text": "Zend\\Expressive\\Plates\\Extension\\EscaperExtension  proxies to functionality\nprovided in the  zend-escaper \npackage. It looks for the following configuration in the  config  service:  // In config/autoload/templates.global.php:\n\nreturn [\n    'plates' => [\n        'encoding' => ?string, // character encoding of generated content\n    ],\n];  By default it assumes UTF-8 for the encoding.  The extension registers the following template methods:  public function escapeHtml(string $html) : string;\npublic function escapeHtmlAttr(string $attribute) : string;\npublic function escapeJs(string $js) : string;\npublic function escapeCss(string $css) : string;\npublic function escapeUrl(string $url) : string;  As examples:  <html>\n  <head>\n    <meta name=\"author\" content=\"<?= $this->escapeHmtmlAttr($this->author) ?>\">\n    <link rel=\"alternative\" href=\"<?= $this->escapeUrl($this->alternative) ?>\">\n    <style><?= $this->escapeCss($this->styles) ?></style>\n    <script><?= $this->escapeJs($this->script) ?></script>\n  </head>\n\n  <body>\n    <?= $this->escapeHtml($this->content) ?>\n  </body>\n</html>",
            "title": "EscaperExtension"
        },
        {
            "location": "/v3/features/template/twig/",
            "text": "Using Twig\n\n\nTwig\n is a template language and engine provided\nas a standalone component by SensioLabs. It provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Twig via\n\nZend\\Expressive\\Twig\\TwigRenderer\n.\n\n\nInstalling Twig\n\n\nTo use the Twig wrapper, you must first install the Twig integration:\n\n\n$ composer require zendframework/zend-expressive-twigrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Twig\\TwigRenderer\n will create\nan instance of the Twig engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Twig\\TwigRenderer\n constructor:\n\n\nuse Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig->addExtension(new CustomExtension());\n$twig->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);\n\n\n\nIncluded extensions and functions\n\n\nThe included Twig extension adds support for url generation. The extension is\nautomatically activated if the \nUrlHelper\n and\n\nServerUrlHelper\n are registered with the\ncontainer.\n\n\nThe following template functions are exposed:\n\n\n\n\npath\n: Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.\n\n\n\n\n{{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3\n\n\n\n\n\nurl\n: Render the absolute url for a given route with its route parameters,\n  query string arguments, and fragment. If there is no route, it returns the\n  current url.\n\n\n\n\n{{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }}\nGenerates: http://example.com/article/3?foo=bar#fragment\n\n\n\n\n\nabsolute_url\n: Render the absolute url from a given path. If the path is\n  empty, it returns the current url.\n\n\n\n\n{{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something\n\n\n\n\n\nasset\n Render an (optionally versioned) asset url.\n\n\n\n\n{{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3\n\n\n\nTo get the absolute url for an asset:\n\n\n{{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3\n\n\n\nConfiguration\n\n\nThe following details configuration specific to Twig, as consumed by the\n\nTwigRendererFactory\n:\n\n\nreturn [\n    'templates' => [\n        'extension' => 'file extension used by templates; defaults to html.twig',\n        'paths' => [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' => [\n        'autoescape' => 'html', // Auto-escaping strategy [html|js|css|url|false]\n        'cache_dir' => 'path to cached templates',\n        'assets_url' => 'base URL for assets',\n        'assets_version' => 'base version for assets',\n        'extensions' => [\n            // extension service names or instances\n        ],\n        'globals' => [\n            // Global variables passed to twig templates\n            'ga_tracking' => 'UA-XXXXX-X'\n        ],\n        'optimizations' => -1, // -1: Enable all (default), 0: disable optimizations\n        'runtime_loaders' => [\n            // runtime loader names or instances\n        ],\n        'timezone' => 'default timezone identifier, e.g. America/New_York',\n    ],\n];\n\n\n\nWhen specifying the \ntwig.extensions\n values, always use fully qualified class\nnames or actual extension instances to ensure compatibility with any version of\nTwig used. Version 2 of Twig \nrequires\n that a fully qualified class name is\nused, and not a short-name alias.",
            "title": "Using Twig"
        },
        {
            "location": "/v3/features/template/twig/#using-twig",
            "text": "Twig  is a template language and engine provided\nas a standalone component by SensioLabs. It provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer .",
            "title": "Using Twig"
        },
        {
            "location": "/v3/features/template/twig/#installing-twig",
            "text": "To use the Twig wrapper, you must first install the Twig integration:  $ composer require zendframework/zend-expressive-twigrenderer",
            "title": "Installing Twig"
        },
        {
            "location": "/v3/features/template/twig/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\Twig\\TwigRenderer  will create\nan instance of the Twig engine, which it will then proxy to.  use Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Twig\\TwigRenderer  constructor:  use Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig->addExtension(new CustomExtension());\n$twig->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v3/features/template/twig/#included-extensions-and-functions",
            "text": "The included Twig extension adds support for url generation. The extension is\nautomatically activated if the  UrlHelper  and ServerUrlHelper  are registered with the\ncontainer.  The following template functions are exposed:   path : Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.   {{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3   url : Render the absolute url for a given route with its route parameters,\n  query string arguments, and fragment. If there is no route, it returns the\n  current url.   {{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }}\nGenerates: http://example.com/article/3?foo=bar#fragment   absolute_url : Render the absolute url from a given path. If the path is\n  empty, it returns the current url.   {{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something   asset  Render an (optionally versioned) asset url.   {{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3  To get the absolute url for an asset:  {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3",
            "title": "Included extensions and functions"
        },
        {
            "location": "/v3/features/template/twig/#configuration",
            "text": "The following details configuration specific to Twig, as consumed by the TwigRendererFactory :  return [\n    'templates' => [\n        'extension' => 'file extension used by templates; defaults to html.twig',\n        'paths' => [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' => [\n        'autoescape' => 'html', // Auto-escaping strategy [html|js|css|url|false]\n        'cache_dir' => 'path to cached templates',\n        'assets_url' => 'base URL for assets',\n        'assets_version' => 'base version for assets',\n        'extensions' => [\n            // extension service names or instances\n        ],\n        'globals' => [\n            // Global variables passed to twig templates\n            'ga_tracking' => 'UA-XXXXX-X'\n        ],\n        'optimizations' => -1, // -1: Enable all (default), 0: disable optimizations\n        'runtime_loaders' => [\n            // runtime loader names or instances\n        ],\n        'timezone' => 'default timezone identifier, e.g. America/New_York',\n    ],\n];  When specifying the  twig.extensions  values, always use fully qualified class\nnames or actual extension instances to ensure compatibility with any version of\nTwig used. Version 2 of Twig  requires  that a fully qualified class name is\nused, and not a short-name alias.",
            "title": "Configuration"
        },
        {
            "location": "/v3/features/template/zend-view/",
            "text": "Using zend-view\n\n\nzend-view\n provides a native PHP\ntemplate system via its \nPhpRenderer\n, and is maintained by Zend Framework. It\nprovides:\n\n\n\n\nLayout facilities.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for zend-view's\n\nPhpRenderer\n via \nZend\\Expressive\\ZendView\\ZendViewRenderer\n.\n\n\nInstalling zend-view\n\n\nTo use the zend-view wrapper, you must first install the zend-view integration:\n\n\n$ composer require zendframework/zend-expressive-zendviewrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\ZendView\\ZendViewRenderer\n will create\nan instance of the \nPhpRenderer\n, which it will then proxy to.\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\ZendView\\ZendViewRenderer\n constructor:\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver->attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver->attach(\n    (new Resolver\\TemplatePathStack())\n    ->setPaths(include 'config/template_paths.php')\n);\n$renderer->setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);\n\n\n\n\n\nNamespaced path resolving\n\n\nExpressive defines a custom zend-view resolver,\n\nZend\\Expressive\\ZendView\\NamespacedPathStackResolver\n. This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the \nnamespace::template\n notation\nrequired of \nTemplateRendererInterface\n implementations.\n\n\nThe \nZendView\n adapter ensures that:\n\n\n\n\nAn \nAggregateResolver\n is registered with the renderer. If the registered\n  resolver is not an \nAggregateResolver\n, it creates one and adds the original\n  resolver to it.\n\n\nA \nNamespacedPathStackResolver\n is registered with the \nAggregateResolver\n, at\n  a low priority (0), ensuring attempts to resolve hit it later.\n\n\n\n\nWith resolvers such as the \nTemplateMapResolver\n, you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!\n\n\n\n\nLayouts\n\n\nUnlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:\n\n\n\n\nYou may pass a layout template name or \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout as the second argument to the constructor.\n\n\nYou may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.\n\n\n\n\nIn each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.\n\n\n\n\nSince 1.3: You may also pass a boolean \nfalse\n value to either\n  \naddDefaultParam()\n or via the template variables for the \nlayout\n key; doing\n  so will disable the layout.\n\n\n\n\nLayout name passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');\n\n\n\nLayout view model passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/prod/',\n]);\n$layout->setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);\n\n\n\nProvide a layout name when rendering\n\n\n$content = $renderer->render('blog/entry', [\n    'layout' => 'layout::blog',\n    'entry'  => $entry,\n]);\n\n\n\nProvide a layout view model when rendering\n\n\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/blog/',\n]);\n$layout->setTemplate('layout::layout');\n\n$content = $renderer->render('blog/entry', [\n    'layout' => $layout,\n    'entry'  => $entry,\n]);\n\n\n\nHelpers\n\n\nExpressive provides overrides of specific view helpers in order to better\nintegrate with \nPSR-7\n. These include:\n\n\n\n\nZend\\Expressive\\ZendView\\UrlHelper\n. This helper consumes the\n  application's \nZend\\Expressive\\Router\\RouterInterface\n instance in order\n  to generate URIs. Its signature is:\n  \nurl($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = [])\n\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n. This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  Its signature is: \nserverUrl($path = null)\n.\n\n\n\n\nTo use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:\n\n\n$serverUrlHelper->setUri($request->getUri());\n\n\n\nWe recommend doing this within a pre-pipeline middleware.\n\n\nRecommendations\n\n\nWe recommend the following practices when using the zend-view adapter:\n\n\n\n\nIf using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.\n\n\nWhile we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.",
            "title": "Using zend-view"
        },
        {
            "location": "/v3/features/template/zend-view/#using-zend-view",
            "text": "zend-view  provides a native PHP\ntemplate system via its  PhpRenderer , and is maintained by Zend Framework. It\nprovides:   Layout facilities.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for zend-view's PhpRenderer  via  Zend\\Expressive\\ZendView\\ZendViewRenderer .",
            "title": "Using zend-view"
        },
        {
            "location": "/v3/features/template/zend-view/#installing-zend-view",
            "text": "To use the zend-view wrapper, you must first install the zend-view integration:  $ composer require zendframework/zend-expressive-zendviewrenderer",
            "title": "Installing zend-view"
        },
        {
            "location": "/v3/features/template/zend-view/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\ZendView\\ZendViewRenderer  will create\nan instance of the  PhpRenderer , which it will then proxy to.  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\ZendView\\ZendViewRenderer  constructor:  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver->attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver->attach(\n    (new Resolver\\TemplatePathStack())\n    ->setPaths(include 'config/template_paths.php')\n);\n$renderer->setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v3/features/template/zend-view/#namespaced-path-resolving",
            "text": "Expressive defines a custom zend-view resolver, Zend\\Expressive\\ZendView\\NamespacedPathStackResolver . This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the  namespace::template  notation\nrequired of  TemplateRendererInterface  implementations.  The  ZendView  adapter ensures that:   An  AggregateResolver  is registered with the renderer. If the registered\n  resolver is not an  AggregateResolver , it creates one and adds the original\n  resolver to it.  A  NamespacedPathStackResolver  is registered with the  AggregateResolver , at\n  a low priority (0), ensuring attempts to resolve hit it later.   With resolvers such as the  TemplateMapResolver , you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!",
            "title": "Namespaced path resolving"
        },
        {
            "location": "/v3/features/template/zend-view/#layouts",
            "text": "Unlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:   You may pass a layout template name or  Zend\\View\\Model\\ModelInterface \n  instance representing the layout as the second argument to the constructor.  You may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a  Zend\\View\\Model\\ModelInterface \n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.   In each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.   Since 1.3: You may also pass a boolean  false  value to either\n   addDefaultParam()  or via the template variables for the  layout  key; doing\n  so will disable the layout.",
            "title": "Layouts"
        },
        {
            "location": "/v3/features/template/zend-view/#layout-name-passed-to-constructor",
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');",
            "title": "Layout name passed to constructor"
        },
        {
            "location": "/v3/features/template/zend-view/#layout-view-model-passed-to-constructor",
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/prod/',\n]);\n$layout->setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);",
            "title": "Layout view model passed to constructor"
        },
        {
            "location": "/v3/features/template/zend-view/#provide-a-layout-name-when-rendering",
            "text": "$content = $renderer->render('blog/entry', [\n    'layout' => 'layout::blog',\n    'entry'  => $entry,\n]);",
            "title": "Provide a layout name when rendering"
        },
        {
            "location": "/v3/features/template/zend-view/#provide-a-layout-view-model-when-rendering",
            "text": "use Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/blog/',\n]);\n$layout->setTemplate('layout::layout');\n\n$content = $renderer->render('blog/entry', [\n    'layout' => $layout,\n    'entry'  => $entry,\n]);",
            "title": "Provide a layout view model when rendering"
        },
        {
            "location": "/v3/features/template/zend-view/#helpers",
            "text": "Expressive provides overrides of specific view helpers in order to better\nintegrate with  PSR-7 . These include:   Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the\n  application's  Zend\\Expressive\\Router\\RouterInterface  instance in order\n  to generate URIs. Its signature is:\n   url($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = [])  Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  Its signature is:  serverUrl($path = null) .   To use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:  $serverUrlHelper->setUri($request->getUri());  We recommend doing this within a pre-pipeline middleware.",
            "title": "Helpers"
        },
        {
            "location": "/v3/features/template/zend-view/#recommendations",
            "text": "We recommend the following practices when using the zend-view adapter:   If using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.  While we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.",
            "title": "Recommendations"
        },
        {
            "location": "/v3/features/error-handling/",
            "text": "Error Handling\n\n\nWe recommend that your code raise exceptions for conditions where it cannot\ngracefully recover. Additionally, we recommend that you have a reasonable PHP\n\nerror_reporting\n setting that includes warnings and fatal errors:\n\n\nerror_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE);\n\n\n\nIf you follow these guidelines, you can then write or use middleware that does\nthe following:\n\n\n\n\nsets an error handler that converts PHP errors to \nErrorException\n instances.\n\n\nwraps execution of the handler (\n$handler->handle()\n) with a try/catch block.\n\n\n\n\nAs an example:\n\n\nfunction (ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n{\n    set_error_handler(function ($errno, $errstr, $errfile, $errline) {\n        if (! (error_reporting() & $errno)) {\n            // Error is not in mask\n            return;\n        }\n        throw new ErrorException($errstr, 0, $errno, $errfile, $errline);\n    });\n\n    try {\n        $response = $handler->handle($request);\n        return $response;\n    } catch (Throwable $e) {\n    }\n\n    restore_error_handler();\n\n    $response = new TextResponse(sprintf(\n        \"[%d] %s\\n\\n%s\",\n        $e->getCode(),\n        $e->getMessage(),\n        $e->getTraceAsString()\n    ), 500);\n}\n\n\n\nYou would then pipe this as the outermost (or close to outermost) layer of your\napplication:\n\n\n$app->pipe($errorMiddleware);\n\n\n\nSo that you do not need to do this, we provide an error handler for you, via\nzend-stratigility: \nZend\\Stratigility\\Middleware\\ErrorHandler\n.\n\n\nThis implementation allows you to both:\n\n\n\n\nprovide a response generator, invoked when an error is caught; and\n\n\nregister listeners to trigger when errors are caught.\n\n\n\n\nWe provide the factory \nZend\\Expressive\\Container\\ErrorHandlerFactory\n for\ngenerating the instance; it should be mapped to the service\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n.\n\n\nWe provide two error response generators for you:\n\n\n\n\nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n, which optionally will\n  accept a \nZend\\Expressive\\Template\\TemplateRendererInterface\n instance, and a\n  template name. When present, these will be used to generate response content;\n  otherwise, a plain text response is generated that notes the request method\n  and URI.\n\n\n\n\nSince version 3.1.0, it also accepts a layout name, if you want to use one\n  other than \nlayout::default\n.\n\n\n\n\nZend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator\n, which uses\n  \nwhoops\n to present detailed exception\n  and request information; this implementation is intended for development\n  purposes.\n\n\n\n\nEach also has an accompanying factory for generating the instance:\n\n\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory\n\n\nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory\n\n\n\n\nMap the service \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n to one of\nthese two factories in your configuration:\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];\n\n\n\n\n\nUse development mode configuration to enable whoops\n\n\nYou can specify the above in one of your \nconfig/autoload/*.global.php\n files,\nto ensure you have a production-capable error response generator.\n\n\nIf you are using \nzf-development-mode\n\nin your application (which is provided by default in the skeleton\napplication), you can toggle usage of whoops by adding configuration to the file\n\nconfig/autoload/development.local.php.dist\n:\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Middleware\\WhoopsErrorResponseGenerator::class => Container\\WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];\n\n\n\nWhen you enable development mode, whoops will then be enabled; when you\ndisable development mode, you'll be using your production generator.\n\n\nIf you are not using zf-development-mode, you can define a\n\nconfig/autoload/*.local.php\n file with the above configuration whenever you\nwant to enable whoops.\n\n\n\n\nListening for errors\n\n\nWhen errors occur, you may want to \nlisten\n for them in order to provide\nfeatures such as logging. \nZend\\Stratigility\\Middleware\\ErrorHandler\n provides\nthe ability to do so via its \nattachListener()\n method.\n\n\nThis method accepts a callable with the following signature:\n\n\nfunction (\n    Throwable $error,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\nThe response provided is the response returned by your error response generator,\nallowing the listener the ability to introspect the generated response as well.\n\n\nAs an example, you could create a logging listener as follows:\n\n\nnamespace Acme;\n\nuse Exception;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass LoggingErrorListener\n{\n    /**\n     * Log format for messages:\n     *\n     * STATUS [METHOD] path: message\n     */\n    const LOG_FORMAT = '%d [%s] %s: %s';\n\n    private $logger;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke(Throwable $error, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $this->logger->error(sprintf(\n            self::LOG_FORMAT,\n            $response->getStatusCode(),\n            $request->getMethod(),\n            (string) $request->getUri(),\n            $error->getMessage()\n        ));\n    }\n}\n\n\n\nYou could then use a \ndelegator factory\n to\ncreate your logger listener and attach it to your error handler:\n\n\nnamespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass LoggingErrorListenerDelegatorFactory\n{\n    public function __invoke(ContainerInterface $container, string $name, callable $callback) : ErrorHandler\n    {\n        $listener = new LoggingErrorListener($container->get(LoggerInterface::class));\n        $errorHandler = $callback();\n        $errorHandler->attachListener($listener);\n        return $errorHandler;\n    }\n}\n\n\n\nHandling more specific error types\n\n\nYou could also write more specific error handlers. As an example, you might want\nto catch \nUnauthorizedException\n instances specifically, and display a login\npage:\n\n\nfunction (ServerRequestInterface $request, RequestHandlerInterface $handler) use ($renderer) : ResponseInterface\n{\n    try {\n        $response = $handler->handle($request);\n        return $response;\n    } catch (UnauthorizedException $e) {\n    }\n\n    return new HtmlResponse(\n        $renderer->render('error::unauthorized'),\n        401\n    );\n}\n\n\n\nYou could then push this into a middleware pipe only when it's needed:\n\n\n$app->get('/dashboard', [\n    $unauthorizedHandlerMiddleware,\n    $middlewareThatChecksForAuthorization,\n    $middlewareBehindAuthorizationWall,\n], 'dashboard');\n\n\n\nPage not found\n\n\nError handlers work at the outermost layer, and are used to catch exceptions and\nerrors in your application. At the \ninnermost\n layer of your application, you\nshould ensure you have middleware that is \nguaranteed\n to return a response;\nthis prevents errors in your application in the event that the application\nexhausts the middleware queue.\n\n\nThis in turn allows you to fully craft what sort of response is returned in such\nconditions.\n\n\nGenerally speaking, reaching the innermost middleware layer indicates that no\nmiddleware was capable of handling the request, and thus an HTTP 404 Not Found\ncondition.\n\n\nTo simplify such responses, we provide\n\nZend\\Expressive\\Handler\\NotFoundHandler\n.  It will report a 404 response,\noptionally using a composed template renderer to do so.\n\n\nWe provide a factory, \nZend\\Expressive\\Container\\NotFoundHandlerFactory\n, for\ncreating an instance, which we \ndetail elsewhere\n. You should pipe it as the innermost layer of your application:\n\n\n// A basic application:\n$app->pipe(ErrorHandler::class);\n// . . .\n$app->pipe(RouteMiddleware::class);\n// . . .\n$app->pipe(DispatchMiddleware::class);\n$app->pipe(NotFoundHandler::class);\n\n\n\nIf you wish to provide an alternate response status or use a canned response,\nyou should provide your own handler and pipe it to your application.",
            "title": "Error Handling"
        },
        {
            "location": "/v3/features/error-handling/#error-handling",
            "text": "We recommend that your code raise exceptions for conditions where it cannot\ngracefully recover. Additionally, we recommend that you have a reasonable PHP error_reporting  setting that includes warnings and fatal errors:  error_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE);  If you follow these guidelines, you can then write or use middleware that does\nthe following:   sets an error handler that converts PHP errors to  ErrorException  instances.  wraps execution of the handler ( $handler->handle() ) with a try/catch block.   As an example:  function (ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n{\n    set_error_handler(function ($errno, $errstr, $errfile, $errline) {\n        if (! (error_reporting() & $errno)) {\n            // Error is not in mask\n            return;\n        }\n        throw new ErrorException($errstr, 0, $errno, $errfile, $errline);\n    });\n\n    try {\n        $response = $handler->handle($request);\n        return $response;\n    } catch (Throwable $e) {\n    }\n\n    restore_error_handler();\n\n    $response = new TextResponse(sprintf(\n        \"[%d] %s\\n\\n%s\",\n        $e->getCode(),\n        $e->getMessage(),\n        $e->getTraceAsString()\n    ), 500);\n}  You would then pipe this as the outermost (or close to outermost) layer of your\napplication:  $app->pipe($errorMiddleware);  So that you do not need to do this, we provide an error handler for you, via\nzend-stratigility:  Zend\\Stratigility\\Middleware\\ErrorHandler .  This implementation allows you to both:   provide a response generator, invoked when an error is caught; and  register listeners to trigger when errors are caught.   We provide the factory  Zend\\Expressive\\Container\\ErrorHandlerFactory  for\ngenerating the instance; it should be mapped to the service Zend\\Stratigility\\Middleware\\ErrorHandler .  We provide two error response generators for you:   Zend\\Expressive\\Middleware\\ErrorResponseGenerator , which optionally will\n  accept a  Zend\\Expressive\\Template\\TemplateRendererInterface  instance, and a\n  template name. When present, these will be used to generate response content;\n  otherwise, a plain text response is generated that notes the request method\n  and URI.   Since version 3.1.0, it also accepts a layout name, if you want to use one\n  other than  layout::default .   Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator , which uses\n   whoops  to present detailed exception\n  and request information; this implementation is intended for development\n  purposes.   Each also has an accompanying factory for generating the instance:   Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory  Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory   Map the service  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  to one of\nthese two factories in your configuration:  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];",
            "title": "Error Handling"
        },
        {
            "location": "/v3/features/error-handling/#use-development-mode-configuration-to-enable-whoops",
            "text": "You can specify the above in one of your  config/autoload/*.global.php  files,\nto ensure you have a production-capable error response generator.  If you are using  zf-development-mode \nin your application (which is provided by default in the skeleton\napplication), you can toggle usage of whoops by adding configuration to the file config/autoload/development.local.php.dist :  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Middleware\\WhoopsErrorResponseGenerator::class => Container\\WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];  When you enable development mode, whoops will then be enabled; when you\ndisable development mode, you'll be using your production generator.  If you are not using zf-development-mode, you can define a config/autoload/*.local.php  file with the above configuration whenever you\nwant to enable whoops.",
            "title": "Use development mode configuration to enable whoops"
        },
        {
            "location": "/v3/features/error-handling/#listening-for-errors",
            "text": "When errors occur, you may want to  listen  for them in order to provide\nfeatures such as logging.  Zend\\Stratigility\\Middleware\\ErrorHandler  provides\nthe ability to do so via its  attachListener()  method.  This method accepts a callable with the following signature:  function (\n    Throwable $error,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  The response provided is the response returned by your error response generator,\nallowing the listener the ability to introspect the generated response as well.  As an example, you could create a logging listener as follows:  namespace Acme;\n\nuse Exception;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass LoggingErrorListener\n{\n    /**\n     * Log format for messages:\n     *\n     * STATUS [METHOD] path: message\n     */\n    const LOG_FORMAT = '%d [%s] %s: %s';\n\n    private $logger;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke(Throwable $error, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $this->logger->error(sprintf(\n            self::LOG_FORMAT,\n            $response->getStatusCode(),\n            $request->getMethod(),\n            (string) $request->getUri(),\n            $error->getMessage()\n        ));\n    }\n}  You could then use a  delegator factory  to\ncreate your logger listener and attach it to your error handler:  namespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass LoggingErrorListenerDelegatorFactory\n{\n    public function __invoke(ContainerInterface $container, string $name, callable $callback) : ErrorHandler\n    {\n        $listener = new LoggingErrorListener($container->get(LoggerInterface::class));\n        $errorHandler = $callback();\n        $errorHandler->attachListener($listener);\n        return $errorHandler;\n    }\n}",
            "title": "Listening for errors"
        },
        {
            "location": "/v3/features/error-handling/#handling-more-specific-error-types",
            "text": "You could also write more specific error handlers. As an example, you might want\nto catch  UnauthorizedException  instances specifically, and display a login\npage:  function (ServerRequestInterface $request, RequestHandlerInterface $handler) use ($renderer) : ResponseInterface\n{\n    try {\n        $response = $handler->handle($request);\n        return $response;\n    } catch (UnauthorizedException $e) {\n    }\n\n    return new HtmlResponse(\n        $renderer->render('error::unauthorized'),\n        401\n    );\n}  You could then push this into a middleware pipe only when it's needed:  $app->get('/dashboard', [\n    $unauthorizedHandlerMiddleware,\n    $middlewareThatChecksForAuthorization,\n    $middlewareBehindAuthorizationWall,\n], 'dashboard');",
            "title": "Handling more specific error types"
        },
        {
            "location": "/v3/features/error-handling/#page-not-found",
            "text": "Error handlers work at the outermost layer, and are used to catch exceptions and\nerrors in your application. At the  innermost  layer of your application, you\nshould ensure you have middleware that is  guaranteed  to return a response;\nthis prevents errors in your application in the event that the application\nexhausts the middleware queue.  This in turn allows you to fully craft what sort of response is returned in such\nconditions.  Generally speaking, reaching the innermost middleware layer indicates that no\nmiddleware was capable of handling the request, and thus an HTTP 404 Not Found\ncondition.  To simplify such responses, we provide Zend\\Expressive\\Handler\\NotFoundHandler .  It will report a 404 response,\noptionally using a composed template renderer to do so.  We provide a factory,  Zend\\Expressive\\Container\\NotFoundHandlerFactory , for\ncreating an instance, which we  detail elsewhere . You should pipe it as the innermost layer of your application:  // A basic application:\n$app->pipe(ErrorHandler::class);\n// . . .\n$app->pipe(RouteMiddleware::class);\n// . . .\n$app->pipe(DispatchMiddleware::class);\n$app->pipe(NotFoundHandler::class);  If you wish to provide an alternate response status or use a canned response,\nyou should provide your own handler and pipe it to your application.",
            "title": "Page not found"
        },
        {
            "location": "/v3/features/modular-applications/",
            "text": "Modular applications\n\n\nZend Framework 2+ applications have a concept of \nmodules\n, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.\n\n\nExpressive provides similar functionality by incorporating two packages within\nthe default skeleton application:\n\n\n\n\nzendframework/zend-config-aggregator\n,\n  which provides features for aggregating configuration from a variety of\n  sources, including:\n\n\nPHP files globbed from the filesystem that return an array of configuration.\n\n\nzend-config\n-compatible\n  configuration files globbed from the filesystem.\n\n\nConfiguration provider classes; these are invokable classes which return an\n  array of configuration.\n\n\n\n\n\n\nzendframework/zend-component-installer\n,\n  a Composer plugin that looks for an \nextra.zf.config-provider\n entry in a\n  package to install, and, if found, adds an entry for that provider to the\n  \nconfig/config.php\n file (if it uses zend-config-aggregator).\n\n\n\n\nThese features allow you to install packages via composer and expose their\nconfiguration \u2014 which may include dependency information \u2014 to your\napplication.\n\n\nMaking your application modular\n\n\nWhen using the Expressive installer via the skeleton application, the first\nquestion asked is the installation type, which includes the options:\n\n\n\n\nMinimal (no default middleware, templates, or assets; configuration only)\n\n\nFlat (flat source code structure; default selection)\n\n\nModular (modular source code structure; recommended)\n\n\n\n\nWe recommend choosing the \"Modular\" option from the outset.\n\n\nIf you do not, you can still create and use modules in your application;\nhowever, the initial \"App\" module will not be modular.\n\n\nModule structure\n\n\nExpressive does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nWe generally recommend that a module have a \nPSR-4\n\nstructure, and that the module contain a \nsrc/\n directory at the minimum, along\nwith directories for other module-specific content, such as templates, tests, and\nassets:\n\n\nsrc/\n  Acme/\n    src/\n      ConfigProvider.php\n      Helper/\n        AuthorizationHelper.php\n      Middleware/\n        VerifyUser.php\n        VerifyUserFactory.php\n    templates/\n      verify-user.php\n    test/\n      Helper/\n        AuthorizationHelperTest.php\n      Middleware/\n        VerifyUserTest.php\n\n\n\nIf you use the above structure, you would then add an entry in your\n\ncomposer.json\n file to provide autoloading:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Acme\\\\\": \"src/Acme/src/\"\n    }\n}\n\n\n\nDon't forget to execute \ncomposer dump-autoload\n after making the change!\n\n\nCreating and enabling a module\n\n\nThe only \nrequirement\n for creating a module is that you define a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nGenerally, a config provider will return dependency information, and\nmodule-specific configuration:\n\n\nnamespace Acme;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'acme' => [\n                'some-setting' => 'default value',\n            ],\n            'templates' => [\n                'paths' => [\n                    'acme' => [__DIR__ . '/../templates'],\n                ],\n            ]\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'invokables' => [\n                Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class,\n            ],\n            'factories' => [\n                Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class,\n            ],\n        ];\n    }\n}\n\n\n\nYou would then add the config provider to the top (or towards the top) of your\n\nconfig/config.php\n:\n\n\n$aggregator = new ConfigAggregator([\n    Acme\\ConfigProvider::class,\n    /* ... */\n\n\n\nThis approach allows your \nconfig/autoload/*\n files to take precedence over the\nmodule configuration, allowing you to override the values.\n\n\nCaching configuration\n\n\nIn order to provide configuration caching, two things must occur:\n\n\n\n\nFirst, you must define a \nconfig_cache_enabled\n key in your configuration\n  somewhere.\n\n\nSecond, you must pass a second argument to the \nConfigManager\n, the location\n  of the cache file to use.\n\n\n\n\nThe \nconfig_cache_enabled\n key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:\n\n\n\n\nconfig/autoload/global.php\n should define the value to \ntrue\n, as the\n  production setting.\n\n\nconfig/autoload/local.php\n should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be \nfalse\n.\n\n\n\n\n// config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];\n\n\n\nYou would then alter your \nconfig/config.php\n file to add the second argument.\nThe following example builds on the previous, and demonstrates having the\n\nAppConfig\n entry enabled. The configuration will be cached to\n\ndata/config-cache.php\n in the application root:\n\n\n$configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');\n\n\n\nWhen the configuration cache path is present, if the \nconfig_cache_enabled\n flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.\n\n\nTooling support\n\n\nThe skeleton ships with zend-expressive-tooling by default, which allows you\nto execute the following command in order to create a module skeleton, add and\nenable autoloading rules for it, and register it with your application:\n\n\n$ composer expressive module:create {ModuleName}\n\n\n\nWe recommend using this tool when creating new modules.\n\n\nFinal notes\n\n\nThis approach may look simple, but it is flexible and powerful:\n\n\n\n\nYou pass a list of config providers to the \nConfigAggregator\n constructor.\n\n\nConfiguration is merged in the same order as it is passed, with later entries\n  having precedence.\n\n\nYou can override module configuration using \n*.global.php\n and \n*.local.php\n files.\n\n\nIf cached config is found, \nConfigAggregator\n does not iterate over provider list.\n\n\n\n\nFor more details, please refer to the \nzend-config-aggregator\ndocumentation\n.",
            "title": "Modular Applications"
        },
        {
            "location": "/v3/features/modular-applications/#modular-applications",
            "text": "Zend Framework 2+ applications have a concept of  modules , independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.  Expressive provides similar functionality by incorporating two packages within\nthe default skeleton application:   zendframework/zend-config-aggregator ,\n  which provides features for aggregating configuration from a variety of\n  sources, including:  PHP files globbed from the filesystem that return an array of configuration.  zend-config -compatible\n  configuration files globbed from the filesystem.  Configuration provider classes; these are invokable classes which return an\n  array of configuration.    zendframework/zend-component-installer ,\n  a Composer plugin that looks for an  extra.zf.config-provider  entry in a\n  package to install, and, if found, adds an entry for that provider to the\n   config/config.php  file (if it uses zend-config-aggregator).   These features allow you to install packages via composer and expose their\nconfiguration \u2014 which may include dependency information \u2014 to your\napplication.",
            "title": "Modular applications"
        },
        {
            "location": "/v3/features/modular-applications/#making-your-application-modular",
            "text": "When using the Expressive installer via the skeleton application, the first\nquestion asked is the installation type, which includes the options:   Minimal (no default middleware, templates, or assets; configuration only)  Flat (flat source code structure; default selection)  Modular (modular source code structure; recommended)   We recommend choosing the \"Modular\" option from the outset.  If you do not, you can still create and use modules in your application;\nhowever, the initial \"App\" module will not be modular.",
            "title": "Making your application modular"
        },
        {
            "location": "/v3/features/modular-applications/#module-structure",
            "text": "Expressive does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  We generally recommend that a module have a  PSR-4 \nstructure, and that the module contain a  src/  directory at the minimum, along\nwith directories for other module-specific content, such as templates, tests, and\nassets:  src/\n  Acme/\n    src/\n      ConfigProvider.php\n      Helper/\n        AuthorizationHelper.php\n      Middleware/\n        VerifyUser.php\n        VerifyUserFactory.php\n    templates/\n      verify-user.php\n    test/\n      Helper/\n        AuthorizationHelperTest.php\n      Middleware/\n        VerifyUserTest.php  If you use the above structure, you would then add an entry in your composer.json  file to provide autoloading:  \"autoload\": {\n    \"psr-4\": {\n        \"Acme\\\\\": \"src/Acme/src/\"\n    }\n}  Don't forget to execute  composer dump-autoload  after making the change!",
            "title": "Module structure"
        },
        {
            "location": "/v3/features/modular-applications/#creating-and-enabling-a-module",
            "text": "The only  requirement  for creating a module is that you define a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  Generally, a config provider will return dependency information, and\nmodule-specific configuration:  namespace Acme;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'acme' => [\n                'some-setting' => 'default value',\n            ],\n            'templates' => [\n                'paths' => [\n                    'acme' => [__DIR__ . '/../templates'],\n                ],\n            ]\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'invokables' => [\n                Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class,\n            ],\n            'factories' => [\n                Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class,\n            ],\n        ];\n    }\n}  You would then add the config provider to the top (or towards the top) of your config/config.php :  $aggregator = new ConfigAggregator([\n    Acme\\ConfigProvider::class,\n    /* ... */  This approach allows your  config/autoload/*  files to take precedence over the\nmodule configuration, allowing you to override the values.",
            "title": "Creating and enabling a module"
        },
        {
            "location": "/v3/features/modular-applications/#caching-configuration",
            "text": "In order to provide configuration caching, two things must occur:   First, you must define a  config_cache_enabled  key in your configuration\n  somewhere.  Second, you must pass a second argument to the  ConfigManager , the location\n  of the cache file to use.   The  config_cache_enabled  key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:   config/autoload/global.php  should define the value to  true , as the\n  production setting.  config/autoload/local.php  should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be  false .   // config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];  You would then alter your  config/config.php  file to add the second argument.\nThe following example builds on the previous, and demonstrates having the AppConfig  entry enabled. The configuration will be cached to data/config-cache.php  in the application root:  $configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');  When the configuration cache path is present, if the  config_cache_enabled  flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.",
            "title": "Caching configuration"
        },
        {
            "location": "/v3/features/modular-applications/#tooling-support",
            "text": "The skeleton ships with zend-expressive-tooling by default, which allows you\nto execute the following command in order to create a module skeleton, add and\nenable autoloading rules for it, and register it with your application:  $ composer expressive module:create {ModuleName}  We recommend using this tool when creating new modules.",
            "title": "Tooling support"
        },
        {
            "location": "/v3/features/modular-applications/#final-notes",
            "text": "This approach may look simple, but it is flexible and powerful:   You pass a list of config providers to the  ConfigAggregator  constructor.  Configuration is merged in the same order as it is passed, with later entries\n  having precedence.  You can override module configuration using  *.global.php  and  *.local.php  files.  If cached config is found,  ConfigAggregator  does not iterate over provider list.   For more details, please refer to the  zend-config-aggregator\ndocumentation .",
            "title": "Final notes"
        },
        {
            "location": "/v3/features/middleware/routing-and-dispatch-middleware/",
            "text": "Routing and Dispatch Middleware\n\n\nWithin Expressive, we differentiate \nrouting\n from \ndispatching\n. \nRouting\n is the\nact of matching a request to middleware; this typically involves inspecting the\npath and HTTP method used, but may also consider aspects such as headers,\nprotocol, and more. \nDispatching\n occurs \nafter\n routing; it examines the\nresults of routing, processing the middleware matched.\n\n\nExpressive goes so far as to separate the two actions into \nseparate\nmiddleware\n. This is done to allow additional middleware to execute between\nthem. For example, as you'll learn in the next two chapters, we can look for\nrouting failures and answer \nHEAD\n and \nOPTIONS\n requests, or return a \n405\nMethod Not Allowed\n status without ever hitting the dispatch middleware. When\nyou \nread about the UrlHelper\n, you'll discover it has\nassociated middleware that can receive the results of routing in order to\nfacilitate URI generation. Keeping the two actions separated as distinct\nmiddleware provides a ton of power and flexibility in building your\napplications.\n\n\nWe provide two middleware around these actions, each in the\n\nZend\\Expressive\\Router\\Middleware\n namespace and provided by the\nzendframework/zend-expressive-router package:\n\n\n\n\n\n\nRouteMiddleware\n, which consumes a \nrouter\n in order\n  to route a request.\n\n\n\n\n\n\nDispatchMiddleware\n, which dispatches the route result.\n\n\n\n\n\n\nRouteMiddleware\n\n\nZend\\Expressive\\Router\\Middleware\\RouteMiddleware\n receives a\n\nZend\\Expressive\\Router\\RouterInterface\n instance to its constructor. When it is\nprocessed, it passes the request to the router in order to receive a\n\nZend\\Expressive\\Router\\RouteResult\n instance.\n\n\nWhen the result indicates a match, the middleware creates an updated request\ninstance that includes each of the route match parameters as attributes.\n\n\nRegardless of the result, it will create an updated request instance that\nincludes the result as the attribute \nZend\\Expressive\\Router\\RouteResult\n.\n\n\nIt then invokes the handler; all later middleware can then access the route\nresult using:\n\n\n$result = $request->getAttribute(\\Zend\\Expressive\\Router\\RouteResult::class);\n\n\n\nDispatchMiddleware\n\n\nZend\\Expressive\\Router\\Middleware\\DispatchMiddleware\n defines only the\n\nprocess()\n method required by the PSR-15 \nMiddlewareInterface\n. Internally, it:\n\n\n\n\nchecks for a \nRouteResult\n in the request, AND\n\n\nprocesses it, passing the request and handler.\n\n\n\n\nIf there is no \nRouteResult\n, it delegates to the handler without doing anything\nelse.",
            "title": "Routing and Dispatch Middleware"
        },
        {
            "location": "/v3/features/middleware/routing-and-dispatch-middleware/#routing-and-dispatch-middleware",
            "text": "Within Expressive, we differentiate  routing  from  dispatching .  Routing  is the\nact of matching a request to middleware; this typically involves inspecting the\npath and HTTP method used, but may also consider aspects such as headers,\nprotocol, and more.  Dispatching  occurs  after  routing; it examines the\nresults of routing, processing the middleware matched.  Expressive goes so far as to separate the two actions into  separate\nmiddleware . This is done to allow additional middleware to execute between\nthem. For example, as you'll learn in the next two chapters, we can look for\nrouting failures and answer  HEAD  and  OPTIONS  requests, or return a  405\nMethod Not Allowed  status without ever hitting the dispatch middleware. When\nyou  read about the UrlHelper , you'll discover it has\nassociated middleware that can receive the results of routing in order to\nfacilitate URI generation. Keeping the two actions separated as distinct\nmiddleware provides a ton of power and flexibility in building your\napplications.  We provide two middleware around these actions, each in the Zend\\Expressive\\Router\\Middleware  namespace and provided by the\nzendframework/zend-expressive-router package:    RouteMiddleware , which consumes a  router  in order\n  to route a request.    DispatchMiddleware , which dispatches the route result.",
            "title": "Routing and Dispatch Middleware"
        },
        {
            "location": "/v3/features/middleware/routing-and-dispatch-middleware/#routemiddleware",
            "text": "Zend\\Expressive\\Router\\Middleware\\RouteMiddleware  receives a Zend\\Expressive\\Router\\RouterInterface  instance to its constructor. When it is\nprocessed, it passes the request to the router in order to receive a Zend\\Expressive\\Router\\RouteResult  instance.  When the result indicates a match, the middleware creates an updated request\ninstance that includes each of the route match parameters as attributes.  Regardless of the result, it will create an updated request instance that\nincludes the result as the attribute  Zend\\Expressive\\Router\\RouteResult .  It then invokes the handler; all later middleware can then access the route\nresult using:  $result = $request->getAttribute(\\Zend\\Expressive\\Router\\RouteResult::class);",
            "title": "RouteMiddleware"
        },
        {
            "location": "/v3/features/middleware/routing-and-dispatch-middleware/#dispatchmiddleware",
            "text": "Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware  defines only the process()  method required by the PSR-15  MiddlewareInterface . Internally, it:   checks for a  RouteResult  in the request, AND  processes it, passing the request and handler.   If there is no  RouteResult , it delegates to the handler without doing anything\nelse.",
            "title": "DispatchMiddleware"
        },
        {
            "location": "/v3/features/middleware/implicit-methods-middleware/",
            "text": "ImplicitHeadMiddleware and ImplicitOptionsMiddleware\n\n\nExpressive offers middleware for implicitly supporting \nHEAD\n and \nOPTIONS\n\nrequests. The HTTP/1.1 specifications indicate that all server implementations\n\nmust\n support \nHEAD\n requests for any given URI, and that they \nshould\n support\n\nOPTIONS\n requests. To make this possible, we have added features to our routing\nlayer, and middleware that can detect \nimplicit\n support for these methods\n(i.e., the route was not registered \nexplicitly\n with the method).\n\n\nBoth middleware detailed here are provided in the zend-expressive-router\npackage.\n\n\nImplicitHeadMiddleware\n\n\nZend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware\n provides support for\nhandling \nHEAD\n requests to routed middleware when the route does not explicitly\nallow for the method. It should be registered \nbetween\n the routing and dispatch\nmiddleware.\n\n\nThe zend-expressive-router package provides a factory for creating an instance,\nand registers it by default via its configuration provider.\n\n\n\n\nIf you want to provide a response instance with additional headers or a custom\nstatus code, you will need to provide your own factory.\n\n\n\n\nWithin your application pipeline, add the middleware between the routing and\ndispatch middleware, generally immediately following the routing middleware:\n\n\n$app->pipe(RouteMiddleware::class);\n$app->pipe(ImplicitHeadMiddleware::class);\n// ...\n$app->pipe(DispatchMiddleware::class);\n\n\n\n(Note: if you used the Expressive skeleton, this middleware is likely already in\nyour pipeline.)\n\n\nWhen in place, it will do the following:\n\n\n\n\nIf the request method is \nHEAD\n, AND\n\n\nthe request composes a \nRouteResult\n attribute, AND\n\n\nthe route result indicates a routing failure due to HTTP method used, THEN\n\n\nthe middleware will return a response.\n\n\n\n\nIn all other cases, it returns the result of delegating to the next middleware\nlayer.\n\n\nWhen the middleware decides it can answer the request, one of two things may\noccur. First, if the route does not support the \nGET\n method, then the\nmiddleware returns an empty response.  However, if \nGET\n is supported, it will\ndispatch the next layer, but with a \nGET\n request instead of \nHEAD\n;\nadditionally, it will inject the returned response with an empty response body\nbefore returning it.\n\n\nDetecting forwarded requests\n\n\nWhen the next layer is dispatched, the request will have an additional\nattribute, \nZend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::FORWARDED_HTTP_METHOD_ATTRIBUTE\n,\nwith a value of \nHEAD\n. As such, you can check for this value in order to vary\nthe headers returned if desired.\n\n\nImplicitOptionsMiddleware\n\n\nZend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware\n provides support for\nhandling \nOPTIONS\n requests to routed middleware when the route does not\nexplicitly allow for the method. Like the \nImplicitHeadMiddleware\n, it should be\nregistered \nbetween\n the routing and dispatch middleware.\n\n\nThe zend-expressive-router package provides a factory for creating an instance,\nand registers it by default via its configuration provider.\n\n\n\n\nIf you want to provide a response instance with additional headers or a custom\nstatus code, you will need to provide your own factory.\n\n\n\n\nWithin your application pipeline, add the middleware between the routing and\ndispatch middleware, generally immediately following the routing middleware or\n\nImplicitHeadMiddleware\n:\n\n\n$app->pipe(RouteMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n// ...\n$app->pipe(DispatchMiddleware::class);\n\n\n\n(Note: if you used the Expressive skeleton, this middleware is likely already in\nyour pipeline.)\n\n\nWhen in place, it will do the following:\n\n\n\n\nIf the request method is \nOPTIONS\n, AND\n\n\nthe request composes a \nRouteResult\n attribute, AND\n\n\nthe route result indicates a routing failure due to HTTP method used, THEN\n\n\nthe middleware will return a 200 response with an \nAllow\n header indicating\n  methods the route allows.\n\n\n\n\nIn all other cases, it returns the result of delegating to the next middleware\nlayer.\n\n\nOne thing to note: the allowed methods reported by the route and/or route\nresult, and returned via the \nAllow\n header,  may vary based on router\nimplementation. In most cases, it should be an aggregate of all routes using the\nsame path specification; however, it \ncould\n be only the methods supported\nexplicitly by the matched route.",
            "title": "Implicit HEAD and OPTIONS Middleware"
        },
        {
            "location": "/v3/features/middleware/implicit-methods-middleware/#implicitheadmiddleware-and-implicitoptionsmiddleware",
            "text": "Expressive offers middleware for implicitly supporting  HEAD  and  OPTIONS \nrequests. The HTTP/1.1 specifications indicate that all server implementations must  support  HEAD  requests for any given URI, and that they  should  support OPTIONS  requests. To make this possible, we have added features to our routing\nlayer, and middleware that can detect  implicit  support for these methods\n(i.e., the route was not registered  explicitly  with the method).  Both middleware detailed here are provided in the zend-expressive-router\npackage.",
            "title": "ImplicitHeadMiddleware and ImplicitOptionsMiddleware"
        },
        {
            "location": "/v3/features/middleware/implicit-methods-middleware/#implicitheadmiddleware",
            "text": "Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware  provides support for\nhandling  HEAD  requests to routed middleware when the route does not explicitly\nallow for the method. It should be registered  between  the routing and dispatch\nmiddleware.  The zend-expressive-router package provides a factory for creating an instance,\nand registers it by default via its configuration provider.   If you want to provide a response instance with additional headers or a custom\nstatus code, you will need to provide your own factory.   Within your application pipeline, add the middleware between the routing and\ndispatch middleware, generally immediately following the routing middleware:  $app->pipe(RouteMiddleware::class);\n$app->pipe(ImplicitHeadMiddleware::class);\n// ...\n$app->pipe(DispatchMiddleware::class);  (Note: if you used the Expressive skeleton, this middleware is likely already in\nyour pipeline.)  When in place, it will do the following:   If the request method is  HEAD , AND  the request composes a  RouteResult  attribute, AND  the route result indicates a routing failure due to HTTP method used, THEN  the middleware will return a response.   In all other cases, it returns the result of delegating to the next middleware\nlayer.  When the middleware decides it can answer the request, one of two things may\noccur. First, if the route does not support the  GET  method, then the\nmiddleware returns an empty response.  However, if  GET  is supported, it will\ndispatch the next layer, but with a  GET  request instead of  HEAD ;\nadditionally, it will inject the returned response with an empty response body\nbefore returning it.",
            "title": "ImplicitHeadMiddleware"
        },
        {
            "location": "/v3/features/middleware/implicit-methods-middleware/#detecting-forwarded-requests",
            "text": "When the next layer is dispatched, the request will have an additional\nattribute,  Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::FORWARDED_HTTP_METHOD_ATTRIBUTE ,\nwith a value of  HEAD . As such, you can check for this value in order to vary\nthe headers returned if desired.",
            "title": "Detecting forwarded requests"
        },
        {
            "location": "/v3/features/middleware/implicit-methods-middleware/#implicitoptionsmiddleware",
            "text": "Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware  provides support for\nhandling  OPTIONS  requests to routed middleware when the route does not\nexplicitly allow for the method. Like the  ImplicitHeadMiddleware , it should be\nregistered  between  the routing and dispatch middleware.  The zend-expressive-router package provides a factory for creating an instance,\nand registers it by default via its configuration provider.   If you want to provide a response instance with additional headers or a custom\nstatus code, you will need to provide your own factory.   Within your application pipeline, add the middleware between the routing and\ndispatch middleware, generally immediately following the routing middleware or ImplicitHeadMiddleware :  $app->pipe(RouteMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n// ...\n$app->pipe(DispatchMiddleware::class);  (Note: if you used the Expressive skeleton, this middleware is likely already in\nyour pipeline.)  When in place, it will do the following:   If the request method is  OPTIONS , AND  the request composes a  RouteResult  attribute, AND  the route result indicates a routing failure due to HTTP method used, THEN  the middleware will return a 200 response with an  Allow  header indicating\n  methods the route allows.   In all other cases, it returns the result of delegating to the next middleware\nlayer.  One thing to note: the allowed methods reported by the route and/or route\nresult, and returned via the  Allow  header,  may vary based on router\nimplementation. In most cases, it should be an aggregate of all routes using the\nsame path specification; however, it  could  be only the methods supported\nexplicitly by the matched route.",
            "title": "ImplicitOptionsMiddleware"
        },
        {
            "location": "/v3/features/middleware/method-not-allowed-middleware/",
            "text": "Returning Method Not Allowed\n\n\nWhen the path matches, but the HTTP method does not, your application should\nreturn a \n405 Method Not Allowed\n status in response.\n\n\nTo enable that functionality, we provide\n\nZend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware\n via the\nzend-expressive-router package.\n\n\nThis middleware triggers when the following conditions occur:\n\n\n\n\nThe request composes a \nRouteResult\n attribute (i.e., routing middleware has\n  completed), AND\n\n\nthe route result indicates a routing failure due to HTTP method used (i.e.,\n  \nRouteResult::isMethodFailure()\n returns \ntrue\n).\n\n\n\n\nWhen these conditions occur, the middleware will generate a response:\n\n\n\n\nwith a \n405 Method Not Allowed\n status, AND\n\n\nan \nAllow\n header indicating the HTTP methods allowed.\n\n\n\n\nPipe the middleware after the routing middleware; if using one or more of the\n\nimplicit methods middleware\n, this middleware\n\nmust\n be piped after them, as it will respond for \nany\n HTTP method!\n\n\n$app->pipe(RouteMiddleware::class);\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(MethodNotAllowedMiddleware::class);\n// ...\n$app->pipe(DispatchMiddleware::class);\n\n\n\n(Note: if you used the Expressive skeleton, this middleware is likely already in\nyour pipeline.)",
            "title": "Returning Method Not Allowed"
        },
        {
            "location": "/v3/features/middleware/method-not-allowed-middleware/#returning-method-not-allowed",
            "text": "When the path matches, but the HTTP method does not, your application should\nreturn a  405 Method Not Allowed  status in response.  To enable that functionality, we provide Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware  via the\nzend-expressive-router package.  This middleware triggers when the following conditions occur:   The request composes a  RouteResult  attribute (i.e., routing middleware has\n  completed), AND  the route result indicates a routing failure due to HTTP method used (i.e.,\n   RouteResult::isMethodFailure()  returns  true ).   When these conditions occur, the middleware will generate a response:   with a  405 Method Not Allowed  status, AND  an  Allow  header indicating the HTTP methods allowed.   Pipe the middleware after the routing middleware; if using one or more of the implicit methods middleware , this middleware must  be piped after them, as it will respond for  any  HTTP method!  $app->pipe(RouteMiddleware::class);\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(MethodNotAllowedMiddleware::class);\n// ...\n$app->pipe(DispatchMiddleware::class);  (Note: if you used the Expressive skeleton, this middleware is likely already in\nyour pipeline.)",
            "title": "Returning Method Not Allowed"
        },
        {
            "location": "/v3/features/helpers/intro/",
            "text": "Helpers\n\n\nSome tasks and features will be common to many if not all applications. For\nthose, Expressive provides \nhelpers\n. These are typically utility classes that\nmay integrate features or simply provide standalone benefits.\n\n\nCurrently, these include:\n\n\n\n\nBody Parsing Middleware\n\n\nContent-Length Middleware\n (since zend-expressive-helpers 4.1.0)\n\n\nUrlHelper\n\n\nServerUrlHelper\n\n\n\n\nInstallation\n\n\nIf you started your project using the Expressive skeleton package, the helpers\nare already installed.\n\n\nIf not, you can install them as follows:\n\n\n$ composer require zendframework/zend-expressive-helpers",
            "title": "Introduction"
        },
        {
            "location": "/v3/features/helpers/intro/#helpers",
            "text": "Some tasks and features will be common to many if not all applications. For\nthose, Expressive provides  helpers . These are typically utility classes that\nmay integrate features or simply provide standalone benefits.  Currently, these include:   Body Parsing Middleware  Content-Length Middleware  (since zend-expressive-helpers 4.1.0)  UrlHelper  ServerUrlHelper",
            "title": "Helpers"
        },
        {
            "location": "/v3/features/helpers/intro/#installation",
            "text": "If you started your project using the Expressive skeleton package, the helpers\nare already installed.  If not, you can install them as follows:  $ composer require zendframework/zend-expressive-helpers",
            "title": "Installation"
        },
        {
            "location": "/v3/features/helpers/url-helper/",
            "text": "UrlHelper\n\n\nZend\\Expressive\\Helper\\UrlHelper\n provides the ability to generate a URI path\nbased on a given route defined in the \nZend\\Expressive\\Router\\RouterInterface\n.\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper->generate('resource', ['id' => 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' => 'sha1']);\n\n\n\nThe signature for both is:\n\n\nfunction (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string\n\n\n\nWhere:\n\n\n\n\n$routeName\n is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.\n\n\n$routeParams\n is an array of substitutions to use for the provided route, with the\n  following behavior:\n\n\nIf a \nRouteResult\n is composed in the helper, and the \n$routeName\n matches\n  it, the provided \n$params\n will be merged with any matched parameters, with\n  those provided taking precedence.\n\n\nIf a \nRouteResult\n is not composed, or if the composed result does not match\n  the provided \n$routeName\n, then only the \n$params\n provided will be used\n  for substitutions.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n matches the currently\n  matched route, then any matched parameters found will be used.\n  parameters found will be used.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n does not match the\n  currently matched route, or if no route result is present, then no\n  substitutions will be made.\n\n\n\n\n\n\n$queryParams\n is an array of query string arguments to include in the\n  generated URI.\n\n\n$fragmentIdentifier\n is a string to use as the URI fragment.\n\n\n$options\n is an array of options to provide to the router for purposes of\n  controlling URI generation. As an example, zend-router can consume \"translator\"\n  and \"text_domain\" options in order to provide translated URIs.\n\n\n\n\nEach method will raise an exception if:\n\n\n\n\nNo \n$routeName\n is provided, and no \nRouteResult\n is composed.\n\n\nNo \n$routeName\n is provided, a \nRouteResult\n is composed, but that result\n  represents a matching failure.\n\n\nThe given \n$routeName\n is not defined in the router.\n\n\n\n\n\n\nSignature changes\n\n\nThe signature listed above is current as of version 3.0.0 of\nzendframework/zend-expressive-helpers. Prior to that version, the helper only\naccepted the route name and route parameters.\n\n\n\n\nOther methods available\n\n\n\n\ngetRouteResult() : ?Zend\\Expressive\\Router\\RouteResult\n (since\n  zend-expressive-helpers 5.2.0): if you want access to the result of routing \u2014\n  and, consequently, the matched route name, matched route parameters, and\n  matched route \u2014 you can use this method. The method returns \nnull\n if no route\n  result has been injected yet \u2014 which typically happens in the\n  \nUrlHelperMiddleware\n, discussed in the next section.\n\n\n\n\nAs an example:\n\n\n$templateParams = [];\n$routeResult    = $this->urlHelper->getRouteResult();\nif ($routeResult->isSuccess()) {\n    $templateParams['route']        = $routeResult->getMatchedRouteName();\n    $templateParams['route_params'] = $routeResult->getMatchedParams();\n}\n\n\n\nRegistering the pipeline middleware\n\n\nFor the \nUrlHelper\n to work, you must first register the \nUrlHelperMiddleware\n\nas pipeline middleware following the routing middleware, and before the dispatch\nmiddleware:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app->pipe(RouteMiddleware::class);\n// ...\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipe(DispatchMiddleware::class);\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nUrlHelper\n and \nUrlHelperMiddleware\n factories are already registered for\nyou, as is the \nUrlHelperMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\n<?php\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $response = $handler->handle($request);\n        return $response->withHeader(\n            'Link',\n            $this->helper->generate('resource', ['id' => 'sha1'])\n        );\n    }\n}\n\n\n\nBase Path support\n\n\nIf your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the \nbase path\n, and thus be invalid. To\naccommodate this, the \nUrlHelper\n supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.\n\n\nAs an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the \nUrlHelper\n with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:\n\n\n<?php\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $uri = $request->getUri();\n        $path = $uri->getPath();\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $handler->handle($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $handler->handle($request->withUri(\n            $uri->withPath(substr($path, strlen($locale) + 1))\n        ));\n    }\n}\n\n\n\n(Note: if the base path injected is not prefixed with \n/\n, the helper will add\nthe slash.)\n\n\nPaths generated by the \nUriHelper\n from this point forward will have the\ndetected language prefix.\n\n\nRouter-specific helpers\n\n\n\n\nSince zend-expressive-router 3.1.0 and zend-expressive-helpers 5.1.0.\n\n\n\n\nOccasionally, you may want to provide a different router instance to nested\npipeline middleware; in particular, this may occur when you want to \nsegregate a\npipeline by path\n.\n\n\nIn such situations, you cannot reuse the \nUrlHelper\n instance, as a different\nrouter is in play; additionally, it may need to define a base path so that any\ngenerated URIs contain the full path information (since path segregation strips\nthe specified path prefix from the request).\n\n\nTo facilitate such scenarios, the factories for the \nUrlHelper\n and\n\nUrlHelperMiddleware\n allow providing optional arguments to allow varying\nbehavior:\n\n\n\n\nUrlHelperFactory\n allows passing an alternate router service name.\n\n\nUrlHelperMiddlewareFactory\n allows passing an alternate URL helper service name.\n\n\n\n\nAs an example, let us consider a module named \nAuth\n where we want to define a\npath-segregated middleware pipeline that has its own router and route\nmiddleware. We might define its dependency configuration as follows:\n\n\nnamespace Auth;\n\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddlewareFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddlewareFactory;\n\nreturn [\n    'dependencies' => [\n          'factories' => [\n              // module-specific class name => factory\n              Router::class                 => FastRouteRouterFactory::class,\n              RouteMiddleware::class        => new RouteMiddlewareFactory(Router::class),\n              UrlHelper::class              => new UrlHelperFactory('/auth', Router::class),\n              UrlHelperMiddleware::class    => new UrlHelperMiddlewareFactory(UrlHelper::class),\n          ],\n    ],\n];\n\n\n\nWe could then create a path-segregated pipeline like the following:\n\n\n$app->pipe('/auth', [\n    \\Auth\\RouteMiddleware::class,     // module-specific routing middleware!\n    ImplicitHeadMiddleware::class,\n    ImplicitOptionsMiddleware::class,\n    MethodNotAllowedMiddleware::class,\n    \\Auth\\UrlHelperMiddleware::class, // module-specific URL helper middleware!\n    DispatchMiddleware::class,\n]);\n\n\n\nAny handlers that the module-specific router routes to can then also compose the\nsame \nUrlHelper\n instance via their factories:\n\n\nnamespace Auth;\n\nuse Psr\\Container\\ContainerInterface;\n\nclass SomeHandlerFactory\n{\n    public function __invoke(ContainerInterface $container) : SomeHandler\n    {\n        return new SomeHandler(\n            $container->get(UrlHelper::class) // module-specific URL helper!\n        );\n    }\n}\n\n\n\nThis instance will then be properly configured to generate links using the\nmodule-specific router.",
            "title": "UrlHelper"
        },
        {
            "location": "/v3/features/helpers/url-helper/#urlhelper",
            "text": "Zend\\Expressive\\Helper\\UrlHelper  provides the ability to generate a URI path\nbased on a given route defined in the  Zend\\Expressive\\Router\\RouterInterface .\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.",
            "title": "UrlHelper"
        },
        {
            "location": "/v3/features/helpers/url-helper/#usage",
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper->generate('resource', ['id' => 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' => 'sha1']);  The signature for both is:  function (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string  Where:   $routeName  is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.  $routeParams  is an array of substitutions to use for the provided route, with the\n  following behavior:  If a  RouteResult  is composed in the helper, and the  $routeName  matches\n  it, the provided  $params  will be merged with any matched parameters, with\n  those provided taking precedence.  If a  RouteResult  is not composed, or if the composed result does not match\n  the provided  $routeName , then only the  $params  provided will be used\n  for substitutions.  If no  $params  are provided, and the  $routeName  matches the currently\n  matched route, then any matched parameters found will be used.\n  parameters found will be used.  If no  $params  are provided, and the  $routeName  does not match the\n  currently matched route, or if no route result is present, then no\n  substitutions will be made.    $queryParams  is an array of query string arguments to include in the\n  generated URI.  $fragmentIdentifier  is a string to use as the URI fragment.  $options  is an array of options to provide to the router for purposes of\n  controlling URI generation. As an example, zend-router can consume \"translator\"\n  and \"text_domain\" options in order to provide translated URIs.   Each method will raise an exception if:   No  $routeName  is provided, and no  RouteResult  is composed.  No  $routeName  is provided, a  RouteResult  is composed, but that result\n  represents a matching failure.  The given  $routeName  is not defined in the router.",
            "title": "Usage"
        },
        {
            "location": "/v3/features/helpers/url-helper/#signature-changes",
            "text": "The signature listed above is current as of version 3.0.0 of\nzendframework/zend-expressive-helpers. Prior to that version, the helper only\naccepted the route name and route parameters.",
            "title": "Signature changes"
        },
        {
            "location": "/v3/features/helpers/url-helper/#other-methods-available",
            "text": "getRouteResult() : ?Zend\\Expressive\\Router\\RouteResult  (since\n  zend-expressive-helpers 5.2.0): if you want access to the result of routing \u2014\n  and, consequently, the matched route name, matched route parameters, and\n  matched route \u2014 you can use this method. The method returns  null  if no route\n  result has been injected yet \u2014 which typically happens in the\n   UrlHelperMiddleware , discussed in the next section.   As an example:  $templateParams = [];\n$routeResult    = $this->urlHelper->getRouteResult();\nif ($routeResult->isSuccess()) {\n    $templateParams['route']        = $routeResult->getMatchedRouteName();\n    $templateParams['route_params'] = $routeResult->getMatchedParams();\n}",
            "title": "Other methods available"
        },
        {
            "location": "/v3/features/helpers/url-helper/#registering-the-pipeline-middleware",
            "text": "For the  UrlHelper  to work, you must first register the  UrlHelperMiddleware \nas pipeline middleware following the routing middleware, and before the dispatch\nmiddleware:  use Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app->pipe(RouteMiddleware::class);\n// ...\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipe(DispatchMiddleware::class);",
            "title": "Registering the pipeline middleware"
        },
        {
            "location": "/v3/features/helpers/url-helper/#skeleton-configures-helpers",
            "text": "If you started your project using the Expressive skeleton package, the UrlHelper  and  UrlHelperMiddleware  factories are already registered for\nyou, as is the  UrlHelperMiddleware  pipeline middleware.",
            "title": "Skeleton configures helpers"
        },
        {
            "location": "/v3/features/helpers/url-helper/#using-the-helper-in-middleware",
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  <?php\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $response = $handler->handle($request);\n        return $response->withHeader(\n            'Link',\n            $this->helper->generate('resource', ['id' => 'sha1'])\n        );\n    }\n}",
            "title": "Using the helper in middleware"
        },
        {
            "location": "/v3/features/helpers/url-helper/#base-path-support",
            "text": "If your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the  base path , and thus be invalid. To\naccommodate this, the  UrlHelper  supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.  As an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the  UrlHelper  with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:  <?php\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $uri = $request->getUri();\n        $path = $uri->getPath();\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $handler->handle($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $handler->handle($request->withUri(\n            $uri->withPath(substr($path, strlen($locale) + 1))\n        ));\n    }\n}  (Note: if the base path injected is not prefixed with  / , the helper will add\nthe slash.)  Paths generated by the  UriHelper  from this point forward will have the\ndetected language prefix.",
            "title": "Base Path support"
        },
        {
            "location": "/v3/features/helpers/url-helper/#router-specific-helpers",
            "text": "Since zend-expressive-router 3.1.0 and zend-expressive-helpers 5.1.0.   Occasionally, you may want to provide a different router instance to nested\npipeline middleware; in particular, this may occur when you want to  segregate a\npipeline by path .  In such situations, you cannot reuse the  UrlHelper  instance, as a different\nrouter is in play; additionally, it may need to define a base path so that any\ngenerated URIs contain the full path information (since path segregation strips\nthe specified path prefix from the request).  To facilitate such scenarios, the factories for the  UrlHelper  and UrlHelperMiddleware  allow providing optional arguments to allow varying\nbehavior:   UrlHelperFactory  allows passing an alternate router service name.  UrlHelperMiddlewareFactory  allows passing an alternate URL helper service name.   As an example, let us consider a module named  Auth  where we want to define a\npath-segregated middleware pipeline that has its own router and route\nmiddleware. We might define its dependency configuration as follows:  namespace Auth;\n\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddlewareFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddlewareFactory;\n\nreturn [\n    'dependencies' => [\n          'factories' => [\n              // module-specific class name => factory\n              Router::class                 => FastRouteRouterFactory::class,\n              RouteMiddleware::class        => new RouteMiddlewareFactory(Router::class),\n              UrlHelper::class              => new UrlHelperFactory('/auth', Router::class),\n              UrlHelperMiddleware::class    => new UrlHelperMiddlewareFactory(UrlHelper::class),\n          ],\n    ],\n];  We could then create a path-segregated pipeline like the following:  $app->pipe('/auth', [\n    \\Auth\\RouteMiddleware::class,     // module-specific routing middleware!\n    ImplicitHeadMiddleware::class,\n    ImplicitOptionsMiddleware::class,\n    MethodNotAllowedMiddleware::class,\n    \\Auth\\UrlHelperMiddleware::class, // module-specific URL helper middleware!\n    DispatchMiddleware::class,\n]);  Any handlers that the module-specific router routes to can then also compose the\nsame  UrlHelper  instance via their factories:  namespace Auth;\n\nuse Psr\\Container\\ContainerInterface;\n\nclass SomeHandlerFactory\n{\n    public function __invoke(ContainerInterface $container) : SomeHandler\n    {\n        return new SomeHandler(\n            $container->get(UrlHelper::class) // module-specific URL helper!\n        );\n    }\n}  This instance will then be properly configured to generate links using the\nmodule-specific router.",
            "title": "Router-specific helpers"
        },
        {
            "location": "/v3/features/helpers/server-url-helper/",
            "text": "ServerUrlHelper\n\n\nZend\\Expressive\\Helper\\ServerUrlHelper\n provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent \nPsr\\Http\\Message\\UriInterface\n instance provided to it in order to\ngenerate a fully qualified URI.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper->generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');\n\n\n\nThe helper is particularly useful when used in conjunction with the\n\nUrlHelper\n, as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:\n\n\n$url = $serverUrl($url('resource', ['id' => 'sha1']));\n\n\n\nThe signature for the ServerUrlHelper \ngenerate()\n and \n__invoke()\n methods is:\n\n\nfunction ($path = null) : string\n\n\n\nWhere:\n\n\n\n\n$path\n, when provided, can be a string path to use to generate a URI.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to inject it with the current\n\nUriInterface\n from the request instance. To automate this, we provide\n\nZend\\Expressive\\Helper\\ServerUrlMiddleware\n, which composes a \nServerUrl\n\ninstance, and, when invoked, injects it with the URI instance.\n\n\nAs such, you will need to register the \nServerUrlMiddleware\n as pipeline\nmiddleware, anytime before the routing middleware:\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipe(RouteMiddleware::class);\n// ...\n$app->pipe(DispatchMiddleware::class);\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nServerUrlHelper\n and \nServerUrlMiddleware\n factories are already registered\nfor you, as is the \nServerUrlMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterfacel\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $response = $handler->handle($request);\n\n        return $response->withHeader(\n            'Link',\n            $this->helper->generate() . '; rel=\"self\"'\n        );\n    }\n}",
            "title": "ServerUrlHelper"
        },
        {
            "location": "/v3/features/helpers/server-url-helper/#serverurlhelper",
            "text": "Zend\\Expressive\\Helper\\ServerUrlHelper  provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent  Psr\\Http\\Message\\UriInterface  instance provided to it in order to\ngenerate a fully qualified URI.",
            "title": "ServerUrlHelper"
        },
        {
            "location": "/v3/features/helpers/server-url-helper/#usage",
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper->generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');  The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:  $url = $serverUrl($url('resource', ['id' => 'sha1']));  The signature for the ServerUrlHelper  generate()  and  __invoke()  methods is:  function ($path = null) : string  Where:   $path , when provided, can be a string path to use to generate a URI.",
            "title": "Usage"
        },
        {
            "location": "/v3/features/helpers/server-url-helper/#creating-an-instance",
            "text": "In order to use the helper, you will need to inject it with the current UriInterface  from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a  ServerUrl \ninstance, and, when invoked, injects it with the URI instance.  As such, you will need to register the  ServerUrlMiddleware  as pipeline\nmiddleware, anytime before the routing middleware:  use Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipe(RouteMiddleware::class);\n// ...\n$app->pipe(DispatchMiddleware::class);",
            "title": "Creating an instance"
        },
        {
            "location": "/v3/features/helpers/server-url-helper/#skeleton-configures-helpers",
            "text": "If you started your project using the Expressive skeleton package, the ServerUrlHelper  and  ServerUrlMiddleware  factories are already registered\nfor you, as is the  ServerUrlMiddleware  pipeline middleware.",
            "title": "Skeleton configures helpers"
        },
        {
            "location": "/v3/features/helpers/server-url-helper/#using-the-helper-in-middleware",
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterfacel\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $response = $handler->handle($request);\n\n        return $response->withHeader(\n            'Link',\n            $this->helper->generate() . '; rel=\"self\"'\n        );\n    }\n}",
            "title": "Using the helper in middleware"
        },
        {
            "location": "/v3/features/helpers/body-parse/",
            "text": "Body Parsing Middleware\n\n\nZend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware\n provides generic\n\nPSR-15\n middleware for parsing the request\nbody into parameters, and returning a new request instance that composes them.\nThe subcomponent provides a strategy pattern around matching the request\n\nContent-Type\n, and then parsing it, giving you a flexible approach that can\ngrow with your accepted content types.\n\n\nBy default, this middleware will detect the following content types:\n\n\n\n\napplication/x-www-form-urlencoded\n (standard web-based forms, without file\n  uploads)\n\n\napplication/json\n, \napplication/*+json\n (JSON payloads)\n\n\n\n\nRegistering the middleware\n\n\nYou can register it programmatically:\n\n\n$app->pipe(BodyParamsMiddleware::class);\n\n\n\nSince body parsing does not necessarily need to happen for every request, you\ncan also choose to incorporate it in route-specific middleware pipelines:\n\n\n$app->post('/login', [\n    BodyParamsMiddleware::class,\n    LoginMiddleware::class,\n]);\n\n\n\nUsing route-based middleware pipelines has the advantage of ensuring that the\nbody parsing middleware only executes for routes that require the processing.\nWhile the middleware has some checks to ensure it only triggers for HTTP\nmethods that accept bodies, those checks are still overhead that you might want\nto avoid; the above strategy of using the middleware only with specific routes\ncan accomplish that.\n\n\nStrategies\n\n\nIf you want to intercept and parse other payload types, you can add \nstrategies\n\nto the middleware. Strategies implement \nZend\\Expressive\\Helper\\BodyParams\\StrategyInterface\n:\n\n\nnamespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     */\n    public function match(string $contentType) : bool;\n\n    /**\n     * Parse the body content and return a new request.\n     */\n    public function parse(ServerRequestInterface $request) : ServerRequestInterface;\n}\n\n\n\nYou then register them with the middleware using the \naddStrategy()\n method:\n\n\n$bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n\n\n\nTo automate the registration, we recommend writing a factory for the\n\nBodyParamsMiddleware\n, and replacing the \ninvokables\n registration with a\nregistration in the \nfactories\n section of the \nmiddleware-pipeline.config.php\n\nfile:\n\n\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nAlternately, use a \ndelegator factory\n.\n\n\nRemoving the default strategies\n\n\nBy default, \nBodyParamsMiddleware\n composes the following strategies:\n\n\n\n\nZend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy\n\n\nZend\\Expressive\\Helper\\BodyParams\\JsonStrategy\n\n\n\n\nThese provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \u2014\n\napplication/x-www-form-urlencoded\n \u2014 matches first, as the middleware\ndelegates parsing to the first match.\n\n\nIf you do not want to use these default strategies, you can clear them from the\nmiddleware using \nclearStrategies()\n:\n\n\n$bodyParamsMiddleware->clearStrategies();\n\n\n\nNote: if you do this, \nall\n strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.",
            "title": "Body Parsing Middleware"
        },
        {
            "location": "/v3/features/helpers/body-parse/#body-parsing-middleware",
            "text": "Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware  provides generic PSR-15  middleware for parsing the request\nbody into parameters, and returning a new request instance that composes them.\nThe subcomponent provides a strategy pattern around matching the request Content-Type , and then parsing it, giving you a flexible approach that can\ngrow with your accepted content types.  By default, this middleware will detect the following content types:   application/x-www-form-urlencoded  (standard web-based forms, without file\n  uploads)  application/json ,  application/*+json  (JSON payloads)",
            "title": "Body Parsing Middleware"
        },
        {
            "location": "/v3/features/helpers/body-parse/#registering-the-middleware",
            "text": "You can register it programmatically:  $app->pipe(BodyParamsMiddleware::class);  Since body parsing does not necessarily need to happen for every request, you\ncan also choose to incorporate it in route-specific middleware pipelines:  $app->post('/login', [\n    BodyParamsMiddleware::class,\n    LoginMiddleware::class,\n]);  Using route-based middleware pipelines has the advantage of ensuring that the\nbody parsing middleware only executes for routes that require the processing.\nWhile the middleware has some checks to ensure it only triggers for HTTP\nmethods that accept bodies, those checks are still overhead that you might want\nto avoid; the above strategy of using the middleware only with specific routes\ncan accomplish that.",
            "title": "Registering the middleware"
        },
        {
            "location": "/v3/features/helpers/body-parse/#strategies",
            "text": "If you want to intercept and parse other payload types, you can add  strategies \nto the middleware. Strategies implement  Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface :  namespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     */\n    public function match(string $contentType) : bool;\n\n    /**\n     * Parse the body content and return a new request.\n     */\n    public function parse(ServerRequestInterface $request) : ServerRequestInterface;\n}  You then register them with the middleware using the  addStrategy()  method:  $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());  To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the  invokables  registration with a\nregistration in the  factories  section of the  middleware-pipeline.config.php \nfile:  use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];  Alternately, use a  delegator factory .",
            "title": "Strategies"
        },
        {
            "location": "/v3/features/helpers/body-parse/#removing-the-default-strategies",
            "text": "By default,  BodyParamsMiddleware  composes the following strategies:   Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy  Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy   These provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded  \u2014 matches first, as the middleware\ndelegates parsing to the first match.  If you do not want to use these default strategies, you can clear them from the\nmiddleware using  clearStrategies() :  $bodyParamsMiddleware->clearStrategies();  Note: if you do this,  all  strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.",
            "title": "Removing the default strategies"
        },
        {
            "location": "/v3/features/helpers/content-length/",
            "text": "Content-Length Middleware\n\n\nIn some cases, you may want to include an explicit \nContent-Length\n response\nheader, without having to inject it manually. To facilitate this, we provide\n\nZend\\Expressive\\Helper\\ContentLengthMiddleware\n.\n\n\n\n\nWhen to use this middleware\n\n\nIn most cases, you do not need to provide an explicit Content-Length value\nin your responses. While the HTTP/1.1 specification indicates the header\nSHOULD be provided, most clients will not degrade to HTTP/1.0 if the header\nis omitted.\n\n\nThe one exception that has been reported is when working with\n\nNew Relic\n, which requires valid \nContent-Length\n\nheaders for some of its analytics; in such cases, enabling this middleware\nwill fix those situations.\n\n\n\n\nThis middleware delegates the request, and operates on the returned response. It\nwill return a new response with the \nContent-Length\n header injected under the\nfollowing conditions:\n\n\n\n\nNo \nContent-Length\n header is already present AND\n\n\nthe body size is non-null.\n\n\n\n\nTo register it in your application, you will need to do two things: register the\nmiddleware with the container, and register the middleware in either your\napplication pipeline, or within routed middleware.\n\n\nTo add it to your container, add the following configuration:\n\n\n// In a `config/autoload/*.global.php` file, or a `ConfigProvider` class:\n\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\ContentLengthMiddleware::class => Helper\\ContentLengthMiddleware::class,\n        ],\n    ],\n];\n\n\n\nTo register it as pipeline middleware to execute on any request:\n\n\n// In `config/pipeline.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->pipe(Helper\\ContentLengthMiddleware::class);\n\n\n\nTo register it within a routed middleware pipeline:\n\n\n// In `config/routes.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->get('/download/tarball', [\n    Helper\\ContentLengthMiddleware::class,\n    Download\\Tarball::class,\n], 'download-tar');\n\n\n\nCaveats\n\n\nOne caveat to note is that if you use this middleware, but also write directly\nto the output buffer (e.g., via a \nvar_dump\n, or if \ndisplay_errors\n is on and\nan uncaught error or exception occurs), the output will not appear as you\nexpect. Generally in such situations, the contents of the output buffer will\nappear, up to the specified \nContent-Length\n value. This can lead to truncated\nerror content and/or truncated application content.\n\n\nWe recommend that if you use this feature, you also use a PHP error and/or\nexception handler that logs errors in order to prevent truncated output.",
            "title": "Content-Length Middleware"
        },
        {
            "location": "/v3/features/helpers/content-length/#content-length-middleware",
            "text": "In some cases, you may want to include an explicit  Content-Length  response\nheader, without having to inject it manually. To facilitate this, we provide Zend\\Expressive\\Helper\\ContentLengthMiddleware .",
            "title": "Content-Length Middleware"
        },
        {
            "location": "/v3/features/helpers/content-length/#when-to-use-this-middleware",
            "text": "In most cases, you do not need to provide an explicit Content-Length value\nin your responses. While the HTTP/1.1 specification indicates the header\nSHOULD be provided, most clients will not degrade to HTTP/1.0 if the header\nis omitted.  The one exception that has been reported is when working with New Relic , which requires valid  Content-Length \nheaders for some of its analytics; in such cases, enabling this middleware\nwill fix those situations.   This middleware delegates the request, and operates on the returned response. It\nwill return a new response with the  Content-Length  header injected under the\nfollowing conditions:   No  Content-Length  header is already present AND  the body size is non-null.   To register it in your application, you will need to do two things: register the\nmiddleware with the container, and register the middleware in either your\napplication pipeline, or within routed middleware.  To add it to your container, add the following configuration:  // In a `config/autoload/*.global.php` file, or a `ConfigProvider` class:\n\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\ContentLengthMiddleware::class => Helper\\ContentLengthMiddleware::class,\n        ],\n    ],\n];  To register it as pipeline middleware to execute on any request:  // In `config/pipeline.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->pipe(Helper\\ContentLengthMiddleware::class);  To register it within a routed middleware pipeline:  // In `config/routes.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->get('/download/tarball', [\n    Helper\\ContentLengthMiddleware::class,\n    Download\\Tarball::class,\n], 'download-tar');",
            "title": "When to use this middleware"
        },
        {
            "location": "/v3/features/helpers/content-length/#caveats",
            "text": "One caveat to note is that if you use this middleware, but also write directly\nto the output buffer (e.g., via a  var_dump , or if  display_errors  is on and\nan uncaught error or exception occurs), the output will not appear as you\nexpect. Generally in such situations, the contents of the output buffer will\nappear, up to the specified  Content-Length  value. This can lead to truncated\nerror content and/or truncated application content.  We recommend that if you use this feature, you also use a PHP error and/or\nexception handler that logs errors in order to prevent truncated output.",
            "title": "Caveats"
        },
        {
            "location": "/v3/features/helpers/template-variable-container/",
            "text": "Template Variable Container\n\n\n\n\n\n\nSince zend-expressive-helpers 5.3.0\n\n\n\n\n\n\nzend-expressive-template\n provides the method\n\nZend\\Expressive\\Template\\TemplateRendererInterface::addDefaultParam()\n\nfor providing template variables that should be available to any template.\n\n\nOne common use case for this is to set things such as the current user, current\nsection of the website, currently matched route, etc. Unfortunately, because the\nmethod changes the internal state of the renderer, this can cause problems in an\nasync environment, such as \nSwoole\n, \nwhere those changes will persist for parallel and subsequent requests.\n\n\nTo provide a stateless alternative, you can create a \nZend\\Expressive\\Helper\\Template\\TemplateVariableContainer\n\nand persist it as a request attribute. This allows you to set template variables\nthat are pipeline-specific, and later extract and merge them with\nhandler-specific values when rendering.\n\n\nTo facilitate this further, we provide \nZend\\Expressive\\Helper\\Template\\TemplateVariableContainerMiddleware\n,\nwhich will populate the attribute for you if it has not yet been.\n\n\nThe container is \nimmutable\n, and any changes will result in a new instance.\nAs such, any middleware that is providing additional values or removing values\n\nmust\n call \n$request->withAttribute()\n to replace the instance, per the\nexamples below.\n\n\n\n\nWhen to use the TemplateVariableContainer\n\n\nIf you are calling \naddDefaultParam()\n only in your factory for creating your\ntemplate renderer instance, or within delegator factories on the renderer,\nyou do not need to make any changes.\n\n\nIf you are using our \nSwoole integrations\n\nor other async application runners, and either currently or plan to set\ntemplate parameters withing pipeline middleware you definitely need to use the\nTemplateVariableContainer in order to prevent state problems.\n\n\nWe actually recommend using this approach even if you are not using Swoole or\nother async application runners, as the approach is more explicit and easily\ntested, and, as noted, does not depend on state within the renderer itself.\n\n\n\n\nUsage\n\n\nAs an example, consider the following pipeline:\n\n\n// In config/pipeline.php\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Handler\\NotFoundHandler;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\Template\\TemplateVariableContainerMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nuse function Zend\\Stratigility\\path;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    $app->pipe(ErrorHandler::class);\n    $app->pipe(ServerUrlMiddleware::class);\n\n        // The following entry is specific to this example:\n    $app->pipe(path(\n        '/api/doc',\n        $factory->lazy(TemplateVariableContainerMiddleware::class)\n    ));\n\n    $app->pipe(RouteMiddleware::class);\n\n    $app->pipe(ImplicitHeadMiddleware::class);\n    $app->pipe(ImplicitOptionsMiddleware::class);\n    $app->pipe(MethodNotAllowedMiddleware::class);\n    $app->pipe(UrlHelperMiddleware::class);\n\n    $app->pipe(DispatchMiddleware::class);\n\n    $app->pipe(NotFoundHandler::class);\n};\n\n\n\nAny middleware or handler that responds to a path beginning with \n/api/doc\n will\nnow have a \nZend\\Expressive\\Helper\\Template\\TemplateVariableContainer\n attribute\nthat contains an instance of that class.\n\n\nWithin middleware that responds on that path, you can then do the following:\n\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nclass InjectUserAndRouteVariablesMiddleware implements MiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n            RequestHandlerInterface $handler\n    ) : ResponseInterface {\n        $container = $request->getAttribute(\n            TemplateVariableContainer::class,\n            new TemplateVariableContainer()\n        );\n\n        // Since containers are immutable, we re-populate the request:\n        $request = $request->withAttribute(\n            TemplateVariableContainer::class,\n            $container->merge([\n                'user'  => $user,\n                'route' => $request->getAttribute(RouteResult::class),\n            ])\n        );\n\n        return $handler->handle($request);\n    }\n}\n\n\n\nIn a handler, you will call \nmergeForTemplate()\n with any local variables you\nwant to use, including those that might override the defaults:\n\n\nuse Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    private $renderer;\n    private $responseFactory;\n    private $streamFactory;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory\n    ) {\n        $this->renderer        = $renderer;\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory   = $streamFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $value = $request->getParsedBody()['key'] ?? null;\n\n        $content = $this->renderer->render(\n            'some::template',\n            $request\n                ->getAttribute(TemplateVariableContainer::class)\n                ->mergeForTemplate([\n                    'local' => $value,\n                ])\n        );\n\n        $body = $this->streamFactory()->createStream($content);\n\n        return $this->responseFactory()->createResponse(200)->withBody($body);\n    }\n}\n\n\n\nThe \nTemplateVariableContainer\n contains the following methods:\n\n\n\n\ncount() : int\n: return a count of variables in the container.\n\n\nget(string $key) : mixed\n: return the value associated with \n$key\n; if not\n  present, a \nnull\n is returned.\n\n\nhas(string $key) : bool\n: does the container have an entry associated with\n  \n$key\n?\n\n\nwith(string $key, mixed $value) : self\n: return a new container instance\n  containing the key/value pair provided.\n\n\nwithout(string $key) : self\n: return a new container instance that does not\n  contain the given \n$key\n.\n\n\nmerge(array $values) : self\n: return a new container that merge the \n$values\n\n  provided with those in the original container. This is useful for setting\n  many values at once.\n\n\nmergeForTemplate(array $values) : array\n: merge \n$values\n with any values in\n  the container, and return the result. This method has no side effects, and\n  should be used when preparing variables to pass to the renderer.\n\n\n\n\nRoute template variable middleware\n\n\n\n\n\n\nSince zend-expressive-helpers 5.3.0\n\n\n\n\n\n\nZend\\Expressive\\Helper\\Template\\RouteTemplateVariableMiddleware\n will inject\nthe currently matched route into the \ntemplate variable container\n.\n\n\nThis middleware relies on the \nTemplateVariableContainerMiddleware\n preceding\nit in the middleware pipeline, or having the \nTemplateVariableContainer\n\nrequest attribute present; if neither is present, it will generate a new\ninstance.\n\n\nIt then populates the container's \nroute\n parameter using the results of\nretrieving the \nZend\\Expressive\\Router\\RouteResult\n request attribute; the value\nwill be either an instance of that class, or \nnull\n.\n\n\nTemplates rendered using the container can then access that value, and test for\nrouting success/failure status, pull the matched route name, route, and/or\nparameters from it.\n\n\nThis middleware can replace the \nUrlHelperMiddleware\n in your\npipeline.",
            "title": "Template Variable Container"
        },
        {
            "location": "/v3/features/helpers/template-variable-container/#template-variable-container",
            "text": "Since zend-expressive-helpers 5.3.0    zend-expressive-template  provides the method Zend\\Expressive\\Template\\TemplateRendererInterface::addDefaultParam() \nfor providing template variables that should be available to any template.  One common use case for this is to set things such as the current user, current\nsection of the website, currently matched route, etc. Unfortunately, because the\nmethod changes the internal state of the renderer, this can cause problems in an\nasync environment, such as  Swoole , \nwhere those changes will persist for parallel and subsequent requests.  To provide a stateless alternative, you can create a  Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer \nand persist it as a request attribute. This allows you to set template variables\nthat are pipeline-specific, and later extract and merge them with\nhandler-specific values when rendering.  To facilitate this further, we provide  Zend\\Expressive\\Helper\\Template\\TemplateVariableContainerMiddleware ,\nwhich will populate the attribute for you if it has not yet been.  The container is  immutable , and any changes will result in a new instance.\nAs such, any middleware that is providing additional values or removing values must  call  $request->withAttribute()  to replace the instance, per the\nexamples below.",
            "title": "Template Variable Container"
        },
        {
            "location": "/v3/features/helpers/template-variable-container/#when-to-use-the-templatevariablecontainer",
            "text": "If you are calling  addDefaultParam()  only in your factory for creating your\ntemplate renderer instance, or within delegator factories on the renderer,\nyou do not need to make any changes.  If you are using our  Swoole integrations \nor other async application runners, and either currently or plan to set\ntemplate parameters withing pipeline middleware you definitely need to use the\nTemplateVariableContainer in order to prevent state problems.  We actually recommend using this approach even if you are not using Swoole or\nother async application runners, as the approach is more explicit and easily\ntested, and, as noted, does not depend on state within the renderer itself.",
            "title": "When to use the TemplateVariableContainer"
        },
        {
            "location": "/v3/features/helpers/template-variable-container/#usage",
            "text": "As an example, consider the following pipeline:  // In config/pipeline.php\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Handler\\NotFoundHandler;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\Template\\TemplateVariableContainerMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nuse function Zend\\Stratigility\\path;\n\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    $app->pipe(ErrorHandler::class);\n    $app->pipe(ServerUrlMiddleware::class);\n\n        // The following entry is specific to this example:\n    $app->pipe(path(\n        '/api/doc',\n        $factory->lazy(TemplateVariableContainerMiddleware::class)\n    ));\n\n    $app->pipe(RouteMiddleware::class);\n\n    $app->pipe(ImplicitHeadMiddleware::class);\n    $app->pipe(ImplicitOptionsMiddleware::class);\n    $app->pipe(MethodNotAllowedMiddleware::class);\n    $app->pipe(UrlHelperMiddleware::class);\n\n    $app->pipe(DispatchMiddleware::class);\n\n    $app->pipe(NotFoundHandler::class);\n};  Any middleware or handler that responds to a path beginning with  /api/doc  will\nnow have a  Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer  attribute\nthat contains an instance of that class.  Within middleware that responds on that path, you can then do the following:  use Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nclass InjectUserAndRouteVariablesMiddleware implements MiddlewareInterface\n{\n    public function process(\n        ServerRequestInterface $request,\n            RequestHandlerInterface $handler\n    ) : ResponseInterface {\n        $container = $request->getAttribute(\n            TemplateVariableContainer::class,\n            new TemplateVariableContainer()\n        );\n\n        // Since containers are immutable, we re-populate the request:\n        $request = $request->withAttribute(\n            TemplateVariableContainer::class,\n            $container->merge([\n                'user'  => $user,\n                'route' => $request->getAttribute(RouteResult::class),\n            ])\n        );\n\n        return $handler->handle($request);\n    }\n}  In a handler, you will call  mergeForTemplate()  with any local variables you\nwant to use, including those that might override the defaults:  use Psr\\Http\\Message\\ResponseFactoryInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\StreamFactoryInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\Template\\TemplateVariableContainer;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass SomeHandler implements RequestHandlerInterface\n{\n    private $renderer;\n    private $responseFactory;\n    private $streamFactory;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        ResponseFactoryInterface $responseFactory,\n        StreamFactoryInterface $streamFactory\n    ) {\n        $this->renderer        = $renderer;\n        $this->responseFactory = $responseFactory;\n        $this->streamFactory   = $streamFactory;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $value = $request->getParsedBody()['key'] ?? null;\n\n        $content = $this->renderer->render(\n            'some::template',\n            $request\n                ->getAttribute(TemplateVariableContainer::class)\n                ->mergeForTemplate([\n                    'local' => $value,\n                ])\n        );\n\n        $body = $this->streamFactory()->createStream($content);\n\n        return $this->responseFactory()->createResponse(200)->withBody($body);\n    }\n}  The  TemplateVariableContainer  contains the following methods:   count() : int : return a count of variables in the container.  get(string $key) : mixed : return the value associated with  $key ; if not\n  present, a  null  is returned.  has(string $key) : bool : does the container have an entry associated with\n   $key ?  with(string $key, mixed $value) : self : return a new container instance\n  containing the key/value pair provided.  without(string $key) : self : return a new container instance that does not\n  contain the given  $key .  merge(array $values) : self : return a new container that merge the  $values \n  provided with those in the original container. This is useful for setting\n  many values at once.  mergeForTemplate(array $values) : array : merge  $values  with any values in\n  the container, and return the result. This method has no side effects, and\n  should be used when preparing variables to pass to the renderer.",
            "title": "Usage"
        },
        {
            "location": "/v3/features/helpers/template-variable-container/#route-template-variable-middleware",
            "text": "Since zend-expressive-helpers 5.3.0    Zend\\Expressive\\Helper\\Template\\RouteTemplateVariableMiddleware  will inject\nthe currently matched route into the  template variable container .  This middleware relies on the  TemplateVariableContainerMiddleware  preceding\nit in the middleware pipeline, or having the  TemplateVariableContainer \nrequest attribute present; if neither is present, it will generate a new\ninstance.  It then populates the container's  route  parameter using the results of\nretrieving the  Zend\\Expressive\\Router\\RouteResult  request attribute; the value\nwill be either an instance of that class, or  null .  Templates rendered using the container can then access that value, and test for\nrouting success/failure status, pull the matched route name, route, and/or\nparameters from it.  This middleware can replace the  UrlHelperMiddleware  in your\npipeline.",
            "title": "Route template variable middleware"
        },
        {
            "location": "/v3/features/emitters/",
            "text": "Emitters\n\n\nTo simplify the usage of Expressive, we added the \nrun()\n method, which handles\nthe incoming request, and emits a response.\n\n\nThe latter aspect, emitting the response, is the responsibility of an\n\nemitter\n.\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.\n\n\nThe zendframework/zend-httphandlerrunner package defines an \nEmitterInterface\n,\nand three emitter implementations. Two of these,\n\nZend\\HttpHandlerRunner\\Emitter\\SapiEmitter\n and\n\nZend\\HttpHandlerRunner\\Emitter\\SapiStreamEmitter\n, send headers and output\nusing PHP's standard SAPI mechanisms (the \nheader()\n method and the output\nbuffer).\n\n\nWe recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use \nReact\n, the SAPI\nemitter will likely not work for you.\n\n\nTo facilitate alternate emitters, we offer two facilities:\n\n\n\n\nFirst, a \nZend\\HttpHandlerRunner\\RequestHandlerRunner\n instance is composed\n  in the \nApplication\n instance, and you can specify an alternate\n  emitter during instantiation, or via the \nZend\\HttpHandlerRunner\\Emitter\\EmitterInterface\n\n  service when using the container factory.\n\n\nSecond, we provide \nZend\\HttpHandlerRunner\\Emitter\\EmitterStack\n, which allows\n  you to compose multiple emitter strategies; the first to return a boolean true\n  will cause execution of the stack to short-circuit.  The \nRequestHandlerRunner\n\n  service composes an \nEmitterStack\n by default, with an \nSapiEmitter\n composed\n  at the bottom of the stack.",
            "title": "Emitters"
        },
        {
            "location": "/v3/features/emitters/#emitters",
            "text": "To simplify the usage of Expressive, we added the  run()  method, which handles\nthe incoming request, and emits a response.  The latter aspect, emitting the response, is the responsibility of an emitter .\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.  The zendframework/zend-httphandlerrunner package defines an  EmitterInterface ,\nand three emitter implementations. Two of these, Zend\\HttpHandlerRunner\\Emitter\\SapiEmitter  and Zend\\HttpHandlerRunner\\Emitter\\SapiStreamEmitter , send headers and output\nusing PHP's standard SAPI mechanisms (the  header()  method and the output\nbuffer).  We recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use  React , the SAPI\nemitter will likely not work for you.  To facilitate alternate emitters, we offer two facilities:   First, a  Zend\\HttpHandlerRunner\\RequestHandlerRunner  instance is composed\n  in the  Application  instance, and you can specify an alternate\n  emitter during instantiation, or via the  Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface \n  service when using the container factory.  Second, we provide  Zend\\HttpHandlerRunner\\Emitter\\EmitterStack , which allows\n  you to compose multiple emitter strategies; the first to return a boolean true\n  will cause execution of the stack to short-circuit.  The  RequestHandlerRunner \n  service composes an  EmitterStack  by default, with an  SapiEmitter  composed\n  at the bottom of the stack.",
            "title": "Emitters"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/",
            "text": "How can I autowire routes and pipelines?\n\n\nSometimes you may find you'd like to keep route definitions close to the\nhandlers and middleware they will invoke. This is particularly important if you\nwant to re-use a module or library in another project.\n\n\nIn this recipe, we'll demonstrate two mechanisms for doing so. One is a built-in\n\ndelegator factory\n, and the other\nis a custom delegator factory.\n\n\nApplicationConfigInjectionDelegator\n\n\nExpressive ships with the class \nZend\\Expressive\\Container\\ApplicationConfigInjectionDelegator\n,\nwhich can be used as a delegator factory for the \nZend\\Expressive\\Application\n\nclass in order to automate piping of pipeline middleware and routing to request\nhandlers and middleware.\n\n\nThe delegator factory looks for configuration that looks like the following:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [\n            // required:\n            'middleware' => 'Middleware service or pipeline',\n            // optional:\n            'path'  => '/path/to/match', // for path-segregated middleware\n            'priority' => 1,             // integer; to ensure specific order\n        ]\n    ],\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware service or pipeline',\n            'allowed_methods' => ['GET', 'POST', 'PATCH'],\n            'name' => 'route.name',\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        'another.route.name' => [\n            'path' => '/another/path/to/match',\n            'middleware' => 'Middleware service or pipeline',\n            'allowed_methods' => ['GET', 'POST'],\n            'options' => [\n                'more'    => 'router',\n                'options' => 'here',\n            ],\n        ],\n    ],\n];\n\n\n\nThis configuration may be placed at the application level, in a file under\n\nconfig/autoload/\n, or within a module's \nConfigProvider\n class. For details on\nwhat values are accepted, see below.\n\n\nIn order to enable the delegator factory, you will need to define the following\nservice configuration somewhere, either at the application level in a\n\nconfig/autoload/\n file, or within a module-specific \nConfigProvider\n class:\n\n\nreturn [\n    'dependencies' => [\n        'delegators' => [\n            \\Zend\\Expressive\\Application::class => [\n                \\Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator::class,\n            ],\n        ],\n    ],\n];\n\n\n\nPipeline middleware\n\n\nPipeline middleware are each described as an associative array, with the\nfollowing keys:\n\n\n\n\nmiddleware\n (\nrequired\n, string or array): the value should be a middleware\n  service name, or an array of service names (in which case a \nMiddlewarePipe\n\n  will be created and piped).\n\n\npath\n (optional, string): if you wish to path-segregate the middleware, provide a\n  literal path prefix that must be matched in order to dispatch the given\n  middleware.\n\n\npriority\n (optional, integer): The elements in the \nmiddleware_pipeline\n\n  section are piped to the application in the order in which they are discovered\n  \u2014 which could have ramifications if multiple components and/or modules\n  provide pipeline middleware. If you wish to force a certain order, you may use\n  the \npriority\n to do so. Higher value integers are piped first, lower value\n  (including \nnegative\n values), last. If two middleware use the same priority,\n  they will be piped in the order discovered.\n\n\n\n\nRouted middleware\n\n\nRouted middleware are also each described as an associative array, using the\nfollowing keys:\n\n\n\n\npath\n (\nrequired\n, string): the path specification to match; this will be\n  dependent on the router implementation you use.\n\n\nmiddleware\n (\nrequired\n, string or array): the value should be a middleware\n  service name, or an array of service names (in which case a \nMiddlewarePipe\n\n  will be created and piped).\n\n\nallowed_methods\n (optional, array or value of `Zend\\Expressive\\Route\\HTTP_METHOD_ANY):\n  the HTTP methods allowed for the route. If this is omitted, the assumption is\n  any method is allowed.\n\n\nname\n (optional, string): the name of the route, if any; this can be used\n  later to generate a URI based on the route, and must be unique. The name may\n  also be set using a string key in the routes configuration array. If both are\n  set the name assigned in the spec will be used.\n\n\noptions\n (optional, array): any options to provide to the generated route.\n  These might be default values or constraints, depending on the router\n  implementation.\n\n\n\n\nCustom delegator factories\n\n\nAs outlined in the introduction to this recipe, we can also create our own\ncustom delegator factories in order to inject pipeline or routed middleware.\nUnlike the above solution, the solution we will outline here will exercise the\n\nZend\\Expressive\\Application\n API in order to populate it.\n\n\nFirst, we'll create the class \nApp\\Factory\\PipelineAndRoutesDelegator\n, with\nthe following contents:\n\n\n<?php\n\nnamespace App\\Factory;\n\nuse App\\Handler;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Handler\\NotFoundHandler;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass PipelineAndRoutesDelegator\n{\n    public function __invoke(\n        ContainerInterface $container,\n        string $serviceName,\n        callable $callback\n    ) : Application {\n        /** @var $app Application */\n        $app = $callback();\n\n        // Setup pipeline:\n        $app->pipe(ErrorHandler::class);\n        $app->pipe(ServerUrlMiddleware::class);\n        $app->pipe(RouteMiddleware::class);\n        $app->pipe(ImplicitHeadMiddleware::class);\n        $app->pipe(ImplicitOptionsMiddleware::class);\n        $app->pipe(MethodNotAllowedMiddleware::class);\n        $app->pipe(UrlHelperMiddleware::class);\n        $app->pipe(DispatchMiddleware::class);\n        $app->pipe(NotFoundHandler::class);\n\n        // Setup routes:\n        $app->get('/', Handler\\HomePageHandler::class, 'home');\n        $app->get('/api/ping', Handler\\PingHandler::class, 'api.ping');\n\n        return $app;\n    }\n}\n\n\n\n\n\nWhere to put the factory\n\n\nYou will place the factory class in one of the following locations:\n\n\n\n\nsrc/App/Factory/PipelineAndRoutesDelegator.php\n if using the default, flat,\n  application structure.\n\n\nsrc/App/src/Factory/PipelineAndRoutesDelegator.php\n if using the\n  recommended, modular, application structure.\n\n\n\n\n\n\nOnce you've created this, edit the class \nApp\\ConfigProvider\n; in it, we'll\nupdate the \ngetDependencies()\n method to add the delegator factory:\n\n\npublic function getDependencies()\n{\n    return [\n        /* . . . */\n        'delegators' => [\n            \\Zend\\Expressive\\Application::class => [\n                Factory\\PipelineAndRoutesDelegator::class,\n            ],\n        ],\n    ];\n}\n\n\n\n\n\nWhere is the ConfigProvider class?\n\n\nThe \nConfigProvider\n class is in one of the following locations:\n\n\n\n\nsrc/App/ConfigProvider.php\n if using the default, flat, application\n  structure.\n\n\nsrc/App/src/ConfigProvider.php\n using the recommended, modular, application\n  structure.\n\n\n\n\nWhy is an array assigned?\n\n\nAs noted above in the description of delegator factories, since each delegator\nfactory returns an instance, you can nest multiple delegator factories in\norder to shape initialization of a service. As such, they are assigned as an\n\narray\n to the service.\n\n\n\n\nIf you're paying careful attention to this example, it essentially replaces\nboth \nconfig/pipeline.php\n and \nconfig/routes.php\n! If you were to update those\nfiles to remove the default pipeline and routes, you should find that reloading\nyour application returns the exact same results!\n\n\nCaution: pipelines\n\n\nUsing delegator factories is a nice way to keep your routing and pipeline\nconfiguration close to the modules in which they are defined. However, there is\na caveat: you likely should \nnot\n register pipeline middleware in a delegator\nfactory \nother than within your root application module\n.\n\n\nThe reason for this is simple: pipelines are linear, and specific to your\napplication. If one module pipes in middleware, there's no guarantee it will be\npiped before or after your main pipeline, and no way to pipe the middleware at a\nposition in the middle of the pipeline!\n\n\nAs such:\n\n\n\n\nUse a \nconfig/pipeline.php\n file for your pipeline, \nOR\n\n\nEnsure you only define the pipeline in a \nsingle\n delegator factory on your\n  \nApplication\n instance.\n\n\n\n\nCaution: third-party, distributed modules\n\n\nIf you are developing a module to distribute as a package via\n\nComposer\n, \nyou should not autowire any delegator\nfactories that inject pipeline middleware or routes in the \nApplication\n.\n\n\nWhy?\n\n\nAs noted in the above section, pipelines should be created exactly once, at\nthe application level. Registering pipeline middleware within a distributable\npackage will very likely not have the intended consequences.\n\n\nIf you ship with pipeline middleware, we suggest that you:\n\n\n\n\nDocument the middleware, and where you anticipate it being used in the\n  middleware pipeline.\n\n\nDocument how to add the middleware service to dependency configuration, or\n  provide the dependency configuration via your module's \nConfigProvider\n.\n\n\n\n\nWith regards to routes, there are other considerations:\n\n\n\n\n\n\nRoutes defined by the package might conflict with the application, or with\n  other packages used by the application.\n\n\n\n\n\n\nRouting definitions are typically highly specific to the router implementation\n  in use. As an example, each of the currently supported router implementations\n  has a different syntax for placeholders:\n\n\n\n\n/user/:id\n + \"constraints\" configuration to define constraints (zend-router)\n\n\n/user/{id}\n + \"tokens\" configuration to define constraints (Aura.Router)\n\n\n/user/{id:\\d+}\n (FastRoute)\n\n\n\n\n\n\n\n\nYour application may have specific routing considerations or design.\n\n\n\n\n\n\nYou could, of course, detect what router is in use, and provide routing for each\nknown, supported router implementation within your delegator factory. We even\nrecommend doing exactly that. However, we note that such an approach does not\nsolve the other two points above.\n\n\nHowever, we still recommend \nshipping\n a delegator factory that would register\nyour routes, since routes \nare\n often a part of module design; just \ndo not\nautowire\n that delegator factory. This way, end-users who \ncan\n use the\ndefaults do not need to cut-and-paste routing definitions from your\ndocumentation into their own applications; they will instead opt-in to your\ndelegator factory by wiring it into their own configuration.\n\n\nSynopsis\n\n\n\n\nWe recommend using delegator factories for the purpose of autowiring routes,\n  and, with caveats, pipeline middleware:\n\n\nThe pipeline should be created exactly once, so calls to \npipe()\n should\n  occur in exactly \none\n delegator factory.\n\n\n\n\n\n\nDistributable packages should create a delegator factory for \nroutes only\n,\n  but \nshould not\n register the delegator factory by default.",
            "title": "Autowiring routes and pipeline middleware"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#how-can-i-autowire-routes-and-pipelines",
            "text": "Sometimes you may find you'd like to keep route definitions close to the\nhandlers and middleware they will invoke. This is particularly important if you\nwant to re-use a module or library in another project.  In this recipe, we'll demonstrate two mechanisms for doing so. One is a built-in delegator factory , and the other\nis a custom delegator factory.",
            "title": "How can I autowire routes and pipelines?"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#applicationconfiginjectiondelegator",
            "text": "Expressive ships with the class  Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator ,\nwhich can be used as a delegator factory for the  Zend\\Expressive\\Application \nclass in order to automate piping of pipeline middleware and routing to request\nhandlers and middleware.  The delegator factory looks for configuration that looks like the following:  return [\n    'middleware_pipeline' => [\n        [\n            // required:\n            'middleware' => 'Middleware service or pipeline',\n            // optional:\n            'path'  => '/path/to/match', // for path-segregated middleware\n            'priority' => 1,             // integer; to ensure specific order\n        ]\n    ],\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware service or pipeline',\n            'allowed_methods' => ['GET', 'POST', 'PATCH'],\n            'name' => 'route.name',\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        'another.route.name' => [\n            'path' => '/another/path/to/match',\n            'middleware' => 'Middleware service or pipeline',\n            'allowed_methods' => ['GET', 'POST'],\n            'options' => [\n                'more'    => 'router',\n                'options' => 'here',\n            ],\n        ],\n    ],\n];  This configuration may be placed at the application level, in a file under config/autoload/ , or within a module's  ConfigProvider  class. For details on\nwhat values are accepted, see below.  In order to enable the delegator factory, you will need to define the following\nservice configuration somewhere, either at the application level in a config/autoload/  file, or within a module-specific  ConfigProvider  class:  return [\n    'dependencies' => [\n        'delegators' => [\n            \\Zend\\Expressive\\Application::class => [\n                \\Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator::class,\n            ],\n        ],\n    ],\n];",
            "title": "ApplicationConfigInjectionDelegator"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#pipeline-middleware",
            "text": "Pipeline middleware are each described as an associative array, with the\nfollowing keys:   middleware  ( required , string or array): the value should be a middleware\n  service name, or an array of service names (in which case a  MiddlewarePipe \n  will be created and piped).  path  (optional, string): if you wish to path-segregate the middleware, provide a\n  literal path prefix that must be matched in order to dispatch the given\n  middleware.  priority  (optional, integer): The elements in the  middleware_pipeline \n  section are piped to the application in the order in which they are discovered\n  \u2014 which could have ramifications if multiple components and/or modules\n  provide pipeline middleware. If you wish to force a certain order, you may use\n  the  priority  to do so. Higher value integers are piped first, lower value\n  (including  negative  values), last. If two middleware use the same priority,\n  they will be piped in the order discovered.",
            "title": "Pipeline middleware"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#routed-middleware",
            "text": "Routed middleware are also each described as an associative array, using the\nfollowing keys:   path  ( required , string): the path specification to match; this will be\n  dependent on the router implementation you use.  middleware  ( required , string or array): the value should be a middleware\n  service name, or an array of service names (in which case a  MiddlewarePipe \n  will be created and piped).  allowed_methods  (optional, array or value of `Zend\\Expressive\\Route\\HTTP_METHOD_ANY):\n  the HTTP methods allowed for the route. If this is omitted, the assumption is\n  any method is allowed.  name  (optional, string): the name of the route, if any; this can be used\n  later to generate a URI based on the route, and must be unique. The name may\n  also be set using a string key in the routes configuration array. If both are\n  set the name assigned in the spec will be used.  options  (optional, array): any options to provide to the generated route.\n  These might be default values or constraints, depending on the router\n  implementation.",
            "title": "Routed middleware"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#custom-delegator-factories",
            "text": "As outlined in the introduction to this recipe, we can also create our own\ncustom delegator factories in order to inject pipeline or routed middleware.\nUnlike the above solution, the solution we will outline here will exercise the Zend\\Expressive\\Application  API in order to populate it.  First, we'll create the class  App\\Factory\\PipelineAndRoutesDelegator , with\nthe following contents:  <?php\n\nnamespace App\\Factory;\n\nuse App\\Handler;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Handler\\NotFoundHandler;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\MethodNotAllowedMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\RouteMiddleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass PipelineAndRoutesDelegator\n{\n    public function __invoke(\n        ContainerInterface $container,\n        string $serviceName,\n        callable $callback\n    ) : Application {\n        /** @var $app Application */\n        $app = $callback();\n\n        // Setup pipeline:\n        $app->pipe(ErrorHandler::class);\n        $app->pipe(ServerUrlMiddleware::class);\n        $app->pipe(RouteMiddleware::class);\n        $app->pipe(ImplicitHeadMiddleware::class);\n        $app->pipe(ImplicitOptionsMiddleware::class);\n        $app->pipe(MethodNotAllowedMiddleware::class);\n        $app->pipe(UrlHelperMiddleware::class);\n        $app->pipe(DispatchMiddleware::class);\n        $app->pipe(NotFoundHandler::class);\n\n        // Setup routes:\n        $app->get('/', Handler\\HomePageHandler::class, 'home');\n        $app->get('/api/ping', Handler\\PingHandler::class, 'api.ping');\n\n        return $app;\n    }\n}",
            "title": "Custom delegator factories"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#where-to-put-the-factory",
            "text": "You will place the factory class in one of the following locations:   src/App/Factory/PipelineAndRoutesDelegator.php  if using the default, flat,\n  application structure.  src/App/src/Factory/PipelineAndRoutesDelegator.php  if using the\n  recommended, modular, application structure.    Once you've created this, edit the class  App\\ConfigProvider ; in it, we'll\nupdate the  getDependencies()  method to add the delegator factory:  public function getDependencies()\n{\n    return [\n        /* . . . */\n        'delegators' => [\n            \\Zend\\Expressive\\Application::class => [\n                Factory\\PipelineAndRoutesDelegator::class,\n            ],\n        ],\n    ];\n}",
            "title": "Where to put the factory"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#where-is-the-configprovider-class",
            "text": "The  ConfigProvider  class is in one of the following locations:   src/App/ConfigProvider.php  if using the default, flat, application\n  structure.  src/App/src/ConfigProvider.php  using the recommended, modular, application\n  structure.",
            "title": "Where is the ConfigProvider class?"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#why-is-an-array-assigned",
            "text": "As noted above in the description of delegator factories, since each delegator\nfactory returns an instance, you can nest multiple delegator factories in\norder to shape initialization of a service. As such, they are assigned as an array  to the service.   If you're paying careful attention to this example, it essentially replaces\nboth  config/pipeline.php  and  config/routes.php ! If you were to update those\nfiles to remove the default pipeline and routes, you should find that reloading\nyour application returns the exact same results!",
            "title": "Why is an array assigned?"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#caution-pipelines",
            "text": "Using delegator factories is a nice way to keep your routing and pipeline\nconfiguration close to the modules in which they are defined. However, there is\na caveat: you likely should  not  register pipeline middleware in a delegator\nfactory  other than within your root application module .  The reason for this is simple: pipelines are linear, and specific to your\napplication. If one module pipes in middleware, there's no guarantee it will be\npiped before or after your main pipeline, and no way to pipe the middleware at a\nposition in the middle of the pipeline!  As such:   Use a  config/pipeline.php  file for your pipeline,  OR  Ensure you only define the pipeline in a  single  delegator factory on your\n   Application  instance.",
            "title": "Caution: pipelines"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#caution-third-party-distributed-modules",
            "text": "If you are developing a module to distribute as a package via Composer ,  you should not autowire any delegator\nfactories that inject pipeline middleware or routes in the  Application .  Why?  As noted in the above section, pipelines should be created exactly once, at\nthe application level. Registering pipeline middleware within a distributable\npackage will very likely not have the intended consequences.  If you ship with pipeline middleware, we suggest that you:   Document the middleware, and where you anticipate it being used in the\n  middleware pipeline.  Document how to add the middleware service to dependency configuration, or\n  provide the dependency configuration via your module's  ConfigProvider .   With regards to routes, there are other considerations:    Routes defined by the package might conflict with the application, or with\n  other packages used by the application.    Routing definitions are typically highly specific to the router implementation\n  in use. As an example, each of the currently supported router implementations\n  has a different syntax for placeholders:   /user/:id  + \"constraints\" configuration to define constraints (zend-router)  /user/{id}  + \"tokens\" configuration to define constraints (Aura.Router)  /user/{id:\\d+}  (FastRoute)     Your application may have specific routing considerations or design.    You could, of course, detect what router is in use, and provide routing for each\nknown, supported router implementation within your delegator factory. We even\nrecommend doing exactly that. However, we note that such an approach does not\nsolve the other two points above.  However, we still recommend  shipping  a delegator factory that would register\nyour routes, since routes  are  often a part of module design; just  do not\nautowire  that delegator factory. This way, end-users who  can  use the\ndefaults do not need to cut-and-paste routing definitions from your\ndocumentation into their own applications; they will instead opt-in to your\ndelegator factory by wiring it into their own configuration.",
            "title": "Caution: third-party, distributed modules"
        },
        {
            "location": "/v3/cookbook/autowiring-routes-and-pipelines/#synopsis",
            "text": "We recommend using delegator factories for the purpose of autowiring routes,\n  and, with caveats, pipeline middleware:  The pipeline should be created exactly once, so calls to  pipe()  should\n  occur in exactly  one  delegator factory.    Distributable packages should create a delegator factory for  routes only ,\n  but  should not  register the delegator factory by default.",
            "title": "Synopsis"
        },
        {
            "location": "/v3/cookbook/using-a-base-path/",
            "text": "How can I tell my application about a base path?\n\n\nIn some environments, your application may be running in a subdirectory of your\nweb root. For example:\n\n\nvar/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php\n\n\n\nwhere \n/var/www\n is the web root, and your Expressive application is in the\n\nexpressive/\n subdirectory. How can you make your application work correctly in\nthis environment?\n\n\n.htaccess in the application root.\n\n\nIf you are using Apache, your first step is to add an \n.htaccess\n file to your\napplication root, with directives for rewriting to the \npublic/\n directory:\n\n\nRewriteEngine On\nRewriteRule (.*) ./public/$1\n\n\n\n\n\nUsing other web servers\n\n\nIf you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to\n\nour issue tracker\n!\n\n\n\n\nUse middleware to rewrite the path\n\n\nThe above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!\n\n\nTo do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.\n\n\nAt the time of writing, we have two suggestions:\n\n\n\n\nlos/basepath\n provides the basic\n  mechanics of rewriting the URL.\n\n\nmtymek/blast-base-url\n provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path.\n\n\n\n\nlos/basepath\n\n\nTo use \nlos/basepath\n, install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.\n\n\nTo install and copy the configuration:\n\n\n$ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php\n\n\n\nWe recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):\n\n\n$ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php\n\n\n\nThen edit one or both, to change the \nlos_basepath\n settings:\n\n\nreturn [\n    'los_basepath' => '<base path here>',\n    /* ... */\n];\n\n\n\nThe base path should be the portion of the web root leading up to the\n\nindex.php\n of your application. In the above example, this would be\n\n/expressive\n.\n\n\nmtymek/blast-base-url\n\n\nTo use \nmtymek/blast-base-url\n, install it via Composer, and register some\nconfiguration.\n\n\nTo install it:\n\n\n$ composer require mtymek/blast-base-url\n\n\n\nIf you are using \nzend-component-installer\n, you will be prompted to configure this package \nautomatically. If you don't choose to do so, you please refer to \nBlast\\BaseUrl\\ConfigProvider\n \nclass to see how to wire it manually.\n\n\nIf using programmatic pipelines, pipe the middleware early in your pipeline (before routing):\n\n\n$app->pipe(\\Blast\\BaseUrl\\BaseUrlMiddleware::class);\n\n\n\nFor configuration-driven pipelines, add an entry in your\n\nconfig/autoload/middleware-pipeline.global.php\n file:\n\n\n'middleware_pipeline' => [\n    ['middleware' => [Blast\\BaseUrl\\BaseUrlMiddleware::class], 'priority' => 1000],\n    /* ... */\n],\n\n\n\nAt this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.\n\n\nThe primary advantage of \nmtymek/blast-base-url\n is in its additional features:\n\n\n\n\nit injects \nZend\\Expressive\\Helper\\UrlHelper\n with the base path, allowing you\n  to create relative route-based URLs.\n\n\nit provides a new helper, \nBlast\\BaseUrl\\BasePathHelper\n, which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.\n  If you are using zend-view as your templating engine, this view helper will\n  be available out of the box.\n\n\n\n\nUsage of the \nBasePath\n helper is as follows:\n\n\n// where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this->basePath('/icons/favicon.ico');",
            "title": "Using Expressive from a subdirectory"
        },
        {
            "location": "/v3/cookbook/using-a-base-path/#how-can-i-tell-my-application-about-a-base-path",
            "text": "In some environments, your application may be running in a subdirectory of your\nweb root. For example:  var/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php  where  /var/www  is the web root, and your Expressive application is in the expressive/  subdirectory. How can you make your application work correctly in\nthis environment?",
            "title": "How can I tell my application about a base path?"
        },
        {
            "location": "/v3/cookbook/using-a-base-path/#htaccess-in-the-application-root",
            "text": "If you are using Apache, your first step is to add an  .htaccess  file to your\napplication root, with directives for rewriting to the  public/  directory:  RewriteEngine On\nRewriteRule (.*) ./public/$1",
            "title": ".htaccess in the application root."
        },
        {
            "location": "/v3/cookbook/using-a-base-path/#using-other-web-servers",
            "text": "If you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to our issue tracker !",
            "title": "Using other web servers"
        },
        {
            "location": "/v3/cookbook/using-a-base-path/#use-middleware-to-rewrite-the-path",
            "text": "The above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!  To do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.  At the time of writing, we have two suggestions:   los/basepath  provides the basic\n  mechanics of rewriting the URL.  mtymek/blast-base-url  provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path.",
            "title": "Use middleware to rewrite the path"
        },
        {
            "location": "/v3/cookbook/using-a-base-path/#losbasepath",
            "text": "To use  los/basepath , install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.  To install and copy the configuration:  $ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php  We recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):  $ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php  Then edit one or both, to change the  los_basepath  settings:  return [\n    'los_basepath' => '<base path here>',\n    /* ... */\n];  The base path should be the portion of the web root leading up to the index.php  of your application. In the above example, this would be /expressive .",
            "title": "los/basepath"
        },
        {
            "location": "/v3/cookbook/using-a-base-path/#mtymekblast-base-url",
            "text": "To use  mtymek/blast-base-url , install it via Composer, and register some\nconfiguration.  To install it:  $ composer require mtymek/blast-base-url  If you are using  zend-component-installer , you will be prompted to configure this package \nautomatically. If you don't choose to do so, you please refer to  Blast\\BaseUrl\\ConfigProvider  \nclass to see how to wire it manually.  If using programmatic pipelines, pipe the middleware early in your pipeline (before routing):  $app->pipe(\\Blast\\BaseUrl\\BaseUrlMiddleware::class);  For configuration-driven pipelines, add an entry in your config/autoload/middleware-pipeline.global.php  file:  'middleware_pipeline' => [\n    ['middleware' => [Blast\\BaseUrl\\BaseUrlMiddleware::class], 'priority' => 1000],\n    /* ... */\n],  At this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.  The primary advantage of  mtymek/blast-base-url  is in its additional features:   it injects  Zend\\Expressive\\Helper\\UrlHelper  with the base path, allowing you\n  to create relative route-based URLs.  it provides a new helper,  Blast\\BaseUrl\\BasePathHelper , which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.\n  If you are using zend-view as your templating engine, this view helper will\n  be available out of the box.   Usage of the  BasePath  helper is as follows:  // where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this->basePath('/icons/favicon.ico');",
            "title": "mtymek/blast-base-url"
        },
        {
            "location": "/v3/cookbook/common-prefix-for-routes/",
            "text": "How can I prepend a common path to all my routes?\n\n\nYou may have multiple middleware in your project, each providing their own\nfunctionality:\n\n\n$app->pipe(UserMiddleware::class);\n$app->pipe(ProjectMiddleware::class);\n\n\n\nLet's assume the above represents an API.\n\n\nAs your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path \n/api\n.\n\n\nTo accomplish it, we will pipe an \narray\n of middleware \nunder a path\n, \n/api\n.\n\n\nWhen we pipe an array of middleware, internally, \nZend\\Expressive\\Application\n\ncreates a new \nZend\\Stratigility\\MiddlewarePipe\n instance, and pipes each\nmiddleware item to it.\n\n\nWhen we specify a path, the middleware is decorated with a\n\nZend\\Stratigility\\Middleware\\PathMiddlewareDecorator\n. This middleware will\ncompare the request path against the path with which it was created; if they\nmatch, it passes processing on to its middleware.\n\n\nThe following example assumes you are using the structure of\n\nconfig/pipeline.php\n as shipped with the skeleton application.\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\n/**\n * Setup middleware pipeline:\n */\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    // . . .\n    $app->pipe('/api', [\n        UserMiddleware::class,\n        ProjectMiddleware::class,\n    ]);\n    // . . .\n}\n\n\n\nAlternately, you can perform the path decoration manually:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\nuse function Zend\\Stratigility\\path;\n\n/**\n * Setup middleware pipeline:\n */\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    // . . .\n    $app->pipe(path('/api', $factory->pipeline(\n        UserMiddleware::class,\n        ProjectMiddleware::class\n    )));\n    // . . .\n}\n\n\n\n(Calling \n$factory->pipeline()\n is necessary here to ensure that we create the\n\nMiddlewarePipe\n instance, and so that each item in the specified pipeline will\nbe decorated as \nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n.)",
            "title": "Prepending a common path to all routes"
        },
        {
            "location": "/v3/cookbook/common-prefix-for-routes/#how-can-i-prepend-a-common-path-to-all-my-routes",
            "text": "You may have multiple middleware in your project, each providing their own\nfunctionality:  $app->pipe(UserMiddleware::class);\n$app->pipe(ProjectMiddleware::class);  Let's assume the above represents an API.  As your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path  /api .  To accomplish it, we will pipe an  array  of middleware  under a path ,  /api .  When we pipe an array of middleware, internally,  Zend\\Expressive\\Application \ncreates a new  Zend\\Stratigility\\MiddlewarePipe  instance, and pipes each\nmiddleware item to it.  When we specify a path, the middleware is decorated with a Zend\\Stratigility\\Middleware\\PathMiddlewareDecorator . This middleware will\ncompare the request path against the path with which it was created; if they\nmatch, it passes processing on to its middleware.  The following example assumes you are using the structure of config/pipeline.php  as shipped with the skeleton application.  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\n/**\n * Setup middleware pipeline:\n */\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    // . . .\n    $app->pipe('/api', [\n        UserMiddleware::class,\n        ProjectMiddleware::class,\n    ]);\n    // . . .\n}  Alternately, you can perform the path decoration manually:  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\MiddlewareFactory;\n\nuse function Zend\\Stratigility\\path;\n\n/**\n * Setup middleware pipeline:\n */\nreturn function (Application $app, MiddlewareFactory $factory, ContainerInterface $container) : void {\n    // . . .\n    $app->pipe(path('/api', $factory->pipeline(\n        UserMiddleware::class,\n        ProjectMiddleware::class\n    )));\n    // . . .\n}  (Calling  $factory->pipeline()  is necessary here to ensure that we create the MiddlewarePipe  instance, and so that each item in the specified pipeline will\nbe decorated as  Zend\\Expressive\\Middleware\\LazyLoadingMiddleware .)",
            "title": "How can I prepend a common path to all my routes?"
        },
        {
            "location": "/v3/cookbook/passing-data-between-middleware/",
            "text": "Passing Data Between Middleware\n\n\nA frequently asked question is how to pass data between middleware.\n\n\nThe answer is present in every middleware: via request object attributes.\n\n\nMiddleware is always executed in the order in which it is piped to the\napplication. This way you can ensure the request object in middleware receiving\ndata contains an attribute containing data passed by outer middleware.\n\n\nIn the following example, \nPassingDataMiddleware\n prepares data to pass as a\nrequest attribute to nested middleware. We use the fully qualified class name\nfor the attribute name to ensure uniqueness, but you can name it anything you\nwant.\n\n\nnamespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass PassingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Step 1: Do something first\n        $data = [\n            'foo' => 'bar',\n        ];\n\n        // Step 2: Inject data into the request, call the next middleware and wait for the response\n        $response = $handler->handle($request->withAttribute(self::class, $data));\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}\n\n\n\nLater, \nReceivingDataMiddleware\n grabs the data and processes it:\n\n\nnamespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass ReceivingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Step 1: Grab the data from the request and use it\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n\n        // Step 2: Call the next middleware and wait for the response\n        $response = $handler->handle($request);\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}\n\n\n\nOf course, you could also use the data in routed middleware, which is usually at\nthe innermost layer of your application. The \nExampleHandler\n below takes that\ninformation and passes it to the template renderer to create an \nHtmlResponse\n:\n\n\nnamespace App\\Handler;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass ExampleHandler implements RequestHandlerInterface\n{\n    // ...\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        // Step 1: Grab the data from the request\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n        $id = $request->getAttribute('id');\n\n        // Step 2: Do some more stuff\n\n        // Step 3: Return a Response\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'data' => $data,\n                'id' => $id,\n            ])\n        );\n    }\n}",
            "title": "Passing data between middleware"
        },
        {
            "location": "/v3/cookbook/passing-data-between-middleware/#passing-data-between-middleware",
            "text": "A frequently asked question is how to pass data between middleware.  The answer is present in every middleware: via request object attributes.  Middleware is always executed in the order in which it is piped to the\napplication. This way you can ensure the request object in middleware receiving\ndata contains an attribute containing data passed by outer middleware.  In the following example,  PassingDataMiddleware  prepares data to pass as a\nrequest attribute to nested middleware. We use the fully qualified class name\nfor the attribute name to ensure uniqueness, but you can name it anything you\nwant.  namespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass PassingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Step 1: Do something first\n        $data = [\n            'foo' => 'bar',\n        ];\n\n        // Step 2: Inject data into the request, call the next middleware and wait for the response\n        $response = $handler->handle($request->withAttribute(self::class, $data));\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}  Later,  ReceivingDataMiddleware  grabs the data and processes it:  namespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass ReceivingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Step 1: Grab the data from the request and use it\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n\n        // Step 2: Call the next middleware and wait for the response\n        $response = $handler->handle($request);\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}  Of course, you could also use the data in routed middleware, which is usually at\nthe innermost layer of your application. The  ExampleHandler  below takes that\ninformation and passes it to the template renderer to create an  HtmlResponse :  namespace App\\Handler;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass ExampleHandler implements RequestHandlerInterface\n{\n    // ...\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        // Step 1: Grab the data from the request\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n        $id = $request->getAttribute('id');\n\n        // Step 2: Do some more stuff\n\n        // Step 3: Return a Response\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'data' => $data,\n                'id' => $id,\n            ])\n        );\n    }\n}",
            "title": "Passing Data Between Middleware"
        },
        {
            "location": "/v3/cookbook/path-segregated-routing/",
            "text": "Path-segregated routing\n\n\n\n\nSince zend-expressive-router 3.1.0, zend-expressive-helpers 5.1.0, and\n  zend-expressive-hal 1.1.0.\n\n\n\n\nYou may want to develop a self-contained module that you can then drop in\nto an existing application; you may even want to \npath-segregate\n it.\n\n\nIn such cases, you will want to use a different router instance, which has a\nhuge number of ramifications:\n\n\n\n\nYou'll need separate routing middleware.\n\n\nYou'll need a separate \nUrlHelper\n instance, as well as its related middleware,\n  if you are generating URIs.\n\n\nIf you are generating \nHAL\n,\n  you'll need:\n\n\na separate URL generator for HAL that consumes the separate \nUrlHelper\n\n    instance.\n\n\na separate \nLinkGenerator\n for HAL that consumes the separate URL generator.\n\n\na separate \nResourceGenerator\n for HAL that consumes the separate\n    \nLinkGenerator\n.\n\n\n\n\nThese tasks can be accomplished by writing your own factories, but that means a\nlot of extra code, and the potential for the factories to go out-of-sync with\nthe official factories for these services. What should you do?\n\n\nWe provide details on how to accomplish these scenarios elsewhere:\n\n\n\n\nFor modules not using HAL\n\n\nFor modules using HAL",
            "title": "Path-segregated routing"
        },
        {
            "location": "/v3/cookbook/path-segregated-routing/#path-segregated-routing",
            "text": "Since zend-expressive-router 3.1.0, zend-expressive-helpers 5.1.0, and\n  zend-expressive-hal 1.1.0.   You may want to develop a self-contained module that you can then drop in\nto an existing application; you may even want to  path-segregate  it.  In such cases, you will want to use a different router instance, which has a\nhuge number of ramifications:   You'll need separate routing middleware.  You'll need a separate  UrlHelper  instance, as well as its related middleware,\n  if you are generating URIs.  If you are generating  HAL ,\n  you'll need:  a separate URL generator for HAL that consumes the separate  UrlHelper \n    instance.  a separate  LinkGenerator  for HAL that consumes the separate URL generator.  a separate  ResourceGenerator  for HAL that consumes the separate\n     LinkGenerator .   These tasks can be accomplished by writing your own factories, but that means a\nlot of extra code, and the potential for the factories to go out-of-sync with\nthe official factories for these services. What should you do?  We provide details on how to accomplish these scenarios elsewhere:   For modules not using HAL  For modules using HAL",
            "title": "Path-segregated routing"
        },
        {
            "location": "/v3/cookbook/access-common-data-in-templates/",
            "text": "How Can I Access Common Data In Templates?\n\n\nTemplates often need access to common request data, such as request attributes,\nthe current route name, the currently authenticated user, and more. Wrangling\nall of that data in every single handler, however, often leads to code\nduplication, and the possibility of accidently omitting some of that data. How\ncan you make such data available to all templates?\n\n\nThe approach detailed in this recipe involves creating a middleware that calls\non the template renderer's \naddDefaultParam()\n method.\n\n\nFoolowing is an example that injects the current user, the matched route name,\nand all flash messages via a single middleware.\n\n\n// In src/App/Middleware/TemplateDefaultsMiddleware.php (flat structure), or\n// in src/App/src/Middleware/TemplateDefaultsMiddleware.php (modular structure):\n<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Session\\Authentication\\UserInterface;\nuse Zend\\Expressive\\Session\\Flash\\FlashMessagesInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplateDefaultsMiddleware implements MiddlewareInterface\n{\n    /** @var TemplateRendererInterface */\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $templateRenderer)\n    {\n        $this->templateRenderer = $templateRenderer;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Inject the current user, or null if there isn't one.\n        $this->templateRenderer->addDefaultParam(\n            TemplateRendererInterface::TEMPLATE_ALL,\n            'security', // This is named security so it will not interfere with your user admin pages\n            $request->getAttribute(UserInterface::class)\n        );\n\n        // Inject the currently matched route name.\n        $routeResult = $request->getAttribute(RouteResult::class);\n        $this->templateRenderer->addDefaultParam(\n            TemplateRendererInterface::TEMPLATE_ALL,\n            'matchedRouteName',\n            $routeResult ? $routeResult->getMatchedRouteName() : null\n        );\n\n        // Inject all flash messages\n        /** @var FlashMessagesInterface $flashMessages */\n        $flashMessages = $request->getAttribute(FlashMessagesInterface::class);\n        $this->templateRenderer->addDefaultParam(\n            TemplateRendererInterface::TEMPLATE_ALL,\n            'notifications',\n            $flashMessages ? $flashMessages->getFlashes() : []\n        );\n\n        // Inject any other data you always need in all your templates...\n\n        return $handler->handle($request);\n    }\n}\n\n\n\nNext you need to create a factory for this middleware and register it with the\nDI container; \nzend-expressive-tooling\n provides\nfunctionality for doing so:\n\n\n$ ./vendor/bin/expressive factory:create \"App\\Middleware\\TemplateDefaultsMiddleware\"\n\n\n\nOnce the factory is created, you can add this to any route that may generate a\ntemplate:\n\n\n// In config/routes.php:\n$app->get('/some/resource/{id}', [\n    App\\Middleware\\TemplateDefaultsMiddleware::class,\n    SomeResourceHandler::class,\n]);\n\n\n\nAlternately, if you want it to apply to any handler, place it in your\napplication pipeline immediately before the \nDispatchMiddleware\n:\n\n\n// In config/pipeline.php:\n$app->pipe(App\\Middleware\\TemplateDefaultsMiddleware::class);\n$app->pipe(DispatchMiddleware::class);\n\n\n\n\n\nBe aware, however, that if authentication is performed in per-handler\npipelines, you will need to use the first approach to ensure that the\nauthenticated user has been discovered.",
            "title": "Provide Access to Common Data In Templates"
        },
        {
            "location": "/v3/cookbook/access-common-data-in-templates/#how-can-i-access-common-data-in-templates",
            "text": "Templates often need access to common request data, such as request attributes,\nthe current route name, the currently authenticated user, and more. Wrangling\nall of that data in every single handler, however, often leads to code\nduplication, and the possibility of accidently omitting some of that data. How\ncan you make such data available to all templates?  The approach detailed in this recipe involves creating a middleware that calls\non the template renderer's  addDefaultParam()  method.  Foolowing is an example that injects the current user, the matched route name,\nand all flash messages via a single middleware.  // In src/App/Middleware/TemplateDefaultsMiddleware.php (flat structure), or\n// in src/App/src/Middleware/TemplateDefaultsMiddleware.php (modular structure):\n<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Session\\Authentication\\UserInterface;\nuse Zend\\Expressive\\Session\\Flash\\FlashMessagesInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplateDefaultsMiddleware implements MiddlewareInterface\n{\n    /** @var TemplateRendererInterface */\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $templateRenderer)\n    {\n        $this->templateRenderer = $templateRenderer;\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Inject the current user, or null if there isn't one.\n        $this->templateRenderer->addDefaultParam(\n            TemplateRendererInterface::TEMPLATE_ALL,\n            'security', // This is named security so it will not interfere with your user admin pages\n            $request->getAttribute(UserInterface::class)\n        );\n\n        // Inject the currently matched route name.\n        $routeResult = $request->getAttribute(RouteResult::class);\n        $this->templateRenderer->addDefaultParam(\n            TemplateRendererInterface::TEMPLATE_ALL,\n            'matchedRouteName',\n            $routeResult ? $routeResult->getMatchedRouteName() : null\n        );\n\n        // Inject all flash messages\n        /** @var FlashMessagesInterface $flashMessages */\n        $flashMessages = $request->getAttribute(FlashMessagesInterface::class);\n        $this->templateRenderer->addDefaultParam(\n            TemplateRendererInterface::TEMPLATE_ALL,\n            'notifications',\n            $flashMessages ? $flashMessages->getFlashes() : []\n        );\n\n        // Inject any other data you always need in all your templates...\n\n        return $handler->handle($request);\n    }\n}  Next you need to create a factory for this middleware and register it with the\nDI container;  zend-expressive-tooling  provides\nfunctionality for doing so:  $ ./vendor/bin/expressive factory:create \"App\\Middleware\\TemplateDefaultsMiddleware\"  Once the factory is created, you can add this to any route that may generate a\ntemplate:  // In config/routes.php:\n$app->get('/some/resource/{id}', [\n    App\\Middleware\\TemplateDefaultsMiddleware::class,\n    SomeResourceHandler::class,\n]);  Alternately, if you want it to apply to any handler, place it in your\napplication pipeline immediately before the  DispatchMiddleware :  // In config/pipeline.php:\n$app->pipe(App\\Middleware\\TemplateDefaultsMiddleware::class);\n$app->pipe(DispatchMiddleware::class);   Be aware, however, that if authentication is performed in per-handler\npipelines, you will need to use the first approach to ensure that the\nauthenticated user has been discovered.",
            "title": "How Can I Access Common Data In Templates?"
        },
        {
            "location": "/v3/cookbook/route-specific-pipeline/",
            "text": "How can I specify a route-specific middleware pipeline?\n\n\nSometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:\n\n\n\n\ncheck for authentication credentials\n\n\ncheck for authorization for the selected action\n\n\nparse the incoming body\n\n\nvalidate the parsed body parameters\n\n\n\n\nbefore\n you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.\n\n\nYou can accomplish this in one of two ways:\n\n\n\n\nHave your middleware service resolve to a \nMiddlewarePipe\n instance that\n  composes the various middlewares.\n\n\nSpecify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a \nMiddlewarePipe\n.\n\n\n\n\nResolving to a MiddlewarePipe\n\n\nYou can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $factory = $container->get(MiddlewareFactory::class);\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($factory->prepare(AuthenticationMiddleware::class));\n        $pipeline->pipe($factory->prepare(AuthorizationMiddleware::class));\n        $pipeline->pipe($factory->prepare(BodyParsingMiddleware::class));\n        $pipeline->pipe($factory->prepare(ValidationMiddleware::class));\n\n        // This is the actual handler you're routing to:\n        $pipeline->pipe($factory->prepare(ApiResource::class));\n\n        return $pipeline;\n    }\n}\n\n\n\n\n\n$factory->prepare()\n is used here to allow lazy-loading each middleware and\nhandler. If we instead pulled each class from the container directly, each would\nbe created, even if it was not ultimately executed.\n\n\n\n\nThis gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.\n\n\nOne alternative when using zend-servicemanager is to use a \ndelegator factory\n.\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface\n{\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) : MiddlewarePipe {\n        $factory = $container->get(MiddlewareFactory::class);\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($factory->prepare(AuthenticationMiddleware::class));\n        $pipeline->pipe($factory->prepare(AuthorizationMiddleware::class));\n        $pipeline->pipe($factory->prepare(BodyParsingMiddleware::class));\n        $pipeline->pipe($factory->prepare(ValidationMiddleware::class));\n\n        // This is the actual handler you're routing to.\n        $pipeline->pipe($callback());\n\n        return $pipeline;\n    }\n}\n\n\n\nWhen configuring the container, you'd do something like the following:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            AuthenticationMiddleware::class => '...',\n            AuthorizationMiddleware::class => '...',\n            BodyParsingMiddleware::class => '...',\n            ValidationMiddleware::class => '...',\n            ApiResource::class => '...',\n        ],\n        'delegators' => [\n            ApiResource::class => [\n                ApiResourcePipelineDelegatorFactory::class,\n            ],\n        ],\n    ],\n];\n\n\n\nThis approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.\n\n\nMiddleware Arrays\n\n\nIf you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares when routing.\n\n\n$app->route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    AuthenticationMiddleware::class,\n    AuthorizationMiddleware::class,\n    BodyParsingMiddleware::class,\n    ValidationMiddleware::class,\n    ApiResource::class,\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');\n\n\n\nWhen either of these approaches are used, the individual middleware listed\n\nMUST\n be one of the following:\n\n\n\n\nan instance of \nPsr\\Http\\Middleware\\MiddlewareInterface\n;\n\n\na callable middleware (will be decorated using \nZend\\Stratigility\\middleware()\n);\n\n\na service name of middleware available in the container;\n\n\na fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.\n\n\n\n\nThis approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.",
            "title": "Route-specific middleware pipelines"
        },
        {
            "location": "/v3/cookbook/route-specific-pipeline/#how-can-i-specify-a-route-specific-middleware-pipeline",
            "text": "Sometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:   check for authentication credentials  check for authorization for the selected action  parse the incoming body  validate the parsed body parameters   before  you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.  You can accomplish this in one of two ways:   Have your middleware service resolve to a  MiddlewarePipe  instance that\n  composes the various middlewares.  Specify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a  MiddlewarePipe .",
            "title": "How can I specify a route-specific middleware pipeline?"
        },
        {
            "location": "/v3/cookbook/route-specific-pipeline/#resolving-to-a-middlewarepipe",
            "text": "You can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $factory = $container->get(MiddlewareFactory::class);\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($factory->prepare(AuthenticationMiddleware::class));\n        $pipeline->pipe($factory->prepare(AuthorizationMiddleware::class));\n        $pipeline->pipe($factory->prepare(BodyParsingMiddleware::class));\n        $pipeline->pipe($factory->prepare(ValidationMiddleware::class));\n\n        // This is the actual handler you're routing to:\n        $pipeline->pipe($factory->prepare(ApiResource::class));\n\n        return $pipeline;\n    }\n}   $factory->prepare()  is used here to allow lazy-loading each middleware and\nhandler. If we instead pulled each class from the container directly, each would\nbe created, even if it was not ultimately executed.   This gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.  One alternative when using zend-servicemanager is to use a  delegator factory .\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:  use Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\MiddlewareFactory;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface\n{\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) : MiddlewarePipe {\n        $factory = $container->get(MiddlewareFactory::class);\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($factory->prepare(AuthenticationMiddleware::class));\n        $pipeline->pipe($factory->prepare(AuthorizationMiddleware::class));\n        $pipeline->pipe($factory->prepare(BodyParsingMiddleware::class));\n        $pipeline->pipe($factory->prepare(ValidationMiddleware::class));\n\n        // This is the actual handler you're routing to.\n        $pipeline->pipe($callback());\n\n        return $pipeline;\n    }\n}  When configuring the container, you'd do something like the following:  return [\n    'dependencies' => [\n        'factories' => [\n            AuthenticationMiddleware::class => '...',\n            AuthorizationMiddleware::class => '...',\n            BodyParsingMiddleware::class => '...',\n            ValidationMiddleware::class => '...',\n            ApiResource::class => '...',\n        ],\n        'delegators' => [\n            ApiResource::class => [\n                ApiResourcePipelineDelegatorFactory::class,\n            ],\n        ],\n    ],\n];  This approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.",
            "title": "Resolving to a MiddlewarePipe"
        },
        {
            "location": "/v3/cookbook/route-specific-pipeline/#middleware-arrays",
            "text": "If you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares when routing.  $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    AuthenticationMiddleware::class,\n    AuthorizationMiddleware::class,\n    BodyParsingMiddleware::class,\n    ValidationMiddleware::class,\n    ApiResource::class,\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');  When either of these approaches are used, the individual middleware listed MUST  be one of the following:   an instance of  Psr\\Http\\Middleware\\MiddlewareInterface ;  a callable middleware (will be decorated using  Zend\\Stratigility\\middleware() );  a service name of middleware available in the container;  a fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.   This approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.",
            "title": "Middleware Arrays"
        },
        {
            "location": "/v3/cookbook/host-segregated-middleware/",
            "text": "How does one segregate middleware by host?\n\n\nIf your application is being re-used to respond to multiple host domains, how\ncan you segregate middleware to work only in reponse to a specific host request?\n\n\nAs an example, perhaps you have an \"admin\" area of your application you only\nwant to expose via the host name \"admin.example.org\"; how can you do this?\n\n\nThe host function\n\n\nStratigility\n provides a\nfunction, \nZend\\Stratigility\\host()\n that can be used to decorate middleware in\na \nZend\\Stratigility\\Middleware\\HostMiddlewareDecorator\n instance. These expect\nthe string name of a host, and the middleware that should only trigger when that\nhost is matched in the request.\n\n\nAs a simple example:\n\n\n// in config/pipeline.php:\nuse function Zend\\Stratigility\\host;\n\n$app->pipe(host('admin.example.org', $adminMiddleware));\n\n\n\nHowever, you'll note that the above uses an already instantiated middleware\ninstance; how can you lazy-load a named service instead?\n\n\nLazy-loading host-segregated middleware\n\n\nThe \nconfig/pipeline.php\n file defines and returns a callable that accepts three\narguments:\n\n\n\n\na \nZend\\Expressive\\Application $app\n instance\n\n\na \nZend\\Expressive\\MiddlewareFactory $factory\n instance\n\n\na \nPsr\\Container\\ContainerInterface $container\n instance\n\n\n\n\nWe can use the second of these to help us. We will use the \nlazy()\n method to\nspecify a middleware service name to lazy-load:\n\n\n$app->pipe(host('admin.example.org', $factory->lazy(AdminMiddleware::class)));\n\n\n\nWhat about specifying a pipeline of middleware? For that, we can use the\n\npipeline()\n method of the factory:\n\n\n$app->pipe(host('admin.example.org', $factory->pipeline(\n    SessionMiddleware::class,\n    AuthenticationMiddleware::class,\n    AuthorizationMiddleware::class,\n    AdminHandler::class\n)));\n\n\n\nAlternately, either of the above examples could use the \nprepare()\n method:\n\n\n// lazy example:\n$app->pipe(host('admin.example.org', $factory->prepare(AdminMiddleware::class)));\n\n// pipeline example:\n$app->pipe(host('admin.example.org', $factory->prepare([\n    SessionMiddleware::class,\n    AuthenticationMiddleware::class,\n    AuthorizationMiddleware::class,\n    AdminHandler::class,\n])));\n\n\n\n\n\nFor more information on the \nMiddlewareFactory\n, \nread its documentation\n.",
            "title": "Segregating middleware by host"
        },
        {
            "location": "/v3/cookbook/host-segregated-middleware/#how-does-one-segregate-middleware-by-host",
            "text": "If your application is being re-used to respond to multiple host domains, how\ncan you segregate middleware to work only in reponse to a specific host request?  As an example, perhaps you have an \"admin\" area of your application you only\nwant to expose via the host name \"admin.example.org\"; how can you do this?",
            "title": "How does one segregate middleware by host?"
        },
        {
            "location": "/v3/cookbook/host-segregated-middleware/#the-host-function",
            "text": "Stratigility  provides a\nfunction,  Zend\\Stratigility\\host()  that can be used to decorate middleware in\na  Zend\\Stratigility\\Middleware\\HostMiddlewareDecorator  instance. These expect\nthe string name of a host, and the middleware that should only trigger when that\nhost is matched in the request.  As a simple example:  // in config/pipeline.php:\nuse function Zend\\Stratigility\\host;\n\n$app->pipe(host('admin.example.org', $adminMiddleware));  However, you'll note that the above uses an already instantiated middleware\ninstance; how can you lazy-load a named service instead?",
            "title": "The host function"
        },
        {
            "location": "/v3/cookbook/host-segregated-middleware/#lazy-loading-host-segregated-middleware",
            "text": "The  config/pipeline.php  file defines and returns a callable that accepts three\narguments:   a  Zend\\Expressive\\Application $app  instance  a  Zend\\Expressive\\MiddlewareFactory $factory  instance  a  Psr\\Container\\ContainerInterface $container  instance   We can use the second of these to help us. We will use the  lazy()  method to\nspecify a middleware service name to lazy-load:  $app->pipe(host('admin.example.org', $factory->lazy(AdminMiddleware::class)));  What about specifying a pipeline of middleware? For that, we can use the pipeline()  method of the factory:  $app->pipe(host('admin.example.org', $factory->pipeline(\n    SessionMiddleware::class,\n    AuthenticationMiddleware::class,\n    AuthorizationMiddleware::class,\n    AdminHandler::class\n)));  Alternately, either of the above examples could use the  prepare()  method:  // lazy example:\n$app->pipe(host('admin.example.org', $factory->prepare(AdminMiddleware::class)));\n\n// pipeline example:\n$app->pipe(host('admin.example.org', $factory->prepare([\n    SessionMiddleware::class,\n    AuthenticationMiddleware::class,\n    AuthorizationMiddleware::class,\n    AdminHandler::class,\n])));   For more information on the  MiddlewareFactory ,  read its documentation .",
            "title": "Lazy-loading host-segregated middleware"
        },
        {
            "location": "/v3/cookbook/double-pass-middleware/",
            "text": "Using Double-Pass Middleware\n\n\nExpressive uses \nPSR-15\n middleware and\nrequest handlers exclusively as of version 3.\n\n\nIn previous releases, however, we supported \"double-pass\" middleware, and a\nnumber of third-party packages provided double-pass middleware. How can you use\nthis middleware with Expressive 3?\n\n\n\n\nWhat is Double-Pass Middleware?\n\n\nDouble pass middleware receives both the request and a response in addition to\nthe handler, and passes both the request and response to the handler when\ninvoking it:\n\n\nfunction (ServerRequestInterface $request, ResponseInterface $response, callable $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Test', time());\n}\n\n\n\nIt is termed \"double pass\" because you pass \nboth\n the request \nand\n response when\ndelegating to the next layer.\n\n\n\n\ndoublePassMiddleware function\n\n\nzend-stratigility v2.2 and v3.0 ship a utility function,\n\nZend\\Stratigility\\doublePassMiddleware()\n, that will decorate a callable\ndouble-pass middleware using a \nZend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator\n\ninstance; this latter is a PSR-15 impelementation, and can thus be used in your\nmiddleware pipelines.\n\n\nThe function (and class) also expects a \nPSR-7\n\n\nResponseInterface\n instance as a second argument; this is then passed as the\n\n$response\n argument to the double-pass middleware. The following examples\ndemostrate both piping and routing to double pass middleware using this\ntechnique, and using zend-diactoros to provide the response instance.\n\n\nuse Zend\\Diactoros\\Response;\n\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\n$app->pipe(doublePassMiddleware(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n}, new Response())); // <-- note the response\n\n$app->get('/api/ping', doublePassMiddleware(function ($request, $response, $next) {\n    return new Response\\JsonResponse([\n        'ack' => time(),\n    ]);\n}, new Response())); // <-- note the response\n\n\n\nDouble-Pass Middleware Services\n\n\nWhat if you're piping or routing to a \nservice\n \u2014 for instance, a class\nprovided by a third-party implementation?\n\n\nIn this case, you have one of two options:\n\n\n\n\nDecorate the middleware before returning it from the factory that creates it.\n\n\nUse a \ndelegator factory\n to\n  decorate the middleware.\n\n\n\n\nDecorating via factory\n\n\nIf you have control of the factory that creates the double-pass middleware you\nwill be using in your application, you can use the strategy outlined above to\ndecorate your middleware before returning it, with one minor change: you can\npull a response factory from the container as well.\n\n\nTo demonstrate:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\nclass SomeDoublePassMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        // Create the middleware instance somehow. This example\n        // assumes it is in `$middleware` when done.\n\n        return doublePassMiddleware(\n            $middleware,\n            ($container->get(ResponseInterface::class))()\n        );\n    }\n}\n\n\n\nThat last line may look a little strange.\n\n\nThe \nPsr\\Http\\Response\\ResponseInterface\n service returns a callable \nfactory\n\nfor producing response instances, and not a response instance itself. As such,\nwe pull it, and then invoke it to produce the response instance for our\ndouble-pass middleware.\n\n\nThis approach will work, but it means code duplication everywhere you have\ndouble-pass middleware. Let's look at the delegator factory solution.\n\n\nDecorating via delegator factory\n\n\nDelegator factories can be re-used for multiple services. In our case, we'll\nre-use it to decorate double-pass middleware.\n\n\nThe delegator factory would look like this:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\nclass DoublePassMiddlewareDelegator\n{\n    public function __invoke(Container $container, string $serviceName, callable $callback)\n    {\n        return doublePassMiddleware(\n            $callback(),\n            ($container->get(ResponseInterface::class))()\n        );\n    }\n}\n\n\n\nThis looks similar to our previous solution, but is self-contained; we rely on\nthe \n$callback\n argument to produce the middleware we want to decorate.\n\n\nThen, for each service we have that represents double-pass middleware, we can\nprovide configuration like the following:\n\n\nreturn [\n    'dependencies' => [\n        'delegators' => [\n            SomeDoublePassMiddleware::class => [\n                DoublePassMiddlewareDelegator::class,\n            ],\n        ],\n    ],\n];\n\n\n\nThis approach has a couple of benefits:\n\n\n\n\nWe do not need to change existing factories.\n\n\nWe do not need to extend factories from third-party services.\n\n\nWe can see explicitly in our configuration all services we consume that are\n  double-pass middleware. This will help us identify projects we want to\n  contribute PSR-15 patches to, or potentially migrate away from, or middleware\n  of our own we need to refactor.\n\n\n\n\nExtending the MiddlewareContainer\n\n\nAnother possibility is to extend \nZend\\Expressive\\MiddlewareContainer\n to add\nawareness of double-pass middleware, and have it auto-decorate them for you.\n\n\nA contributor has created such a library:\n\n\n\n\nhttps://github.com/Moln/expressive-callable-middleware-compat\n\n\n\n\nYou can install it using \ncomposer require moln/expressive-callable-middleware-compat\n.\nOnce installed, add its \nMoln\\ExpressiveCallableCompat\\ConfigProvider\n as an\nentry in your \nconfig/config.php\n \nafter\n the \nZend\\Expressive\\ConfigProvider\n\nentry. This last point is particularly important: providers are merged in the order\npresented, with later entries having precedence; you need to ensure the new\npackage overrides the \nMiddlewareContainer\n service provided by zend-expressive!\n\n\nWhen you use this approach, it will automatically detect double-pass middleware\nand decorate it for you.\n\n\nThe main drawback with such an approach is that it will not help you identify\ndouble-pass middleware in your system.",
            "title": "Using double-pass middleware"
        },
        {
            "location": "/v3/cookbook/double-pass-middleware/#using-double-pass-middleware",
            "text": "Expressive uses  PSR-15  middleware and\nrequest handlers exclusively as of version 3.  In previous releases, however, we supported \"double-pass\" middleware, and a\nnumber of third-party packages provided double-pass middleware. How can you use\nthis middleware with Expressive 3?",
            "title": "Using Double-Pass Middleware"
        },
        {
            "location": "/v3/cookbook/double-pass-middleware/#what-is-double-pass-middleware",
            "text": "Double pass middleware receives both the request and a response in addition to\nthe handler, and passes both the request and response to the handler when\ninvoking it:  function (ServerRequestInterface $request, ResponseInterface $response, callable $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Test', time());\n}  It is termed \"double pass\" because you pass  both  the request  and  response when\ndelegating to the next layer.",
            "title": "What is Double-Pass Middleware?"
        },
        {
            "location": "/v3/cookbook/double-pass-middleware/#doublepassmiddleware-function",
            "text": "zend-stratigility v2.2 and v3.0 ship a utility function, Zend\\Stratigility\\doublePassMiddleware() , that will decorate a callable\ndouble-pass middleware using a  Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator \ninstance; this latter is a PSR-15 impelementation, and can thus be used in your\nmiddleware pipelines.  The function (and class) also expects a  PSR-7  ResponseInterface  instance as a second argument; this is then passed as the $response  argument to the double-pass middleware. The following examples\ndemostrate both piping and routing to double pass middleware using this\ntechnique, and using zend-diactoros to provide the response instance.  use Zend\\Diactoros\\Response;\n\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\n$app->pipe(doublePassMiddleware(function ($request, $response, $next) {\n    $response = $next($request, $response);\n    return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n}, new Response())); // <-- note the response\n\n$app->get('/api/ping', doublePassMiddleware(function ($request, $response, $next) {\n    return new Response\\JsonResponse([\n        'ack' => time(),\n    ]);\n}, new Response())); // <-- note the response",
            "title": "doublePassMiddleware function"
        },
        {
            "location": "/v3/cookbook/double-pass-middleware/#double-pass-middleware-services",
            "text": "What if you're piping or routing to a  service  \u2014 for instance, a class\nprovided by a third-party implementation?  In this case, you have one of two options:   Decorate the middleware before returning it from the factory that creates it.  Use a  delegator factory  to\n  decorate the middleware.",
            "title": "Double-Pass Middleware Services"
        },
        {
            "location": "/v3/cookbook/double-pass-middleware/#decorating-via-factory",
            "text": "If you have control of the factory that creates the double-pass middleware you\nwill be using in your application, you can use the strategy outlined above to\ndecorate your middleware before returning it, with one minor change: you can\npull a response factory from the container as well.  To demonstrate:  use Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\nclass SomeDoublePassMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        // Create the middleware instance somehow. This example\n        // assumes it is in `$middleware` when done.\n\n        return doublePassMiddleware(\n            $middleware,\n            ($container->get(ResponseInterface::class))()\n        );\n    }\n}  That last line may look a little strange.  The  Psr\\Http\\Response\\ResponseInterface  service returns a callable  factory \nfor producing response instances, and not a response instance itself. As such,\nwe pull it, and then invoke it to produce the response instance for our\ndouble-pass middleware.  This approach will work, but it means code duplication everywhere you have\ndouble-pass middleware. Let's look at the delegator factory solution.",
            "title": "Decorating via factory"
        },
        {
            "location": "/v3/cookbook/double-pass-middleware/#decorating-via-delegator-factory",
            "text": "Delegator factories can be re-used for multiple services. In our case, we'll\nre-use it to decorate double-pass middleware.  The delegator factory would look like this:  use Psr\\Container\\ContainerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\nclass DoublePassMiddlewareDelegator\n{\n    public function __invoke(Container $container, string $serviceName, callable $callback)\n    {\n        return doublePassMiddleware(\n            $callback(),\n            ($container->get(ResponseInterface::class))()\n        );\n    }\n}  This looks similar to our previous solution, but is self-contained; we rely on\nthe  $callback  argument to produce the middleware we want to decorate.  Then, for each service we have that represents double-pass middleware, we can\nprovide configuration like the following:  return [\n    'dependencies' => [\n        'delegators' => [\n            SomeDoublePassMiddleware::class => [\n                DoublePassMiddlewareDelegator::class,\n            ],\n        ],\n    ],\n];  This approach has a couple of benefits:   We do not need to change existing factories.  We do not need to extend factories from third-party services.  We can see explicitly in our configuration all services we consume that are\n  double-pass middleware. This will help us identify projects we want to\n  contribute PSR-15 patches to, or potentially migrate away from, or middleware\n  of our own we need to refactor.",
            "title": "Decorating via delegator factory"
        },
        {
            "location": "/v3/cookbook/double-pass-middleware/#extending-the-middlewarecontainer",
            "text": "Another possibility is to extend  Zend\\Expressive\\MiddlewareContainer  to add\nawareness of double-pass middleware, and have it auto-decorate them for you.  A contributor has created such a library:   https://github.com/Moln/expressive-callable-middleware-compat   You can install it using  composer require moln/expressive-callable-middleware-compat .\nOnce installed, add its  Moln\\ExpressiveCallableCompat\\ConfigProvider  as an\nentry in your  config/config.php   after  the  Zend\\Expressive\\ConfigProvider \nentry. This last point is particularly important: providers are merged in the order\npresented, with later entries having precedence; you need to ensure the new\npackage overrides the  MiddlewareContainer  service provided by zend-expressive!  When you use this approach, it will automatically detect double-pass middleware\nand decorate it for you.  The main drawback with such an approach is that it will not help you identify\ndouble-pass middleware in your system.",
            "title": "Extending the MiddlewareContainer"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/",
            "text": "How can I setup the locale depending on a routing parameter?\n\n\nLocalized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.\n\n\n\n\nRouting parameters\n\n\nUsing the approach in this chapter requires that you add a \n/:locale\n (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non \nsetting the locale without routing parameters\n.\n\n\n\n\nSetting up the route\n\n\nIf you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.\n\n\nIn the following examples, we use the \nlocale\n parameter, which should consist\nof two lowercase alphabetical characters.\n\n\nDependency configuration\n\n\nThe examples assume the following middleware dependency configuration:\n\n\nuse App\\Handler;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Handler\\HomePageHandler::class    => Handler\\HomePageHandlerFactory::class,\n            Handler\\ContactPageHandler::class => Handler\\ContactPageFactory::class,\n        ],\n    ],\n];\n\n\n\nProgrammatic routes\n\n\nThe following describes routing configuration for use when using a\nprogrammatic application.\n\n\nuse App\\Handler\\ContactPageHandler;\nuse App\\Handler\\HomePageHandler;\n\n$localeOptions = ['locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)'];\n\n$app->get('/:locale', HomePageHandler::class, 'home')\n    ->setOptions($localeOptions);\n$app->get('/:locale/contact', ContactPageHandler::class, 'contact')\n    ->setOptions($localeOptions);\n\n\n\n\n\nNote: Routing may differ based on router\n\n\nThe routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.\n\n\nFor Aura.Router, the 'home' route as listed above would read:\n\n\n$app->get('/{locale}', HomePageHandler::class, 'home')\n    ->setOptions([\n        'tokens' => [\n            'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n        ],\n    ]);\n\n\n\nFor FastRoute:\n\n\n$app->get(\n    '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    HomePageHandler::class,\n    'home'\n);\n\n\n\nAs such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.\n\n\n\n\nCreate a route result middleware class for localization\n\n\nTo make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.\n\n\nSuch a \nLocalizationMiddleware\n class could look similar to this:\n\n\n<?php\nnamespace App\\I18n;\n\nuse Locale;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass LocalizationMiddleware implements MiddlewareInterface\n{\n    public const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request->getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $handler->handle($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale));\n    }\n}\n\n\n\n\n\nLocale::setDefault is unsafe\n\n\nDo not use \nLocale::setDefault($locale)\n to set a global static locale.\nPSR-15 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.\n\n\nUse a request parameter as detailed above instead, as the request is created\nspecific to each process.\n\n\n\n\nRegister this new middleware in either \nconfig/autoload/middleware-pipeline.global.php\n\nor \nconfig/autoload/dependencies.global.php\n:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            LocalizationMiddleware::class => LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nPipe it immediately after your routing middleware:\n\n\nuse App\\I18n\\LocalizationMiddleware;\n\n/* ... */\n$app->pipe(RouteMiddleware::class);\n$app->pipe(LocalizationMiddleware::class);\n/* ... */",
            "title": "Setting a locale based on a routing parameter"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/#how-can-i-setup-the-locale-depending-on-a-routing-parameter",
            "text": "Localized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.",
            "title": "How can I setup the locale depending on a routing parameter?"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/#routing-parameters",
            "text": "Using the approach in this chapter requires that you add a  /:locale  (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non  setting the locale without routing parameters .",
            "title": "Routing parameters"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/#setting-up-the-route",
            "text": "If you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.  In the following examples, we use the  locale  parameter, which should consist\nof two lowercase alphabetical characters.",
            "title": "Setting up the route"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/#dependency-configuration",
            "text": "The examples assume the following middleware dependency configuration:  use App\\Handler;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Handler\\HomePageHandler::class    => Handler\\HomePageHandlerFactory::class,\n            Handler\\ContactPageHandler::class => Handler\\ContactPageFactory::class,\n        ],\n    ],\n];",
            "title": "Dependency configuration"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/#programmatic-routes",
            "text": "The following describes routing configuration for use when using a\nprogrammatic application.  use App\\Handler\\ContactPageHandler;\nuse App\\Handler\\HomePageHandler;\n\n$localeOptions = ['locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)'];\n\n$app->get('/:locale', HomePageHandler::class, 'home')\n    ->setOptions($localeOptions);\n$app->get('/:locale/contact', ContactPageHandler::class, 'contact')\n    ->setOptions($localeOptions);",
            "title": "Programmatic routes"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/#note-routing-may-differ-based-on-router",
            "text": "The routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.  For Aura.Router, the 'home' route as listed above would read:  $app->get('/{locale}', HomePageHandler::class, 'home')\n    ->setOptions([\n        'tokens' => [\n            'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n        ],\n    ]);  For FastRoute:  $app->get(\n    '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    HomePageHandler::class,\n    'home'\n);  As such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.",
            "title": "Note: Routing may differ based on router"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/#create-a-route-result-middleware-class-for-localization",
            "text": "To make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.  Such a  LocalizationMiddleware  class could look similar to this:  <?php\nnamespace App\\I18n;\n\nuse Locale;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass LocalizationMiddleware implements MiddlewareInterface\n{\n    public const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request->getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $handler->handle($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale));\n    }\n}",
            "title": "Create a route result middleware class for localization"
        },
        {
            "location": "/v3/cookbook/setting-locale-depending-routing-parameter/#localesetdefault-is-unsafe",
            "text": "Do not use  Locale::setDefault($locale)  to set a global static locale.\nPSR-15 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.  Use a request parameter as detailed above instead, as the request is created\nspecific to each process.   Register this new middleware in either  config/autoload/middleware-pipeline.global.php \nor  config/autoload/dependencies.global.php :  return [\n    'dependencies' => [\n        'invokables' => [\n            LocalizationMiddleware::class => LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Pipe it immediately after your routing middleware:  use App\\I18n\\LocalizationMiddleware;\n\n/* ... */\n$app->pipe(RouteMiddleware::class);\n$app->pipe(LocalizationMiddleware::class);\n/* ... */",
            "title": "Locale::setDefault is unsafe"
        },
        {
            "location": "/v3/cookbook/setting-locale-without-routing-parameter/",
            "text": "How can I setup the locale without routing parameters?\n\n\nLocalized web applications often set the locale (and therefore the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.\n\n\n\n\nDistinguishing between routes that require localization\n\n\nIf your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the\n\n\"Setting a locale based on a routing parameter\" recipe\n.\n\n\n\n\nSetup a middleware to extract the locale from the URI\n\n\nFirst, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If it doesn't find one, it sets a default.\n\n\nIf it does find one, it uses the value to setup the locale. It also:\n\n\n\n\namends the request with a truncated path (removing the locale segment).\n\n\nadds the locale segment as the base path of the \nUrlHelper\n.\n\n\n\n\n<?php\nnamespace App\\I18n;\n\nuse Locale;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    private $defaultLocale;\n    private $fallbackLocale = 'en_US';\n\n    const REGEX_LOCALE = '#^/(?P<locale>[a-z]{2,3}|[a-z]{2}[-_][a-zA-Z]{2})(?:/|$)#';\n\n    public function __construct(UrlHelper $helper, string $defaultLocale = null)\n    {\n        $this->helper = $helper;\n        if ($defaultLocale) {\n            $this->defaultLocale = $defaultLocale;\n        }\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $uri = $request->getUri();\n\n        $path = $uri->getPath();\n\n        if (! preg_match(self::REGEX_LOCALE, $path, $matches)) {\n            Locale::setDefault($this->defaultLocale ?: $this->fallbackLocale);\n            return $handler->handle($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        $path = substr($path, strlen($locale) + 1);\n\n        return $handler->handle($request->withUri(\n            $uri->withPath($path ?: '/')\n        ));\n    }\n}\n\n\n\nThen you will need a factory for the \nSetLocaleMiddleware\n to inject the\n\nUrlHelper\n instance.\n\n\n<?php\nnamespace App\\I18n;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\n/**\n * Configuration for setting a default locale should look like the following:\n *\n * <code>\n * 'i18n' => [\n *     'default_locale' => 'de_DE',\n * ]\n * </code>\n */\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $config = $container->has('config') ? $container->get('config') : [];\n\n        return new SetLocaleMiddleware(\n            $container->get(UrlHelper::class),\n            $config['i18n']['default_locale'] ?? null\n        );\n    }\n}\n\n\n\nNext, map the middleware to its factory in either\n\n/config/autoload/dependencies.global.php\n or\n\n/config/autoload/middleware-pipeline.global.php\n:\n\n\nuse App\\I18n\\SetLocaleMiddleware;\nuse App\\I18n\\SetLocaleMiddlewareFactory;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nFinally, you will need to configure your middleware pipeline to ensure this\nmiddleware is executed on every request.\n\n\nPipe the middleware early in your application, before routing is performed:\n\n\nuse App\\I18n\\SetLocaleMiddleware;\n\n/* ... */\n$app->pipe(SetLocaleMiddleware::class);\n/* ... */\n$app->pipe(RouteMiddleware::class);\n/* ... */\n$app->pipe(DispatchMiddleware::class);\n/* ... */\n\n\n\nUrl generation in the view\n\n\nSince the \nUrlHelper\n has the locale set as a base path, you don't need\nto worry about generating URLs within your view. Just use the helper to\ngenerate a URL and it will do the rest.\n\n\n<?= $this->url('your-route') ?>\n\n\n\n\n\nHelpers differ between template renderers\n\n\nThe above example is specific to zend-view; syntax will differ for\nTwig and Plates.\n\n\n\n\nRedirecting within your request handlers\n\n\nIf you want to add the locale parameter when creating URIs within your\nrequest handlers, you just need to inject the \nUrlHelper\n into your\nhandler and use it for URL generation:\n\n\n<?php\nnamespace App\\Handler;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectHandler implements RequestHandlerInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this->helper->generate('your-route', $routeParams)\n        );\n    }\n}\n\n\n\nInjecting the \nUrlHelper\n into your request handler will also require that the\nhandler have a factory that manages the injection. As an example, the following\nwould work for the above middleware:\n\n\nnamespace App\\Handler;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectHandler(\n            $container->get(UrlHelper::class)\n        );\n    }\n}",
            "title": "Setting a locale without a routing parameter"
        },
        {
            "location": "/v3/cookbook/setting-locale-without-routing-parameter/#how-can-i-setup-the-locale-without-routing-parameters",
            "text": "Localized web applications often set the locale (and therefore the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.",
            "title": "How can I setup the locale without routing parameters?"
        },
        {
            "location": "/v3/cookbook/setting-locale-without-routing-parameter/#distinguishing-between-routes-that-require-localization",
            "text": "If your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the \"Setting a locale based on a routing parameter\" recipe .",
            "title": "Distinguishing between routes that require localization"
        },
        {
            "location": "/v3/cookbook/setting-locale-without-routing-parameter/#setup-a-middleware-to-extract-the-locale-from-the-uri",
            "text": "First, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If it doesn't find one, it sets a default.  If it does find one, it uses the value to setup the locale. It also:   amends the request with a truncated path (removing the locale segment).  adds the locale segment as the base path of the  UrlHelper .   <?php\nnamespace App\\I18n;\n\nuse Locale;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    private $defaultLocale;\n    private $fallbackLocale = 'en_US';\n\n    const REGEX_LOCALE = '#^/(?P<locale>[a-z]{2,3}|[a-z]{2}[-_][a-zA-Z]{2})(?:/|$)#';\n\n    public function __construct(UrlHelper $helper, string $defaultLocale = null)\n    {\n        $this->helper = $helper;\n        if ($defaultLocale) {\n            $this->defaultLocale = $defaultLocale;\n        }\n    }\n\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        $uri = $request->getUri();\n\n        $path = $uri->getPath();\n\n        if (! preg_match(self::REGEX_LOCALE, $path, $matches)) {\n            Locale::setDefault($this->defaultLocale ?: $this->fallbackLocale);\n            return $handler->handle($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        $path = substr($path, strlen($locale) + 1);\n\n        return $handler->handle($request->withUri(\n            $uri->withPath($path ?: '/')\n        ));\n    }\n}  Then you will need a factory for the  SetLocaleMiddleware  to inject the UrlHelper  instance.  <?php\nnamespace App\\I18n;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\n/**\n * Configuration for setting a default locale should look like the following:\n *\n * <code>\n * 'i18n' => [\n *     'default_locale' => 'de_DE',\n * ]\n * </code>\n */\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $config = $container->has('config') ? $container->get('config') : [];\n\n        return new SetLocaleMiddleware(\n            $container->get(UrlHelper::class),\n            $config['i18n']['default_locale'] ?? null\n        );\n    }\n}  Next, map the middleware to its factory in either /config/autoload/dependencies.global.php  or /config/autoload/middleware-pipeline.global.php :  use App\\I18n\\SetLocaleMiddleware;\nuse App\\I18n\\SetLocaleMiddlewareFactory;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ],\n];  Finally, you will need to configure your middleware pipeline to ensure this\nmiddleware is executed on every request.  Pipe the middleware early in your application, before routing is performed:  use App\\I18n\\SetLocaleMiddleware;\n\n/* ... */\n$app->pipe(SetLocaleMiddleware::class);\n/* ... */\n$app->pipe(RouteMiddleware::class);\n/* ... */\n$app->pipe(DispatchMiddleware::class);\n/* ... */",
            "title": "Setup a middleware to extract the locale from the URI"
        },
        {
            "location": "/v3/cookbook/setting-locale-without-routing-parameter/#url-generation-in-the-view",
            "text": "Since the  UrlHelper  has the locale set as a base path, you don't need\nto worry about generating URLs within your view. Just use the helper to\ngenerate a URL and it will do the rest.  <?= $this->url('your-route') ?>",
            "title": "Url generation in the view"
        },
        {
            "location": "/v3/cookbook/setting-locale-without-routing-parameter/#helpers-differ-between-template-renderers",
            "text": "The above example is specific to zend-view; syntax will differ for\nTwig and Plates.",
            "title": "Helpers differ between template renderers"
        },
        {
            "location": "/v3/cookbook/setting-locale-without-routing-parameter/#redirecting-within-your-request-handlers",
            "text": "If you want to add the locale parameter when creating URIs within your\nrequest handlers, you just need to inject the  UrlHelper  into your\nhandler and use it for URL generation:  <?php\nnamespace App\\Handler;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectHandler implements RequestHandlerInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function handle(ServerRequestInterface $request) : ResponseInterface\n    {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this->helper->generate('your-route', $routeParams)\n        );\n    }\n}  Injecting the  UrlHelper  into your request handler will also require that the\nhandler have a factory that manages the injection. As an example, the following\nwould work for the above middleware:  namespace App\\Handler;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectHandler(\n            $container->get(UrlHelper::class)\n        );\n    }\n}",
            "title": "Redirecting within your request handlers"
        },
        {
            "location": "/v3/cookbook/debug-toolbars/",
            "text": "How can I get a debug toolbar for my Expressive application?\n\n\nMany modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?\n\n\nZend Server Z-Ray\n\n\nZend Server\n ships with a tool\ncalled \nZ-Ray\n, which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently \navailable as a standalone technology\npreview\n, and can be added\nas an extension to an existing PHP installation.\n\n\nWhen using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the\n\nZ-Ray documentation\n\nfor full usage details.\n\n\nphp-middleware/php-debug-bar\n\n\nphp-middleware/php-debug-bar\n\nprovides a PSR-15 middleware wrapper around \nmaximebf/php-debugbar\n,\na popular framework-agnostic debug bar for PHP projects.\n\n\nFirst, install the middleware in your application:\n\n\n$ composer require php-middleware/php-debug-bar\n\n\n\nThis package supplies a config provider, which could be added to your\n\nconfig/config.php\n when using zend-config-aggregator or\nexpressive-config-manager. However, because it should only be enabled in\ndevelopment, we recommend creating a \"local\" configuration file (e.g.,\n\nconfig/autoload/php-debugbar.local.php\n) when you need to enable it, with the\nfollowing contents:\n\n\n<?php\nuse PhpMiddleware\\PhpDebugBar\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();\n\n\n\n\n\nUse locally!\n\n\nRemember to enable \nPhpMiddleware\\PhpDebugBar\\ConfigProvider\n only in your\ndevelopment environments!",
            "title": "Enabling debug toolbars"
        },
        {
            "location": "/v3/cookbook/debug-toolbars/#how-can-i-get-a-debug-toolbar-for-my-expressive-application",
            "text": "Many modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?",
            "title": "How can I get a debug toolbar for my Expressive application?"
        },
        {
            "location": "/v3/cookbook/debug-toolbars/#zend-server-z-ray",
            "text": "Zend Server  ships with a tool\ncalled  Z-Ray , which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently  available as a standalone technology\npreview , and can be added\nas an extension to an existing PHP installation.  When using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the Z-Ray documentation \nfor full usage details.",
            "title": "Zend Server Z-Ray"
        },
        {
            "location": "/v3/cookbook/debug-toolbars/#php-middlewarephp-debug-bar",
            "text": "php-middleware/php-debug-bar \nprovides a PSR-15 middleware wrapper around  maximebf/php-debugbar ,\na popular framework-agnostic debug bar for PHP projects.  First, install the middleware in your application:  $ composer require php-middleware/php-debug-bar  This package supplies a config provider, which could be added to your config/config.php  when using zend-config-aggregator or\nexpressive-config-manager. However, because it should only be enabled in\ndevelopment, we recommend creating a \"local\" configuration file (e.g., config/autoload/php-debugbar.local.php ) when you need to enable it, with the\nfollowing contents:  <?php\nuse PhpMiddleware\\PhpDebugBar\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();",
            "title": "php-middleware/php-debug-bar"
        },
        {
            "location": "/v3/cookbook/debug-toolbars/#use-locally",
            "text": "Remember to enable  PhpMiddleware\\PhpDebugBar\\ConfigProvider  only in your\ndevelopment environments!",
            "title": "Use locally!"
        },
        {
            "location": "/v3/cookbook/flash-messengers/",
            "text": "How Can I Implement Flash Messages?\n\n\nFlash messages\n are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a\n\nPost/Redirect/Get (PRG)\n\nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.\n\n\nExpressive does not provide native session facilities out-of-the-box, which\nmeans you will need:\n\n\n\n\nSession functionality.\n\n\nFlash message functionality, for handling message expiry from the session\n  after first access.\n\n\n\n\nA number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are:\n\n\n\n\nzendframework/zend-expressive-flash\n\n\nslim/flash\n\n\n\n\nzendframework/zend-expressive-flash\n\n\nzend-expressive-flash\n\nis a new offering from Zend Framework. Using it requires a session persistence\nengine as well, and Zend Framework provides that as well. Install the component\nusing the following:\n\n\n$ composer require zendframework/zend-expressive-flash zendframework/zend-expressive-session-ext\n\n\n\nOnce installed, you will need to pipe the middleware, along with the\nzend-expressive-session middleware, in your pipeline. This can be done at the\napplication level:\n\n\n$app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class);\n\n\n\nor within a routed middleware pipeline:\n\n\n$app->post('/user/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class,\n    LoginHandler::class,\n]);\n\n\n\nOnce this is in place, the flash message container will be registered as a\nrequest attribute, which you can then pull and manipulate:\n\n\n$flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE);\n// or $flashMessages = $request->getAttribute('flash');\n\n// Create a flash message for the next request:\n$flashMessages->flash($messageName, $messageValue);\n\n// Or retrieve them:\n$message = $flashMessages->getFlash($messageName);\n\n\n\nThe component has functionality for specifying the number of hops the message\nwill be valid for, as well as accessing messages created in the current request;\n\nread more in the documentation\n.\n\n\nslim/flash\n\n\nSlim's \nFlash messages service provider\n can be\nused in Expressive. It uses PHP's native session support.\n\n\nFirst, you'll need to add it to your application:\n\n\n$ composer require slim/flash\n\n\n\nSecond, create middleware that will add the flash message provider to the request:\n\n\n<?php\nnamespace App;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Start the session whenever we use this!\n        session_start();\n\n        return $handler->handle(\n            $request->withAttribute('flash', new Messages())\n        );\n    }\n}\n\n\n\nThird, we will register the new middleware with our container as an invokable.\nEdit either the file \nconfig/autoload/dependencies.global.php\n or\n\nconfig/autoload/middleware-pipeline.global.php\n to add the following:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nFinally, let's register it with our middleware pipeline. For programmatic\npipelines, pipe the middleware somewhere, generally before the routing middleware:\n\n\n$app->pipe(App\\SlimFlashMiddleware::class);\n\n\n\nOr as part of a routed middleware pipeline:\n\n\n$app->post('/form/handler', [\n    App\\SlimFlashMiddleware::class,\n    FormHandlerMiddleware::class,\n]);\n\n\n\nIf using configuration-driven pipelines, edit\n\nconfig/autoload/middleware-pipeline.global.php\n to make the following\nadditions:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\nWhere to register the flash middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead, as demonstrated\nin the programmatic pipelines above.\n\n\n\n\nFrom here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:\n\n\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, RequestHandlerInterface $handler)\n{\n    $flash = $request->getAttribute('flash');\n    $flash->addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\nAnd middleware consuming the message might read:\n\n\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nfunction($request, RequestHandlerInterface $handler)\n{\n    $flash = $request->getAttribute('flash');\n    $messages = $flash->getMessages();\n    // ...\n}\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.",
            "title": "Flash Messengers"
        },
        {
            "location": "/v3/cookbook/flash-messengers/#how-can-i-implement-flash-messages",
            "text": "Flash messages  are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) \nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.  Expressive does not provide native session facilities out-of-the-box, which\nmeans you will need:   Session functionality.  Flash message functionality, for handling message expiry from the session\n  after first access.   A number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are:   zendframework/zend-expressive-flash  slim/flash",
            "title": "How Can I Implement Flash Messages?"
        },
        {
            "location": "/v3/cookbook/flash-messengers/#zendframeworkzend-expressive-flash",
            "text": "zend-expressive-flash \nis a new offering from Zend Framework. Using it requires a session persistence\nengine as well, and Zend Framework provides that as well. Install the component\nusing the following:  $ composer require zendframework/zend-expressive-flash zendframework/zend-expressive-session-ext  Once installed, you will need to pipe the middleware, along with the\nzend-expressive-session middleware, in your pipeline. This can be done at the\napplication level:  $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class);  or within a routed middleware pipeline:  $app->post('/user/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class,\n    LoginHandler::class,\n]);  Once this is in place, the flash message container will be registered as a\nrequest attribute, which you can then pull and manipulate:  $flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE);\n// or $flashMessages = $request->getAttribute('flash');\n\n// Create a flash message for the next request:\n$flashMessages->flash($messageName, $messageValue);\n\n// Or retrieve them:\n$message = $flashMessages->getFlash($messageName);  The component has functionality for specifying the number of hops the message\nwill be valid for, as well as accessing messages created in the current request; read more in the documentation .",
            "title": "zendframework/zend-expressive-flash"
        },
        {
            "location": "/v3/cookbook/flash-messengers/#slimflash",
            "text": "Slim's  Flash messages service provider  can be\nused in Expressive. It uses PHP's native session support.  First, you'll need to add it to your application:  $ composer require slim/flash  Second, create middleware that will add the flash message provider to the request:  <?php\nnamespace App;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\MiddlewareInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface\n    {\n        // Start the session whenever we use this!\n        session_start();\n\n        return $handler->handle(\n            $request->withAttribute('flash', new Messages())\n        );\n    }\n}  Third, we will register the new middleware with our container as an invokable.\nEdit either the file  config/autoload/dependencies.global.php  or config/autoload/middleware-pipeline.global.php  to add the following:  return [\n    'dependencies' => [\n        'invokables' => [\n            App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Finally, let's register it with our middleware pipeline. For programmatic\npipelines, pipe the middleware somewhere, generally before the routing middleware:  $app->pipe(App\\SlimFlashMiddleware::class);  Or as part of a routed middleware pipeline:  $app->post('/form/handler', [\n    App\\SlimFlashMiddleware::class,\n    FormHandlerMiddleware::class,\n]);  If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php  to make the following\nadditions:  return [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];",
            "title": "slim/flash"
        },
        {
            "location": "/v3/cookbook/flash-messengers/#where-to-register-the-flash-middleware",
            "text": "Sessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead, as demonstrated\nin the programmatic pipelines above.   From here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:  use Psr\\Http\\Server\\RequestHandlerInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, RequestHandlerInterface $handler)\n{\n    $flash = $request->getAttribute('flash');\n    $flash->addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  And middleware consuming the message might read:  use Psr\\Http\\Server\\RequestHandlerInterface;\n\nfunction($request, RequestHandlerInterface $handler)\n{\n    $flash = $request->getAttribute('flash');\n    $messages = $flash->getMessages();\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.",
            "title": "Where to register the flash middleware"
        },
        {
            "location": "/v3/cookbook/using-custom-view-helpers/",
            "text": "How do you register custom view helpers when using zend-view?\n\n\nIf you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?\n\n\nAssuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for \nZend\\View\\HelperPluginManager\n, and it will\nbe injected into the \nPhpRenderer\n instance used. Since the \nHelperPluginManager\n\nis available, we can configure it.\n\n\nOpen the file \nconfig/autoload/templates.global.php\n. In that file, you'll see\nthree top-level keys:\n\n\nreturn [\n    'dependencies' => [ /* ... */ ],\n    'templates' => [ /* ... */ ],\n    'view_helpers' => [ /* ... */ ],\n];\n\n\n\nThe last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created.\n\nSee the zend-view custom helpers documentation\n\nfor information on how to populate this configuration.",
            "title": "Registering custom view helpers when using zend-view"
        },
        {
            "location": "/v3/cookbook/using-custom-view-helpers/#how-do-you-register-custom-view-helpers-when-using-zend-view",
            "text": "If you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?  Assuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for  Zend\\View\\HelperPluginManager , and it will\nbe injected into the  PhpRenderer  instance used. Since the  HelperPluginManager \nis available, we can configure it.  Open the file  config/autoload/templates.global.php . In that file, you'll see\nthree top-level keys:  return [\n    'dependencies' => [ /* ... */ ],\n    'templates' => [ /* ... */ ],\n    'view_helpers' => [ /* ... */ ],\n];  The last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created. See the zend-view custom helpers documentation \nfor information on how to populate this configuration.",
            "title": "How do you register custom view helpers when using zend-view?"
        },
        {
            "location": "/v3/cookbook/using-zend-form-view-helpers/",
            "text": "How can I use zend-form view helpers?\n\n\nIf you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:\n\n\n\n\nzend-form\n\n\nzend-i18n\n\n\nzend-navigation\n\n\n\n\nBy default, only the view helpers directly available in zend-view are available;\nhow can you add the others?\n\n\nConfigProvider\n\n\nWhen you install zend-form, Composer should prompt you if you want to inject one\nor more \nConfigProvider\n classes, including those from zend-hydrator,\nzend-inputfilter, and several others. Always answer \"yes\" to these; when you do,\na Composer plugin will add entries for their \nConfigProvider\n classes to your\n\nconfig/config.php\n file.\n\n\nIf for some reason you are not prompted, or chose \"no\" when answering the\nprompts, you can add them manually. Add the following entries in the array used\nto create your \nConfigAggregator\n instance within \nconfig/config.php\n:\n\n\n    \\Zend\\Form\\ConfigProvider::class,\n    \\Zend\\InputFilter\\ConfigProvider::class,\n    \\Zend\\Filter\\ConfigProvider::class,\n    \\Zend\\Validator\\ConfigProvider::class,\n    \\Zend\\Hydrator\\ConfigProvider::class,\n\n\n\nIf you installed Expressive via the skeleton, the service\n\nZend\\View\\HelperPluginManager\n is registered for you, and represents the helper\nplugin manager injected into the \nPhpRenderer\n instance. This instance gets its\nhelper configuration from the \nview_helpers\n top-level configuration key \u2014\nwhich the zend-form \nConfigProvider\n helps to populate!\n\n\nAt this point, all view helpers provided by zend-form are registered and ready\nto use.",
            "title": "Using zend-form view helpers"
        },
        {
            "location": "/v3/cookbook/using-zend-form-view-helpers/#how-can-i-use-zend-form-view-helpers",
            "text": "If you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:   zend-form  zend-i18n  zend-navigation   By default, only the view helpers directly available in zend-view are available;\nhow can you add the others?",
            "title": "How can I use zend-form view helpers?"
        },
        {
            "location": "/v3/cookbook/using-zend-form-view-helpers/#configprovider",
            "text": "When you install zend-form, Composer should prompt you if you want to inject one\nor more  ConfigProvider  classes, including those from zend-hydrator,\nzend-inputfilter, and several others. Always answer \"yes\" to these; when you do,\na Composer plugin will add entries for their  ConfigProvider  classes to your config/config.php  file.  If for some reason you are not prompted, or chose \"no\" when answering the\nprompts, you can add them manually. Add the following entries in the array used\nto create your  ConfigAggregator  instance within  config/config.php :      \\Zend\\Form\\ConfigProvider::class,\n    \\Zend\\InputFilter\\ConfigProvider::class,\n    \\Zend\\Filter\\ConfigProvider::class,\n    \\Zend\\Validator\\ConfigProvider::class,\n    \\Zend\\Hydrator\\ConfigProvider::class,  If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager  is registered for you, and represents the helper\nplugin manager injected into the  PhpRenderer  instance. This instance gets its\nhelper configuration from the  view_helpers  top-level configuration key \u2014\nwhich the zend-form  ConfigProvider  helps to populate!  At this point, all view helpers provided by zend-form are registered and ready\nto use.",
            "title": "ConfigProvider"
        },
        {
            "location": "/v3/why-expressive/",
            "text": "Should You Choose zend-expressive Over zend-mvc?\n\n\nWe recommend that you choose Expressive for any new project \u2014 \nif the\nchoice is yours to make\n.\n\n\nWhy Use zend-mvc?\n\n\nzend-mvc is a proven platform, with more than half a decade of development\nbehind it. It is stable and battle-tested in production platforms.\n\n\nBecause it is opinionated about project structure and architecture, fewer\ndecisions need be made up front; developers know where new code goes, and how it\nwill wire into the overall application.\n\n\nAdditionally, a number of training courses exist, including \nofferings by\nZend\n, allowing you\nor your team to fully learn the framework and take advantage of all its features.\n\n\nFinally, zend-mvc has a lively \nmodule ecosystem\n,\nallowing you to add features and capabilities to your application without\nneeding to develop them from scratch.\n\n\nWe Recommend Expressive\n\n\nzend-mvc\n has many preconceptions\nabout how things work, yet they're very broad and general. What\u2019s more, it\nalso has several pre-wired structures in place that may either aid you \u2014\nor get in your way.\n\n\nAs a result, you are required to know a lot of what those things are \u2014 \nif\n you\nwant to use it optimally. And to acquire that depth of knowledge, you\u2019re going\nto need to spend a lot of time digging deep into zend-mvc\u2019s internals before\nyou begin to get the most out of it.\n\n\nTo quote Zend Framework project lead, \nMatthew Weier O\u2019Phinney\n:\n\n\n\n\nThe problem is that zend-mvc is anything but beginner-friendly at this point.\nYou're required to deep dive into the event manager, service manager, and\nmodule system \u2014 right from the outset; And to do this you need more than a\npassing understanding of object-oriented programming and a range of design\npatterns.\n\n\n\n\nExpressive (specifically applications based on\n\nthe Expressive Skeleton Installer\n)\non the other hand, comes with barely any of these assumptions and requirements.\n\n\nIt provides a very minimalist structure. Essentially all you have to become\nfamiliar with are five core components. These are:\n\n\n\n\nA DI container.\n\n\nA router.\n\n\nAn error handler for development.\n\n\nA template engine (if you\u2019re not creating an API).\n\n\nPSR-7 messages and PSR-15 middleware and request handlers.\n\n\n\n\nIn many cases, these are provided for you by the skeleton, and do not require\nany additional knowledge on your part. Given that, you can quickly get up to\nspeed with the framework and begin creating the application that you need. We\nbelieve that this approach \u2014 in contrast to the zend-mvc approach \u2014\nis more flexible and accommodating.\n\n\nWhat\u2019s more, you can mix and match the types of applications that you create.\n\n\n\n\nDo you just need an API? Great; you can do that quite quickly.\n\n\nDo you want an HTML-based front-end? That\u2019s available too.\n\n\n\n\nWhen building applications with Expressive, you can make use of the various Zend\ncomponents, or any third-party components or middleware. You can pick and\nchoose what you need, as and when you need it. You\u2019re not bound by many, if\nany, constraints and design decisions.\n\n\nIn Conclusion\n\n\nFor what it\u2019s worth, we\u2019re \nnot\n saying that zend-mvc is a poor choice!  What\nwe are saying is:\n\n\n\n\nThe learning curve, from getting started to building the first application,\n   is \nsignificantly\n lower with Expressive\n\n\nThe ways in which you can create applications, whether through multiple\n   pieces of middleware or by combining multiple Expressive apps, into one\n   larger one, is a much more efficient and fluid way to work\n\n\n\n\nUltimately, the choice is always up to you, your team, and your project\u2019s needs.\nWe just want to ensure that you\u2019ve got all the information you need, to make an\ninformed decision.",
            "title": "Why choose Expressive?"
        },
        {
            "location": "/v3/why-expressive/#should-you-choose-zend-expressive-over-zend-mvc",
            "text": "We recommend that you choose Expressive for any new project \u2014  if the\nchoice is yours to make .",
            "title": "Should You Choose zend-expressive Over zend-mvc?"
        },
        {
            "location": "/v3/why-expressive/#why-use-zend-mvc",
            "text": "zend-mvc is a proven platform, with more than half a decade of development\nbehind it. It is stable and battle-tested in production platforms.  Because it is opinionated about project structure and architecture, fewer\ndecisions need be made up front; developers know where new code goes, and how it\nwill wire into the overall application.  Additionally, a number of training courses exist, including  offerings by\nZend , allowing you\nor your team to fully learn the framework and take advantage of all its features.  Finally, zend-mvc has a lively  module ecosystem ,\nallowing you to add features and capabilities to your application without\nneeding to develop them from scratch.",
            "title": "Why Use zend-mvc?"
        },
        {
            "location": "/v3/why-expressive/#we-recommend-expressive",
            "text": "zend-mvc  has many preconceptions\nabout how things work, yet they're very broad and general. What\u2019s more, it\nalso has several pre-wired structures in place that may either aid you \u2014\nor get in your way.  As a result, you are required to know a lot of what those things are \u2014  if  you\nwant to use it optimally. And to acquire that depth of knowledge, you\u2019re going\nto need to spend a lot of time digging deep into zend-mvc\u2019s internals before\nyou begin to get the most out of it.  To quote Zend Framework project lead,  Matthew Weier O\u2019Phinney :   The problem is that zend-mvc is anything but beginner-friendly at this point.\nYou're required to deep dive into the event manager, service manager, and\nmodule system \u2014 right from the outset; And to do this you need more than a\npassing understanding of object-oriented programming and a range of design\npatterns.   Expressive (specifically applications based on the Expressive Skeleton Installer )\non the other hand, comes with barely any of these assumptions and requirements.  It provides a very minimalist structure. Essentially all you have to become\nfamiliar with are five core components. These are:   A DI container.  A router.  An error handler for development.  A template engine (if you\u2019re not creating an API).  PSR-7 messages and PSR-15 middleware and request handlers.   In many cases, these are provided for you by the skeleton, and do not require\nany additional knowledge on your part. Given that, you can quickly get up to\nspeed with the framework and begin creating the application that you need. We\nbelieve that this approach \u2014 in contrast to the zend-mvc approach \u2014\nis more flexible and accommodating.  What\u2019s more, you can mix and match the types of applications that you create.   Do you just need an API? Great; you can do that quite quickly.  Do you want an HTML-based front-end? That\u2019s available too.   When building applications with Expressive, you can make use of the various Zend\ncomponents, or any third-party components or middleware. You can pick and\nchoose what you need, as and when you need it. You\u2019re not bound by many, if\nany, constraints and design decisions.",
            "title": "We Recommend Expressive"
        },
        {
            "location": "/v3/why-expressive/#in-conclusion",
            "text": "For what it\u2019s worth, we\u2019re  not  saying that zend-mvc is a poor choice!  What\nwe are saying is:   The learning curve, from getting started to building the first application,\n   is  significantly  lower with Expressive  The ways in which you can create applications, whether through multiple\n   pieces of middleware or by combining multiple Expressive apps, into one\n   larger one, is a much more efficient and fluid way to work   Ultimately, the choice is always up to you, your team, and your project\u2019s needs.\nWe just want to ensure that you\u2019ve got all the information you need, to make an\ninformed decision.",
            "title": "In Conclusion"
        },
        {
            "location": "/v3/reference/cli-tooling/",
            "text": "Command Line Tooling\n\n\nExpressive offers a number of tools for assisting in project development. This\npage catalogues each.\n\n\nDevelopment Mode\n\n\nThe package \nzfcampus/zf-development-mode\n\nprovides a simple way to toggle in and out of \ndevelopment mode\n. Doing so\nallows you to ship known development-specific settings within your repository,\nwhile ensuring they are not enabled in production. The tooling essentially\nenables optional, development-specific configuration in your application by:\n\n\n\n\nCopying the file \nconfig/development.config.php.dist\n to\n  \nconfig/development.config.php\n; this can be used to enable\n  development-specific modules or settings (such as the \ndebug\n flag).\n\n\nCopying the file \nconfig/autoload/development.local.php.dist\n to\n  \nconfig/autoload/development.local.php\n; this can be used to provide local\n  overrides of a number of configuration settings.\n\n\n\n\nThe package provides the tooling via \nvendor/bin/zf-development-mode\n. If you\nare using the Expressive skeleton, it provides aliases via Composer:\n\n\n$ composer development-enable\n$ composer development-disable\n$ composer development-status\n\n\n\nAdd settings to your \ndevelopment.*.php.dist\n files, and commit those files to\nyour repository; always toggle out of and into development mode after making\nchanges, to ensure they pick up in your development environment.\n\n\nExpressive command-line tool\n\n\nThe package \nzendframework/zend-expressive-tooling\n\nprovides the script \nvendor/bin/expressive\n, which contains a number of commands\nrelated to migration, modules, and middleware.\n\n\nYou can install it if it is not already present in your application:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nOnce installed, invoking the binary without arguments will give a listing of\navailable tools:\n\n\n$ ./vendor/bin/expressive\n\n\n\n\n\nIntegration with Composer\n\n\nIn the skeleton application, we provide direct integration with Composer,\nallowing you to invoke the tooling using:\n\n\n$ composer expressive\n\n\n\nYou can use either that form, or invoke the script directly as detailed above.\n\n\n\n\nCommands supported include:\n\n\n\n\n\n\naction:create [options] <action>\n: This is an alias for the\n  \nhandler:create\n command detailed below.\n\n\n\n\n\n\nfactory:create [options] <class>\n: Create a factory for the named class.\n  By default, the command will also register the class with its factory in the\n  application container.\n\n\n\n\n\n\nhandler:create [options] <handler>\n: Create a request handler named after\n \u00a0\n<handler>\n. By default, the command will also generate a factory, register\n  both with the application container, and, if a template renderer is\n  discovered, generate a template in an appropriate location. \nNote:\n\n  \n<handler>\n will either need to be quoted or the backslashes escaped.\n  \nExample:\n \nhandler:create \"ModuleName\\Handler\\IndexHandler\"\n or\n  \nhandler:create ModuleName\\\\Handler\\\\IndexHandler\n.\n\n\n\n\n\n\nmiddleware:create <middleware>\n: Create a class file for the named\n  middleware class. The class \nmust\n use a namespace already declared in your\n  application, and will be created relative to the path associated with that\n  namespace.\n\n\n\n\n\n\nmigrate:interop-middleware [options]\n: Migrates former http-interop\n  middleware under the \nsrc/\n tree to PSR-15 middleware.\n\n\n\n\n\n\nmigrate:middleware-to-request-handler [options]\n: Migrates PSR-15\n  middleware under the \nsrc/\n tree to PSR-15 request handlers; it will only\n  migrate those that never call on their \n$handler\n argument.\n\n\n\n\n\n\nmodule:create [--composer|-c] [--modules-path|-p] <module>\n: Create the\n  named module including a filesystem skeleton, add and generate autoloading\n  rules for it, and register the module's \nConfigProvider\n with your\n  application.\n\n\n\n\n\n\nmodule:register [--composer|-c] [--modules-path|-p] <module>\n: Add and\n  generate autoloading rules for the named module,  and register the module's\n  \nConfigProvider\n with your application.\n\n\n\n\n\n\nmodule:deregister [--composer|-c] [--modules-path|-p] <module>\n: Remove\n  autoloading rules for the named module and regenerate autoloading rules;\n  remove the module's \nConfigProvider\n from the application configuration.\n\n\n\n\n\n\nYou may obtain full help for each command by invoking:\n\n\n$ ./vendor/bin/expressive help <command>",
            "title": "CLI Tooling"
        },
        {
            "location": "/v3/reference/cli-tooling/#command-line-tooling",
            "text": "Expressive offers a number of tools for assisting in project development. This\npage catalogues each.",
            "title": "Command Line Tooling"
        },
        {
            "location": "/v3/reference/cli-tooling/#development-mode",
            "text": "The package  zfcampus/zf-development-mode \nprovides a simple way to toggle in and out of  development mode . Doing so\nallows you to ship known development-specific settings within your repository,\nwhile ensuring they are not enabled in production. The tooling essentially\nenables optional, development-specific configuration in your application by:   Copying the file  config/development.config.php.dist  to\n   config/development.config.php ; this can be used to enable\n  development-specific modules or settings (such as the  debug  flag).  Copying the file  config/autoload/development.local.php.dist  to\n   config/autoload/development.local.php ; this can be used to provide local\n  overrides of a number of configuration settings.   The package provides the tooling via  vendor/bin/zf-development-mode . If you\nare using the Expressive skeleton, it provides aliases via Composer:  $ composer development-enable\n$ composer development-disable\n$ composer development-status  Add settings to your  development.*.php.dist  files, and commit those files to\nyour repository; always toggle out of and into development mode after making\nchanges, to ensure they pick up in your development environment.",
            "title": "Development Mode"
        },
        {
            "location": "/v3/reference/cli-tooling/#expressive-command-line-tool",
            "text": "The package  zendframework/zend-expressive-tooling \nprovides the script  vendor/bin/expressive , which contains a number of commands\nrelated to migration, modules, and middleware.  You can install it if it is not already present in your application:  $ composer require --dev zendframework/zend-expressive-tooling  Once installed, invoking the binary without arguments will give a listing of\navailable tools:  $ ./vendor/bin/expressive",
            "title": "Expressive command-line tool"
        },
        {
            "location": "/v3/reference/cli-tooling/#integration-with-composer",
            "text": "In the skeleton application, we provide direct integration with Composer,\nallowing you to invoke the tooling using:  $ composer expressive  You can use either that form, or invoke the script directly as detailed above.   Commands supported include:    action:create [options] <action> : This is an alias for the\n   handler:create  command detailed below.    factory:create [options] <class> : Create a factory for the named class.\n  By default, the command will also register the class with its factory in the\n  application container.    handler:create [options] <handler> : Create a request handler named after\n \u00a0 <handler> . By default, the command will also generate a factory, register\n  both with the application container, and, if a template renderer is\n  discovered, generate a template in an appropriate location.  Note: \n   <handler>  will either need to be quoted or the backslashes escaped.\n   Example:   handler:create \"ModuleName\\Handler\\IndexHandler\"  or\n   handler:create ModuleName\\\\Handler\\\\IndexHandler .    middleware:create <middleware> : Create a class file for the named\n  middleware class. The class  must  use a namespace already declared in your\n  application, and will be created relative to the path associated with that\n  namespace.    migrate:interop-middleware [options] : Migrates former http-interop\n  middleware under the  src/  tree to PSR-15 middleware.    migrate:middleware-to-request-handler [options] : Migrates PSR-15\n  middleware under the  src/  tree to PSR-15 request handlers; it will only\n  migrate those that never call on their  $handler  argument.    module:create [--composer|-c] [--modules-path|-p] <module> : Create the\n  named module including a filesystem skeleton, add and generate autoloading\n  rules for it, and register the module's  ConfigProvider  with your\n  application.    module:register [--composer|-c] [--modules-path|-p] <module> : Add and\n  generate autoloading rules for the named module,  and register the module's\n   ConfigProvider  with your application.    module:deregister [--composer|-c] [--modules-path|-p] <module> : Remove\n  autoloading rules for the named module and regenerate autoloading rules;\n  remove the module's  ConfigProvider  from the application configuration.    You may obtain full help for each command by invoking:  $ ./vendor/bin/expressive help <command>",
            "title": "Integration with Composer"
        },
        {
            "location": "/v3/reference/expressive-projects/",
            "text": "Projects powered by zend-expressive\n\n\nzend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.\n\n\nSample Code & Tutorials\n\n\n\n\nExpressive Tutorial (WIP) - \nsource\n\n\nAstroSplash\n - \nsource\n\n  (Also, read the \nrelated article on sitepoint\n)\n\n\nphp-ddd-cargo-sample\n - \nsource\n\n\n\n\nPersonal Sites\n\n\n\n\nmwop.net\n - \nsource\n\n\nxtreamwayz.com\n - \nsource\n\n\nalejandrocelaya.com\n - \nsource\n\n\nzimuel.it\n - \nsource",
            "title": "Expressive Projects"
        },
        {
            "location": "/v3/reference/expressive-projects/#projects-powered-by-zend-expressive",
            "text": "zend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.",
            "title": "Projects powered by zend-expressive"
        },
        {
            "location": "/v3/reference/expressive-projects/#sample-code-tutorials",
            "text": "Expressive Tutorial (WIP) -  source  AstroSplash  -  source \n  (Also, read the  related article on sitepoint )  php-ddd-cargo-sample  -  source",
            "title": "Sample Code &amp; Tutorials"
        },
        {
            "location": "/v3/reference/expressive-projects/#personal-sites",
            "text": "mwop.net  -  source  xtreamwayz.com  -  source  alejandrocelaya.com  -  source  zimuel.it  -  source",
            "title": "Personal Sites"
        },
        {
            "location": "/v3/reference/migration/",
            "text": "Migration to Expressive 3.0\n\n\nExpressive 3.0 should not result in many upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:\n\n\n\n\nPHP 7.1 support\n\n\nPSR-15 support\n\n\nNew dependencies\n\n\nNew features\n\n\nSignature and behavior changes\n\n\nRemoved classes and traits\n\n\nUpgrading from v2\n\n\n\n\nPHP 7.1 support\n\n\nStarting in Expressive 3.0 we support only PHP 7.1+.\n\n\nPSR-15 Support\n\n\nAll middleware and delegators now implement interfaces from\n\nPSR-15\n instead of\nhttp-interop/http-middleware (a PSR-15 precursor). This means the following\nchanges were made throughout Expressive:\n\n\n\n\n\n\nThe \nprocess()\n method of all middleware now type hint the second argument\n  against the PSR-15 \nRequestHandlerInterface\n, instead of the previous\n  \nDelegateInterface\n.\n\n\n\n\n\n\nThe \nprocess()\n method of all middleware now have a return type hint of\n  \n\\Psr\\Http\\Message\\ResponseInterface\n.\n\n\n\n\n\n\nAll \"delegators\" have become request handlers: these now implement the PSR-15\n  interface \nRequestHandlerInterface\n instead of the former \nDelegateInterface\n.\n\n\n\n\n\n\nThe \nprocess()\n method of handlers (formerly delegators) have been renamed to\n  \nhandle()\n and given a return type hint of\n  \n\\Psr\\Http\\Message\\ResponseInterface\n.\n\n\n\n\n\n\nThis change also affects all middleware you, as an application developer, have\nwritten, and your middleware will need to be update. We provide a tool for this\nvia zend-expressive-tooling. Make sure that package is up-to-date (a version 1\nrelease should be installed), and run the following:\n\n\n$ ./vendor/bin/expressive migrate:interop-middleware\n\n\n\nThis tool will locate any http-interop middleware and update it to PSR-15\nmiddleware.\n\n\nNew dependencies\n\n\nExpressive adds the following packages as dependencies:\n\n\n\n\n\n\npsr/http-server-middleware\n\n  provides the PSR-15 interfaces, and replaces the previous dependency on\n  http-interop/http-middleware.\n\n\n\n\n\n\nzendframework/zend-expressive-router\n;\n  previously, we depended on this package indirectly; now it is a direct\n  requirement.\n\n\n\n\n\n\nzendframework/zend-expressive-tooling\n;\n  this was suggested previously, but is now required as a development\n  dependency.\n\n\n\n\n\n\nzendframework/zend-httphandlerrunner\n;\n  this is now used for the purposes of marshaling the server request, dispatching\n  the application, and emitting the response. The functionality is generalized\n  enough to warrant a separate package.\n\n\n\n\n\n\nNew features\n\n\nThe following classes were added in version 3:\n\n\n\n\n\n\nZend\\Expressive\\Container\\ApplicationConfigInjectionDelegator\n is a\n  \ndelegator factory\n capable of\n  piping and routing middleware from configuration. See the \nrecipe on\n  autowiring routes and pipeline middleware\n\n  for more information.\n\n\n\n\n\n\nZend\\Expressive\\Container\\ApplicationPipelineFactory\n will produce an empty\n  \nMiddlewarePipe\n for use with \nZend\\Expressive\\Application\n.\n\n\n\n\n\n\nZend\\Expressive\\Container\\EmitterFactory\n will produce a\n  \nZend\\HttpHandlerRunner\\Emitter\\EmitterStack\n instance for use with the\n  \nRequestHandlerRunner\n instance composed by the \nApplication\n. See the\n  \nchapter on emitters\n for more details.\n\n\n\n\n\n\nZend\\Expressive\\Container\\MiddlewareContainerFactory\n will produce a\n  \nMiddlewareContainer\n composing the application container instance.\n\n\n\n\n\n\nZend\\Expressive\\Container\\MiddlewareFactoryFactory\n will produce a\n  \nMiddlewareFactory\n composing a \nMiddlewareContainer\n instance.\n\n\n\n\n\n\nZend\\Expressive\\Container\\RequestHandlerRunnerFactory\n will produce a\n  \nZend\\HttpHandlerRunner\\RequestHandlerRunner\n instance for use with the\n  \nApplication\n instance. See the \nzend-httphandlerrunner\n  documentation\n for more\n  details on this collaborator.\n\n\n\n\n\n\nZend\\Expressive\\Container\\ServerRequestErrorResponseGeneratorFactory\n will\n  produce a \nZend\\Expressive\\Response\\ServerRequestErrorResponseGenerator\n\n  instance for use with the \nRequestHandlerRunner\n.\n\n\n\n\n\n\nZend\\Expressive\\Container\\ServerRequestFactoryFactory\n will produce a PHP\n  callable capable of generating a PSR-7 \nServerRequestInterface\n instance for use\n  with the \nRequestHandlerRunner\n.\n\n\n\n\n\n\nZend\\Expressive\\MiddlewareContainer\n decorates a PSR-11 container, and\n  ensures that the values pulled are PSR-15 \nMiddlewareInterface\n instances.\n  If the container returns a PSR-15 \nRequestHandlerInterface\n, it decorates it\n  via \nZend\\Stratigility\\Middleware\\RequestHandlerMiddleware\n. All other types\n  result in an exception being thrown.\n\n\n\n\n\n\nZend\\Expressive\\MiddlewareFactory\n allows creation of \nMiddlewareInterface\n\n  instances from a variety of argument types, and is used by \nApplication\n to\n  allow piping and routing to middleware services, arrays of services, and more.\n  It composes a \nMiddlewareContainer\n internally.\n\n\n\n\n\n\nZend\\Expressive\\Response\\ServerRequestErrorResponseGenerator\n can act as a\n  response generator for the \nRequestHandlerRunner\n when its composed server\n  request factory raises an exception.\n\n\n\n\n\n\nSignature and behavior changes\n\n\nThe following signature changes were made that could affect \nclass extensions\n\nand/or consumers.\n\n\nApplication\n\n\nZend\\Expressive\\Application\n was refactored dramatically for version 3.\n\n\nIf you were instantiating it directly previously, the constructor arguments are\nnow, in order:\n\n\n\n\nZend\\Expressive\\MiddlewareFactory\n\n\nZend\\Stratigility\\MiddlewarePipeInterface\n\n\nZend\\Expressive\\Router\\RouteCollector\n\n\nZend\\HttpHandlerRunner\\RequestHandlerRunner\n\n\nZend\\Expressive\\Application::__construct(...)\n\n\n\n\nApplication\n no longer supports piping or routing to double-pass middleware. If\nyou continue to need double-pass middleware (e.g., defined by a third-party\nlibrary), use \nZend\\Stratigility\\doublePassMiddleware()\n to decorate it prior to\npiping or routing to it:\n\n\nuse Zend\\Diactoros\\Response;\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\n$app->pipe(doublePassMiddleware($someDoublePassMiddleware, new Response()));\n\n$app->get('/foo', doublePassMiddleware($someDoublePassMiddleware, new Response()));\n\n\n\nAdditionally, the following methods were \nremoved\n:\n\n\n\n\npipeRoutingMiddleware()\n: use \npipe(\\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class)\n\n  instead.\n\n\npipeDispatchMiddleware()\n: use \npipe(\\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class)\n\n  instead.\n\n\ngetContainer()\n\n\ngetDefaultDelegate()\n: ensure you pipe middleware or a request handler\n  capable of returning a response at the innermost layer;\n  \nZend\\Expressive\\Handler\\NotFoundHandler\n can be used for this.\n\n\ngetEmitter()\n: use the \nZend\\HttpHandlerRunner\\Emitter\\EmitterInterface\n service from the container.\n\n\ninjectPipelineFromConfig()\n: use the new \nApplicationConfigInjectionDelegator\n and/or the static method of the same name it defines.\n\n\ninjectRoutesFromConfig()\n: use the new \nApplicationConfigInjectionDelegator\n and/or the static method of the same name it defines.\n\n\n\n\nApplicationFactory\n\n\nZend\\Expressive\\Container\\ApplicationFactory\n no longer looks at the\n\nzend-expressive.programmatic_pipeline\n flag, nor does it inject pipeline\nmiddleware and/or routed middleware from configuration any longer.\n\n\nIf you want to use configuration-driven pipelines and/or middleware, you may\nregister the new class \nZend\\Expressive\\Container\\ApplicationConfigInjectionDelegator\n\nas a delegator factory on the \nZend\\Expressive\\Application\n service.\n\n\nNotFoundHandlerFactory\n\n\nZend\\Expressive\\Container\\NotFoundHandlerFactory\n now returns an instance of\n\nZend\\Expressive\\Handler\\NotFoundHandler\n, instead of\n\nZend\\Expressive\\Middleware\\NotFoundHandler\n (which has been removed).\n\n\nLazyLoadingMiddleware\n\n\nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n now composes a\n\nZend\\Expressive\\MiddlewareContainer\n instance instead of a more general PSR-11\ncontainer; this is to ensure that the value returned is a PSR-15\n\nMiddlewareInterface\n instance.\n\n\nRemoved classes and traits\n\n\n\n\n\n\nZend\\Expressive\\AppFactory\n was removed. If you were using it previously,\n  either use \nZend\\Expressive\\Application\n directly, or a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\n\n\nZend\\Expressive\\ApplicationConfigInjectionTrait\n; the functionality of this\n  trait was replaced by the \nZend\\Expressive\\Container\\ApplicationConfigInjectionDelegator\n.\n\n\n\n\n\n\nZend\\Expressive\\Delegate\\NotFoundDelegate\n; use \nZend\\Expressive\\Handler\\NotFoundHandler\n\n  instead. Its factory, \nZend\\Expressive\\Container\\NotFoundDelegateFactory\n, was\n  also removed.\n\n\n\n\n\n\nZend\\Expressive\\Emitter\\EmitterStack\n; use \nZend\\HttpHandlerRunner\\Emitter\\EmitterStack\n\n  instead.\n\n\n\n\n\n\nZend\\Expressive\\IsCallableInteropMiddlewareTrait\n; there is no functional\n  equivalent, nor a need for this functionality as of version 3.\n\n\n\n\n\n\nZend\\Expressive\\MarshalMiddlewareTrait\n; the functionality of this trait was\n  replaced by a combination of \nZend\\Expressive\\MiddlewareContainer\n and\n  \nZend\\Expressive\\MiddlewareFactory\n.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\DispatchMiddleware\n; use\n  \nZend\\Expressive\\Router\\Middleware\\DispatchMiddleware\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\ImplicitHeadMiddleware\n; use\n  \nZend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\ImplicitOptionsMiddleware\n; use\n  \nZend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\NotFoundHandler\n; use \nZend\\Expressive\\Handler\\NotFoundHandler\n\n  instead.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\RouteMiddleware\n; use\n  \nZend\\Expressive\\Router\\Middleware\\RouteMiddleware\n instead.\n\n\n\n\n\n\nUpgrading\n\n\nWe provide a package you can add to your existing v2 application in order to\nupgrade it to version 3.\n\n\nBefore installing and running the migration tooling, make sure you have checked\nin your latest changes (assuming you are using version control), or have a\nbackup of your existing code.\n\n\nInstall the migration tooling using the following command:\n\n\n$ composer require --dev zendframework/zend-expressive-migration\n\n\n\nOnce installed, run the following command to migrate your application:\n\n\n$ ./vendor/bin/expressive-migration migrate\n\n\n\nThis package does the following:\n\n\n\n\nUninstalls all current dependencies (by removing the \nvendor/\n directory).\n\n\nUpdates existing dependency constraints for known Expressive packages to their\n  latest stable versions. (See the tools \nREADME\n\n  for details on what versions of which packages the tool uses.)\n\n\nAdds development dependencies on zendframework/zend-component-installer and\n  zendframework/zend-expressive-tooling.\n\n\nUpdates the \nconfig/pipeline.php\n file to:\n\n\nadd strict type declarations.\n\n\nmodify it to return a callable, per the v3 skeleton.\n\n\nupdate the middleware pipeline as follows:\n\n\npipeRoutingMiddleware()\n becomes a \npipe()\n operation referencing the\n  zend-expressive-router \nRouteMiddleware\n.\n\n\npipeDispatchMiddleware()\n becomes a \npipe()\n operation referencing the\n  zend-expressive-router \nDispatchMiddleware\n.\n\n\nupdate references to \nImplicitHeadMiddleware\n to reference the version\n  in zend-expressive-router.\n\n\nupdate references to \nImplicitOptionsMiddleware\n to reference the version\n  in zend-expressive-router.\n\n\nupdate references to \nZend\\Expressive\\Middleware\\NotFoundHandler\n to\n  reference \nZend\\Expressive\\Handler\\NotFoundHandler\n.\n\n\nadd a \npipe()\n entry for the zend-expressive-router\n  \nMethodNotAllowedMiddleware\n.\n\n\n\n\n\n\n\n\n\n\nUpdates the \nconfig/routes.php\n file to:\n\n\nadd strict type declarations.\n\n\nmodify it to return a callable, per the v3 skeleton.\n\n\n\n\n\n\nReplaces the \npublic/index.php\n file with the latest version from the skeleton.\n\n\nUpdates \nconfig/container.php\n when Pimple or Aura.Di are in use:\n\n\nFor Pimple:\n\n\nThe package \nxtreamwayz/pimple-container-interop\n is replaced with\n  \nzendframework/zend-pimple-config\n.\n\n\nThe Pimple variant of \ncontainer.php\n from the v3 skeleton is used.\n\n\n\n\n\n\nFor Aura.Di\n\n\nThe package \naura/di\n is replaced with \nzendframework/zend-auradi-config\n.\n\n\nThe Aura.Di variant of \ncontainer.php\n from the v3 skeleton is used.\n\n\n\n\n\n\n\n\n\n\nExecutes \n./vendor/bin/expressive migrate:interop-middleware\n.\n\n\nExecutes \n./vendor/bin/expressive migrate:middleware-to-request-handler\n.\n\n\nRuns \n./vendor/bin/phpcbf\n if it is installed.\n\n\n\n\nThese steps should take care of most migration tasks.\n\n\nIt \ndoes not\n update unit tests. These cannot be automatically updated, due to\nthe amount of variance in testing strategies.\n\n\nWhen done, use a diffing tool to compare and verify all changes. Please be aware\nthat the tool is not designed for edge cases; there may be things it does not do\nor cannot catch within your code. When unsure, refer to the other sections in\nthis document to determine what else you may need to change.",
            "title": "Migration"
        },
        {
            "location": "/v3/reference/migration/#migration-to-expressive-30",
            "text": "Expressive 3.0 should not result in many upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:   PHP 7.1 support  PSR-15 support  New dependencies  New features  Signature and behavior changes  Removed classes and traits  Upgrading from v2",
            "title": "Migration to Expressive 3.0"
        },
        {
            "location": "/v3/reference/migration/#php-71-support",
            "text": "Starting in Expressive 3.0 we support only PHP 7.1+.",
            "title": "PHP 7.1 support"
        },
        {
            "location": "/v3/reference/migration/#psr-15-support",
            "text": "All middleware and delegators now implement interfaces from PSR-15  instead of\nhttp-interop/http-middleware (a PSR-15 precursor). This means the following\nchanges were made throughout Expressive:    The  process()  method of all middleware now type hint the second argument\n  against the PSR-15  RequestHandlerInterface , instead of the previous\n   DelegateInterface .    The  process()  method of all middleware now have a return type hint of\n   \\Psr\\Http\\Message\\ResponseInterface .    All \"delegators\" have become request handlers: these now implement the PSR-15\n  interface  RequestHandlerInterface  instead of the former  DelegateInterface .    The  process()  method of handlers (formerly delegators) have been renamed to\n   handle()  and given a return type hint of\n   \\Psr\\Http\\Message\\ResponseInterface .    This change also affects all middleware you, as an application developer, have\nwritten, and your middleware will need to be update. We provide a tool for this\nvia zend-expressive-tooling. Make sure that package is up-to-date (a version 1\nrelease should be installed), and run the following:  $ ./vendor/bin/expressive migrate:interop-middleware  This tool will locate any http-interop middleware and update it to PSR-15\nmiddleware.",
            "title": "PSR-15 Support"
        },
        {
            "location": "/v3/reference/migration/#new-dependencies",
            "text": "Expressive adds the following packages as dependencies:    psr/http-server-middleware \n  provides the PSR-15 interfaces, and replaces the previous dependency on\n  http-interop/http-middleware.    zendframework/zend-expressive-router ;\n  previously, we depended on this package indirectly; now it is a direct\n  requirement.    zendframework/zend-expressive-tooling ;\n  this was suggested previously, but is now required as a development\n  dependency.    zendframework/zend-httphandlerrunner ;\n  this is now used for the purposes of marshaling the server request, dispatching\n  the application, and emitting the response. The functionality is generalized\n  enough to warrant a separate package.",
            "title": "New dependencies"
        },
        {
            "location": "/v3/reference/migration/#new-features",
            "text": "The following classes were added in version 3:    Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator  is a\n   delegator factory  capable of\n  piping and routing middleware from configuration. See the  recipe on\n  autowiring routes and pipeline middleware \n  for more information.    Zend\\Expressive\\Container\\ApplicationPipelineFactory  will produce an empty\n   MiddlewarePipe  for use with  Zend\\Expressive\\Application .    Zend\\Expressive\\Container\\EmitterFactory  will produce a\n   Zend\\HttpHandlerRunner\\Emitter\\EmitterStack  instance for use with the\n   RequestHandlerRunner  instance composed by the  Application . See the\n   chapter on emitters  for more details.    Zend\\Expressive\\Container\\MiddlewareContainerFactory  will produce a\n   MiddlewareContainer  composing the application container instance.    Zend\\Expressive\\Container\\MiddlewareFactoryFactory  will produce a\n   MiddlewareFactory  composing a  MiddlewareContainer  instance.    Zend\\Expressive\\Container\\RequestHandlerRunnerFactory  will produce a\n   Zend\\HttpHandlerRunner\\RequestHandlerRunner  instance for use with the\n   Application  instance. See the  zend-httphandlerrunner\n  documentation  for more\n  details on this collaborator.    Zend\\Expressive\\Container\\ServerRequestErrorResponseGeneratorFactory  will\n  produce a  Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator \n  instance for use with the  RequestHandlerRunner .    Zend\\Expressive\\Container\\ServerRequestFactoryFactory  will produce a PHP\n  callable capable of generating a PSR-7  ServerRequestInterface  instance for use\n  with the  RequestHandlerRunner .    Zend\\Expressive\\MiddlewareContainer  decorates a PSR-11 container, and\n  ensures that the values pulled are PSR-15  MiddlewareInterface  instances.\n  If the container returns a PSR-15  RequestHandlerInterface , it decorates it\n  via  Zend\\Stratigility\\Middleware\\RequestHandlerMiddleware . All other types\n  result in an exception being thrown.    Zend\\Expressive\\MiddlewareFactory  allows creation of  MiddlewareInterface \n  instances from a variety of argument types, and is used by  Application  to\n  allow piping and routing to middleware services, arrays of services, and more.\n  It composes a  MiddlewareContainer  internally.    Zend\\Expressive\\Response\\ServerRequestErrorResponseGenerator  can act as a\n  response generator for the  RequestHandlerRunner  when its composed server\n  request factory raises an exception.",
            "title": "New features"
        },
        {
            "location": "/v3/reference/migration/#signature-and-behavior-changes",
            "text": "The following signature changes were made that could affect  class extensions \nand/or consumers.",
            "title": "Signature and behavior changes"
        },
        {
            "location": "/v3/reference/migration/#application",
            "text": "Zend\\Expressive\\Application  was refactored dramatically for version 3.  If you were instantiating it directly previously, the constructor arguments are\nnow, in order:   Zend\\Expressive\\MiddlewareFactory  Zend\\Stratigility\\MiddlewarePipeInterface  Zend\\Expressive\\Router\\RouteCollector  Zend\\HttpHandlerRunner\\RequestHandlerRunner  Zend\\Expressive\\Application::__construct(...)   Application  no longer supports piping or routing to double-pass middleware. If\nyou continue to need double-pass middleware (e.g., defined by a third-party\nlibrary), use  Zend\\Stratigility\\doublePassMiddleware()  to decorate it prior to\npiping or routing to it:  use Zend\\Diactoros\\Response;\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\n$app->pipe(doublePassMiddleware($someDoublePassMiddleware, new Response()));\n\n$app->get('/foo', doublePassMiddleware($someDoublePassMiddleware, new Response()));  Additionally, the following methods were  removed :   pipeRoutingMiddleware() : use  pipe(\\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class) \n  instead.  pipeDispatchMiddleware() : use  pipe(\\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class) \n  instead.  getContainer()  getDefaultDelegate() : ensure you pipe middleware or a request handler\n  capable of returning a response at the innermost layer;\n   Zend\\Expressive\\Handler\\NotFoundHandler  can be used for this.  getEmitter() : use the  Zend\\HttpHandlerRunner\\Emitter\\EmitterInterface  service from the container.  injectPipelineFromConfig() : use the new  ApplicationConfigInjectionDelegator  and/or the static method of the same name it defines.  injectRoutesFromConfig() : use the new  ApplicationConfigInjectionDelegator  and/or the static method of the same name it defines.",
            "title": "Application"
        },
        {
            "location": "/v3/reference/migration/#applicationfactory",
            "text": "Zend\\Expressive\\Container\\ApplicationFactory  no longer looks at the zend-expressive.programmatic_pipeline  flag, nor does it inject pipeline\nmiddleware and/or routed middleware from configuration any longer.  If you want to use configuration-driven pipelines and/or middleware, you may\nregister the new class  Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator \nas a delegator factory on the  Zend\\Expressive\\Application  service.",
            "title": "ApplicationFactory"
        },
        {
            "location": "/v3/reference/migration/#notfoundhandlerfactory",
            "text": "Zend\\Expressive\\Container\\NotFoundHandlerFactory  now returns an instance of Zend\\Expressive\\Handler\\NotFoundHandler , instead of Zend\\Expressive\\Middleware\\NotFoundHandler  (which has been removed).",
            "title": "NotFoundHandlerFactory"
        },
        {
            "location": "/v3/reference/migration/#lazyloadingmiddleware",
            "text": "Zend\\Expressive\\Middleware\\LazyLoadingMiddleware  now composes a Zend\\Expressive\\MiddlewareContainer  instance instead of a more general PSR-11\ncontainer; this is to ensure that the value returned is a PSR-15 MiddlewareInterface  instance.",
            "title": "LazyLoadingMiddleware"
        },
        {
            "location": "/v3/reference/migration/#removed-classes-and-traits",
            "text": "Zend\\Expressive\\AppFactory  was removed. If you were using it previously,\n  either use  Zend\\Expressive\\Application  directly, or a\n   Zend\\Stratigility\\MiddlewarePipe  instance.    Zend\\Expressive\\ApplicationConfigInjectionTrait ; the functionality of this\n  trait was replaced by the  Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator .    Zend\\Expressive\\Delegate\\NotFoundDelegate ; use  Zend\\Expressive\\Handler\\NotFoundHandler \n  instead. Its factory,  Zend\\Expressive\\Container\\NotFoundDelegateFactory , was\n  also removed.    Zend\\Expressive\\Emitter\\EmitterStack ; use  Zend\\HttpHandlerRunner\\Emitter\\EmitterStack \n  instead.    Zend\\Expressive\\IsCallableInteropMiddlewareTrait ; there is no functional\n  equivalent, nor a need for this functionality as of version 3.    Zend\\Expressive\\MarshalMiddlewareTrait ; the functionality of this trait was\n  replaced by a combination of  Zend\\Expressive\\MiddlewareContainer  and\n   Zend\\Expressive\\MiddlewareFactory .    Zend\\Expressive\\Middleware\\DispatchMiddleware ; use\n   Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware  instead.    Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware ; use\n   Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware  instead.    Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware ; use\n   Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware  instead.    Zend\\Expressive\\Middleware\\NotFoundHandler ; use  Zend\\Expressive\\Handler\\NotFoundHandler \n  instead.    Zend\\Expressive\\Middleware\\RouteMiddleware ; use\n   Zend\\Expressive\\Router\\Middleware\\RouteMiddleware  instead.",
            "title": "Removed classes and traits"
        },
        {
            "location": "/v3/reference/migration/#upgrading",
            "text": "We provide a package you can add to your existing v2 application in order to\nupgrade it to version 3.  Before installing and running the migration tooling, make sure you have checked\nin your latest changes (assuming you are using version control), or have a\nbackup of your existing code.  Install the migration tooling using the following command:  $ composer require --dev zendframework/zend-expressive-migration  Once installed, run the following command to migrate your application:  $ ./vendor/bin/expressive-migration migrate  This package does the following:   Uninstalls all current dependencies (by removing the  vendor/  directory).  Updates existing dependency constraints for known Expressive packages to their\n  latest stable versions. (See the tools  README \n  for details on what versions of which packages the tool uses.)  Adds development dependencies on zendframework/zend-component-installer and\n  zendframework/zend-expressive-tooling.  Updates the  config/pipeline.php  file to:  add strict type declarations.  modify it to return a callable, per the v3 skeleton.  update the middleware pipeline as follows:  pipeRoutingMiddleware()  becomes a  pipe()  operation referencing the\n  zend-expressive-router  RouteMiddleware .  pipeDispatchMiddleware()  becomes a  pipe()  operation referencing the\n  zend-expressive-router  DispatchMiddleware .  update references to  ImplicitHeadMiddleware  to reference the version\n  in zend-expressive-router.  update references to  ImplicitOptionsMiddleware  to reference the version\n  in zend-expressive-router.  update references to  Zend\\Expressive\\Middleware\\NotFoundHandler  to\n  reference  Zend\\Expressive\\Handler\\NotFoundHandler .  add a  pipe()  entry for the zend-expressive-router\n   MethodNotAllowedMiddleware .      Updates the  config/routes.php  file to:  add strict type declarations.  modify it to return a callable, per the v3 skeleton.    Replaces the  public/index.php  file with the latest version from the skeleton.  Updates  config/container.php  when Pimple or Aura.Di are in use:  For Pimple:  The package  xtreamwayz/pimple-container-interop  is replaced with\n   zendframework/zend-pimple-config .  The Pimple variant of  container.php  from the v3 skeleton is used.    For Aura.Di  The package  aura/di  is replaced with  zendframework/zend-auradi-config .  The Aura.Di variant of  container.php  from the v3 skeleton is used.      Executes  ./vendor/bin/expressive migrate:interop-middleware .  Executes  ./vendor/bin/expressive migrate:middleware-to-request-handler .  Runs  ./vendor/bin/phpcbf  if it is installed.   These steps should take care of most migration tasks.  It  does not  update unit tests. These cannot be automatically updated, due to\nthe amount of variance in testing strategies.  When done, use a diffing tool to compare and verify all changes. Please be aware\nthat the tool is not designed for edge cases; there may be things it does not do\nor cannot catch within your code. When unsure, refer to the other sections in\nthis document to determine what else you may need to change.",
            "title": "Upgrading"
        },
        {
            "location": "/v2/",
            "text": "Expressive: PSR-7 Middleware in Minutes\n\n\nExpressive builds on \nStratigility\n\nto provide a minimalist \nPSR-7\n middleware\nframework for PHP, with the following features:\n\n\n\n\nRouting. Choose your own router; we support:\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-router\n\n\n\n\n\n\nDI Containers, via \nPSR-11 Container\n.\n  All middleware composed in Expressive may be retrieved from the composed\n  container.\n\n\nOptionally, templating. We support:\n\n\nPlates\n\n\nTwig\n\n\nZF2's PhpRenderer\n\n\n\n\n\n\nError handling. Create templated error pages, or use tools like\n  \nwhoops\n for debugging purposes.\n\n\nNested middleware applications. Write an application, and compose it later\n  in another, optionally under a separate subpath.\n\n\nSimplified installation\n. Our custom\n  \nComposer\n-based installer prompts you for your\n  initial stack choices, giving you exactly the base you want to start from.\n\n\n\n\nEssentially, Expressive allows \nyou\n to develop using the tools \nyou\n prefer,\nand provides minimal structure and facilities to ease your development.\n\n\nShould I choose it over Zend\\Mvc?\nThat\u2019s a good question. \nHere\u2019s what we recommend.\n\n\nIf you\u2019re keen to get started, then \nkeep reading\n\nand get started writing your first middleware application today!",
            "title": "Expressive: PSR-7 Middleware in Minutes"
        },
        {
            "location": "/v2/#expressive-psr-7-middleware-in-minutes",
            "text": "Expressive builds on  Stratigility \nto provide a minimalist  PSR-7  middleware\nframework for PHP, with the following features:   Routing. Choose your own router; we support:  Aura.Router  FastRoute  zend-router    DI Containers, via  PSR-11 Container .\n  All middleware composed in Expressive may be retrieved from the composed\n  container.  Optionally, templating. We support:  Plates  Twig  ZF2's PhpRenderer    Error handling. Create templated error pages, or use tools like\n   whoops  for debugging purposes.  Nested middleware applications. Write an application, and compose it later\n  in another, optionally under a separate subpath.  Simplified installation . Our custom\n   Composer -based installer prompts you for your\n  initial stack choices, giving you exactly the base you want to start from.   Essentially, Expressive allows  you  to develop using the tools  you  prefer,\nand provides minimal structure and facilities to ease your development.  Should I choose it over Zend\\Mvc?\nThat\u2019s a good question.  Here\u2019s what we recommend.  If you\u2019re keen to get started, then  keep reading \nand get started writing your first middleware application today!",
            "title": "Expressive: PSR-7 Middleware in Minutes"
        },
        {
            "location": "/v2/getting-started/features/",
            "text": "Overview\n\n\nExpressive allows you to write \nPSR-7\n\n\nmiddleware\n\napplications for the web.\n\n\nPSR-7 is a standard defining HTTP message interfaces; these are the incoming\nrequest and outgoing response for your application. By using PSR-7, we ensure\nthat your applications will work in other PSR-7 contexts.\n\n\nMiddleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.\n\n\nMiddleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.\n\n\nWith Expressive, you can build PSR-7-based middleware applications:\n\n\n\n\nAPIs\n\n\nWebsites\n\n\nSingle Page Applications\n\n\nand more.\n\n\n\n\nFeatures\n\n\nExpressive builds on \nzend-stratigility\n\nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:\n\n\n\n\nRouting\n\n\n\n\nStratigility provides limited, literal matching only. Expressive allows you\n  to utilize dynamic routing capabilities from a variety of routers, providing\n  much more fine-grained matching capabilities. The routing layer also allows\n  restricting matched routes to specific HTTP methods, and will return \"405 Not\n  Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP\n  methods for invalid requests.\n\n\nRouting is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-mvc router.\n\n\n\n\nPSR-11 Container\n\n\n\n\nExpressive encourages the use of Dependency Injection, and defines its\n  \nApplication\n class to compose a \nPSR-11\n\n  \nContainerInterface\n instance. The container is used to lazy-load middleware,\n  whether it is piped (Stratigility interface) or routed (Expressive).\n\n\n\n\nTemplating\n\n\n\n\nWhile Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.\n\n\n\n\nError Handling\n\n\n\n\nApplications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own \nErrorHandler\n implementation, providing\n  specialized error response generators that can perform templating or use\n  Whoops.\n\n\nFlow Overview\n\n\nBelow is a diagram detailing the workflow used by Expressive.\n\n\n\n\nThe \nApplication\n acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.\n\n\nThe \nApplication\n dispatches each middleware. Each middleware receives a request\nand a delegate for handing off processing of the request should the middleware\nnot be able to fully process it itself. Internally, the delegate composes a\nqueue of middleware, and invokes the next in the queue when invoked.\n\n\nAny given middleware can return a \nresponse\n, at which point execution winds\nits way back out the onion.\n\n\n\n\nPipelines\n\n\nThe terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a \nqueue\n, which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:\n\n\n\n\nIn most cases, the entire queue \nwill not\n be traversed.\n\n\nThe inner-most layer of the onion represents the last item in the queue, and\n  should be guaranteed to return a response; usually this is indicative of\n  a malformed request (HTTP 400 response status) and/or inability to route\n  the middleware to a handler (HTTP 404 response status).\n\n\nResponses are returned back \nthrough\n the pipeline, in reverse order of\n  traversal.\n\n\n\n\nDouble pass middleware\n\n\nThe system described above is what is known as \nlambda middleware\n. Each\nmiddleware receives the request and the delegate, and you pass only the\nrequest to the delegate when wanting to hand off processing:\n\n\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Test', time());\n}\n\n\n\nIn Expressive 1.X, the default middleware style was what is known as \ndouble\npass\n middleware. Double pass middleware receives both the request and a\nresponse in addition to the delegate, and passes both the request and response\nto the delegate when invoking it:\n\n\nfunction (ServerRequestInterface $request, ResponseInterface $response, callable $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Test', time());\n}\n\n\n\nIt is termed \"double pass\" because you pass both the request and response when\ndelegating to the next layer.\n\n\nExpressive 2.X still supports double-pass middleware, though we recommend the\nlambda style.\n\n\n\n\nThe \nApplication\n allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.\n\n\nYou can attach middleware manually, in which case the pipeline is executed in\nthe order of attachment, or use configuration. When you use configuration, you\nwill specify a priority integer to dictate the order in which middleware should\nbe attached. Middleware specifying high integer priorities are attached (and\nthus executed) earlier, while those specifying lower and/or negative integers\nare attached later. The default priority is 1.\n\n\nExpressive provides default implementations of \"routing\" and \"dispatch\"\nmiddleware, which you either attach to the middleware pipeline manually, or via\nconfiguration. These are implemented as the classes\n\nZend\\Expressive\\Middleware\\RouteMiddleware\n and\n\nZend\\Expressive\\Middleware\\DispatchMiddleware\n, respectively.\n\n\nRouting within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:\n\n\n\n\nmap a GET request to the path \n/api/ping\n to the \nPingMiddleware\n\n\nmap a POST request to the path \n/contact/process\n to the \nHandleContactMiddleware\n\n\netc.\n\n\n\n\nDispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation.\n\n\nThe majority of your application will consist of routing rules that map to\nrouted middleware.\n\n\nMiddleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:\n\n\n\n\nbootstrapping\n\n\nparsing of request body parameters\n\n\naddition of debugging tools\n\n\nembedded Expressive applications that you want to match at a given literal\n  path\n\n\netc.\n\n\n\n\nSuch middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.\n\n\nMiddleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:\n\n\n\n\nrouting failed\n\n\nrouted middleware called on the next middleware instead of returning a response.\n\n\n\n\nAs such, the largest use case for such middleware is to provide a \"default\"\nerror response for your application, usually as an HTTP 404 Not Found response.\n\n\nThe main points to remember are:\n\n\n\n\nThe application is a queue, and operates in FIFO order.\n\n\nEach middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.\n\n\nMost of the time, you will be defining \nrouted middleware\n, and the routing\n  rules that map to them.\n\n\nYou\n get to control the workflow of your application by deciding the order in\n  which middleware is queued.",
            "title": "Overview and Features"
        },
        {
            "location": "/v2/getting-started/features/#overview",
            "text": "Expressive allows you to write  PSR-7  middleware \napplications for the web.  PSR-7 is a standard defining HTTP message interfaces; these are the incoming\nrequest and outgoing response for your application. By using PSR-7, we ensure\nthat your applications will work in other PSR-7 contexts.  Middleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.  Middleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.  With Expressive, you can build PSR-7-based middleware applications:   APIs  Websites  Single Page Applications  and more.",
            "title": "Overview"
        },
        {
            "location": "/v2/getting-started/features/#features",
            "text": "Expressive builds on  zend-stratigility \nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:   Routing   Stratigility provides limited, literal matching only. Expressive allows you\n  to utilize dynamic routing capabilities from a variety of routers, providing\n  much more fine-grained matching capabilities. The routing layer also allows\n  restricting matched routes to specific HTTP methods, and will return \"405 Not\n  Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP\n  methods for invalid requests.  Routing is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-mvc router.   PSR-11 Container   Expressive encourages the use of Dependency Injection, and defines its\n   Application  class to compose a  PSR-11 \n   ContainerInterface  instance. The container is used to lazy-load middleware,\n  whether it is piped (Stratigility interface) or routed (Expressive).   Templating   While Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.   Error Handling   Applications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own  ErrorHandler  implementation, providing\n  specialized error response generators that can perform templating or use\n  Whoops.",
            "title": "Features"
        },
        {
            "location": "/v2/getting-started/features/#flow-overview",
            "text": "Below is a diagram detailing the workflow used by Expressive.   The  Application  acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.  The  Application  dispatches each middleware. Each middleware receives a request\nand a delegate for handing off processing of the request should the middleware\nnot be able to fully process it itself. Internally, the delegate composes a\nqueue of middleware, and invokes the next in the queue when invoked.  Any given middleware can return a  response , at which point execution winds\nits way back out the onion.",
            "title": "Flow Overview"
        },
        {
            "location": "/v2/getting-started/features/#pipelines",
            "text": "The terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a  queue , which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:   In most cases, the entire queue  will not  be traversed.  The inner-most layer of the onion represents the last item in the queue, and\n  should be guaranteed to return a response; usually this is indicative of\n  a malformed request (HTTP 400 response status) and/or inability to route\n  the middleware to a handler (HTTP 404 response status).  Responses are returned back  through  the pipeline, in reverse order of\n  traversal.",
            "title": "Pipelines"
        },
        {
            "location": "/v2/getting-started/features/#double-pass-middleware",
            "text": "The system described above is what is known as  lambda middleware . Each\nmiddleware receives the request and the delegate, and you pass only the\nrequest to the delegate when wanting to hand off processing:  function (ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    $response = $delegate->process($request);\n    return $response->withHeader('X-Test', time());\n}  In Expressive 1.X, the default middleware style was what is known as  double\npass  middleware. Double pass middleware receives both the request and a\nresponse in addition to the delegate, and passes both the request and response\nto the delegate when invoking it:  function (ServerRequestInterface $request, ResponseInterface $response, callable $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Test', time());\n}  It is termed \"double pass\" because you pass both the request and response when\ndelegating to the next layer.  Expressive 2.X still supports double-pass middleware, though we recommend the\nlambda style.   The  Application  allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.  You can attach middleware manually, in which case the pipeline is executed in\nthe order of attachment, or use configuration. When you use configuration, you\nwill specify a priority integer to dictate the order in which middleware should\nbe attached. Middleware specifying high integer priorities are attached (and\nthus executed) earlier, while those specifying lower and/or negative integers\nare attached later. The default priority is 1.  Expressive provides default implementations of \"routing\" and \"dispatch\"\nmiddleware, which you either attach to the middleware pipeline manually, or via\nconfiguration. These are implemented as the classes Zend\\Expressive\\Middleware\\RouteMiddleware  and Zend\\Expressive\\Middleware\\DispatchMiddleware , respectively.  Routing within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:   map a GET request to the path  /api/ping  to the  PingMiddleware  map a POST request to the path  /contact/process  to the  HandleContactMiddleware  etc.   Dispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation.  The majority of your application will consist of routing rules that map to\nrouted middleware.  Middleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:   bootstrapping  parsing of request body parameters  addition of debugging tools  embedded Expressive applications that you want to match at a given literal\n  path  etc.   Such middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.  Middleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:   routing failed  routed middleware called on the next middleware instead of returning a response.   As such, the largest use case for such middleware is to provide a \"default\"\nerror response for your application, usually as an HTTP 404 Not Found response.  The main points to remember are:   The application is a queue, and operates in FIFO order.  Each middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.  Most of the time, you will be defining  routed middleware , and the routing\n  rules that map to them.  You  get to control the workflow of your application by deciding the order in\n  which middleware is queued.",
            "title": "Double pass middleware"
        },
        {
            "location": "/v2/getting-started/standalone/",
            "text": "Quick Start: Standalone Usage\n\n\nExpressive allows you to get started at your own pace. You can start with\nthe simplest example, detailed below, or move on to a more structured,\nconfiguration-driven approach as detailed in the \nuse case examples\n.\n\n\n\n\nDeprecated with version 2.2\n\n\nThe \nZend\\Expressive\\AppFactory\n detailed in this chapter is deprecated as of\nversion 2.2, and will be removed in version 3.0. We recommend instead\nconstructing \nZend\\Expressive\\Application\n manually, or using a\n\nZend\\Stratigility\\MiddlewarePipe\n instance instead.\n\n\n\n\n1. Create a new project directory\n\n\nFirst, let's create a new project directory and enter it:\n\n\n$ mkdir expressive\n$ cd expressive\n\n\n\n2. Install Expressive\n\n\nIf you haven't already, \ninstall Composer\n. Once you\nhave, we can install Expressive, along with a router and a container:\n\n\n$ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager\n\n\n\n\n\nRouters\n\n\nExpressive needs a routing implementation in order to create routed\nmiddleware. We suggest FastRoute in the quick start, but you can also\ncurrently choose from Aura.Router and zend-router.\n\n\nContainers\n\n\nWe highly recommend using dependency injection containers with Expressive;\nthey allow you to define dependencies for your middleware, as well as to lazy\nload your middleware only when it needs to be executed. We suggest\nzend-servicemanager in the quick start, but you can also use any container\nsupporting \nPSR-11 Container\n.\n\n\n\n\n3. Create a web root directory\n\n\nYou'll need a directory from which to serve your application, and for security\nreasons, it's a good idea to keep it separate from your source code. We'll\ncreate a \npublic/\n directory for this:\n\n\n$ mkdir public\n\n\n\n4. Create your bootstrap script\n\n\nNext, we'll create a bootstrap script. Such scripts typically setup the\nenvironment, setup the application, and invoke it. This needs to be in our web\nroot, and we want it to intercept any incoming request; as such, we'll use\n\npublic/index.php\n:\n\n\n<?php\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\AppFactory;\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$app = AppFactory::create();\n\n$app->get('/', function ($request, DelegateInterface $delegate) {\n    return new TextResponse('Hello, world!');\n});\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->run();\n\n\n\n\n\nRewriting URLs\n\n\nMany web servers will not rewrite URLs to the bootstrap script by default. If\nyou use Apache, for instance, you'll need to setup rewrite rules to ensure\nyour bootstrap is invoked for unknown URLs. We'll cover that in a later\nchapter.\n\n\nRouting and dispatching\n\n\nNote the lines from the above:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nExpressive's \nApplication\n class provides two separate middlewares, one for\nrouting, and one for dispatching middleware matched by routing. This allows\nyou to slip in validations between the two activities if desired. They are\nnot automatically piped to the application, however, to allow exactly that\nsituation, which means they must be piped manually.\n\n\n\n\n5. Start a web server\n\n\nSince we're just testing out the basic functionality of our application, we'll\nuse PHP's \nbuilt-in web server\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ php -S 0.0.0.0:8080 -t public/\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\n\n\nTip: Serve via Composer\n\n\nTo simplify starting up a local web server, try adding the following to your\n\ncomposer.json\n:\n\n\n\"scripts\": {\n    \"serve\": \"php -S 0.0.0.0:8080 -t public/\"\n}\n\n\n\nOnce you've added that, you can fire up the web server using:\n\n\n$ composer serve\n\n\n\nSetting a timeout\n\n\nComposer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the \nphp -S\n command that \ncomposer serve\n spawns continues running\nas a background process, but on other systems halts when the timeout occurs.\n\n\nAs such, we recommend running the \nserve\n script using a timeout. This can\nbe done by using \ncomposer run\n to execute the \nserve\n script, with a\n\n--timeout\n option. When set to \n0\n, as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via\n\nCtrl-C\n). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:\n\n\n$ composer run --timeout=86400 serve\n\n\n\n\n\nNext steps\n\n\nAt this point, you have a working zend-expressive application, that responds to\na single route. From here, you may want to read up on:\n\n\n\n\nApplications\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling\n\n\n\n\nAdditionally, we have more \nuse case examples\n.",
            "title": "Quick Start: Standalone"
        },
        {
            "location": "/v2/getting-started/standalone/#quick-start-standalone-usage",
            "text": "Expressive allows you to get started at your own pace. You can start with\nthe simplest example, detailed below, or move on to a more structured,\nconfiguration-driven approach as detailed in the  use case examples .",
            "title": "Quick Start: Standalone Usage"
        },
        {
            "location": "/v2/getting-started/standalone/#deprecated-with-version-22",
            "text": "The  Zend\\Expressive\\AppFactory  detailed in this chapter is deprecated as of\nversion 2.2, and will be removed in version 3.0. We recommend instead\nconstructing  Zend\\Expressive\\Application  manually, or using a Zend\\Stratigility\\MiddlewarePipe  instance instead.",
            "title": "Deprecated with version 2.2"
        },
        {
            "location": "/v2/getting-started/standalone/#1-create-a-new-project-directory",
            "text": "First, let's create a new project directory and enter it:  $ mkdir expressive\n$ cd expressive",
            "title": "1. Create a new project directory"
        },
        {
            "location": "/v2/getting-started/standalone/#2-install-expressive",
            "text": "If you haven't already,  install Composer . Once you\nhave, we can install Expressive, along with a router and a container:  $ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager",
            "title": "2. Install Expressive"
        },
        {
            "location": "/v2/getting-started/standalone/#routers",
            "text": "Expressive needs a routing implementation in order to create routed\nmiddleware. We suggest FastRoute in the quick start, but you can also\ncurrently choose from Aura.Router and zend-router.",
            "title": "Routers"
        },
        {
            "location": "/v2/getting-started/standalone/#containers",
            "text": "We highly recommend using dependency injection containers with Expressive;\nthey allow you to define dependencies for your middleware, as well as to lazy\nload your middleware only when it needs to be executed. We suggest\nzend-servicemanager in the quick start, but you can also use any container\nsupporting  PSR-11 Container .",
            "title": "Containers"
        },
        {
            "location": "/v2/getting-started/standalone/#3-create-a-web-root-directory",
            "text": "You'll need a directory from which to serve your application, and for security\nreasons, it's a good idea to keep it separate from your source code. We'll\ncreate a  public/  directory for this:  $ mkdir public",
            "title": "3. Create a web root directory"
        },
        {
            "location": "/v2/getting-started/standalone/#4-create-your-bootstrap-script",
            "text": "Next, we'll create a bootstrap script. Such scripts typically setup the\nenvironment, setup the application, and invoke it. This needs to be in our web\nroot, and we want it to intercept any incoming request; as such, we'll use public/index.php :  <?php\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\AppFactory;\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$app = AppFactory::create();\n\n$app->get('/', function ($request, DelegateInterface $delegate) {\n    return new TextResponse('Hello, world!');\n});\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->run();",
            "title": "4. Create your bootstrap script"
        },
        {
            "location": "/v2/getting-started/standalone/#rewriting-urls",
            "text": "Many web servers will not rewrite URLs to the bootstrap script by default. If\nyou use Apache, for instance, you'll need to setup rewrite rules to ensure\nyour bootstrap is invoked for unknown URLs. We'll cover that in a later\nchapter.",
            "title": "Rewriting URLs"
        },
        {
            "location": "/v2/getting-started/standalone/#routing-and-dispatching",
            "text": "Note the lines from the above:  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();  Expressive's  Application  class provides two separate middlewares, one for\nrouting, and one for dispatching middleware matched by routing. This allows\nyou to slip in validations between the two activities if desired. They are\nnot automatically piped to the application, however, to allow exactly that\nsituation, which means they must be piped manually.",
            "title": "Routing and dispatching"
        },
        {
            "location": "/v2/getting-started/standalone/#5-start-a-web-server",
            "text": "Since we're just testing out the basic functionality of our application, we'll\nuse PHP's  built-in web server .  From the project root directory, execute the following:  $ php -S 0.0.0.0:8080 -t public/  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!",
            "title": "5. Start a web server"
        },
        {
            "location": "/v2/getting-started/standalone/#tip-serve-via-composer",
            "text": "To simplify starting up a local web server, try adding the following to your composer.json :  \"scripts\": {\n    \"serve\": \"php -S 0.0.0.0:8080 -t public/\"\n}  Once you've added that, you can fire up the web server using:  $ composer serve",
            "title": "Tip: Serve via Composer"
        },
        {
            "location": "/v2/getting-started/standalone/#setting-a-timeout",
            "text": "Composer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the  php -S  command that  composer serve  spawns continues running\nas a background process, but on other systems halts when the timeout occurs.  As such, we recommend running the  serve  script using a timeout. This can\nbe done by using  composer run  to execute the  serve  script, with a --timeout  option. When set to  0 , as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via Ctrl-C ). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:  $ composer run --timeout=86400 serve",
            "title": "Setting a timeout"
        },
        {
            "location": "/v2/getting-started/standalone/#next-steps",
            "text": "At this point, you have a working zend-expressive application, that responds to\na single route. From here, you may want to read up on:   Applications  Containers  Routing  Templating  Error Handling   Additionally, we have more  use case examples .",
            "title": "Next steps"
        },
        {
            "location": "/v2/getting-started/skeleton/",
            "text": "Quick Start: Using the Skeleton + Installer\n\n\nThe easiest way to get started with Expressive is to use the \nskeleton\napplication and installer\n.\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.\n\n\nCreate a new project\n\n\nFirst, we'll create a new project, using Composer's \ncreate-project\n command:\n\n\n$ composer create-project zendframework/zend-expressive-skeleton expressive\n\n\n\nThis will prompt you to choose:\n\n\n\n\n\n\nWhether to install a minimal skeleton (no default middleware), a flat\n  application structure (all code under \nsrc/\n), or a modular structure\n  (directories under \nsrc/\n are modules, each with source code and potentially\n  templates, configuration, assets, etc.).\n\n\n\n\n\n\nA dependency injection container. We recommend using the default, Zend\n  ServiceManager.\n\n\n\n\n\n\nA router. We recommend using the default, FastRoute.\n\n\n\n\n\n\nA template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.\n\n\n\n\n\n\nAn error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.\n\n\n\n\n\n\nStart a web server\n\n\nThe Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using \nbuilt-in web\nserver\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ composer run --timeout=0 serve\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\n\n\nSetting a timeout\n\n\nComposer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the \nphp -S\n command that \ncomposer serve\n spawns continues running\nas a background process, but on other systems halts when the timeout occurs.\n\n\nAs such, we recommend running the \nserve\n script using a timeout. This can\nbe done by using \ncomposer run\n to execute the \nserve\n script, with a\n\n--timeout\n option. When set to \n0\n, as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via\n\nCtrl-C\n). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:\n\n\n$ composer run --timeout=86400 serve\n\n\n\n\n\nDevelopment Tools\n\n\nWe ship tools in our skeleton application to make development easier.\n\n\nDevelopment Mode\n\n\nzf-development-mode\n allows\nyou to enable and disable development mode from your cli.\n\n\n$ composer development-enable  # enable development mode\n$ composer development-disable # disable development mode\n$ composer development-status  # show development status\n\n\n\nThe development configuration is set in \nconfig/autoload/development.local.php.dist\n.\nIt also allows you to specify configuration and modules that should only be enabled\nwhen in development, and not when in production.\n\n\nClear config cache\n\n\nProduction settings are the default, which means enabling the configuration cache.\nHowever, it must be easy for developers to clear the configuration cache. That's\nwhat this command does.\n\n\n$ composer clear-config-cache\n\n\n\nTesting Your Code\n\n\nPHPUnit\n and\n\nPHP_CodeSniffer\n are now\ninstalled by default. To execute tests and detect coding standards violations,\nrun the following command:\n\n\n$ composer check\n\n\n\nSecurity Advisories\n\n\nWe have included the \nsecurity-advisories\n\npackage to notify you about installed dependencies with known security\nvulnerabilities. Each time you run \ncomposer update\n, \ncomposer install\n, or\n\ncomposer require\n, it prevents installation of software with known and\ndocumented security issues.\n\n\nModules\n\n\nComposer will prompt you during installation to ask if you want a\nminimal application (no structure or default middleware provided), flat\napplication (all source code under the same tree, and the default selection), or\nmodular application. This latter option is new in the version 2 series, and\nallows you to segregate discrete areas of application functionality into\n\nmodules\n, which can contain source code, templates, assets, and more; these can\nlater be repackaged for re-use if desired.\n\n\nSupport for modules is available via the\n\nzend-component-installer\n\nand \nzend-config-aggregator\n\npackages; the \nzend-expressive-tooling\n.\npackage provides tools for creating and manipulating modules in your\napplication.\n\n\nComponent Installer\n\n\nWhenever you add a component or module that exposes itself as such, the\n\nzend-component-installer\n\ncomposer plugin will prompt you, asking if and where you want to inject its\nconfiguration. This ensures that components are wired automatically for you.\n\n\nIn most cases, you will choose to inject in the \nconfig/config.php\n file; for\ntools intended only for usage during development, choose\n\nconfig/development.config.php.dist\n.\n\n\nConfig Aggregator\n\n\nThe \nzend-config-aggregator\n\nlibrary collects and merges configuration from different sources. It also supports\nconfiguration caching.\n\n\nAs an example, your \nconfig/config.php\n file might read as follows in order to\naggregate configuration from development mode settings, application\nconfiguration, and theoretical \nUser\n, \nBlog\n, and \nApp\n modules:\n\n\n<?php // config/config.php\n\n$aggregator = new ConfigAggregator([\n    // Module configuration\n    App\\ConfigProvider::class,\n    BlogModule\\ConfigProvider::class,\n    UserModule\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], 'data/config-cache.php');\n\nreturn $aggregator->getMergedConfig();\n\n\n\nThe configuration is merged in the same order as it is passed, with later entries\nhaving precedence.\n\n\nConfig Providers\n\n\nConfigAggregator\n works by aggregating \"Config Providers\" passed to its\nconstructor. Each provider should be a callable class that requires no\nconstructor parameters, where invocation returns a configuration array (or a PHP\ngenerator) to be merged.\n\n\nLibraries or modules can have configuration providers that provide default values\nfor a library or module. For the \nUserModule\\ConfigProvider\n class loaded in the\n\nConfigAggregator\n above, the \nConfigProvider\n might look like this:\n\n\n<?php\n\nnamespace UserModule;\n\nclass ConfigProvider\n{\n    /**\n     * Returns the configuration array\n     *\n     * To add some sort of a structure, each section is defined in a separate\n     * method which returns an array with its configuration.\n     *\n     * @return array\n     */\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'users'        => $this->getConfig(),\n        ];\n    }\n\n    /**\n     * Returns the container dependencies\n     *\n     * @return array\n     */\n    public function getDependencies()\n    {\n        return [\n            'factories'  => [\n                Action\\LoginAction::class =>\n                    Factory\\Action\\LoginActionFactory::class,\n\n                Middleware\\AuthenticationMiddleware::class =>\n                    Factory\\Middleware\\AuthenticationMiddlewareFactory::class,\n            ],\n        ];\n    }\n\n    /**\n     * Returns the default module configuration\n     *\n     * @return array\n     */\n    public function getConfig()\n    {\n        return [\n            'paths' => [\n                'enable_registration' => true,\n                'enable_username'     => false,\n                'enable_display_name' => true,\n            ],\n        ];\n    }\n}\n\n\n\nexpressive-module command\n\n\nTo aid in the creation, registration, and deregistration of modules in your\napplication, the installer will add the \nzendframework/zend-expressive-tooling\n\nas a development requirement when you choose the modular application layout.\n\n\nThe tool is available from your application root directory via\n\n./vendor/bin/expressive-module\n. For brevity, we will only reference the tool's\nname, \nexpressive-module\n, when describing its capabilities.\n\n\nThis tool provides the following functionality:\n\n\n\n\nexpressive-module create <modulename>\n will create the default directory\n  structure for the named module, create a \nConfigProvider\n for the module, add\n  an autoloading rule to \ncomposer.json\n, and register the \nConfigProvider\n with\n  the application configuration.\n\n\nexpressive-module register <modulename>\n will add an autoloading rule to\n  \ncomposer.json\n for the module, and register its \nConfigProvider\n, if found,\n  with the application configuration.\n\n\nexpressive-module deregister <modulename>\n will remove any autoloading rules\n  for the module from \ncomposer.json\n, and deregister its \nConfigProvider\n, if\n  found, from the application configuration.\n\n\n\n\nYou can find out more about its features in the \ncommand line tooling\ndocumentation\n.\n\n\nAdding Middleware\n\n\nThe skeleton makes the assumption that you will be writing your middleware as\nclasses, and uses \npiping and routing\n to add\nyour middleware.\n\n\nPiping\n\n\nPiping\n is a foundation feature of the\nunderlying \nzend-stratigility\n\nimplementation. You can setup the middleware pipeline in \nconfig/pipeline.php\n.\nIn this section, we'll demonstrate setting up a basic pipeline that includes\nerror handling, segregated applications, routing, middleware dispatch, and more.\n\n\nThe error handler should be the first (most outer) middleware to catch all\nexceptions.\n\n\n$app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);\n\n\n\nAfter the \nErrorHandler\n you can pipe more middleware that you want to execute\non every request, such as bootstrapping, pre-conditions, and modifications to\noutgoing responses:\n\n\n$app->pipe(ServerUrlMiddleware::class);\n\n\n\nPiped middleware may be either callables or service names. Middleware may also\nbe passed as an array; each item in the array must resolve to middleware\neventually (i.e., callable or service name); underneath, Expressive creates\n\nZend\\Stratigility\\MiddlewarePipe\n instances with each of the middleware listed\npiped to it.\n\n\nMiddleware can be attached to specific paths, allowing you to mix and match\napplications under a common domain. The handlers in each middleware attached\nthis way will see a URI with the \nMATCHED PATH SEGMENT REMOVED!!!\n\n\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n\n\nNext, you should register the routing middleware in the middleware pipeline:\n\n\n$app->pipeRoutingMiddleware();\n\n\n\nAdd more middleware that needs to introspect the routing results; this might\ninclude:\n\n\n\n\nhandling for HTTP \nHEAD\n requests\n\n\nhandling for HTTP \nOPTIONS\n requests\n\n\nmiddleware for handling URI generation\n\n\nroute-based authentication\n\n\nroute-based validation\n\n\netc.\n\n\n\n\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n\n\n\nNext, register the dispatch middleware in the middleware pipeline:\n\n\n$app->pipeDispatchMiddleware();\n\n\n\nAt this point, if no response is return by any middleware, we need to provide a\nway of notifying the user of this; by default, we use the \nNotFoundHandler\n, but\nyou can provide any other fallback middleware you wish:\n\n\n$app->pipe(NotFoundHandler::class);\n\n\n\nThe full example then looks something like this:\n\n\n// In config/pipeline.php:\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);\n\n// These assume that the variables listed are defined in this scope:\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n$app->pipeRoutingMiddleware();\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n$app->pipe(NotFoundHandler::class);\n\n\n\nRouting\n\n\nRouting\n is an additional feature\nprovided by Expressive. Routing is setup in \nconfig/routes.php\n.\n\n\nYou can setup routes with a single request method:\n\n\n$app->get('/', App\\Action\\HomePageAction::class, 'home');\n$app->post('/album', App\\Action\\AlbumCreateAction::class, 'album.create');\n$app->put('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.put');\n$app->patch('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.patch');\n$app->delete('/album/:id', App\\Action\\AlbumDeleteAction::class, 'album.delete');\n\n\n\nOr with multiple request methods:\n\n\n$app->route('/contact', App\\Action\\ContactAction::class, ['GET', 'POST', ...], 'contact');\n\n\n\nOr handling all request methods:\n\n\n$app->route('/contact', App\\Action\\ContactAction::class)->setName('contact');\n\n\n\nAlternately, to be explicit, the above could be written as:\n\n\n$app->route(\n  '/contact',\n  App\\Action\\ContactAction::class,\n  Zend\\Expressive\\Router\\Route::HTTP_METHOD_ANY,\n  'contact'\n);\n\n\n\nWe recommend a single middleware class per combination of route and request\nmethod.\n\n\nNext Steps\n\n\nThe skeleton provides a default structure for templates, if you choose to use them.\nLet's see how you can create your first vanilla middleware, and templated middleware.\n\n\nCreating middleware\n\n\nTo create middleware, create a class implementing\n\nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n. This interface defines a\nsingle method, \nprocess()\n, which accepts a\n\nPsr\\Http\\Message\\ServerRequestInterface\n instance and an\n\nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instance.\n\n\n\n\nLegacy double-pass middleware\n\n\nPrior to Expressive 2.0, the default middleware style was what is termed\n\"double-pass\", for the fact that it passes both the request and response between\nlayers. This middleware did not require an interface, and relied on a\nconventional definition of:\n\n\nuse Psr\\Http\\Message;\n\nfunction (\n  Message\\ServerRequestInterface $request,\n  Message\\ResponseInterface $response,\n  callable $next\n) : Message\\ResponseInterface\n\n\n\nWhile this style of middleware is still quite wide-spread and used in a number\nof projects, it has some flaws. Chief among them is the fact that middleware\nshould not rely on the \n$response\n instance provided to them (as it may have\nmodifications unacceptable for the current context), and that a response\nreturned from inner layers may not be based off the \n$response\n provided to them\n(as inner layers may create and return a completely different response).\n\n\nStarting in Expressive 2.0, we add support for\n\nhttp-interop/http-middleware\n,\nwhich is a working group of \nPHP-FIG\n dedicated to\ncreating a common middleware standard. This middleware uses what is termed\na \"single-pass\" or \"lambda\" architecture, whereby only the request instance is\npassed between layers. We now recommend writing middleware using the\nhttp-middleware interfaces for all new middleware.\n\n\nMiddleware using the double-pass style is still accepted by Expressive, but\nsupport for it will be discontinued with version 3.\n\n\n\n\nThe skeleton defines an \nApp\n namespace for you, and suggests placing middleware\nunder the namespace \nApp\\Action\n.\n\n\nLet's create a \"Hello\" action. Place the following in\n\nsrc/App/Action/HelloAction.php\n:\n\n\n<?php\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass HelloAction implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // On all PHP versions:\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        // Or, on PHP 7+:\n        $target = $request->getQueryParams()['target'] ?? 'World';\n\n        $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\n\n        return new HtmlResponse(sprintf(\n            '<h1>Hello, %s!</h1>',\n            $target\n        ));\n    }\n}\n\n\n\nThe above looks for a query string parameter \"target\", and uses its value to\nprovide a message, which is then returned in an HTML response.\n\n\nNow we need to inform the application of this middleware, and indicate what\npath will invoke it. Open the file \nconfig/autoload/dependencies.global.php\n.\nEdit that file to add an \ninvokable\n entry for the new middleware:\n\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'invokables' => [\n            App\\Action\\HelloAction::class => App\\Action\\HelloAction::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nNow open the file \nconfig/routes.php\n, and add the following at the bottom of\nthe file:\n\n\n$app->get('/hello', App\\Action\\HelloAction::class, 'hello');\n\n\n\nOnce you've completed the above, give it a try by going to each of the\nfollowing URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYou should see the message change as you go between the two URIs!\n\n\nUsing templates\n\n\nYou likely don't want to hardcode HTML into your middleware; so, let's use\ntemplates. This particular exercise assumes you chose to use the\n\nPlates\n integration.\n\n\nTemplates are installed under the \ntemplates/\n subdirectory. By default, we also\nregister the template namespace \napp\n to correspond with the \ntemplates/app\n\nsubdirectory. Create the file \ntemplates/app/hello-world.phtml\n with the\nfollowing contents:\n\n\n<?php $this->layout('layout::default', ['title' => 'Greetings']) ?>\n\n<h2>Hello, <?= $this->e($target) ?></h2>\n\n\n\nNow that we have a template, we need to:\n\n\n\n\nInject a renderer into our action class.\n\n\nUse the renderer to render the contents.\n\n\n\n\nReplace your \nsrc/App/Action/HelloAction.php\n file with the following contents:\n\n\n<?php\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloAction implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // On all PHP versions:\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        // Or, on PHP 7+:\n        $target = $request->getQueryParams()['target'] ?? 'World';\n\n        return new HtmlResponse(\n            $this->renderer->render('app::hello-world', ['target' => $target])\n        );\n    }\n}\n\n\n\nThe above modifies the class to accept a renderer to the constructor, and then\ncalls on it to render a template. Note that we no longer need to escape our\ntarget; the template takes care of that for us.\n\n\nHow does the template renderer get into the action? The answer is dependency\ninjection.\n\n\nFor the next part of the example, we'll be creating and wiring a factory for\ncreating the \nHelloAction\n instance; the example assumes you used the default\nselection for a dependency injection container, zend-servicemanager.\n\n\nzend-servicemanager provides a tool for generating factories based on\nreflecting a class; we'll use that to generate our factory:\n\n\n$ ./vendor/bin/generate-factory-for-class \"App\\\\Action\\\\HelloAction\" > src/App/Action/HelloActionFactory.php\n\n\n\nWith that in place, we'll now update our configuration. Open the file\n\nconfig/autoload/dependencies.global.php\n; we'll remove the \ninvokables\n entry\nwe created previously, and add a \nfactories\n entry:\n\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'invokables' => [\n            // Remove this entry:\n            App\\Action\\HelloAction::class => App\\Action\\HelloAction::class,\n        ],\n        'factories' => [\n            /* ... */\n            // Add this:\n            App\\Action\\HelloAction::class => App\\Action\\HelloActionFactory::class,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nSave that file, and now re-visit the URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYour page should now have the same layout as the landing page of the skeleton\napplication!\n\n\nCongratulations!\n\n\nCongratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:\n\n\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling",
            "title": "Quick Start: Skeleton Installer"
        },
        {
            "location": "/v2/getting-started/skeleton/#quick-start-using-the-skeleton-installer",
            "text": "The easiest way to get started with Expressive is to use the  skeleton\napplication and installer .\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.",
            "title": "Quick Start: Using the Skeleton + Installer"
        },
        {
            "location": "/v2/getting-started/skeleton/#create-a-new-project",
            "text": "First, we'll create a new project, using Composer's  create-project  command:  $ composer create-project zendframework/zend-expressive-skeleton expressive  This will prompt you to choose:    Whether to install a minimal skeleton (no default middleware), a flat\n  application structure (all code under  src/ ), or a modular structure\n  (directories under  src/  are modules, each with source code and potentially\n  templates, configuration, assets, etc.).    A dependency injection container. We recommend using the default, Zend\n  ServiceManager.    A router. We recommend using the default, FastRoute.    A template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.    An error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.",
            "title": "Create a new project"
        },
        {
            "location": "/v2/getting-started/skeleton/#start-a-web-server",
            "text": "The Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using  built-in web\nserver .  From the project root directory, execute the following:  $ composer run --timeout=0 serve  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!",
            "title": "Start a web server"
        },
        {
            "location": "/v2/getting-started/skeleton/#setting-a-timeout",
            "text": "Composer commands time out after 300 seconds (5 minutes). On Linux-based\nsystems, the  php -S  command that  composer serve  spawns continues running\nas a background process, but on other systems halts when the timeout occurs.  As such, we recommend running the  serve  script using a timeout. This can\nbe done by using  composer run  to execute the  serve  script, with a --timeout  option. When set to  0 , as in the previous example, no timeout\nwill be used, and it will run until you cancel the process (usually via Ctrl-C ). Alternately, you can specify a finite timeout; as an example,\nthe following will extend the timeout to a full day:  $ composer run --timeout=86400 serve",
            "title": "Setting a timeout"
        },
        {
            "location": "/v2/getting-started/skeleton/#development-tools",
            "text": "We ship tools in our skeleton application to make development easier.",
            "title": "Development Tools"
        },
        {
            "location": "/v2/getting-started/skeleton/#development-mode",
            "text": "zf-development-mode  allows\nyou to enable and disable development mode from your cli.  $ composer development-enable  # enable development mode\n$ composer development-disable # disable development mode\n$ composer development-status  # show development status  The development configuration is set in  config/autoload/development.local.php.dist .\nIt also allows you to specify configuration and modules that should only be enabled\nwhen in development, and not when in production.",
            "title": "Development Mode"
        },
        {
            "location": "/v2/getting-started/skeleton/#clear-config-cache",
            "text": "Production settings are the default, which means enabling the configuration cache.\nHowever, it must be easy for developers to clear the configuration cache. That's\nwhat this command does.  $ composer clear-config-cache",
            "title": "Clear config cache"
        },
        {
            "location": "/v2/getting-started/skeleton/#testing-your-code",
            "text": "PHPUnit  and PHP_CodeSniffer  are now\ninstalled by default. To execute tests and detect coding standards violations,\nrun the following command:  $ composer check",
            "title": "Testing Your Code"
        },
        {
            "location": "/v2/getting-started/skeleton/#security-advisories",
            "text": "We have included the  security-advisories \npackage to notify you about installed dependencies with known security\nvulnerabilities. Each time you run  composer update ,  composer install , or composer require , it prevents installation of software with known and\ndocumented security issues.",
            "title": "Security Advisories"
        },
        {
            "location": "/v2/getting-started/skeleton/#modules",
            "text": "Composer will prompt you during installation to ask if you want a\nminimal application (no structure or default middleware provided), flat\napplication (all source code under the same tree, and the default selection), or\nmodular application. This latter option is new in the version 2 series, and\nallows you to segregate discrete areas of application functionality into modules , which can contain source code, templates, assets, and more; these can\nlater be repackaged for re-use if desired.  Support for modules is available via the zend-component-installer \nand  zend-config-aggregator \npackages; the  zend-expressive-tooling .\npackage provides tools for creating and manipulating modules in your\napplication.",
            "title": "Modules"
        },
        {
            "location": "/v2/getting-started/skeleton/#component-installer",
            "text": "Whenever you add a component or module that exposes itself as such, the zend-component-installer \ncomposer plugin will prompt you, asking if and where you want to inject its\nconfiguration. This ensures that components are wired automatically for you.  In most cases, you will choose to inject in the  config/config.php  file; for\ntools intended only for usage during development, choose config/development.config.php.dist .",
            "title": "Component Installer"
        },
        {
            "location": "/v2/getting-started/skeleton/#config-aggregator",
            "text": "The  zend-config-aggregator \nlibrary collects and merges configuration from different sources. It also supports\nconfiguration caching.  As an example, your  config/config.php  file might read as follows in order to\naggregate configuration from development mode settings, application\nconfiguration, and theoretical  User ,  Blog , and  App  modules:  <?php // config/config.php\n\n$aggregator = new ConfigAggregator([\n    // Module configuration\n    App\\ConfigProvider::class,\n    BlogModule\\ConfigProvider::class,\n    UserModule\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], 'data/config-cache.php');\n\nreturn $aggregator->getMergedConfig();  The configuration is merged in the same order as it is passed, with later entries\nhaving precedence.",
            "title": "Config Aggregator"
        },
        {
            "location": "/v2/getting-started/skeleton/#config-providers",
            "text": "ConfigAggregator  works by aggregating \"Config Providers\" passed to its\nconstructor. Each provider should be a callable class that requires no\nconstructor parameters, where invocation returns a configuration array (or a PHP\ngenerator) to be merged.  Libraries or modules can have configuration providers that provide default values\nfor a library or module. For the  UserModule\\ConfigProvider  class loaded in the ConfigAggregator  above, the  ConfigProvider  might look like this:  <?php\n\nnamespace UserModule;\n\nclass ConfigProvider\n{\n    /**\n     * Returns the configuration array\n     *\n     * To add some sort of a structure, each section is defined in a separate\n     * method which returns an array with its configuration.\n     *\n     * @return array\n     */\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'users'        => $this->getConfig(),\n        ];\n    }\n\n    /**\n     * Returns the container dependencies\n     *\n     * @return array\n     */\n    public function getDependencies()\n    {\n        return [\n            'factories'  => [\n                Action\\LoginAction::class =>\n                    Factory\\Action\\LoginActionFactory::class,\n\n                Middleware\\AuthenticationMiddleware::class =>\n                    Factory\\Middleware\\AuthenticationMiddlewareFactory::class,\n            ],\n        ];\n    }\n\n    /**\n     * Returns the default module configuration\n     *\n     * @return array\n     */\n    public function getConfig()\n    {\n        return [\n            'paths' => [\n                'enable_registration' => true,\n                'enable_username'     => false,\n                'enable_display_name' => true,\n            ],\n        ];\n    }\n}",
            "title": "Config Providers"
        },
        {
            "location": "/v2/getting-started/skeleton/#expressive-module-command",
            "text": "To aid in the creation, registration, and deregistration of modules in your\napplication, the installer will add the  zendframework/zend-expressive-tooling \nas a development requirement when you choose the modular application layout.  The tool is available from your application root directory via ./vendor/bin/expressive-module . For brevity, we will only reference the tool's\nname,  expressive-module , when describing its capabilities.  This tool provides the following functionality:   expressive-module create <modulename>  will create the default directory\n  structure for the named module, create a  ConfigProvider  for the module, add\n  an autoloading rule to  composer.json , and register the  ConfigProvider  with\n  the application configuration.  expressive-module register <modulename>  will add an autoloading rule to\n   composer.json  for the module, and register its  ConfigProvider , if found,\n  with the application configuration.  expressive-module deregister <modulename>  will remove any autoloading rules\n  for the module from  composer.json , and deregister its  ConfigProvider , if\n  found, from the application configuration.   You can find out more about its features in the  command line tooling\ndocumentation .",
            "title": "expressive-module command"
        },
        {
            "location": "/v2/getting-started/skeleton/#adding-middleware",
            "text": "The skeleton makes the assumption that you will be writing your middleware as\nclasses, and uses  piping and routing  to add\nyour middleware.",
            "title": "Adding Middleware"
        },
        {
            "location": "/v2/getting-started/skeleton/#piping",
            "text": "Piping  is a foundation feature of the\nunderlying  zend-stratigility \nimplementation. You can setup the middleware pipeline in  config/pipeline.php .\nIn this section, we'll demonstrate setting up a basic pipeline that includes\nerror handling, segregated applications, routing, middleware dispatch, and more.  The error handler should be the first (most outer) middleware to catch all\nexceptions.  $app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);  After the  ErrorHandler  you can pipe more middleware that you want to execute\non every request, such as bootstrapping, pre-conditions, and modifications to\noutgoing responses:  $app->pipe(ServerUrlMiddleware::class);  Piped middleware may be either callables or service names. Middleware may also\nbe passed as an array; each item in the array must resolve to middleware\neventually (i.e., callable or service name); underneath, Expressive creates Zend\\Stratigility\\MiddlewarePipe  instances with each of the middleware listed\npiped to it.  Middleware can be attached to specific paths, allowing you to mix and match\napplications under a common domain. The handlers in each middleware attached\nthis way will see a URI with the  MATCHED PATH SEGMENT REMOVED!!!  $app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);  Next, you should register the routing middleware in the middleware pipeline:  $app->pipeRoutingMiddleware();  Add more middleware that needs to introspect the routing results; this might\ninclude:   handling for HTTP  HEAD  requests  handling for HTTP  OPTIONS  requests  middleware for handling URI generation  route-based authentication  route-based validation  etc.   $app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);  Next, register the dispatch middleware in the middleware pipeline:  $app->pipeDispatchMiddleware();  At this point, if no response is return by any middleware, we need to provide a\nway of notifying the user of this; by default, we use the  NotFoundHandler , but\nyou can provide any other fallback middleware you wish:  $app->pipe(NotFoundHandler::class);  The full example then looks something like this:  // In config/pipeline.php:\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(ErrorHandler::class);\n$app->pipe(ServerUrlMiddleware::class);\n\n// These assume that the variables listed are defined in this scope:\n$app->pipe('/api', $apiMiddleware);\n$app->pipe('/docs', $apiDocMiddleware);\n$app->pipe('/files', $filesMiddleware);\n\n$app->pipeRoutingMiddleware();\n$app->pipe(ImplicitHeadMiddleware::class);\n$app->pipe(ImplicitOptionsMiddleware::class);\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n$app->pipe(NotFoundHandler::class);",
            "title": "Piping"
        },
        {
            "location": "/v2/getting-started/skeleton/#routing",
            "text": "Routing  is an additional feature\nprovided by Expressive. Routing is setup in  config/routes.php .  You can setup routes with a single request method:  $app->get('/', App\\Action\\HomePageAction::class, 'home');\n$app->post('/album', App\\Action\\AlbumCreateAction::class, 'album.create');\n$app->put('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.put');\n$app->patch('/album/:id', App\\Action\\AlbumUpdateAction::class, 'album.patch');\n$app->delete('/album/:id', App\\Action\\AlbumDeleteAction::class, 'album.delete');  Or with multiple request methods:  $app->route('/contact', App\\Action\\ContactAction::class, ['GET', 'POST', ...], 'contact');  Or handling all request methods:  $app->route('/contact', App\\Action\\ContactAction::class)->setName('contact');  Alternately, to be explicit, the above could be written as:  $app->route(\n  '/contact',\n  App\\Action\\ContactAction::class,\n  Zend\\Expressive\\Router\\Route::HTTP_METHOD_ANY,\n  'contact'\n);  We recommend a single middleware class per combination of route and request\nmethod.",
            "title": "Routing"
        },
        {
            "location": "/v2/getting-started/skeleton/#next-steps",
            "text": "The skeleton provides a default structure for templates, if you choose to use them.\nLet's see how you can create your first vanilla middleware, and templated middleware.",
            "title": "Next Steps"
        },
        {
            "location": "/v2/getting-started/skeleton/#creating-middleware",
            "text": "To create middleware, create a class implementing Interop\\Http\\ServerMiddleware\\MiddlewareInterface . This interface defines a\nsingle method,  process() , which accepts a Psr\\Http\\Message\\ServerRequestInterface  instance and an Interop\\Http\\ServerMiddleware\\DelegateInterface  instance.",
            "title": "Creating middleware"
        },
        {
            "location": "/v2/getting-started/skeleton/#legacy-double-pass-middleware",
            "text": "Prior to Expressive 2.0, the default middleware style was what is termed\n\"double-pass\", for the fact that it passes both the request and response between\nlayers. This middleware did not require an interface, and relied on a\nconventional definition of:  use Psr\\Http\\Message;\n\nfunction (\n  Message\\ServerRequestInterface $request,\n  Message\\ResponseInterface $response,\n  callable $next\n) : Message\\ResponseInterface  While this style of middleware is still quite wide-spread and used in a number\nof projects, it has some flaws. Chief among them is the fact that middleware\nshould not rely on the  $response  instance provided to them (as it may have\nmodifications unacceptable for the current context), and that a response\nreturned from inner layers may not be based off the  $response  provided to them\n(as inner layers may create and return a completely different response).  Starting in Expressive 2.0, we add support for http-interop/http-middleware ,\nwhich is a working group of  PHP-FIG  dedicated to\ncreating a common middleware standard. This middleware uses what is termed\na \"single-pass\" or \"lambda\" architecture, whereby only the request instance is\npassed between layers. We now recommend writing middleware using the\nhttp-middleware interfaces for all new middleware.  Middleware using the double-pass style is still accepted by Expressive, but\nsupport for it will be discontinued with version 3.   The skeleton defines an  App  namespace for you, and suggests placing middleware\nunder the namespace  App\\Action .  Let's create a \"Hello\" action. Place the following in src/App/Action/HelloAction.php :  <?php\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass HelloAction implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // On all PHP versions:\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        // Or, on PHP 7+:\n        $target = $request->getQueryParams()['target'] ?? 'World';\n\n        $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\n\n        return new HtmlResponse(sprintf(\n            '<h1>Hello, %s!</h1>',\n            $target\n        ));\n    }\n}  The above looks for a query string parameter \"target\", and uses its value to\nprovide a message, which is then returned in an HTML response.  Now we need to inform the application of this middleware, and indicate what\npath will invoke it. Open the file  config/autoload/dependencies.global.php .\nEdit that file to add an  invokable  entry for the new middleware:  return [\n    'dependencies' => [\n        /* ... */\n        'invokables' => [\n            App\\Action\\HelloAction::class => App\\Action\\HelloAction::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Now open the file  config/routes.php , and add the following at the bottom of\nthe file:  $app->get('/hello', App\\Action\\HelloAction::class, 'hello');  Once you've completed the above, give it a try by going to each of the\nfollowing URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   You should see the message change as you go between the two URIs!",
            "title": "Legacy double-pass middleware"
        },
        {
            "location": "/v2/getting-started/skeleton/#using-templates",
            "text": "You likely don't want to hardcode HTML into your middleware; so, let's use\ntemplates. This particular exercise assumes you chose to use the Plates  integration.  Templates are installed under the  templates/  subdirectory. By default, we also\nregister the template namespace  app  to correspond with the  templates/app \nsubdirectory. Create the file  templates/app/hello-world.phtml  with the\nfollowing contents:  <?php $this->layout('layout::default', ['title' => 'Greetings']) ?>\n\n<h2>Hello, <?= $this->e($target) ?></h2>  Now that we have a template, we need to:   Inject a renderer into our action class.  Use the renderer to render the contents.   Replace your  src/App/Action/HelloAction.php  file with the following contents:  <?php\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloAction implements MiddlewareInterface\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // On all PHP versions:\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        // Or, on PHP 7+:\n        $target = $request->getQueryParams()['target'] ?? 'World';\n\n        return new HtmlResponse(\n            $this->renderer->render('app::hello-world', ['target' => $target])\n        );\n    }\n}  The above modifies the class to accept a renderer to the constructor, and then\ncalls on it to render a template. Note that we no longer need to escape our\ntarget; the template takes care of that for us.  How does the template renderer get into the action? The answer is dependency\ninjection.  For the next part of the example, we'll be creating and wiring a factory for\ncreating the  HelloAction  instance; the example assumes you used the default\nselection for a dependency injection container, zend-servicemanager.  zend-servicemanager provides a tool for generating factories based on\nreflecting a class; we'll use that to generate our factory:  $ ./vendor/bin/generate-factory-for-class \"App\\\\Action\\\\HelloAction\" > src/App/Action/HelloActionFactory.php  With that in place, we'll now update our configuration. Open the file config/autoload/dependencies.global.php ; we'll remove the  invokables  entry\nwe created previously, and add a  factories  entry:  return [\n    'dependencies' => [\n        /* ... */\n        'invokables' => [\n            // Remove this entry:\n            App\\Action\\HelloAction::class => App\\Action\\HelloAction::class,\n        ],\n        'factories' => [\n            /* ... */\n            // Add this:\n            App\\Action\\HelloAction::class => App\\Action\\HelloActionFactory::class,\n        ],\n        /* ... */\n    ],\n];  Save that file, and now re-visit the URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   Your page should now have the same layout as the landing page of the skeleton\napplication!",
            "title": "Using templates"
        },
        {
            "location": "/v2/getting-started/skeleton/#congratulations",
            "text": "Congratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:   Containers  Routing  Templating  Error Handling",
            "title": "Congratulations!"
        },
        {
            "location": "/v2/features/middleware-types/",
            "text": "Middleware Types\n\n\nExpressive allows you to compose applications out of \npipeline\n and \nrouted\n\nmiddleware.\n\n\nPipeline\n middleware is middleware that defines the workflow of your\napplication. These generally run on every execution of the application, and\ninclude such aspects as:\n\n\n\n\nError handling\n\n\nLocale detection\n\n\nSession setup\n\n\nAuthentication and authorization\n\n\n\n\nRouted\n middleware is middleware that responds only to specific URI paths and\nHTTP methods. As an example, you might want middleware that only responds to\nHTTP POST requests to the path \n/users\n.\n\n\nExpressive allows you to define middleware using any of the following:\n\n\n\n\nhttp-interop/http-middleware\n\n  instances.\n\n\nCallable middleware that implements the http-interop/http-middleware signature.\n\n\nCallable \"double-pass\" middleware (as used in Expressive 1.X, and supported in\n  Expressive 2.X).\n\n\nService names resolving to one of the above middleware types.\n\n\nMiddleware pipelines expressed as arrays of the above middleware types.\n\n\n\n\nhttp-interop/http-middleware\n\n\nThe http-interop/http-middleware project is the basis for the proposed\n\nPSR-15\n specification, which covers HTTP\nServer Middleware that consumes \nPSR-7\n HTTP\nmessages. The project defines two interfaces, \nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n\nand \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n. Expressive accepts\nmiddleware that implements the \nMiddlewareInterface\n. As an example:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass SomeMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do something and return a response, or\n        // delegate to another handler capable of\n        // returning a response via:\n        //\n        // return $delegate->process($request);\n    }\n}\n\n\n\nIf you are using PHP 7 or above, you could also implement such middleware via an\nanonymous class.\n\n\nCallable http-middleware\n\n\nSometimes you may not want to create a class for one-off middleware. As such,\nExpressive allows you to provide a PHP callable that uses the same signature as\n\nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    // do something and return a response, or\n    // delegate to another handler capable of\n    // returning a response via:\n    //\n    // return $delegate->process($request);\n}\n\n\n\nOne note: the \n$request\n argument does not require a typehint, and examples\nthroughout the manual will omit the typehint when demonstrating callable\nmiddleware.\n\n\nDouble-pass middleware\n\n\nExpressive 1.X was based on Stratigility 1.X, which allowed middleware with the\nfollowing signature:\n\n\n<?php\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction(\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    // Process the request and return a response,\n    // or delegate to another process to handle\n    // the request via:\n    //\n    // return $next($request, $response);\n}\n\n\n\nThis middleware is called \"double-pass\" due to the fact that it requires both\nthe request and response arguments.\n\n\nIn such middleware, no typehints are \nrequired\n, but they are \nencouraged\n.\nAdditionally, we encourage users to \nnever\n use the provided \n$response\n\nargument, but instead create a concrete response to return, or manipulate the\nresponse returned by \n$next\n; this prevents a number of potential error\nconditions that may otherwise occur due to incomplete or mutated response state.\n\n\nThis middleware is still supported in Expressive 2.X, but we encourage users to\nadopt http-interop/http-middleware signatures, as we will be deprecating\ndouble-pass middleware eventually.\n\n\nService-based middleware\n\n\nWe encourage the use of a dependency injection container for providing your\nmiddleware. As such, Expressive also allows you to use \nservice names\n for both\npipeline and routed middleware. Generally, service names will be the specific\nmiddleware class names, but can be any valid string that resolves to a service.\n\n\nWhen Expressive is provided a service name for middleware, it internally\ndecorates the middleware in a \nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n\ninstance, allowing it to be loaded only when dispatched.\n\n\nMiddleware pipelines\n\n\nExpressive allows any pipeline or routed middleware to be self-contained\n\nmiddleware pipelines\n.\nTo prevent the need for instantiating a \nZend\\Stratigility\\MiddlewarePipe\n or\n\nZend\\Expressive\\Application\n instance when defining the pipeline, Expressive\nallows you to provide an array of middleware:\n\n\n// Pipeline middleware:\n$app->pipe([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n// Routed middleware:\n$app->get([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n\n\nThe values in these arrays may be any valid middleware type as defined in this\nchapter.",
            "title": "Middleware Types"
        },
        {
            "location": "/v2/features/middleware-types/#middleware-types",
            "text": "Expressive allows you to compose applications out of  pipeline  and  routed \nmiddleware.  Pipeline  middleware is middleware that defines the workflow of your\napplication. These generally run on every execution of the application, and\ninclude such aspects as:   Error handling  Locale detection  Session setup  Authentication and authorization   Routed  middleware is middleware that responds only to specific URI paths and\nHTTP methods. As an example, you might want middleware that only responds to\nHTTP POST requests to the path  /users .  Expressive allows you to define middleware using any of the following:   http-interop/http-middleware \n  instances.  Callable middleware that implements the http-interop/http-middleware signature.  Callable \"double-pass\" middleware (as used in Expressive 1.X, and supported in\n  Expressive 2.X).  Service names resolving to one of the above middleware types.  Middleware pipelines expressed as arrays of the above middleware types.",
            "title": "Middleware Types"
        },
        {
            "location": "/v2/features/middleware-types/#http-interophttp-middleware",
            "text": "The http-interop/http-middleware project is the basis for the proposed PSR-15  specification, which covers HTTP\nServer Middleware that consumes  PSR-7  HTTP\nmessages. The project defines two interfaces,  Interop\\Http\\ServerMiddleware\\MiddlewareInterface \nand  Interop\\Http\\ServerMiddleware\\DelegateInterface . Expressive accepts\nmiddleware that implements the  MiddlewareInterface . As an example:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass SomeMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do something and return a response, or\n        // delegate to another handler capable of\n        // returning a response via:\n        //\n        // return $delegate->process($request);\n    }\n}  If you are using PHP 7 or above, you could also implement such middleware via an\nanonymous class.",
            "title": "http-interop/http-middleware"
        },
        {
            "location": "/v2/features/middleware-types/#callable-http-middleware",
            "text": "Sometimes you may not want to create a class for one-off middleware. As such,\nExpressive allows you to provide a PHP callable that uses the same signature as Interop\\Http\\ServerMiddleware\\MiddlewareInterface :  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction (ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    // do something and return a response, or\n    // delegate to another handler capable of\n    // returning a response via:\n    //\n    // return $delegate->process($request);\n}  One note: the  $request  argument does not require a typehint, and examples\nthroughout the manual will omit the typehint when demonstrating callable\nmiddleware.",
            "title": "Callable http-middleware"
        },
        {
            "location": "/v2/features/middleware-types/#double-pass-middleware",
            "text": "Expressive 1.X was based on Stratigility 1.X, which allowed middleware with the\nfollowing signature:  <?php\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nfunction(\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    // Process the request and return a response,\n    // or delegate to another process to handle\n    // the request via:\n    //\n    // return $next($request, $response);\n}  This middleware is called \"double-pass\" due to the fact that it requires both\nthe request and response arguments.  In such middleware, no typehints are  required , but they are  encouraged .\nAdditionally, we encourage users to  never  use the provided  $response \nargument, but instead create a concrete response to return, or manipulate the\nresponse returned by  $next ; this prevents a number of potential error\nconditions that may otherwise occur due to incomplete or mutated response state.  This middleware is still supported in Expressive 2.X, but we encourage users to\nadopt http-interop/http-middleware signatures, as we will be deprecating\ndouble-pass middleware eventually.",
            "title": "Double-pass middleware"
        },
        {
            "location": "/v2/features/middleware-types/#service-based-middleware",
            "text": "We encourage the use of a dependency injection container for providing your\nmiddleware. As such, Expressive also allows you to use  service names  for both\npipeline and routed middleware. Generally, service names will be the specific\nmiddleware class names, but can be any valid string that resolves to a service.  When Expressive is provided a service name for middleware, it internally\ndecorates the middleware in a  Zend\\Expressive\\Middleware\\LazyLoadingMiddleware \ninstance, allowing it to be loaded only when dispatched.",
            "title": "Service-based middleware"
        },
        {
            "location": "/v2/features/middleware-types/#middleware-pipelines",
            "text": "Expressive allows any pipeline or routed middleware to be self-contained middleware pipelines .\nTo prevent the need for instantiating a  Zend\\Stratigility\\MiddlewarePipe  or Zend\\Expressive\\Application  instance when defining the pipeline, Expressive\nallows you to provide an array of middleware:  // Pipeline middleware:\n$app->pipe([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);\n\n// Routed middleware:\n$app->get([\n    FirstMiddleware::class,\n    SecondMiddleware::class,\n]);  The values in these arrays may be any valid middleware type as defined in this\nchapter.",
            "title": "Middleware pipelines"
        },
        {
            "location": "/v2/features/application/",
            "text": "Applications\n\n\nIn zend-expressive, you define a \nZend\\Expressive\\Application\n instance and\nexecute it. The \nApplication\n instance is itself\n\nmiddleware\n\nthat composes:\n\n\n\n\na \nrouter\n, for dynamically routing requests to middleware.\n\n\na \ndependency injection container\n, for retrieving\n  middleware to dispatch.\n\n\na \ndefault delegate\n (Expressive 2.X)\n  or \nfinal handler\n\n\nan \nemitter\n,\n  for emitting the response when application execution is complete.\n\n\n\n\nYou can define the \nApplication\n instance in several ways:\n\n\n\n\nDirect instantiation, which requires providing several dependencies.\n\n\nThe \nAppFactory\n, which will use some common defaults, but allows injecting alternate\n  container and/or router implementations.\n\n\nVia a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.\n\n\n\n\nRegardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.\n\n\nInstantiation\n\n\nAs noted at the start of this document, we provide several ways to create an\n\nApplication\n instance.\n\n\nConstructor\n\n\nIf you wish to manually instantiate the \nApplication\n instance, it has the\nfollowing constructor:\n\n\n/**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Psr\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate\n *     Delegate to invoke when the internal middleware pipeline is exhausted\n *     without returning a response.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Psr\\Container\\ContainerInterface $container = null,\n    Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);\n\n\n\nIf no container is provided at instantiation, then all routed and piped\nmiddleware \nmust\n be provided as callables.\n\n\nAppFactory\n\n\n\n\nDeprecated since version 2.2; instantiate \nApplication\n directly and/or use a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance instead.\n\n\n\n\nZend\\Expressive\\AppFactory\n provides a convenience layer for creating an\n\nApplication\n instance; it makes the assumption that you will use defaults in\nmost situations, and likely only change which container and/or router you wish\nto use. It has the following signature:\n\n\nAppFactory::create(\n    Psr\\Container\\ContainerInterface $container = null,\n    Zend\\Expressive\\Router\\RouterInterface $router = null\n);\n\n\n\nWhen no container or router are provided, it defaults to:\n\n\n\n\nzend-servicemanager for the container.\n\n\nFastRoute for the router.\n\n\n\n\nContainer factory\n\n\nWe also provide a factory that can be consumed by a\n\nPSR-11\n dependency injection container;\nsee the \ncontainer factories documentation\n for details.\n\n\nAdding routable middleware\n\n\nWe \ndiscuss routing vs piping elsewhere\n; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.\n\n\nRegardless of which \nrouter implementation\n you use, you\ncan use the following methods to provide routable middleware:\n\n\nroute()\n\n\nroute()\n has the following signature:\n\n\npublic function route(\n    $pathOrRoute,\n    $middleware = null,\n    array $methods = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nwhere:\n\n\n\n\n$pathOrRoute\n may be either a string path to match, or a\n  \nZend\\Expressive\\Router\\Route\n instance.\n\n\n$middleware\n \nmust\n be present if \n$pathOrRoute\n is a string path, and\n  \nmust\n be:\n\n\na callable;\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class;\n\n\nan array of any of the above; these will be composed in order into a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\n\n\n$methods\n must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.\n\n\n$name\n is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on \nroute naming\n\n  for details.\n\n\n\n\nThis method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.\n\n\nget(), post(), put(), patch(), delete(), any()\n\n\nEach of the methods \nget()\n, \npost()\n, \nput()\n, \npatch()\n, \ndelete()\n, and \nany()\n\nproxies to \nroute()\n and has the signature:\n\n\nfunction (\n    $pathOrRoute,\n    $middleware = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nEssentially, each calls \nroute()\n and specifies an array consisting solely of\nthe corresponding HTTP method for the \n$methods\n argument.\n\n\nPiping\n\n\nBecause zend-expressive builds on \nzend-stratigility\n,\nand, more specifically, its \nMiddlewarePipe\n definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.\n\n\nThe signature of \npipe()\n is:\n\n\npublic function pipe($pathOrMiddleware, $middleware = null)\n\n\n\nwhere:\n\n\n\n\n$pathOrMiddleware\n is either a string URI path (for path segregation), a\n  callable middleware, or the service name for a middleware to fetch from the\n  composed container.\n\n\n$middleware\n is required if \n$pathOrMiddleware\n is a string URI path. It can\n  be one of:\n\n\na callable;\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class;\n\n\nan array of any of the above; these will be composed in order into a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\n\n\n\n\nUnlike \nZend\\Stratigility\\MiddlewarePipe\n, \nApplication::pipe()\n \nallows\nfetching middleware by service name\n. This facility allows lazy-loading of\nmiddleware only when it is invoked. Internally, it wraps the call to fetch and\ndispatch the middleware inside a closure.\n\n\nAdditionally, we define a new method, \npipeErrorHandler()\n, with the following\nsignature:\n\n\npublic function pipeErrorHandler($pathOrMiddleware, $middleware = null)\n\n\n\nIt acts just like \npipe()\n except when the middleware specified is a service\nname; in that particular case, when it wraps the middleware in a closure, it\nuses the error handler signature:\n\n\nfunction ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next);\n\n\n\nRead the section on \npiping vs routing\n for more information.\n\n\nRegistering routing and dispatch middleware\n\n\nRouting is accomplished via dedicated middleware, \nZend\\Expressive\\Middleware\\RouteMiddleware\n;\nsimilarly, dispatching of routed middleware has a corresponding middleware,\n\nZend\\Expressive\\Middleware\\DispatchMiddleware\n. Each can be piped/registered\nwith other middleware platforms if desired.\n\n\nThese methods \nMUST\n be piped to the application so that the application will\nroute and dispatch routed middleware. This is done using the following methods:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nSee the section on \npiping\n to see how you can register\nnon-routed middleware and create layered middleware applications.\n\n\n\n\nChanged in version 2.2\n\n\nStarting in version 2.2, the methods \npipeRoutingMiddleware\n and\n\npipeDispatchMiddleware\n are deprecated in favor of piping the middleware\nmanually.\n\n\nAdditionally, the middleware has been ported to the zend-expressive-router\npackage, under the namespace \nZend\\Expressive\\Router\\Middleware\n. We suggest\npiping them by service name. Please see our \nmigration documentation\n\nfor more details, and for information on how to automatically update your\napplication.\n\n\n\n\nRetrieving dependencies\n\n\nAs noted in the intro, the \nApplication\n class has several dependencies. Some of\nthese may allow further configuration, or may be useful on their own, and have\nmethods for retrieving them. They include:\n\n\n\n\ngetContainer()\n: returns the composed \nPSR-11 container\n\n  instance (used to retrieve routed middleware).\n\n\ngetEmitter()\n: returns the composed\n  \nemitter\n,\n  typically a \nZend\\Expressive\\Emitter\\EmitterStack\n instance.\n\n\ngetDefaultDelegate()\n: retrieves the default delegate to use when the internal middleware pipeline is exhausted without returning a response. If none is provided at instantiation, this method will do one of the following:\n\n\nIf no container is composed, instanatiates a\n  \nZend\\Expressive\\Delegate\\NotFoundDelegate\n using the composed response\n  prototype only.\n\n\nIf a container is composed, but does not have the\n  \nZend\\Expressive\\Delegate\\DefaultDelegate\n service, it creates and invokes an\n  instance of \nZend\\Expressive\\Container\\NotFoundDelegateFactory\n, passing it\n  the composed container, and uses the value created.\n\n\nIf a container is composed and contains the \nZend\\Expressive\\Delegate\\DefaultDelegate\n\n  service, it returns that.\n\n\n\n\n\n\n\n\n\n\nDeprecated\n\n\nEach of the above methods are deprecated starting in version 2.2, and will be\nremoved in version 3.0.\n\n\n\n\nExecuting the application: run()\n\n\nWhen the application is completely setup, you can execute it with the \nrun()\n\nmethod. The method may be called with no arguments, but has the following\nsignature:\n\n\npublic function run(\n    ServerRequestInterface $request = null,\n    ResponseInterface $response = null\n);",
            "title": "Applications"
        },
        {
            "location": "/v2/features/application/#applications",
            "text": "In zend-expressive, you define a  Zend\\Expressive\\Application  instance and\nexecute it. The  Application  instance is itself middleware \nthat composes:   a  router , for dynamically routing requests to middleware.  a  dependency injection container , for retrieving\n  middleware to dispatch.  a  default delegate  (Expressive 2.X)\n  or  final handler  an  emitter ,\n  for emitting the response when application execution is complete.   You can define the  Application  instance in several ways:   Direct instantiation, which requires providing several dependencies.  The  AppFactory , which will use some common defaults, but allows injecting alternate\n  container and/or router implementations.  Via a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.   Regardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.",
            "title": "Applications"
        },
        {
            "location": "/v2/features/application/#instantiation",
            "text": "As noted at the start of this document, we provide several ways to create an Application  instance.",
            "title": "Instantiation"
        },
        {
            "location": "/v2/features/application/#constructor",
            "text": "If you wish to manually instantiate the  Application  instance, it has the\nfollowing constructor:  /**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Psr\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate\n *     Delegate to invoke when the internal middleware pipeline is exhausted\n *     without returning a response.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Psr\\Container\\ContainerInterface $container = null,\n    Interop\\Http\\ServerMiddleware\\DelegateInterface $defaultDelegate = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);  If no container is provided at instantiation, then all routed and piped\nmiddleware  must  be provided as callables.",
            "title": "Constructor"
        },
        {
            "location": "/v2/features/application/#appfactory",
            "text": "Deprecated since version 2.2; instantiate  Application  directly and/or use a\n   Zend\\Stratigility\\MiddlewarePipe  instance instead.   Zend\\Expressive\\AppFactory  provides a convenience layer for creating an Application  instance; it makes the assumption that you will use defaults in\nmost situations, and likely only change which container and/or router you wish\nto use. It has the following signature:  AppFactory::create(\n    Psr\\Container\\ContainerInterface $container = null,\n    Zend\\Expressive\\Router\\RouterInterface $router = null\n);  When no container or router are provided, it defaults to:   zend-servicemanager for the container.  FastRoute for the router.",
            "title": "AppFactory"
        },
        {
            "location": "/v2/features/application/#container-factory",
            "text": "We also provide a factory that can be consumed by a PSR-11  dependency injection container;\nsee the  container factories documentation  for details.",
            "title": "Container factory"
        },
        {
            "location": "/v2/features/application/#adding-routable-middleware",
            "text": "We  discuss routing vs piping elsewhere ; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.  Regardless of which  router implementation  you use, you\ncan use the following methods to provide routable middleware:",
            "title": "Adding routable middleware"
        },
        {
            "location": "/v2/features/application/#route",
            "text": "route()  has the following signature:  public function route(\n    $pathOrRoute,\n    $middleware = null,\n    array $methods = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route  where:   $pathOrRoute  may be either a string path to match, or a\n   Zend\\Expressive\\Router\\Route  instance.  $middleware   must  be present if  $pathOrRoute  is a string path, and\n   must  be:  a callable;  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class;  an array of any of the above; these will be composed in order into a\n   Zend\\Stratigility\\MiddlewarePipe  instance.    $methods  must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.  $name  is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on  route naming \n  for details.   This method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.",
            "title": "route()"
        },
        {
            "location": "/v2/features/application/#get-post-put-patch-delete-any",
            "text": "Each of the methods  get() ,  post() ,  put() ,  patch() ,  delete() , and  any() \nproxies to  route()  and has the signature:  function (\n    $pathOrRoute,\n    $middleware = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route  Essentially, each calls  route()  and specifies an array consisting solely of\nthe corresponding HTTP method for the  $methods  argument.",
            "title": "get(), post(), put(), patch(), delete(), any()"
        },
        {
            "location": "/v2/features/application/#piping",
            "text": "Because zend-expressive builds on  zend-stratigility ,\nand, more specifically, its  MiddlewarePipe  definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.  The signature of  pipe()  is:  public function pipe($pathOrMiddleware, $middleware = null)  where:   $pathOrMiddleware  is either a string URI path (for path segregation), a\n  callable middleware, or the service name for a middleware to fetch from the\n  composed container.  $middleware  is required if  $pathOrMiddleware  is a string URI path. It can\n  be one of:  a callable;  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class;  an array of any of the above; these will be composed in order into a\n   Zend\\Stratigility\\MiddlewarePipe  instance.     Unlike  Zend\\Stratigility\\MiddlewarePipe ,  Application::pipe()   allows\nfetching middleware by service name . This facility allows lazy-loading of\nmiddleware only when it is invoked. Internally, it wraps the call to fetch and\ndispatch the middleware inside a closure.  Additionally, we define a new method,  pipeErrorHandler() , with the following\nsignature:  public function pipeErrorHandler($pathOrMiddleware, $middleware = null)  It acts just like  pipe()  except when the middleware specified is a service\nname; in that particular case, when it wraps the middleware in a closure, it\nuses the error handler signature:  function ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next);  Read the section on  piping vs routing  for more information.",
            "title": "Piping"
        },
        {
            "location": "/v2/features/application/#registering-routing-and-dispatch-middleware",
            "text": "Routing is accomplished via dedicated middleware,  Zend\\Expressive\\Middleware\\RouteMiddleware ;\nsimilarly, dispatching of routed middleware has a corresponding middleware, Zend\\Expressive\\Middleware\\DispatchMiddleware . Each can be piped/registered\nwith other middleware platforms if desired.  These methods  MUST  be piped to the application so that the application will\nroute and dispatch routed middleware. This is done using the following methods:  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();  See the section on  piping  to see how you can register\nnon-routed middleware and create layered middleware applications.",
            "title": "Registering routing and dispatch middleware"
        },
        {
            "location": "/v2/features/application/#changed-in-version-22",
            "text": "Starting in version 2.2, the methods  pipeRoutingMiddleware  and pipeDispatchMiddleware  are deprecated in favor of piping the middleware\nmanually.  Additionally, the middleware has been ported to the zend-expressive-router\npackage, under the namespace  Zend\\Expressive\\Router\\Middleware . We suggest\npiping them by service name. Please see our  migration documentation \nfor more details, and for information on how to automatically update your\napplication.",
            "title": "Changed in version 2.2"
        },
        {
            "location": "/v2/features/application/#retrieving-dependencies",
            "text": "As noted in the intro, the  Application  class has several dependencies. Some of\nthese may allow further configuration, or may be useful on their own, and have\nmethods for retrieving them. They include:   getContainer() : returns the composed  PSR-11 container \n  instance (used to retrieve routed middleware).  getEmitter() : returns the composed\n   emitter ,\n  typically a  Zend\\Expressive\\Emitter\\EmitterStack  instance.  getDefaultDelegate() : retrieves the default delegate to use when the internal middleware pipeline is exhausted without returning a response. If none is provided at instantiation, this method will do one of the following:  If no container is composed, instanatiates a\n   Zend\\Expressive\\Delegate\\NotFoundDelegate  using the composed response\n  prototype only.  If a container is composed, but does not have the\n   Zend\\Expressive\\Delegate\\DefaultDelegate  service, it creates and invokes an\n  instance of  Zend\\Expressive\\Container\\NotFoundDelegateFactory , passing it\n  the composed container, and uses the value created.  If a container is composed and contains the  Zend\\Expressive\\Delegate\\DefaultDelegate \n  service, it returns that.",
            "title": "Retrieving dependencies"
        },
        {
            "location": "/v2/features/application/#deprecated",
            "text": "Each of the above methods are deprecated starting in version 2.2, and will be\nremoved in version 3.0.",
            "title": "Deprecated"
        },
        {
            "location": "/v2/features/application/#executing-the-application-run",
            "text": "When the application is completely setup, you can execute it with the  run() \nmethod. The method may be called with no arguments, but has the following\nsignature:  public function run(\n    ServerRequestInterface $request = null,\n    ResponseInterface $response = null\n);",
            "title": "Executing the application: run()"
        },
        {
            "location": "/v2/features/container/intro/",
            "text": "Containers\n\n\nExpressive promotes and advocates the usage of\n\nDependency Injection\n/\nInversion of Control\n\n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:\n\n\n\n\n\n\nDefining \napplication\n dependencies: routers, template engines, error\n  handlers, even the \nApplication\n instance itself.\n\n\n\n\n\n\nDefining \nmiddleware\n and related dependencies.\n\n\n\n\n\n\nThe \nApplication\n instance itself stores a container, from which it fetches\nmiddleware when ready to dispatch it; this encourages the idea of defining\nmiddleware-specific dependencies, and factories for ensuring they are injected.\n\n\nTo facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against \nPSR-11 Container\n,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.\n\n\nAt this time, we document support for the following specific containers:\n\n\n\n\nzend-servicemanager\n\n\npimple-interop\n\n\naura.di\n\n\n\n\n\n\nService Names\n\n\nWe recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.\n\n\nFollowing these practices encourages the following:\n\n\n\n\nConsumers have a reasonable idea of what the service should return.\n\n\nUsing interface names as service names promotes re-use and substitution.\n\n\n\n\nIn a few cases, we define \"virtual service\" names. These are cases where there is no\nclear typehint to follow (e.g., most middleware only uses \ncallable\n as a\ntypehint, or where we want to imply specific configuration is necessary (e.g.,\n\nWhoops\n requires specific configuration to\nwork correctly with Expressive, and thus we do not want a generic service name\nfor it). We try to keep these to a minimum, however.",
            "title": "Introduction"
        },
        {
            "location": "/v2/features/container/intro/#containers",
            "text": "Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control \n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:    Defining  application  dependencies: routers, template engines, error\n  handlers, even the  Application  instance itself.    Defining  middleware  and related dependencies.    The  Application  instance itself stores a container, from which it fetches\nmiddleware when ready to dispatch it; this encourages the idea of defining\nmiddleware-specific dependencies, and factories for ensuring they are injected.  To facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against  PSR-11 Container ,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.  At this time, we document support for the following specific containers:   zend-servicemanager  pimple-interop  aura.di",
            "title": "Containers"
        },
        {
            "location": "/v2/features/container/intro/#service-names",
            "text": "We recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.  Following these practices encourages the following:   Consumers have a reasonable idea of what the service should return.  Using interface names as service names promotes re-use and substitution.   In a few cases, we define \"virtual service\" names. These are cases where there is no\nclear typehint to follow (e.g., most middleware only uses  callable  as a\ntypehint, or where we want to imply specific configuration is necessary (e.g., Whoops  requires specific configuration to\nwork correctly with Expressive, and thus we do not want a generic service name\nfor it). We try to keep these to a minimum, however.",
            "title": "Service Names"
        },
        {
            "location": "/v2/features/container/factories/",
            "text": "Provided Factories\n\n\nExpressive provides several factories compatible with\n\nPSR-11 Container\n to facilitate\nsetting up common dependencies. The following is a list of provided\ncontainers, what they will create, the suggested service name, and any\nadditional dependencies they may require.\n\n\nAll factories, unless noted otherwise, are in the \nZend\\Expressive\\Container\n\nnamespace, and define an \n__invoke()\n method that accepts an\n\nPsr\\Container\\ContainerInterface\n instance as the sole argument.\n\n\nApplicationFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Application\n\n\nSuggested Name\n: \nZend\\Expressive\\Application\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n. When provided, the service will\n  be used to construct the \nApplication\n instance; otherwise, an FastRoute router\n  implementation will be used.\n\n\nZend\\Expressive\\Delegate\\DefaultDelegate\n. This should return an\n  \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instance to process\n  when the middleware pipeline is exhausted without returning a response;\n  by default, this will be a \nZend\\Expressive\\Delegate\\NotFoundDelegate\n\n  instance.\n\n\nZend\\Diactoros\\Response\\EmitterInterface\n. If none is provided, an instance\n  of \nZend\\Expressive\\Emitter\\EmitterStack\n composing a\n  \nZend\\Diactoros\\Response\\SapiEmitter\n instance will be used.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This \nmay\n be used to seed the\n  application instance with pipeline middleware and/or routed\n  middleware (see more below).\n\n\n\n\n\n\n\n\nAdditionally, the container instance itself is injected into the \nApplication\n\ninstance.\n\n\nWhen the \nconfig\n service is present, the factory can utilize several keys in\norder to seed the \nApplication\n instance:\n\n\n\n\n\n\nprogrammatic_pipeline\n (bool) (Since 1.1.0): when enabled,\n  \nmiddleware_pipeline\n and \nroutes\n configuration are ignored, and the factory\n  will assume that these are injected programmatically elsewhere.\n\n\n\n\n\n\nraise_throwables\n (bool) (Since 1.1.0; obsolete as of 2.0.0): when enabled,\n  this flag will prevent the Stratigility middleware dispatcher from catching\n  exceptions, and instead allow them to bubble outwards.\n\n\n\n\n\n\nmiddleware_pipeline\n can be used to seed the middleware pipeline:\n\n\n\n\n\n\n'middleware_pipeline' => [\n    // An array of middleware to register.\n    [ /* ... */ ],\n\n    // Expressive 1.0:\n    Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n\n    // Expressive 1.1 and above (above constants will still work, though):\n    Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n\n    [ /* ... */ ],\n],\n\n\n\nEach item of the array, other than the entries for routing and dispatch\n  middleware, must be an array itself, with the following structure:\n\n\n[\n    // required:\n    'middleware' => 'Name of middleware service, valid middleware, or an array of these',\n    // optional:\n    'path'  => '/path/to/match',\n    'priority' => 1, // Integer\n\n    // optional under Expressive 1.X; ignored under 2.X:\n    'error' => false, // boolean\n],\n\n\n\nThe \nmiddleware\n key itself is the middleware to execute, and must be a\n  service name resolving to valid middleware, middleware instances (either\n  http-interop middleware or callable double-pass middleware), or an array of\n  these values. If an array is provided, the specified middleware will be\n  composed into a \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\nIf the \npath\n key is present, that key will be used to segregate the\n  middleware to a specific matched path (in other words, it will not execute if\n  the path is not matched).\n\n\nThe \npriority\n defaults to 1, and follows the semantics of\n  \nSplPriorityQueue\n: higher integer values\n  indicate higher priority (will execute earlier), while lower/negative integer\n  values indicate lower priority (will execute last). Default priority is 1; use\n  granular priority values to specify the order in which middleware should be\n  piped to the application.\n\n\nYou \ncan\n specify keys for each middleware specification. These will be\n  ignored by the factory, but can be useful when merging several configurations\n  into one for the application.\n\n\nUnder Expressive 1.X, if the \nerror\n key is present and boolean \ntrue\n, then\n  the middleware will be registered as error middleware. (This is necessary due\n  to the fact that the factory defines a callable wrapper around middleware to\n  enable lazy-loading of middleware.) We recommend \nnot\n using this feature;\n  see the chapter on \nerror handling\n for details.\n\n\n\n\nroutes\n is used to define routed middleware. The value must be an array,\n  consisting of arrays defining each middleware:\n\n\n\n\n'routes' => [\n    [\n        'path' => '/path/to/match',\n        'middleware' => 'Middleware service name, valid middleware, or array of these values',\n        'allowed_methods' => ['GET', 'POST', 'PATCH'],\n        'options' => [\n            'stuff' => 'to',\n            'pass'  => 'to',\n            'the'   => 'underlying router',\n        ],\n    ],\n    // etc.\n],\n\n\n\nEach route \nrequires\n:\n\n\n- `path`: the path to match. Format will be based on the router you choose for\n  your project.\n\n- `middleware`: a service name resolving to valid middleware, valid\n  middleware (either http-interop middleware or callable double-pass\n  middleware), or an array of such values (which will be composed into\n  a `Zend\\Stratigility\\MiddlewarePipe` instance); this middleware will be\n  dispatched when the route matches.\n\n\n\n\nOptionally, the route definition may provide:\n\n\n- `allowed_methods`: an array of allowed HTTP methods. If not provided, the\n  application assumes any method is allowed.\n\n- `name`: if not provided, the path will be used as the route name (and, if\n  specific HTTP methods are allowed, a list of those).\n\n- `options`: a key/value set of additional options to pass to the underlying\n  router implementation for the given route. (Typical use cases include\n  passing constraints or default values.)\n\n\n\n\nErrorHandlerFactory\n\n\n\n\nProvides\n: \nZend\\Stratigility\\Middleware\\ErrorHandler\n\n\nSuggested Name\n: \nZend\\Stratigility\\Middleware\\ErrorHandler\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n. If not provided, the error\n  handler will not compose an error response generator, making it largely\n  useless other than to provide an empty response.\n\n\n\n\n\n\n\n\nErrorResponseGeneratorFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n\n\nSuggested Name\n: \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the\n  error response generator will provide a plain text response instead of a\n  templated one.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nErrorResponseGenerator\n instance with a template name to use for errors (see\n  more below), and/or a \"debug\" flag value.\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize two values:\n\n\n\n\ndebug\n, a flag indicating whether or not to provide debug information when\n  creating an error response.\n\n\nzend-expressive.error_handler.template_error\n, a name of an alternate\n  template to use (instead of the default represented in the\n  \nZend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT\n\n  constant).\n\n\n\n\nAs an example:\n\n\n'debug' => true,\n'zend-expressive' => [\n    'error_handler' => [\n        'template_error' => 'name of error template',\n    ],\n],\n\n\n\nNotFoundDelegateFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Delegate\\NotFoundDelegate\n\n\nSuggested Name\n: \nZend\\Expressive\\Delegate\\NotFoundDelegate\n, and aliased\n  to \nZend\\Expressive\\Delegate\\DefaultDelegate\n.\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the\n  delegate will provide a plain text response instead of a templated one.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nNotFoundDelegate\n instance with a template name to use.\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize two values:\n\n\n\n\nzend-expressive.error_handler.template_404\n, a name of an alternate\n  template to use (instead of the default represented in the\n  \nZend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT\n constant).\n\n\n\n\nAs an example:\n\n\n'zend-expressive' => [\n    'error_handler' => [\n        'template_404' => 'name of 404 template',\n    ],\n],\n\n\n\nNotFoundHandlerFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Middleware\\NotFoundHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\Middleware\\NotFoundHandler\n\n\nRequires\n: \nZend\\Expressive\\Delegate\\DefaultDelegate\n\n\n\n\nWhoopsErrorResponseGeneratorFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator\n\n\nSuggested Name\n: \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n\n\nRequires\n: \nZend\\Expressive\\Whoops\n (see \nWhoopsFactory\n,\nbelow)\n\n\n\n\nWhoopsFactory\n\n\n\n\nProvides\n: \nWhoops\\Run\n\n\nSuggested Name\n: \nZend\\Expressive\\Whoops\n\n\nRequires\n:\n\n\nZend\\Expressive\\WhoopsPageHandler\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed\n  additional page handlers, specifically the \nJsonResponseHandler\n (see\n  more below).\n\n\n\n\n\n\n\n\nThis factory creates and configures a \nWhoops\\Run\n instance so that it will work\nproperly with \nZend\\Expressive\\Application\n; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The \nPrettyPageHandler\n returned\nfor the \nZend\\Expressive\\WhoopsPageHandler\n service will be injected.\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' => [\n    'json_exceptions' => [\n        'display'    => true,\n        'show_trace' => true,\n        'ajax_only'  => true,\n    ],\n],\n\n\n\nIf no \nwhoops\n top-level key is present in the configuration, a default instance\nwith no \nJsonResponseHandler\n composed will be created.\n\n\nWhoopsPageHandlerFactory\n\n\n\n\nProvides\n: \nWhoops\\Handler\\PrettyPageHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\WhoopsPageHandler\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPrettyPageHandler\n instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' => [\n    'editor' => 'editor name, editor service name, or callable',\n],\n\n\n\nThe \neditor\n value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.\n\n\nPlatesRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\PlatesRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Plates\\PlatesRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPlates\n instance, specifically with the filename extension\n  to use, and paths to inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' => [\n    'extension' => 'file extension used by templates; defaults to html',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nOne note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.\n\n\nTwigRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\TwigRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Twig\\TwigRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n; if found, it will be used to\n  seed a \nZend\\Expressive\\Twig\\TwigExtension\n instance for purposes\n  of rendering application URLs.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nTwig\n instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'debug' => boolean,\n'templates' => [\n    'cache_dir' => 'path to cached templates',\n    'assets_url' => 'base URL for assets',\n    'assets_version' => 'base version for assets',\n    'extension' => 'file extension used by templates; defaults to html.twig',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nWhen \ndebug\n is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The \nassets_*\n values are used to seed\nthe \nTwigExtension\n instance (assuming the router was found).\n\n\nZendViewRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\ZendViewRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\ZendView\\ZendViewRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nZend\\Expressive\\Router\\RouterInterface\n, in order to inject the custom\n  url helper implementation.\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nZendView\n instance, specifically with the layout template\n  name, entries for a \nTemplateMapResolver\n, and and template paths to\n  inject.\n\n\nZend\\View\\HelperPluginManager\n; if present, will be used to inject the\n  \nPhpRenderer\n instance.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' => [\n    'layout' => 'name of layout view to use, if any',\n    'map'    => [\n        // template => filename pairs\n    ],\n    'paths'  => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nWhen creating the \nPhpRenderer\n instance, it will inject it with a\n\nZend\\View\\HelperPluginManager\n instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers, \nZend\\Expressive\\ZendView\\UrlHelper\n and\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n, respetively.",
            "title": "Container Factories"
        },
        {
            "location": "/v2/features/container/factories/#provided-factories",
            "text": "Expressive provides several factories compatible with PSR-11 Container  to facilitate\nsetting up common dependencies. The following is a list of provided\ncontainers, what they will create, the suggested service name, and any\nadditional dependencies they may require.  All factories, unless noted otherwise, are in the  Zend\\Expressive\\Container \nnamespace, and define an  __invoke()  method that accepts an Psr\\Container\\ContainerInterface  instance as the sole argument.",
            "title": "Provided Factories"
        },
        {
            "location": "/v2/features/container/factories/#applicationfactory",
            "text": "Provides :  Zend\\Expressive\\Application  Suggested Name :  Zend\\Expressive\\Application  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface . When provided, the service will\n  be used to construct the  Application  instance; otherwise, an FastRoute router\n  implementation will be used.  Zend\\Expressive\\Delegate\\DefaultDelegate . This should return an\n   Interop\\Http\\ServerMiddleware\\DelegateInterface  instance to process\n  when the middleware pipeline is exhausted without returning a response;\n  by default, this will be a  Zend\\Expressive\\Delegate\\NotFoundDelegate \n  instance.  Zend\\Diactoros\\Response\\EmitterInterface . If none is provided, an instance\n  of  Zend\\Expressive\\Emitter\\EmitterStack  composing a\n   Zend\\Diactoros\\Response\\SapiEmitter  instance will be used.  config , an array or  ArrayAccess  instance. This  may  be used to seed the\n  application instance with pipeline middleware and/or routed\n  middleware (see more below).     Additionally, the container instance itself is injected into the  Application \ninstance.  When the  config  service is present, the factory can utilize several keys in\norder to seed the  Application  instance:    programmatic_pipeline  (bool) (Since 1.1.0): when enabled,\n   middleware_pipeline  and  routes  configuration are ignored, and the factory\n  will assume that these are injected programmatically elsewhere.    raise_throwables  (bool) (Since 1.1.0; obsolete as of 2.0.0): when enabled,\n  this flag will prevent the Stratigility middleware dispatcher from catching\n  exceptions, and instead allow them to bubble outwards.    middleware_pipeline  can be used to seed the middleware pipeline:    'middleware_pipeline' => [\n    // An array of middleware to register.\n    [ /* ... */ ],\n\n    // Expressive 1.0:\n    Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n\n    // Expressive 1.1 and above (above constants will still work, though):\n    Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n\n    [ /* ... */ ],\n],  Each item of the array, other than the entries for routing and dispatch\n  middleware, must be an array itself, with the following structure:  [\n    // required:\n    'middleware' => 'Name of middleware service, valid middleware, or an array of these',\n    // optional:\n    'path'  => '/path/to/match',\n    'priority' => 1, // Integer\n\n    // optional under Expressive 1.X; ignored under 2.X:\n    'error' => false, // boolean\n],  The  middleware  key itself is the middleware to execute, and must be a\n  service name resolving to valid middleware, middleware instances (either\n  http-interop middleware or callable double-pass middleware), or an array of\n  these values. If an array is provided, the specified middleware will be\n  composed into a  Zend\\Stratigility\\MiddlewarePipe  instance.  If the  path  key is present, that key will be used to segregate the\n  middleware to a specific matched path (in other words, it will not execute if\n  the path is not matched).  The  priority  defaults to 1, and follows the semantics of\n   SplPriorityQueue : higher integer values\n  indicate higher priority (will execute earlier), while lower/negative integer\n  values indicate lower priority (will execute last). Default priority is 1; use\n  granular priority values to specify the order in which middleware should be\n  piped to the application.  You  can  specify keys for each middleware specification. These will be\n  ignored by the factory, but can be useful when merging several configurations\n  into one for the application.  Under Expressive 1.X, if the  error  key is present and boolean  true , then\n  the middleware will be registered as error middleware. (This is necessary due\n  to the fact that the factory defines a callable wrapper around middleware to\n  enable lazy-loading of middleware.) We recommend  not  using this feature;\n  see the chapter on  error handling  for details.   routes  is used to define routed middleware. The value must be an array,\n  consisting of arrays defining each middleware:   'routes' => [\n    [\n        'path' => '/path/to/match',\n        'middleware' => 'Middleware service name, valid middleware, or array of these values',\n        'allowed_methods' => ['GET', 'POST', 'PATCH'],\n        'options' => [\n            'stuff' => 'to',\n            'pass'  => 'to',\n            'the'   => 'underlying router',\n        ],\n    ],\n    // etc.\n],  Each route  requires :  - `path`: the path to match. Format will be based on the router you choose for\n  your project.\n\n- `middleware`: a service name resolving to valid middleware, valid\n  middleware (either http-interop middleware or callable double-pass\n  middleware), or an array of such values (which will be composed into\n  a `Zend\\Stratigility\\MiddlewarePipe` instance); this middleware will be\n  dispatched when the route matches.  Optionally, the route definition may provide:  - `allowed_methods`: an array of allowed HTTP methods. If not provided, the\n  application assumes any method is allowed.\n\n- `name`: if not provided, the path will be used as the route name (and, if\n  specific HTTP methods are allowed, a list of those).\n\n- `options`: a key/value set of additional options to pass to the underlying\n  router implementation for the given route. (Typical use cases include\n  passing constraints or default values.)",
            "title": "ApplicationFactory"
        },
        {
            "location": "/v2/features/container/factories/#errorhandlerfactory",
            "text": "Provides :  Zend\\Stratigility\\Middleware\\ErrorHandler  Suggested Name :  Zend\\Stratigility\\Middleware\\ErrorHandler  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator . If not provided, the error\n  handler will not compose an error response generator, making it largely\n  useless other than to provide an empty response.",
            "title": "ErrorHandlerFactory"
        },
        {
            "location": "/v2/features/container/factories/#errorresponsegeneratorfactory",
            "text": "Provides :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  Suggested Name :  Zend\\Stratigility\\Middleware\\ErrorResponseGenerator  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the\n  error response generator will provide a plain text response instead of a\n  templated one.  config , an array or  ArrayAccess  instance. This will be used to seed the\n   ErrorResponseGenerator  instance with a template name to use for errors (see\n  more below), and/or a \"debug\" flag value.     When the  config  service is present, the factory can utilize two values:   debug , a flag indicating whether or not to provide debug information when\n  creating an error response.  zend-expressive.error_handler.template_error , a name of an alternate\n  template to use (instead of the default represented in the\n   Zend\\Expressive\\Middleware\\ErrorResponseGenerator::TEMPLATE_DEFAULT \n  constant).   As an example:  'debug' => true,\n'zend-expressive' => [\n    'error_handler' => [\n        'template_error' => 'name of error template',\n    ],\n],",
            "title": "ErrorResponseGeneratorFactory"
        },
        {
            "location": "/v2/features/container/factories/#notfounddelegatefactory",
            "text": "Provides :  Zend\\Expressive\\Delegate\\NotFoundDelegate  Suggested Name :  Zend\\Expressive\\Delegate\\NotFoundDelegate , and aliased\n  to  Zend\\Expressive\\Delegate\\DefaultDelegate .  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the\n  delegate will provide a plain text response instead of a templated one.  config , an array or  ArrayAccess  instance. This will be used to seed the\n   NotFoundDelegate  instance with a template name to use.     When the  config  service is present, the factory can utilize two values:   zend-expressive.error_handler.template_404 , a name of an alternate\n  template to use (instead of the default represented in the\n   Zend\\Expressive\\Delegate\\NotFoundDelegate::TEMPLATE_DEFAULT  constant).   As an example:  'zend-expressive' => [\n    'error_handler' => [\n        'template_404' => 'name of 404 template',\n    ],\n],",
            "title": "NotFoundDelegateFactory"
        },
        {
            "location": "/v2/features/container/factories/#notfoundhandlerfactory",
            "text": "Provides :  Zend\\Expressive\\Middleware\\NotFoundHandler  Suggested Name :  Zend\\Expressive\\Middleware\\NotFoundHandler  Requires :  Zend\\Expressive\\Delegate\\DefaultDelegate",
            "title": "NotFoundHandlerFactory"
        },
        {
            "location": "/v2/features/container/factories/#whoopserrorresponsegeneratorfactory",
            "text": "Provides :  Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator  Suggested Name :  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  Requires :  Zend\\Expressive\\Whoops  (see  WhoopsFactory ,\nbelow)",
            "title": "WhoopsErrorResponseGeneratorFactory"
        },
        {
            "location": "/v2/features/container/factories/#whoopsfactory",
            "text": "Provides :  Whoops\\Run  Suggested Name :  Zend\\Expressive\\Whoops  Requires :  Zend\\Expressive\\WhoopsPageHandler    Optional :  config , an array or  ArrayAccess  instance. This will be used to seed\n  additional page handlers, specifically the  JsonResponseHandler  (see\n  more below).     This factory creates and configures a  Whoops\\Run  instance so that it will work\nproperly with  Zend\\Expressive\\Application ; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The  PrettyPageHandler  returned\nfor the  Zend\\Expressive\\WhoopsPageHandler  service will be injected.  It consumes the following  config  structure:  'whoops' => [\n    'json_exceptions' => [\n        'display'    => true,\n        'show_trace' => true,\n        'ajax_only'  => true,\n    ],\n],  If no  whoops  top-level key is present in the configuration, a default instance\nwith no  JsonResponseHandler  composed will be created.",
            "title": "WhoopsFactory"
        },
        {
            "location": "/v2/features/container/factories/#whoopspagehandlerfactory",
            "text": "Provides :  Whoops\\Handler\\PrettyPageHandler  Suggested Name :  Zend\\Expressive\\WhoopsPageHandler  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  PrettyPageHandler  instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).     It consumes the following  config  structure:  'whoops' => [\n    'editor' => 'editor name, editor service name, or callable',\n],  The  editor  value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.",
            "title": "WhoopsPageHandlerFactory"
        },
        {
            "location": "/v2/features/container/factories/#platesrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\PlatesRenderer  FactoryName :  Zend\\Expressive\\Plates\\PlatesRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Plates  instance, specifically with the filename extension\n  to use, and paths to inject.     It consumes the following  config  structure:  'templates' => [\n    'extension' => 'file extension used by templates; defaults to html',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  One note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.",
            "title": "PlatesRendererFactory"
        },
        {
            "location": "/v2/features/container/factories/#twigrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\TwigRenderer  FactoryName :  Zend\\Expressive\\Twig\\TwigRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to\n  seed a  Zend\\Expressive\\Twig\\TwigExtension  instance for purposes\n  of rendering application URLs.  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Twig  instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.     It consumes the following  config  structure:  'debug' => boolean,\n'templates' => [\n    'cache_dir' => 'path to cached templates',\n    'assets_url' => 'base URL for assets',\n    'assets_version' => 'base version for assets',\n    'extension' => 'file extension used by templates; defaults to html.twig',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When  debug  is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The  assets_*  values are used to seed\nthe  TwigExtension  instance (assuming the router was found).",
            "title": "TwigRendererFactory"
        },
        {
            "location": "/v2/features/container/factories/#zendviewrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\ZendViewRenderer  FactoryName :  Zend\\Expressive\\ZendView\\ZendViewRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Zend\\Expressive\\Router\\RouterInterface , in order to inject the custom\n  url helper implementation.    Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  ZendView  instance, specifically with the layout template\n  name, entries for a  TemplateMapResolver , and and template paths to\n  inject.  Zend\\View\\HelperPluginManager ; if present, will be used to inject the\n   PhpRenderer  instance.     It consumes the following  config  structure:  'templates' => [\n    'layout' => 'name of layout view to use, if any',\n    'map'    => [\n        // template => filename pairs\n    ],\n    'paths'  => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When creating the  PhpRenderer  instance, it will inject it with a Zend\\View\\HelperPluginManager  instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers,  Zend\\Expressive\\ZendView\\UrlHelper  and Zend\\Expressive\\ZendView\\ServerUrlHelper , respetively.",
            "title": "ZendViewRendererFactory"
        },
        {
            "location": "/v2/features/container/delegator-factories/",
            "text": "Delegator Factories\n\n\nExpressive supports the concept of \ndelegator factories\n, which allow decoration\nof services created by your dependency injection container, across all\ndependency injection containers supported by Expressive.\n\n\nDelegator factories\n accept the following arguments:\n\n\n\n\nThe container itself;\n\n\nThe name of the service whose creation is being decorated;\n\n\nA callback that will produce the service being decorated.\n\n\n\n\nAs an example, let's say we have a \nUserRepository\n class that composes some sort of\nevent manager. We might want to attach listeners to that event manager, but not\nwish to alter the basic creation logic for the repository itself. As such, we\nmight write a \ndelegator factory\n as follows:\n\n\nnamespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass UserRepositoryListenerDelegatorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $name\n     * @param callable $callback\n     * @return UserRepository\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback)\n    {\n        $listener = new LoggerListener($container->get(LoggerInterface::class));\n        $repository = $callback();\n        $repository->getEventManager()->attach($listener);\n        return $repository;\n    }\n}\n\n\n\nTo notify the container about this delegator factory, we would add the following\nconfiguration to our application:\n\n\n'dependencies' => [\n    'delegators' => [\n        Acme\\UserRepository::class => [\n            Acme\\UserRepositoryListenerDelegatorFactory::class,\n        ],\n    ],\n],\n\n\n\nNote that you specify delegator factories using the service name being decorated\nas the key, with an \narray\n of delegator factories as a value. \nYou may attach\nmultiple delegator factories to any given service\n, which can be a very\npowerful feature.\n\n\nAt the time of writing, this feature works for each of the Aura.Di, Pimple, and\nzend-servicemanager container implementations. Delegator factories have been\nsupported with Pimple and zend-servicemanager since the 1.X series.",
            "title": "Delegator Factories"
        },
        {
            "location": "/v2/features/container/delegator-factories/#delegator-factories",
            "text": "Expressive supports the concept of  delegator factories , which allow decoration\nof services created by your dependency injection container, across all\ndependency injection containers supported by Expressive.  Delegator factories  accept the following arguments:   The container itself;  The name of the service whose creation is being decorated;  A callback that will produce the service being decorated.   As an example, let's say we have a  UserRepository  class that composes some sort of\nevent manager. We might want to attach listeners to that event manager, but not\nwish to alter the basic creation logic for the repository itself. As such, we\nmight write a  delegator factory  as follows:  namespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\n\nclass UserRepositoryListenerDelegatorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $name\n     * @param callable $callback\n     * @return UserRepository\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback)\n    {\n        $listener = new LoggerListener($container->get(LoggerInterface::class));\n        $repository = $callback();\n        $repository->getEventManager()->attach($listener);\n        return $repository;\n    }\n}  To notify the container about this delegator factory, we would add the following\nconfiguration to our application:  'dependencies' => [\n    'delegators' => [\n        Acme\\UserRepository::class => [\n            Acme\\UserRepositoryListenerDelegatorFactory::class,\n        ],\n    ],\n],  Note that you specify delegator factories using the service name being decorated\nas the key, with an  array  of delegator factories as a value.  You may attach\nmultiple delegator factories to any given service , which can be a very\npowerful feature.  At the time of writing, this feature works for each of the Aura.Di, Pimple, and\nzend-servicemanager container implementations. Delegator factories have been\nsupported with Pimple and zend-servicemanager since the 1.X series.",
            "title": "Delegator Factories"
        },
        {
            "location": "/v2/features/container/zend-servicemanager/",
            "text": "Using zend-servicemanager\n\n\nzend-servicemanager\n is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:\n\n\n\n\nlazy-loading of invokable (constructor-less) classes.\n\n\nability to define factories for specific classes.\n\n\nability to define generalized factories for classes with identical\n  construction patterns (aka \nabstract factories\n).\n\n\nability to create lazy-loading proxies.\n\n\nability to intercept before or after instantiation to alter the construction\n  workflow (aka \ndelegator factories\n).\n\n\ninterface injection (via \ninitializers\n).\n\n\n\n\nzend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:\n\n\n[\n    'services' => [\n        'service name' => $serviceInstance,\n    ],\n    'invokables' => [\n        'service name' => 'class to instantiate',\n    ],\n    'factories' => [\n        'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' => [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' => [\n        'service name' => [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' => [\n        'class_map' => [\n            'service name' => 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' => [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]\n\n\n\nRead more about zend-servicemanager in \nits documentation\n.\n\n\nInstalling zend-servicemanager\n\n\nTo use zend-servicemanager with zend-expressive, you can install it via\ncomposer:\n\n\n$ composer require zendframework/zend-servicemanager\n\n\n\nConfiguring zend-servicemanager\n\n\nYou can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.\n\n\nProgrammatically\n\n\nTo use zend-servicemanager programatically, you'll need to create a\n\nZend\\ServiceManager\\ServiceManager\n instance, and then start populating it.\n\n\nFor this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in \nconfig/config.php\n, and that that file\nreturns an array.\n\n\nWe'll create a \nconfig/container.php\n file that creates and returns a\n\nZend\\ServiceManager\\ServiceManager\n instance as follows:\n\n\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container->setService('config', include 'config/config.php');\n$container->setFactory(\n    Zend\\Expressive\\Application::class,\n    Zend\\Expressive\\Container\\ApplicationFactory::class\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Template\\TemplateRendererInterface::class,\n    Zend\\Expressive\\Plates\\PlatesRenderer::class\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator\n// implementation:\n$container->setFactory(\n    'Zend\\Expressive\\Whoops',\n    Zend\\Expressive\\Container\\WhoopsFactory::class\n);\n$container->setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class\n);\n\n// Error Handling\n\n// All environments:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorHandler::class,\n    Zend\\Expressive\\Container\\ErrorHandlerFactory::class\n);\n\n// If in development:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n);\n\n// If in production:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n);\n\nreturn $container;\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(\\Zend\\Expressive\\Application::class);\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();\n\n\n\nConfiguration-Driven Container\n\n\nAlternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in \nconfig/config.php\n, and our\n\nconfig/container.php\n file will still return our service manager instance; we'll\ndefine the service configuration in \nconfig/dependencies.php\n:\n\n\nreturn [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => 'Zend\\Expressive\\Delegate\\NotFoundDelegate',\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        Zend\\Expressive\\Delegate\\NotFoundDelegate::class  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];\n\n\n\nconfig/container.php\n becomes:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));\n\n\n\nThere is one problem, however: you may want to vary error handling strategies\nbased on whether or not you're in production: You have two choices on how to\napproach this:\n\n\n\n\nSelectively inject the factory in the bootstrap.\n\n\nDefine the final handler service in an environment specific file and use file\n  globbing to merge files.\n\n\n\n\nIn the first case, you would change the \nconfig/container.php\n example to look\nlike this:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/container.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n        );\n        break;\n    case 'production':\n    default:\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n        );\n}\nreturn $container;\n\n\n\nIn the second case, you will need to install zend-config:\n\n\n$ composer require zendframework/zend-config\n\n\n\nThen, create the directory \nconfig/autoload/\n, and create two files,\n\ndependencies.global.php\n and \ndependencies.local.php\n. In your \n.gitignore\n,\nadd an entry for \nconfig/autoload/*local.php\n to ensure \"local\"\n(environment-specific) files are excluded from the repository.\n\n\nconfig/dependencies.php\n will look like this:\n\n\nuse Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);\n\n\n\nconfig/autoload/dependencies.global.php\n will look like this:\n\n\nreturn [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => Zend\\Expressive\\Delegate\\NotFoundDelegate::class,\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class,\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        'Zend\\Expressive\\Delegate\\NotFoundDelegate'  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];\n\n\n\nconfig/autoload/dependencies.local.php\n on your development machine can look\nlike this:\n\n\nreturn [\n    'factories' => [\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => 'Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class,\n    ],\n];\n\n\n\nUsing the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)",
            "title": "Using zend-servicemanager"
        },
        {
            "location": "/v2/features/container/zend-servicemanager/#using-zend-servicemanager",
            "text": "zend-servicemanager  is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:   lazy-loading of invokable (constructor-less) classes.  ability to define factories for specific classes.  ability to define generalized factories for classes with identical\n  construction patterns (aka  abstract factories ).  ability to create lazy-loading proxies.  ability to intercept before or after instantiation to alter the construction\n  workflow (aka  delegator factories ).  interface injection (via  initializers ).   zend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:  [\n    'services' => [\n        'service name' => $serviceInstance,\n    ],\n    'invokables' => [\n        'service name' => 'class to instantiate',\n    ],\n    'factories' => [\n        'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' => [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' => [\n        'service name' => [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' => [\n        'class_map' => [\n            'service name' => 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' => [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]  Read more about zend-servicemanager in  its documentation .",
            "title": "Using zend-servicemanager"
        },
        {
            "location": "/v2/features/container/zend-servicemanager/#installing-zend-servicemanager",
            "text": "To use zend-servicemanager with zend-expressive, you can install it via\ncomposer:  $ composer require zendframework/zend-servicemanager",
            "title": "Installing zend-servicemanager"
        },
        {
            "location": "/v2/features/container/zend-servicemanager/#configuring-zend-servicemanager",
            "text": "You can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.",
            "title": "Configuring zend-servicemanager"
        },
        {
            "location": "/v2/features/container/zend-servicemanager/#programmatically",
            "text": "To use zend-servicemanager programatically, you'll need to create a Zend\\ServiceManager\\ServiceManager  instance, and then start populating it.  For this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in  config/config.php , and that that file\nreturns an array.  We'll create a  config/container.php  file that creates and returns a Zend\\ServiceManager\\ServiceManager  instance as follows:  use Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container->setService('config', include 'config/config.php');\n$container->setFactory(\n    Zend\\Expressive\\Application::class,\n    Zend\\Expressive\\Container\\ApplicationFactory::class\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container->setInvokableClass(\n    Zend\\Expressive\\Template\\TemplateRendererInterface::class,\n    Zend\\Expressive\\Plates\\PlatesRenderer::class\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator\n// implementation:\n$container->setFactory(\n    'Zend\\Expressive\\Whoops',\n    Zend\\Expressive\\Container\\WhoopsFactory::class\n);\n$container->setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class\n);\n\n// Error Handling\n\n// All environments:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorHandler::class,\n    Zend\\Expressive\\Container\\ErrorHandlerFactory::class\n);\n\n// If in development:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n);\n\n// If in production:\n$container->setFactory(\n    Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n    Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n);\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(\\Zend\\Expressive\\Application::class);\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();",
            "title": "Programmatically"
        },
        {
            "location": "/v2/features/container/zend-servicemanager/#configuration-driven-container",
            "text": "Alternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in  config/config.php , and our config/container.php  file will still return our service manager instance; we'll\ndefine the service configuration in  config/dependencies.php :  return [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => 'Zend\\Expressive\\Delegate\\NotFoundDelegate',\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        Zend\\Expressive\\Delegate\\NotFoundDelegate::class  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];  config/container.php  becomes:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));  There is one problem, however: you may want to vary error handling strategies\nbased on whether or not you're in production: You have two choices on how to\napproach this:   Selectively inject the factory in the bootstrap.  Define the final handler service in an environment specific file and use file\n  globbing to merge files.   In the first case, you would change the  config/container.php  example to look\nlike this:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/container.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class\n        );\n        break;\n    case 'production':\n    default:\n        $container->setFactory(\n            Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class,\n            Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class\n        );\n}\nreturn $container;  In the second case, you will need to install zend-config:  $ composer require zendframework/zend-config  Then, create the directory  config/autoload/ , and create two files, dependencies.global.php  and  dependencies.local.php . In your  .gitignore ,\nadd an entry for  config/autoload/*local.php  to ensure \"local\"\n(environment-specific) files are excluded from the repository.  config/dependencies.php  will look like this:  use Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);  config/autoload/dependencies.global.php  will look like this:  return [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'aliases' => [\n        'Zend\\Expressive\\Delegate\\DefaultDelegate' => Zend\\Expressive\\Delegate\\NotFoundDelegate::class,\n    ],\n    'invokables' => [\n        Zend\\Expressive\\Router\\RouterInterface::class     => Zend\\Expressive\\Router\\AuraRouter::class,\n        Zend\\Expressive\\Template\\TemplateRendererInterface::class => 'Zend\\Expressive\\Plates\\PlatesRenderer::class\n    ],\n    'factories' => [\n        Zend\\Expressive\\Application::class       => Zend\\Expressive\\Container\\ApplicationFactory::class,\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::class,\n        Zend\\Stratigility\\Middleware\\ErrorHandler::class    => Zend\\Expressive\\Container\\ErrorHandlerFactory::class,\n        'Zend\\Expressive\\Delegate\\NotFoundDelegate'  => Zend\\Expressive\\Container\\NotFoundDelegateFactory::class,\n        Zend\\Expressive\\Middleware\\NotFoundHandler::class => Zend\\Expressive\\Container\\NotFoundHandlerFactory::class,\n    ],\n];  config/autoload/dependencies.local.php  on your development machine can look\nlike this:  return [\n    'factories' => [\n        'Zend\\Expressive\\Whoops'            => Zend\\Expressive\\Container\\WhoopsFactory::class,\n        'Zend\\Expressive\\WhoopsPageHandler' => Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::class,\n        Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class => 'Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::class,\n    ],\n];  Using the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)",
            "title": "Configuration-Driven Container"
        },
        {
            "location": "/v2/features/container/pimple/",
            "text": "Using Pimple\n\n\nPimple\n is a widely used code-driven dependency\ninjection container provided as a standalone component by SensioLabs. It\nfeatures:\n\n\n\n\ncombined parameter and service storage.\n\n\nability to define factories for specific classes.\n\n\nlazy-loading via factories.\n\n\n\n\nPimple only supports programmatic creation at this time.\n\n\nInstalling Pimple\n\n\nPimple does not currently (as of v3) implement\n\nPSR-11 Container\n; as\nsuch, you need to install the \nxtreamwayz/pimple-container-interop\n project,\nwhich provides a PSR-11 container wrapper around Pimple v3:\n\n\n$ composer require xtreamwayz/pimple-container-interop\n\n\n\nConfiguring Pimple\n\n\nTo configure Pimple, instantiate it, and then add the factories desired. We\nrecommend doing this in a dedicated script that returns the Pimple instance; in\nthis example, we'll have that in \nconfig/container.php\n.\n\n\nuse Xtreamwayz\\Pimple\\Container as Pimple;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\n$container = new Pimple();\n\n// Application and configuration\n$container['config'] = include 'config/config.php';\n$container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory;\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) {\n    return new Router\\Aura();\n};\n\n// We'll provide a default delegate:\n$delegateFactory = new Container\\NotFoundDelegateFactory();\n$container['Zend\\Expressive\\Delegate\\DefaultDelegate'] = $delegateFactory;\n$container[Zend\\Expressive\\Delegate\\NotFoundDelegate::class] = $delegateFactory;\n\n// We'll provide a not found handler:\n$container[Zend\\Expressive\\Middleware\\NotFoundHandler::class] = new Container\\NotFoundHandlerFactory();\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container[TemplateRendererInterface::class] = function ($container) {\n    return new PlatesRenderer();\n};\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator\n// implementation\n$container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory();\n$container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory();\n\n// Error Handling\n\n// - In all environments:\n$container['Zend\\Expressive\\Middleware\\ErrorHandler'] = new Container\\ErrorHandlerFactory();\n\n// If in development:\n$container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\WhoopsErrorResponseGeneratorFactory();\n\n// If in production:\n$container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\ErrorResponseGeneratorFactory();\n\nreturn $container;\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();\n\n\n\n\n\nEnvironments\n\n\nIn the example above, we provide two alternate definitions for the\nservice \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n, one for\ndevelopment and one for production. You will need to add logic to your file to\ndetermine which definition to provide; this could be accomplished via an\nenvironment variable.",
            "title": "Using Pimple"
        },
        {
            "location": "/v2/features/container/pimple/#using-pimple",
            "text": "Pimple  is a widely used code-driven dependency\ninjection container provided as a standalone component by SensioLabs. It\nfeatures:   combined parameter and service storage.  ability to define factories for specific classes.  lazy-loading via factories.   Pimple only supports programmatic creation at this time.",
            "title": "Using Pimple"
        },
        {
            "location": "/v2/features/container/pimple/#installing-pimple",
            "text": "Pimple does not currently (as of v3) implement PSR-11 Container ; as\nsuch, you need to install the  xtreamwayz/pimple-container-interop  project,\nwhich provides a PSR-11 container wrapper around Pimple v3:  $ composer require xtreamwayz/pimple-container-interop",
            "title": "Installing Pimple"
        },
        {
            "location": "/v2/features/container/pimple/#configuring-pimple",
            "text": "To configure Pimple, instantiate it, and then add the factories desired. We\nrecommend doing this in a dedicated script that returns the Pimple instance; in\nthis example, we'll have that in  config/container.php .  use Xtreamwayz\\Pimple\\Container as Pimple;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\n$container = new Pimple();\n\n// Application and configuration\n$container['config'] = include 'config/config.php';\n$container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory;\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) {\n    return new Router\\Aura();\n};\n\n// We'll provide a default delegate:\n$delegateFactory = new Container\\NotFoundDelegateFactory();\n$container['Zend\\Expressive\\Delegate\\DefaultDelegate'] = $delegateFactory;\n$container[Zend\\Expressive\\Delegate\\NotFoundDelegate::class] = $delegateFactory;\n\n// We'll provide a not found handler:\n$container[Zend\\Expressive\\Middleware\\NotFoundHandler::class] = new Container\\NotFoundHandlerFactory();\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container[TemplateRendererInterface::class] = function ($container) {\n    return new PlatesRenderer();\n};\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator\n// implementation\n$container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory();\n$container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory();\n\n// Error Handling\n\n// - In all environments:\n$container['Zend\\Expressive\\Middleware\\ErrorHandler'] = new Container\\ErrorHandlerFactory();\n\n// If in development:\n$container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\WhoopsErrorResponseGeneratorFactory();\n\n// If in production:\n$container[Zend\\Expressive\\Middleware\\ErrorResponseGenerator::class] = new Container\\ErrorResponseGeneratorFactory();\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n// All versions:\n$app->run();",
            "title": "Configuring Pimple"
        },
        {
            "location": "/v2/features/container/pimple/#environments",
            "text": "In the example above, we provide two alternate definitions for the\nservice  Zend\\Expressive\\Middleware\\ErrorResponseGenerator , one for\ndevelopment and one for production. You will need to add logic to your file to\ndetermine which definition to provide; this could be accomplished via an\nenvironment variable.",
            "title": "Environments"
        },
        {
            "location": "/v2/features/container/aura-di/",
            "text": "Using Aura.Di\n\n\nAura.Di\n provides a serializable dependency\ninjection container with the following features:\n\n\n\n\nconstructor and setter injection.\n\n\ninheritance of constructor parameter and setter method values from parent\n  classes.\n\n\ninheritance of setter method values from interfaces and traits.\n\n\nlazy-loaded instances, services, includes/requires, and values.\n\n\ninstance factories.\n\n\noptional auto-resolution of typehinted constructor parameter values.\n\n\n\n\nInstalling Aura.Di\n\n\nAura.Di implements \nPSR-11\n as of version\n3.\n\n\n$ composer require aura/di\n\n\n\nConfiguration\n\n\nAura.Di can help you to organize your code better with\n\nContainerConfig classes\n and\n\ntwo step configuration\n.\nIn this example, we'll put that in \nconfig/container.php\n:\n\n\n<?php\nuse Aura\\Di\\ContainerBuilder;\n\n$containerBuilder = new ContainerBuilder();\n\n// Use the builder to create and configure a container using an array of\n// ContainerConfig classes. Make sure the classes can be autoloaded!\nreturn $containerBuilder->newConfiguredInstance([\n    'Application\\Config\\Common',\n]);\n\n\n\nThe bare minimum \nContainerConfig\n code needed to make zend-expressive work is:\n\n\n<?php\n// In src/Config/Common.php:\nnamespace Application\\Config;\n\nuse Aura\\Di\\Container;\nuse Aura\\Di\\ContainerConfig;\nuse Aura\\Router\\Generator;\nuse Aura\\Router\\RouteCollection;\nuse Aura\\Router\\RouteFactory;\nuse Aura\\Router\\Router;\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container as ExpressiveContainer;\nuse Zend\\Expressive\\Delegate;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router\\AuraRouter;\nuse Zend\\Expressive\\Router\\Route;\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass Common extends ContainerConfig\n{\n    public function define(Container $di)\n    {\n        $di->params[RouteCollection::class] = array(\n            'route_factory' => $di->lazyNew(RouteFactory::class),\n        );\n        $di->params[Router::class] = array(\n            'routes' => $di->lazyNew(RouteCollection::class),\n            'generator' => $di->lazyNew(Generator::class),\n        );\n        $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class);\n        $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class));\n        $di->set(Container\\NotFoundDelegateFactory::class, $di->lazyNew(ExpressiveContainer\\NotFoundDelegateFactory::class));\n        $di->set(Delegate\\NotFoundDelegate::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di));\n        $di->set('Zend\\Expressive\\Delegate\\DefaultDelegate', $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di));\n        $di->set(Container\\ApplicationFactory::class, $di->lazyNew(ExpressiveContainer\\ApplicationFactory::class));\n        $di->set(Application::class, $di->lazyGetCall(ExpressiveContainer\\ApplicationFactory::class, '__invoke', $di));\n\n        // Not Found handler\n        $di->set(Middleware\\NotFoundHandler::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundHandlerFactory::class, '__invoke', $di));\n\n        // Templating\n        // In most cases, you can instantiate the template renderer you want to use\n        // without using a factory:\n        $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class));\n\n        // These next two can be added in any environment; they won't be used unless\n        // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator implementation:\n        $di->set(ExpressiveContainer\\WhoopsFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsFactory::class));\n        $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(ExpressiveContainer\\WhoopsFactory::class, '__invoke', $di));\n        $di->set(ExpressiveContainer\\WhoopsPageHandlerFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsPageHandlerFactory::class));\n        $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(ExpressiveContainer\\WhoopsPageHandlerFactory::class, '__invoke', $di));\n\n        // Error Handling\n        $di->set('Zend\\Stratigility\\Middleware\\ErrorHandler', $di->lazyGetCall(ExpressiveContainer\\ErrorHandlerFactory::class, '__invoke', $di));\n\n        // If in development:\n        $di->set(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class));\n        $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, '__invoke', $di));\n\n        // If in production:\n        // $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(Container\\ErrorResponseGeneratorFactory::class, '__invoke', $di));\n    }\n\n    public function modify(Container $di)\n    {\n        /*\n        $router = $di->get(RouterInterface::class);\n        $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) {\n            $escaper = new Escaper();\n            $name = $request->getAttribute('name', 'World');\n            $response->getBody()->write('Hello ' . $escaper->escapeHtml($name));\n            return $response;\n        }, Route::HTTP_METHOD_ANY, 'hello'));\n        */\n    }\n}\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();",
            "title": "Using Aura.Di"
        },
        {
            "location": "/v2/features/container/aura-di/#using-auradi",
            "text": "Aura.Di  provides a serializable dependency\ninjection container with the following features:   constructor and setter injection.  inheritance of constructor parameter and setter method values from parent\n  classes.  inheritance of setter method values from interfaces and traits.  lazy-loaded instances, services, includes/requires, and values.  instance factories.  optional auto-resolution of typehinted constructor parameter values.",
            "title": "Using Aura.Di"
        },
        {
            "location": "/v2/features/container/aura-di/#installing-auradi",
            "text": "Aura.Di implements  PSR-11  as of version\n3.  $ composer require aura/di",
            "title": "Installing Aura.Di"
        },
        {
            "location": "/v2/features/container/aura-di/#configuration",
            "text": "Aura.Di can help you to organize your code better with ContainerConfig classes  and two step configuration .\nIn this example, we'll put that in  config/container.php :  <?php\nuse Aura\\Di\\ContainerBuilder;\n\n$containerBuilder = new ContainerBuilder();\n\n// Use the builder to create and configure a container using an array of\n// ContainerConfig classes. Make sure the classes can be autoloaded!\nreturn $containerBuilder->newConfiguredInstance([\n    'Application\\Config\\Common',\n]);  The bare minimum  ContainerConfig  code needed to make zend-expressive work is:  <?php\n// In src/Config/Common.php:\nnamespace Application\\Config;\n\nuse Aura\\Di\\Container;\nuse Aura\\Di\\ContainerConfig;\nuse Aura\\Router\\Generator;\nuse Aura\\Router\\RouteCollection;\nuse Aura\\Router\\RouteFactory;\nuse Aura\\Router\\Router;\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container as ExpressiveContainer;\nuse Zend\\Expressive\\Delegate;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router\\AuraRouter;\nuse Zend\\Expressive\\Router\\Route;\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass Common extends ContainerConfig\n{\n    public function define(Container $di)\n    {\n        $di->params[RouteCollection::class] = array(\n            'route_factory' => $di->lazyNew(RouteFactory::class),\n        );\n        $di->params[Router::class] = array(\n            'routes' => $di->lazyNew(RouteCollection::class),\n            'generator' => $di->lazyNew(Generator::class),\n        );\n        $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class);\n        $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class));\n        $di->set(Container\\NotFoundDelegateFactory::class, $di->lazyNew(ExpressiveContainer\\NotFoundDelegateFactory::class));\n        $di->set(Delegate\\NotFoundDelegate::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di));\n        $di->set('Zend\\Expressive\\Delegate\\DefaultDelegate', $di->lazyGetCall(ExpressiveContainer\\NotFoundDelegateFactory::class, '__invoke', $di));\n        $di->set(Container\\ApplicationFactory::class, $di->lazyNew(ExpressiveContainer\\ApplicationFactory::class));\n        $di->set(Application::class, $di->lazyGetCall(ExpressiveContainer\\ApplicationFactory::class, '__invoke', $di));\n\n        // Not Found handler\n        $di->set(Middleware\\NotFoundHandler::class, $di->lazyGetCall(ExpressiveContainer\\NotFoundHandlerFactory::class, '__invoke', $di));\n\n        // Templating\n        // In most cases, you can instantiate the template renderer you want to use\n        // without using a factory:\n        $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class));\n\n        // These next two can be added in any environment; they won't be used unless\n        // you add the WhoopsErrorResponseGenerator as the ErrorResponseGenerator implementation:\n        $di->set(ExpressiveContainer\\WhoopsFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsFactory::class));\n        $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(ExpressiveContainer\\WhoopsFactory::class, '__invoke', $di));\n        $di->set(ExpressiveContainer\\WhoopsPageHandlerFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsPageHandlerFactory::class));\n        $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(ExpressiveContainer\\WhoopsPageHandlerFactory::class, '__invoke', $di));\n\n        // Error Handling\n        $di->set('Zend\\Stratigility\\Middleware\\ErrorHandler', $di->lazyGetCall(ExpressiveContainer\\ErrorHandlerFactory::class, '__invoke', $di));\n\n        // If in development:\n        $di->set(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, $di->lazyNew(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class));\n        $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(ExpressiveContainer\\WhoopsErrorResponseGeneratorFactory::class, '__invoke', $di));\n\n        // If in production:\n        // $di->set(Middleware\\ErrorResponseGenerator::class, $di->lazyGetCall(Container\\ErrorResponseGeneratorFactory::class, '__invoke', $di));\n    }\n\n    public function modify(Container $di)\n    {\n        /*\n        $router = $di->get(RouterInterface::class);\n        $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) {\n            $escaper = new Escaper();\n            $name = $request->getAttribute('name', 'World');\n            $response->getBody()->write('Hello ' . $escaper->escapeHtml($name));\n            return $response;\n        }, Route::HTTP_METHOD_ANY, 'hello'));\n        */\n    }\n}  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/container.php';\n$app = $container->get(Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();",
            "title": "Configuration"
        },
        {
            "location": "/v2/features/router/intro/",
            "text": "Routing\n\n\nOne fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:\n\n\n\n\n/books\n might return a collection of books\n\n\n/books/zend-expressive\n might return the individual book identified by\n  \"zend-expressive\".\n\n\n\n\nExpressive does not provide routing on its own; you must choose a routing\nadapter that implements \nZend\\Expressive\\Router\\RouterInterface\n and provide it\nto the \nApplication\n instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.\n\n\nRetrieving matched parameters\n\n\nRouting enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as \nattributes\n.\n\n\nIn the example above, let's assume the route was defined as \n/books/:id\n, where\n\nid\n is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the \nid\n attribute to discover what was\nmatched:\n\n\n$id = $request->getAttribute('id');\n\n\n\nRetrieving the matched route\n\n\nWhen routing is successful, the routing middleware injects a\n\nZend\\Expressive\\Router\\RouteResult\n instance as a request attribute, using that\nclass name as the attribute name. The \nRouteResult\n instance provides you access\nto the following:\n\n\n\n\nThe matched \nZend\\Expressive\\Router\\Route\n instance, via \n$result->getMatchedRoute()\n.\n\n\nThe matched route name, via \n$result->getMatchedRouteName()\n (or via\n  \n$result->getMatchedRoute()->getName()\n).\n\n\nThe matched middleware, via \n$result->getMatchedMiddleware()\n (or via\n  \n$result->getMatchedRoute()->getMiddleware()\n).\n\n\nMatched parameters, via \n$result->getMatchedParams()\n (as noted above, these\n  are also each injected as discrete request attributes).\n\n\nAllowed HTTP methods, via \n$result->getAllowedMethods()\n.\n\n\n\n\nAs an example, you could use middleware similar to the following to return a 403\nresponse if routing was successful, but no \nAuthorization\n header is present:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nfunction ($request, DelegateInterface $delegate) use ($routesRequiringAuthorization, $validator) {\n    if (! ($result = $request->getAttribute(RouteResult::class, false))) {\n        // No route matched; delegate to next middleware\n        return $delegate->process($request);\n    }\n\n    if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) {\n        // Not a route requiring authorization\n        return $delegate->process($request);\n    }\n\n    $header = $request->getHeaderLine('Authorization');\n    if (! $validator($header)) {\n        return new EmptyResponse(403);\n    }\n\n    return $delegate->process($request);\n}\n\n\n\nNote that the first step is to determine if we have a \nRouteResult\n; if we do\nnot have one, we should either delegate to the next middleware, or return some\nsort of response (generally a 404). In the case of Expressive, a later\nmiddleware will generate the 404 response for us, so we can safely delegate.\n\n\nURI generation\n\n\nBecause routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the \nRouterInterface\n,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.\n\n\nAt it's most basic level, you call the \ngenerateUri()\n method with a route name\nand any substitutions you want to make:\n\n\n$uri = $router->generateUri('book', ['id' => 'zend-expressive']);\n\n\n\nSome routers may support providing \noptions\n during URI generation. Starting in\nzend-expressive-router 2.0, which ships with Expressive starting with version\n2.0, you may also pass a third argument to \ngenerateUri()\n, an array of router\noptions:\n\n\n$uri = $router->generateUri('book', ['id' => 'zend-expressive'], [\n    'translator'  => $translator,\n    'text_domain' => $currentLocale,\n]);\n\n\n\nSupported implementations\n\n\nExpressive currently ships with adapters for the following routers:\n\n\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-mvc Router",
            "title": "Introduction"
        },
        {
            "location": "/v2/features/router/intro/#routing",
            "text": "One fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:   /books  might return a collection of books  /books/zend-expressive  might return the individual book identified by\n  \"zend-expressive\".   Expressive does not provide routing on its own; you must choose a routing\nadapter that implements  Zend\\Expressive\\Router\\RouterInterface  and provide it\nto the  Application  instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.",
            "title": "Routing"
        },
        {
            "location": "/v2/features/router/intro/#retrieving-matched-parameters",
            "text": "Routing enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as  attributes .  In the example above, let's assume the route was defined as  /books/:id , where id  is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the  id  attribute to discover what was\nmatched:  $id = $request->getAttribute('id');",
            "title": "Retrieving matched parameters"
        },
        {
            "location": "/v2/features/router/intro/#retrieving-the-matched-route",
            "text": "When routing is successful, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult  instance as a request attribute, using that\nclass name as the attribute name. The  RouteResult  instance provides you access\nto the following:   The matched  Zend\\Expressive\\Router\\Route  instance, via  $result->getMatchedRoute() .  The matched route name, via  $result->getMatchedRouteName()  (or via\n   $result->getMatchedRoute()->getName() ).  The matched middleware, via  $result->getMatchedMiddleware()  (or via\n   $result->getMatchedRoute()->getMiddleware() ).  Matched parameters, via  $result->getMatchedParams()  (as noted above, these\n  are also each injected as discrete request attributes).  Allowed HTTP methods, via  $result->getAllowedMethods() .   As an example, you could use middleware similar to the following to return a 403\nresponse if routing was successful, but no  Authorization  header is present:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nfunction ($request, DelegateInterface $delegate) use ($routesRequiringAuthorization, $validator) {\n    if (! ($result = $request->getAttribute(RouteResult::class, false))) {\n        // No route matched; delegate to next middleware\n        return $delegate->process($request);\n    }\n\n    if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) {\n        // Not a route requiring authorization\n        return $delegate->process($request);\n    }\n\n    $header = $request->getHeaderLine('Authorization');\n    if (! $validator($header)) {\n        return new EmptyResponse(403);\n    }\n\n    return $delegate->process($request);\n}  Note that the first step is to determine if we have a  RouteResult ; if we do\nnot have one, we should either delegate to the next middleware, or return some\nsort of response (generally a 404). In the case of Expressive, a later\nmiddleware will generate the 404 response for us, so we can safely delegate.",
            "title": "Retrieving the matched route"
        },
        {
            "location": "/v2/features/router/intro/#uri-generation",
            "text": "Because routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the  RouterInterface ,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.  At it's most basic level, you call the  generateUri()  method with a route name\nand any substitutions you want to make:  $uri = $router->generateUri('book', ['id' => 'zend-expressive']);  Some routers may support providing  options  during URI generation. Starting in\nzend-expressive-router 2.0, which ships with Expressive starting with version\n2.0, you may also pass a third argument to  generateUri() , an array of router\noptions:  $uri = $router->generateUri('book', ['id' => 'zend-expressive'], [\n    'translator'  => $translator,\n    'text_domain' => $currentLocale,\n]);",
            "title": "URI generation"
        },
        {
            "location": "/v2/features/router/intro/#supported-implementations",
            "text": "Expressive currently ships with adapters for the following routers:   Aura.Router  FastRoute  zend-mvc Router",
            "title": "Supported implementations"
        },
        {
            "location": "/v2/features/router/interface/",
            "text": "Routing Interface\n\n\nExpressive defines \nZend\\Expressive\\Router\\RouterInterface\n, which can be\ninjected into and consumed by \nZend\\Expressive\\Application\n in order to provide\ndynamic routing capabilities to middleware. The interface serves as an\nabstraction to allow routers with varying capabilities to be used with an\napplication.\n\n\nThe interface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @param Route $route\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route);\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     *\n     * @param  Request $request\n     * @return RouteResult\n     */\n    public function match(Request $request);\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it.\n     *\n     * @see https://github.com/auraphp/Aura.Router#generating-a-route-path\n     * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html\n     * @param string $name\n     * @param array $substitutions\n     * @param array $options\n     * @return string\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri($name, array $substitutions = [], array $options = []);\n}\n\n\n\nDevelopers may create and use their own implementations. We recommend\nregistering your implementation as the service\n\nZend\\Expressive\\Router\\RouterInterface\n in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.\n\n\nImplementors should also read the following sections detailing the \nRoute\n and\n\nRouteResult\n classes, to ensure that their implementations interoperate\ncorrectly.\n\n\nRoutes\n\n\nRoutes are defined via \nZend\\Expressive\\Router\\Route\n, and aggregate the\nfollowing information:\n\n\n\n\nPath to match.\n\n\nMiddleware to use when the route is matched. This may be a callable or a\n  service name resolving to middleware.\n\n\nHTTP methods allowed for the route; if none are provided, all are assumed.\n\n\nOptionally, a name by which to reference the route.\n\n\n\n\nThe \nRoute\n class has the following signature:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\n\nclass Route\n{\n    const HTTP_METHOD_ANY = 0xff;\n    const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param string|callable|MiddlewareInterface $middleware Middleware to use\n     *     when this route is matched.\n     * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param string|null $name the route name\n     * @throws Exception\\InvalidArgumentException for invalid path type.\n     * @throws Exception\\InvalidArgumentException for invalid middleware type.\n     * @throws Exception\\InvalidArgumentException for any invalid HTTP method names.\n     */\n    public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null);\n\n    /**\n     * @return string\n     */\n    public function getPath();\n\n    /**\n     * Set the route name.\n     *\n     * @param string $name\n     */\n    public function setName($name);\n\n    /**\n     * @return string\n     */\n    public function getName();\n\n    /**\n     * @return string|callable|MiddlewareInterface\n     */\n    public function getMiddleware();\n\n    /**\n     * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods();\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     * @return bool\n     */\n    public function allowsMethod($method);\n\n    /**\n     * @param array $options\n     */\n    public function setOptions(array $options);\n\n    /**\n     * @return array\n     */\n    public function getOptions();\n}\n\n\n\nTypically, developers will use \nZend\\Expressive\\Application::route()\n (or one of\nthe HTTP-specific routing methods) to create routes, and will not need to\ninteract with \nRoute\n instances. However, that method can \nalso\n accept \nRoute\n\ninstances, allowing more flexibility in defining and configuring them;\nadditionally, when working with \nRouteResult\n instances, you may pull the\n\nRoute\n instance from that in order to obtain data about the matched route.\n\n\nMatching and RouteResults\n\n\nInternally, \nZend\\Expressive\\Application\n calls on \nRouterInterface::match()\n,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the\n\nHTTPS\n server variable, etc.\n\n\nImplementations are expected to return a \nZend\\Expressive\\Router\\RouteResult\n\ninstance, which the routing middleware then uses to determine if routing\nsucceeded. In the event of success, it will pull any matched parameters from the\nresult and inject them as request attributes, and then pull the matched\nmiddleware and execute it. In the case of failure, it will determine if the\nfailure was due to inability to match, or usage of a disallowed HTTP method; in\nthe former case, it proceeds to the next middleware in the stack, and in the\nlatter, returns a 405 response.\n\n\nThe \nRouteResult\n signature is as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nclass RouteResult\n{\n    /**\n     * Create an instance representing a route success from a Route instance.\n     *\n     * This method should be used for generating an instance indicating a route\n     * success.\n     *\n     * @param Route $route\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRoute(Route $route, array $params = []);\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|int|array $methods HTTP methods allowed for the current URI, if any\n     * @return static\n     */\n    public static function fromRouteFailure($methods = null);\n\n    /**\n     * Does the result represent successful routing?\n     *\n     * @return bool\n     */\n    public function isSuccess();\n\n    /**\n     * Retrieve the matched route, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route instance.\n     *\n     * @return Route\n     */\n    public function getMatchedRoute();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Retrieve the matched middleware, if possible.\n     *\n     * @return false|callable|string Returns false if the result represents a\n     *     failure; otherwise, a callable or a string service name.\n     */\n    public function getMatchedMiddleware();\n\n    /**\n     * Returns the matched params.\n     *\n     * Guaranteed to return an array, even if it is simply empty.\n     *\n     * @return array\n     */\n    public function getMatchedParams();\n\n    /**\n     * Is this a routing failure result?\n     *\n     * @return bool\n     */\n    public function isFailure();\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     *\n     * @return bool\n     */\n    public function isMethodFailure();\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods();\n}\n\n\n\nTypically, only those implementing routers will interact with this class.",
            "title": "Routing Interface"
        },
        {
            "location": "/v2/features/router/interface/#routing-interface",
            "text": "Expressive defines  Zend\\Expressive\\Router\\RouterInterface , which can be\ninjected into and consumed by  Zend\\Expressive\\Application  in order to provide\ndynamic routing capabilities to middleware. The interface serves as an\nabstraction to allow routers with varying capabilities to be used with an\napplication.  The interface is defined as follows:  namespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @param Route $route\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route);\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     *\n     * @param  Request $request\n     * @return RouteResult\n     */\n    public function match(Request $request);\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it.\n     *\n     * @see https://github.com/auraphp/Aura.Router#generating-a-route-path\n     * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html\n     * @param string $name\n     * @param array $substitutions\n     * @param array $options\n     * @return string\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri($name, array $substitutions = [], array $options = []);\n}  Developers may create and use their own implementations. We recommend\nregistering your implementation as the service Zend\\Expressive\\Router\\RouterInterface  in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.  Implementors should also read the following sections detailing the  Route  and RouteResult  classes, to ensure that their implementations interoperate\ncorrectly.",
            "title": "Routing Interface"
        },
        {
            "location": "/v2/features/router/interface/#routes",
            "text": "Routes are defined via  Zend\\Expressive\\Router\\Route , and aggregate the\nfollowing information:   Path to match.  Middleware to use when the route is matched. This may be a callable or a\n  service name resolving to middleware.  HTTP methods allowed for the route; if none are provided, all are assumed.  Optionally, a name by which to reference the route.   The  Route  class has the following signature:  namespace Zend\\Expressive\\Router;\n\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\n\nclass Route\n{\n    const HTTP_METHOD_ANY = 0xff;\n    const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param string|callable|MiddlewareInterface $middleware Middleware to use\n     *     when this route is matched.\n     * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param string|null $name the route name\n     * @throws Exception\\InvalidArgumentException for invalid path type.\n     * @throws Exception\\InvalidArgumentException for invalid middleware type.\n     * @throws Exception\\InvalidArgumentException for any invalid HTTP method names.\n     */\n    public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null);\n\n    /**\n     * @return string\n     */\n    public function getPath();\n\n    /**\n     * Set the route name.\n     *\n     * @param string $name\n     */\n    public function setName($name);\n\n    /**\n     * @return string\n     */\n    public function getName();\n\n    /**\n     * @return string|callable|MiddlewareInterface\n     */\n    public function getMiddleware();\n\n    /**\n     * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods();\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     * @return bool\n     */\n    public function allowsMethod($method);\n\n    /**\n     * @param array $options\n     */\n    public function setOptions(array $options);\n\n    /**\n     * @return array\n     */\n    public function getOptions();\n}  Typically, developers will use  Zend\\Expressive\\Application::route()  (or one of\nthe HTTP-specific routing methods) to create routes, and will not need to\ninteract with  Route  instances. However, that method can  also  accept  Route \ninstances, allowing more flexibility in defining and configuring them;\nadditionally, when working with  RouteResult  instances, you may pull the Route  instance from that in order to obtain data about the matched route.",
            "title": "Routes"
        },
        {
            "location": "/v2/features/router/interface/#matching-and-routeresults",
            "text": "Internally,  Zend\\Expressive\\Application  calls on  RouterInterface::match() ,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the HTTPS  server variable, etc.  Implementations are expected to return a  Zend\\Expressive\\Router\\RouteResult \ninstance, which the routing middleware then uses to determine if routing\nsucceeded. In the event of success, it will pull any matched parameters from the\nresult and inject them as request attributes, and then pull the matched\nmiddleware and execute it. In the case of failure, it will determine if the\nfailure was due to inability to match, or usage of a disallowed HTTP method; in\nthe former case, it proceeds to the next middleware in the stack, and in the\nlatter, returns a 405 response.  The  RouteResult  signature is as follows:  namespace Zend\\Expressive\\Router;\n\nclass RouteResult\n{\n    /**\n     * Create an instance representing a route success from a Route instance.\n     *\n     * This method should be used for generating an instance indicating a route\n     * success.\n     *\n     * @param Route $route\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRoute(Route $route, array $params = []);\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|int|array $methods HTTP methods allowed for the current URI, if any\n     * @return static\n     */\n    public static function fromRouteFailure($methods = null);\n\n    /**\n     * Does the result represent successful routing?\n     *\n     * @return bool\n     */\n    public function isSuccess();\n\n    /**\n     * Retrieve the matched route, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route instance.\n     *\n     * @return Route\n     */\n    public function getMatchedRoute();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Retrieve the matched middleware, if possible.\n     *\n     * @return false|callable|string Returns false if the result represents a\n     *     failure; otherwise, a callable or a string service name.\n     */\n    public function getMatchedMiddleware();\n\n    /**\n     * Returns the matched params.\n     *\n     * Guaranteed to return an array, even if it is simply empty.\n     *\n     * @return array\n     */\n    public function getMatchedParams();\n\n    /**\n     * Is this a routing failure result?\n     *\n     * @return bool\n     */\n    public function isFailure();\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     *\n     * @return bool\n     */\n    public function isMethodFailure();\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods();\n}  Typically, only those implementing routers will interact with this class.",
            "title": "Matching and RouteResults"
        },
        {
            "location": "/v2/features/router/uri-generation/",
            "text": "URI Generation\n\n\nOne aspect of the \nZend\\Expressive\\Router\\RouterInterface\n is that it provides a\n\ngenerateUri()\n method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders). You may also pass router-specific options to use\nduring URI generation as a third argument.\n\n\nNaming routes\n\n\nBy default, routes use a combination of the path and HTTP methods supported as\nthe name:\n\n\n\n\nIf you call \nroute()\n with no HTTP methods, the name is the literal path with\n  no changes.\n\n\n\n\n$app->route('/foo', $middleware); // \"foo\"\n\n\n\n\n\nIf you call \nget()\n, \npost()\n, \nput()\n, \npatch()\n, or \ndelete()\n, the name\n  will be the literal path, followed by a caret (\n^\n), followed by the\n  uppercase HTTP method name:\n\n\n\n\n$app->get('/foo', $middleware); // \"foo^GET\"\n\n\n\nAlternately, these methods return a \nRoute\n instance, and you can set the\n  name on it:\n\n\n$app->get('/foo', $middleware)->setName('foo'); // \"foo\"\n\n\n\n\n\nIf you call \nroute()\n and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret (\n^\n), followed by a colon\n  (\n:\n)-separated list of the uppercase HTTP method names, in the order in which\n  they were added.\n\n\n\n\n$app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n\n\n\nLike the HTTP-specific methods, \nroute()\n also returns a \nRoute\n instance,\n  and you can set the name on it:\n\n\n$route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n$route->setName('foo'); // \"foo\"\n\n\n\nClearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:\n\n\n$app->route('/foo', $middleware, 'foo'); // 'foo'\n$app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'\n\n\n\nAs noted above, these methods also return \nRoute\n instances, allowing you to\nset the name after-the-fact; this is particularly useful with the \nroute()\n\nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:\n\n\n$app->route('/foo', $middleware)->setName('foo'); // 'foo'\n\n\n\nWe recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.\n\n\nGenerating URIs\n\n\nOnce you know the name of a URI you wish to generate, you can do so from the\nrouter instance:\n\n\n$uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\"\n\n\n\nYou can omit the second argument if no substitutions are necessary.\n\n\n\n\nCompose the router\n\n\nFor this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the\n\nZend\\Expressive\\Router\\RouterInterface\n service in these situations.",
            "title": "URI Generation"
        },
        {
            "location": "/v2/features/router/uri-generation/#uri-generation",
            "text": "One aspect of the  Zend\\Expressive\\Router\\RouterInterface  is that it provides a generateUri()  method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders). You may also pass router-specific options to use\nduring URI generation as a third argument.",
            "title": "URI Generation"
        },
        {
            "location": "/v2/features/router/uri-generation/#naming-routes",
            "text": "By default, routes use a combination of the path and HTTP methods supported as\nthe name:   If you call  route()  with no HTTP methods, the name is the literal path with\n  no changes.   $app->route('/foo', $middleware); // \"foo\"   If you call  get() ,  post() ,  put() ,  patch() , or  delete() , the name\n  will be the literal path, followed by a caret ( ^ ), followed by the\n  uppercase HTTP method name:   $app->get('/foo', $middleware); // \"foo^GET\"  Alternately, these methods return a  Route  instance, and you can set the\n  name on it:  $app->get('/foo', $middleware)->setName('foo'); // \"foo\"   If you call  route()  and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret ( ^ ), followed by a colon\n  ( : )-separated list of the uppercase HTTP method names, in the order in which\n  they were added.   $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"  Like the HTTP-specific methods,  route()  also returns a  Route  instance,\n  and you can set the name on it:  $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n$route->setName('foo'); // \"foo\"  Clearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:  $app->route('/foo', $middleware, 'foo'); // 'foo'\n$app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'  As noted above, these methods also return  Route  instances, allowing you to\nset the name after-the-fact; this is particularly useful with the  route() \nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:  $app->route('/foo', $middleware)->setName('foo'); // 'foo'  We recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.",
            "title": "Naming routes"
        },
        {
            "location": "/v2/features/router/uri-generation/#generating-uris",
            "text": "Once you know the name of a URI you wish to generate, you can do so from the\nrouter instance:  $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\"  You can omit the second argument if no substitutions are necessary.",
            "title": "Generating URIs"
        },
        {
            "location": "/v2/features/router/uri-generation/#compose-the-router",
            "text": "For this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the Zend\\Expressive\\Router\\RouterInterface  service in these situations.",
            "title": "Compose the router"
        },
        {
            "location": "/v2/features/router/piping/",
            "text": "Routing vs Piping\n\n\nExpressive provides two mechanisms for adding middleware to your\napplication:\n\n\n\n\npiping, which is a foundation feature of the underlying\n  \nzend-stratigility\n\n  implementation.\n\n\nrouting, which is an additional feature provided by zend-expressive.\n\n\n\n\nPiping\n\n\nzend-stratigility provides a mechanism termed \npiping\n for composing middleware\nin an application. When you \npipe\n middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\nIf none ever returns a response instance, execution is delegated to a \"final\nhandler\", which determines whether or not to return an error, and, if so, what\nkind of error to return.\n\n\nStratigility also allows you to segregate piped middleware to specific paths. As\nan example:\n\n\n$app->pipe('/api', $apiMiddleware);\n\n\n\nwill execute \n$apiMiddleware\n only if the path matches \n/api\n; otherwise, it\nwill skip over that middleware.\n\n\nThis path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.\n\n\nExpressive uses and exposes piping to users, with one addition: \nmiddleware\nmay be specified by service name, and zend-expressive will lazy-load the service\nonly when the middleware is invoked\n.\n\n\nIn order to accomplish the lazy-loading, zend-expressive wraps the calls to\nfetch and dispatch the middleware inside a\n\nZend\\Expressive\\Middleware\\LazyLoadingMiddleware\n instance; as such, there is\nno overhead to utilizing service-based middleware \nuntil it is dispatched\n.\n\n\nRouting\n\n\nRouting is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:\n\n\n\n\n/book/:id\n (ZF2)\n\n\n/book/{id}\n (Aura.Router)\n\n\n/book/{id:\\d+}\n (FastRoute)\n\n\n\n\nIn each of the above, if the router determines that the request matches the\ncriteria, it will indicate:\n\n\n\n\nthe route that matched\n\n\nthe \nid\n parameter was matched, and the value matched\n\n\n\n\nMost routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:\n\n\n\n\ndefault values for unmatched parameters\n\n\ncriteria for evaluating a match (such as a regular expression)\n\n\nadditional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)\n\n\n\n\nAs such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).\n\n\nWhen to Pipe\n\n\nIn Expressive, we recommend that you pipe middleware in the following\ncircumstances:\n\n\n\n\nIt should (potentially) run on every execution. Examples for such usage\n  include:\n\n\nLogging requests\n\n\nPerforming content negotiation\n\n\nHandling cookies\n\n\n\n\n\n\nError handling.\n\n\nApplication segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.\n\n\n\n\nWhen to Route\n\n\nUse routing when:\n\n\n\n\nYour middleware is reacting to a given path.\n\n\nYou want to use dynamic routing.\n\n\nYou want to restrict usage of middleware to specific HTTP methods.\n\n\nYou want to be able to generate URIs to your middleware.\n\n\n\n\nThe above cover most use cases; \nin other words, most middleware should be added\nto the application as routed middleware\n.\n\n\nControlling middleware execution order\n\n\nAs noted in the earlier section on piping, piped middleware is \nqueued\n, meaning\nit has a FIFO (\"first in, first out\") execution order.\n\n\nAdditionally, zend-expressive's routing and dispatch capabilities are themselves\nimplemented as piped middleware.\n\n\nTo ensure your middleware is piped correctly, keep in mind the following:\n\n\n\n\nIf middleware should execute on \nevery request\n, pipe it early.\n\n\nPipe routing and dispatch middleware using their dedicated application methods\n  (more on this below), optionally with middleware between them to further shape\n  application flow.\n\n\nPipe middleware guaranteed to return a response (such as a \"not found\" handler\n  or similar) \nlast\n.\n\n\n\n\nTo use the shipped routing and dispatch middleware (likely a good idea!), use\nthe dedicated application methods \npipeRoutingMiddleware()\n and\n\npipeDispatchMiddleware()\n; \nApplication\n contains logic to ensure neither of\nthese are called more than once.\n\n\nAs an example:\n\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipe(XClacksOverhead::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipe(AuthorizationCheck::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);",
            "title": "Routing vs Piping"
        },
        {
            "location": "/v2/features/router/piping/#routing-vs-piping",
            "text": "Expressive provides two mechanisms for adding middleware to your\napplication:   piping, which is a foundation feature of the underlying\n   zend-stratigility \n  implementation.  routing, which is an additional feature provided by zend-expressive.",
            "title": "Routing vs Piping"
        },
        {
            "location": "/v2/features/router/piping/#piping",
            "text": "zend-stratigility provides a mechanism termed  piping  for composing middleware\nin an application. When you  pipe  middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\nIf none ever returns a response instance, execution is delegated to a \"final\nhandler\", which determines whether or not to return an error, and, if so, what\nkind of error to return.  Stratigility also allows you to segregate piped middleware to specific paths. As\nan example:  $app->pipe('/api', $apiMiddleware);  will execute  $apiMiddleware  only if the path matches  /api ; otherwise, it\nwill skip over that middleware.  This path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.  Expressive uses and exposes piping to users, with one addition:  middleware\nmay be specified by service name, and zend-expressive will lazy-load the service\nonly when the middleware is invoked .  In order to accomplish the lazy-loading, zend-expressive wraps the calls to\nfetch and dispatch the middleware inside a Zend\\Expressive\\Middleware\\LazyLoadingMiddleware  instance; as such, there is\nno overhead to utilizing service-based middleware  until it is dispatched .",
            "title": "Piping"
        },
        {
            "location": "/v2/features/router/piping/#routing",
            "text": "Routing is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:   /book/:id  (ZF2)  /book/{id}  (Aura.Router)  /book/{id:\\d+}  (FastRoute)   In each of the above, if the router determines that the request matches the\ncriteria, it will indicate:   the route that matched  the  id  parameter was matched, and the value matched   Most routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:   default values for unmatched parameters  criteria for evaluating a match (such as a regular expression)  additional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)   As such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).",
            "title": "Routing"
        },
        {
            "location": "/v2/features/router/piping/#when-to-pipe",
            "text": "In Expressive, we recommend that you pipe middleware in the following\ncircumstances:   It should (potentially) run on every execution. Examples for such usage\n  include:  Logging requests  Performing content negotiation  Handling cookies    Error handling.  Application segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.",
            "title": "When to Pipe"
        },
        {
            "location": "/v2/features/router/piping/#when-to-route",
            "text": "Use routing when:   Your middleware is reacting to a given path.  You want to use dynamic routing.  You want to restrict usage of middleware to specific HTTP methods.  You want to be able to generate URIs to your middleware.   The above cover most use cases;  in other words, most middleware should be added\nto the application as routed middleware .",
            "title": "When to Route"
        },
        {
            "location": "/v2/features/router/piping/#controlling-middleware-execution-order",
            "text": "As noted in the earlier section on piping, piped middleware is  queued , meaning\nit has a FIFO (\"first in, first out\") execution order.  Additionally, zend-expressive's routing and dispatch capabilities are themselves\nimplemented as piped middleware.  To ensure your middleware is piped correctly, keep in mind the following:   If middleware should execute on  every request , pipe it early.  Pipe routing and dispatch middleware using their dedicated application methods\n  (more on this below), optionally with middleware between them to further shape\n  application flow.  Pipe middleware guaranteed to return a response (such as a \"not found\" handler\n  or similar)  last .   To use the shipped routing and dispatch middleware (likely a good idea!), use\nthe dedicated application methods  pipeRoutingMiddleware()  and pipeDispatchMiddleware() ;  Application  contains logic to ensure neither of\nthese are called more than once.  As an example:  $app->pipe(OriginalMessages::class);\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipe(XClacksOverhead::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipe(AuthorizationCheck::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);",
            "title": "Controlling middleware execution order"
        },
        {
            "location": "/v2/features/router/aura/",
            "text": "Using Aura.Router\n\n\nAura.Router\n provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:\n\n\n\n\nA regular expression that applies the same for a given routing match:\n\n\n\n\n// Parameters named \"id\" will only match digits by default:\n$router->addTokens([\n  'id' => '\\d+',\n]);\n\n\n\n\n\nA default parameter and/or its default value to always provide:\n\n\n\n\n// mediatype defaults to \"application/xhtml+xml\" and will be available in all\n// requests:\n$router->addValues([\n  'mediatype' => 'application/xhtml+xml',\n]);\n\n\n\n\n\nOnly match if secure (i.e., under HTTPS):\n\n\n\n\n$router->setSecure(true);\n\n\n\nIn order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling Aura.Router\n\n\nTo use Aura.Router, you will first need to install the Aura.Router integration:\n\n\n$ composer require zendframework/zend-expressive-aurarouter\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\AuraRouter\n instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\AuraRouter\n during instantiation.\n\n\n<?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())->newInstance();\n$auraRouter->setSecure(true);\n$auraRouter->addValues([\n    'mediatype' => 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your Aura.Router implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\AuraRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Application\\Container\\RouterFactory::class\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nAura\\Router\\Router\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\AuraRouter\n instance composing the\n  \nAura\\Router\\Router\n instance.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n// in src/Application/Container/AuraRouterFactory.php:\nnamespace Application\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Psr\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())->newInstance();\n        $router->setSecure(true);\n        $router->addValues([\n            'mediatype' => 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container->get('Aura\\Router\\Router'));\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'Aura\\Router\\Router',\n    Application\\Container\\AuraRouterFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'Aura\\Router\\Router' => Application\\Container\\AuraRouterFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => 'Application\\Container\\RouterFactory::class,\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\AuraRouterFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['Aura\\Router\\Router'] = new AuraRouterFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Using Aura"
        },
        {
            "location": "/v2/features/router/aura/#using-aurarouter",
            "text": "Aura.Router  provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:   A regular expression that applies the same for a given routing match:   // Parameters named \"id\" will only match digits by default:\n$router->addTokens([\n  'id' => '\\d+',\n]);   A default parameter and/or its default value to always provide:   // mediatype defaults to \"application/xhtml+xml\" and will be available in all\n// requests:\n$router->addValues([\n  'mediatype' => 'application/xhtml+xml',\n]);   Only match if secure (i.e., under HTTPS):   $router->setSecure(true);  In order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.",
            "title": "Using Aura.Router"
        },
        {
            "location": "/v2/features/router/aura/#installing-aurarouter",
            "text": "To use Aura.Router, you will first need to install the Aura.Router integration:  $ composer require zendframework/zend-expressive-aurarouter",
            "title": "Installing Aura.Router"
        },
        {
            "location": "/v2/features/router/aura/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\AuraRouter  instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:  use Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/v2/features/router/aura/#programmatic-creation",
            "text": "If you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter  during instantiation.  <?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())->newInstance();\n$auraRouter->setSecure(true);\n$auraRouter->addValues([\n    'mediatype' => 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/v2/features/router/aura/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/v2/features/router/aura/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your Aura.Router implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/v2/features/router/aura/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\AuraRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Application\\Container\\RouterFactory::class\n);  And in Pimple:  $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\AuraRouter::class\n);",
            "title": "Basic Router"
        },
        {
            "location": "/v2/features/router/aura/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Aura\\Router\\Router  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\AuraRouter  instance composing the\n   Aura\\Router\\Router  instance.   Sound difficult? It's not; we've essentially done it above already!  // in src/Application/Container/AuraRouterFactory.php:\nnamespace Application\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Psr\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())->newInstance();\n        $router->setSecure(true);\n        $router->addValues([\n            'mediatype' => 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container->get('Aura\\Router\\Router'));\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'Aura\\Router\\Router',\n    Application\\Container\\AuraRouterFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'Aura\\Router\\Router' => Application\\Container\\AuraRouterFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => 'Application\\Container\\RouterFactory::class,\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\AuraRouterFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['Aura\\Router\\Router'] = new AuraRouterFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/v2/features/router/fast-route/",
            "text": "Using FastRoute\n\n\nFastRoute\n provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.\n\n\nInternally, we use the standard route parser (\nFastRoute\\RouterParser\\Std\n) to\nparse routes, a \nRouteCollector\n to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.\n\n\nIf you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the \nZend\\Expressive\\Router\\FastRouteRouter\n class, at instantiation.\n\n\nThe \nFastRouteRouter\n bridge class accepts two arguments at instantiation:\n\n\n\n\nA \nFastRoute\\RouteCollector\n instance\n\n\nA callable that will return a \nFastRoute\\Dispatcher\\RegexBasedAbstract\n\n  instance.\n\n\n\n\nInjection can be done either programmatically or via a factory to use in\nconjunction with your container instance.\n\n\nInstalling FastRoute\n\n\nTo use FastRoute, you will first need to install the FastRoute integration:\n\n\n$ composer require zendframework/zend-expressive-fastroute\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\FastRouteRouter\n instance\nwith no arguments; it will create the underlying FastRoute objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\n$router = new FastRouteRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the FastRoute setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\FastRouteRouter\n during instantiation.\n\n\nTo do so, you will need to setup your \nRouteCollector\n instance and/or\noptionally callable to return your \nRegexBasedAbstract\n instance manually,\ninject them in your \nZend\\Expressive\\Router\\FastRouteRouter\n instance, and inject use\nthat when creating your \nApplication\n instance.\n\n\n<?php\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\n$fastRoute = new RouteCollector(\n    new RouteParser(),\n    new RouteGenerator()\n);\n$getDispatcher = function ($data) {\n    return new FastRouteDispatcher($data);\n};\n\n\n$router = new FastRouteBridge($fastRoute, $getDispatcher);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your FastRoute implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\FastRouteRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new App\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\FastRouteRouter::class\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:\n\n\n\n\nA factory to register as and generate a \nFastRoute\\RouteCollector\n instance.\n\n\nA factory to register as \nFastRoute\\DispatcherFactory\n and return a callable\n  factory that returns a \nRegexBasedAbstract\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\FastRouteRouter\n instance composing the\n  two services.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n<?php\n// in src/App/Container/FastRouteCollectorFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/App/Container/FastRouteDispatcherFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container->get(FastRoute\\RouteCollector::class),\n            $container->get(FastRoute\\DispatcherFactory::class)\n        );\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    FastRoute\\RouteCollector::class,\n    App\\Container\\FastRouteCollectorFactory::class\n);\n$container->addFactory(\n    FastRoute\\DispatcherFactory::class,\n    App\\Container\\FastRouteDispatcherFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'FastRoute\\RouteCollector' => App\\Container\\FastRouteCollectorFactory::class,\n        'FastRoute\\DispatcherFactory' => App\\Container\\FastRouteDispatcherFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse App\\Container\\FastRouteCollectorFactory;\nuse App\\Container\\FastRouteDispatcherFactory;\nuse App\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container[FastRoute\\RouteCollector::class] = new FastRouteCollectorFactory();\n$container[FastRoute\\RouteDispatcher::class] = new FastRouteDispatcherFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();\n\n\n\nFastRoute caching support\n\n\n\n\nSince zend-expressive-fastroute 1.3.0.\n\n\n\n\nStarting from version 1.3.0, zend-expressive-fastroute comes with support\nfor FastRoute native dispatch data caching.\n\n\nEnabling this feature requires changes to your configuration. Typically, router\nconfiguration occurs in \nconfig/autoload/routes.global.php\n; as such, we will\nreference that file when indicating configuration changes.\n\n\nThe changes required are:\n\n\n\n\n\n\nYou will need to delegate creation of the router instance to a new factory.\n\n\n\n\n\n\nYou will need to add a new configuration entry, \n$config['router']['fastroute']\n.\n  The options in this entry will be used by the factory to build the router\n  instance in order to toggle caching support and to specify a custom cache\n  file.\n\n\n\n\n\n\nAs an example:\n\n\n// File config/autoload/routes.global.php\n\nreturn [\n    'dependencies' => [\n        //..\n        'invokables' => [\n            /* ... */\n            // Comment out or remove the following line:\n            // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n            // Add this line; the specified factory now creates the router instance:\n            Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class,\n            /* ... */\n        ],\n    ],\n\n    // Add the following to enable caching support:\n    'router' => [\n        'fastroute' => [\n             // Enable caching support:\n            'cache_enabled' => true,\n             // Optional (but recommended) cache file path:\n            'cache_file'    => 'data/cache/fastroute.php.cache',\n        ],\n    ],\n\n    'routes' => [ /* ... */ ],\n]\n\n\n\nThe FastRoute-specific caching options are as follows:\n\n\n\n\n\n\ncache_enabled\n (bool) is used to toggle caching support. It's advisable to enable\n  caching in a production environment and leave it disabled for the development\n  environment. Commenting or omitting this option is equivalent to having it set\n  to \nfalse\n. We recommend enabling it in \nconfig/autoload/routes.global.php\n,\n  and, in development, disabling it within \nconfig/autoload/routes.local.php\n or\n  \nconfig/autoload/local.php\n.\n\n\n\n\n\n\ncache_file\n (string) is an optional parameter that represents the path of\n  the dispatch data cache file. It can be provided as an absolute file path or\n  as a path relative to the zend-expressive working directory.\n\n\n\n\n\n\nIt defaults to \ndata/cache/fastroute.php.cache\n, where \ndata/cache/\n is the\n  cache directory defined within the zend-expressive skeleton application.  An\n  explicit absolute file path is recommended since the php \ninclude\n construct\n  will skip searching the \ninclude_path\n and the current directory.\n\n\nIf you choose a custom path, make sure that the directory exists and is\n  writable by the owner of the PHP process. As with any other zend-expressive\n  cached configuration, you will need to purge this file in order to enable any\n  newly added route when FastRoute caching is enabled.",
            "title": "Using FastRoute"
        },
        {
            "location": "/v2/features/router/fast-route/#using-fastroute",
            "text": "FastRoute  provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.  Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to\nparse routes, a  RouteCollector  to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.  If you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the  Zend\\Expressive\\Router\\FastRouteRouter  class, at instantiation.  The  FastRouteRouter  bridge class accepts two arguments at instantiation:   A  FastRoute\\RouteCollector  instance  A callable that will return a  FastRoute\\Dispatcher\\RegexBasedAbstract \n  instance.   Injection can be done either programmatically or via a factory to use in\nconjunction with your container instance.",
            "title": "Using FastRoute"
        },
        {
            "location": "/v2/features/router/fast-route/#installing-fastroute",
            "text": "To use FastRoute, you will first need to install the FastRoute integration:  $ composer require zendframework/zend-expressive-fastroute",
            "title": "Installing FastRoute"
        },
        {
            "location": "/v2/features/router/fast-route/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\FastRouteRouter  instance\nwith no arguments; it will create the underlying FastRoute objects required\nand compose them for you:  use Zend\\Expressive\\Router\\FastRouteRouter;\n\n$router = new FastRouteRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/v2/features/router/fast-route/#programmatic-creation",
            "text": "If you need greater control over the FastRoute setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\FastRouteRouter  during instantiation.  To do so, you will need to setup your  RouteCollector  instance and/or\noptionally callable to return your  RegexBasedAbstract  instance manually,\ninject them in your  Zend\\Expressive\\Router\\FastRouteRouter  instance, and inject use\nthat when creating your  Application  instance.  <?php\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\n$fastRoute = new RouteCollector(\n    new RouteParser(),\n    new RouteGenerator()\n);\n$getDispatcher = function ($data) {\n    return new FastRouteDispatcher($data);\n};\n\n\n$router = new FastRouteBridge($fastRoute, $getDispatcher);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/v2/features/router/fast-route/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/v2/features/router/fast-route/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your FastRoute implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/v2/features/router/fast-route/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\FastRouteRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);  And in Pimple:  $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new App\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\FastRouteRouter::class\n);",
            "title": "Basic Router"
        },
        {
            "location": "/v2/features/router/fast-route/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:   A factory to register as and generate a  FastRoute\\RouteCollector  instance.  A factory to register as  FastRoute\\DispatcherFactory  and return a callable\n  factory that returns a  RegexBasedAbstract  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\FastRouteRouter  instance composing the\n  two services.   Sound difficult? It's not; we've essentially done it above already!  <?php\n// in src/App/Container/FastRouteCollectorFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/App/Container/FastRouteDispatcherFactory.php:\nnamespace App\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Psr\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container->get(FastRoute\\RouteCollector::class),\n            $container->get(FastRoute\\DispatcherFactory::class)\n        );\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    FastRoute\\RouteCollector::class,\n    App\\Container\\FastRouteCollectorFactory::class\n);\n$container->addFactory(\n    FastRoute\\DispatcherFactory::class,\n    App\\Container\\FastRouteDispatcherFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'FastRoute\\RouteCollector' => App\\Container\\FastRouteCollectorFactory::class,\n        'FastRoute\\DispatcherFactory' => App\\Container\\FastRouteDispatcherFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];  For Pimple, configuration looks like:  use App\\Container\\FastRouteCollectorFactory;\nuse App\\Container\\FastRouteDispatcherFactory;\nuse App\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container[FastRoute\\RouteCollector::class] = new FastRouteCollectorFactory();\n$container[FastRoute\\RouteDispatcher::class] = new FastRouteDispatcherFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/v2/features/router/fast-route/#fastroute-caching-support",
            "text": "Since zend-expressive-fastroute 1.3.0.   Starting from version 1.3.0, zend-expressive-fastroute comes with support\nfor FastRoute native dispatch data caching.  Enabling this feature requires changes to your configuration. Typically, router\nconfiguration occurs in  config/autoload/routes.global.php ; as such, we will\nreference that file when indicating configuration changes.  The changes required are:    You will need to delegate creation of the router instance to a new factory.    You will need to add a new configuration entry,  $config['router']['fastroute'] .\n  The options in this entry will be used by the factory to build the router\n  instance in order to toggle caching support and to specify a custom cache\n  file.    As an example:  // File config/autoload/routes.global.php\n\nreturn [\n    'dependencies' => [\n        //..\n        'invokables' => [\n            /* ... */\n            // Comment out or remove the following line:\n            // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n            // Add this line; the specified factory now creates the router instance:\n            Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class,\n            /* ... */\n        ],\n    ],\n\n    // Add the following to enable caching support:\n    'router' => [\n        'fastroute' => [\n             // Enable caching support:\n            'cache_enabled' => true,\n             // Optional (but recommended) cache file path:\n            'cache_file'    => 'data/cache/fastroute.php.cache',\n        ],\n    ],\n\n    'routes' => [ /* ... */ ],\n]  The FastRoute-specific caching options are as follows:    cache_enabled  (bool) is used to toggle caching support. It's advisable to enable\n  caching in a production environment and leave it disabled for the development\n  environment. Commenting or omitting this option is equivalent to having it set\n  to  false . We recommend enabling it in  config/autoload/routes.global.php ,\n  and, in development, disabling it within  config/autoload/routes.local.php  or\n   config/autoload/local.php .    cache_file  (string) is an optional parameter that represents the path of\n  the dispatch data cache file. It can be provided as an absolute file path or\n  as a path relative to the zend-expressive working directory.    It defaults to  data/cache/fastroute.php.cache , where  data/cache/  is the\n  cache directory defined within the zend-expressive skeleton application.  An\n  explicit absolute file path is recommended since the php  include  construct\n  will skip searching the  include_path  and the current directory.  If you choose a custom path, make sure that the directory exists and is\n  writable by the owner of the PHP process. As with any other zend-expressive\n  cached configuration, you will need to purge this file in order to enable any\n  newly added route when FastRoute caching is enabled.",
            "title": "FastRoute caching support"
        },
        {
            "location": "/v2/features/router/zf2/",
            "text": "Using the ZF2 Router\n\n\nzend-router\n provides several\nrouter implementations used for ZF2+ applications; the default is\n\nZend\\Router\\Http\\TreeRouteStack\n, which can compose a number of different\nroutes of differing types in order to perform routing.\n\n\nThe ZF2 bridge we provide, \nZend\\Expressive\\Router\\ZendRouter\n, uses the\n\nTreeRouteStack\n, and injects \nSegment\n routes to it; these are in turn injected\nwith \nMethod\n routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.\n\n\nIf you instantiate it with no arguments, it will create an empty\n\nTreeRouteStack\n. Thus, the simplest way to start with this router is:\n\n\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$app = AppFactory::create(null, new ZendRouter());\n\n\n\nThe \nTreeRouteStack\n offers some unique features:\n\n\n\n\nRoute \"prototypes\". These are essentially like child routes that must \nalso\n\n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.\n\n\nBase URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.\n\n\n\n\nTo specify these, you need access to the underlying \nTreeRouteStack\n\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling the ZF2 Router\n\n\nTo use the ZF2 router, you will need to install the zend-mvc router integration:\n\n\n$ composer require zendframework/zend-expressive-zendrouter\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\ZendRouter\n instance\nwith no arguments; it will create the underlying zend-mvc routing objects\nrequired and compose them for you:\n\n\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$router = new ZendRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the zend-mvc router setup and configuration,\nyou can create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\ZendRouter\n during instantiation.\n\n\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\nuse Zend\\Router\\Http\\TreeRouteStack;\n\n$zendRouter = new TreeRouteStack();\n$zendRouter->addPrototypes(/* ... */);\n$zendRouter->setBaseUrl(/* ... */);\n\n$router = new Zf2Bridge($zendRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your zend-mvc router implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\ZendRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return ZendRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new ZendRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\ZendRouter::class\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nZend\\Router\\Http\\TreeRouteStack\n\n  instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\ZendRouter\n instance composing the\n  \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n instance.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n// in src/App/Container/TreeRouteStackFactory.php:\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Http\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router->addPrototypes(/* ... */);\n        $router->setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class));\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    Zend\\Router\\Http\\TreeRouteStack::class,\n    App\\Container\\TreeRouteStackFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        Zend\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\TreeRouteStackFactory;\nuse Application\\Container\\ZfRouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop;\n\n$container = new PimpleInterop();\n$container[Zend\\Router\\Http\\TreeRouteStackFactory::class] = new TreeRouteStackFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Using the ZF2 Router"
        },
        {
            "location": "/v2/features/router/zf2/#using-the-zf2-router",
            "text": "zend-router  provides several\nrouter implementations used for ZF2+ applications; the default is Zend\\Router\\Http\\TreeRouteStack , which can compose a number of different\nroutes of differing types in order to perform routing.  The ZF2 bridge we provide,  Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects  Segment  routes to it; these are in turn injected\nwith  Method  routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.  If you instantiate it with no arguments, it will create an empty TreeRouteStack . Thus, the simplest way to start with this router is:  use Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$app = AppFactory::create(null, new ZendRouter());  The  TreeRouteStack  offers some unique features:   Route \"prototypes\". These are essentially like child routes that must  also \n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.  Base URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.   To specify these, you need access to the underlying  TreeRouteStack \ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.",
            "title": "Using the ZF2 Router"
        },
        {
            "location": "/v2/features/router/zf2/#installing-the-zf2-router",
            "text": "To use the ZF2 router, you will need to install the zend-mvc router integration:  $ composer require zendframework/zend-expressive-zendrouter",
            "title": "Installing the ZF2 Router"
        },
        {
            "location": "/v2/features/router/zf2/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\ZendRouter  instance\nwith no arguments; it will create the underlying zend-mvc routing objects\nrequired and compose them for you:  use Zend\\Expressive\\Router\\ZendRouter;\n\n$router = new ZendRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/v2/features/router/zf2/#programmatic-creation",
            "text": "If you need greater control over the zend-mvc router setup and configuration,\nyou can create the instances necessary and inject them into Zend\\Expressive\\Router\\ZendRouter  during instantiation.  use Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\nuse Zend\\Router\\Http\\TreeRouteStack;\n\n$zendRouter = new TreeRouteStack();\n$zendRouter->addPrototypes(/* ... */);\n$zendRouter->setBaseUrl(/* ... */);\n\n$router = new Zf2Bridge($zendRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/v2/features/router/zf2/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/v2/features/router/zf2/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your zend-mvc router implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/v2/features/router/zf2/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\ZendRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return ZendRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new ZendRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);  And in Pimple:  $pimple[Zend\\Expressive\\Router\\RouterInterface::class] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    Zend\\Expressive\\Router\\ZendRouter::class\n);",
            "title": "Basic Router"
        },
        {
            "location": "/v2/features/router/zf2/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Zend\\Router\\Http\\TreeRouteStack \n  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\ZendRouter  instance composing the\n   Zend\\Mvc\\Router\\Http\\TreeRouteStack  instance.   Sound difficult? It's not; we've essentially done it above already!  // in src/App/Container/TreeRouteStackFactory.php:\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Http\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router->addPrototypes(/* ... */);\n        $router->setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/App/Container/RouterFactory.php\nnamespace App\\Container;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container->get(Zend\\Mvc\\Router\\Http\\TreeRouteStack::class));\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    Zend\\Router\\Http\\TreeRouteStack::class,\n    App\\Container\\TreeRouteStackFactory::class\n);\n$container->addFactory(\n    Zend\\Expressive\\Router\\RouterInterface::class,\n    App\\Container\\RouterFactory::class\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        Zend\\Router\\Http\\TreeRouteStack::class => App\\Container\\TreeRouteStackFactory::class,\n        Zend\\Expressive\\Router\\RouterInterface::class => App\\Container\\RouterFactory::class,\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\TreeRouteStackFactory;\nuse Application\\Container\\ZfRouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop;\n\n$container = new PimpleInterop();\n$container[Zend\\Router\\Http\\TreeRouteStackFactory::class] = new TreeRouteStackFactory();\n$container[Zend\\Expressive\\Router\\RouterInterface::class] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/v2/features/template/intro/",
            "text": "Templating\n\n\nBy default, no middleware in Expressive is templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.\n\n\nWe do, however, provide abstraction for templating via the interface\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n, which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:\n\n\n\n\nAll adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation \nnamespace::template\n when rendering.\n\n\nAdapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).\n\n\nAdapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.\n\n\nAdapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.\n\n\n\n\nIn this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.\n\n\nWe currently support:\n\n\n\n\nPlates\n\n\nTwig\n\n\nzend-view\n\n\n\n\nEach has an associated container factory; details are found in the\n\nfactories documentation\n.",
            "title": "Introduction"
        },
        {
            "location": "/v2/features/template/intro/#templating",
            "text": "By default, no middleware in Expressive is templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.  We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:   All adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation  namespace::template  when rendering.  Adapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).  Adapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.  Adapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.   In this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.  We currently support:   Plates  Twig  zend-view   Each has an associated container factory; details are found in the factories documentation .",
            "title": "Templating"
        },
        {
            "location": "/v2/features/template/interface/",
            "text": "The Template Renderer Interface\n\n\nExpressive defines \nZend\\Expressive\\Template\\TemplateRendererInterface\n, which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param string $name\n     * @param array|object $params\n     * @return string\n     */\n    public function render($name, $params = []);\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     *\n     * @param string $path\n     * @param string $namespace\n     */\n    public function addPath($path, $namespace = null);\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths();\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param string $param Param name.\n     * @param mixed $value\n     */\n    public function addDefaultParam($templateName, $param, $value);\n}\n\n\n\n\n\nNamespaces\n\n\nUnfortunately, namespace syntax varies between different template engine\nimplementations. As an example:\n\n\n\n\nPlates uses the syntax \nnamespace::template\n.\n\n\nTwig uses the syntax \n@namespace/template\n.\n\n\nzend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.\n\n\n\n\nTo make different engines compatible, we require implementations to support\nthe syntax \nnamespace::template\n (where \nnamespace::\n is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.\n\n\nWhen using a \nTemplateRendererInterface\n implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.\n\n\n\n\nPaths\n\n\nMost template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the \naddPath()\n method to do so:\n\n\n$renderer->addPath('templates');\n\n\n\nTemplate engines adapted for zend-expressive are also required to allow\n\nnamespacing\n templates; when adding a path, you specify the template\n\nnamespace\n that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.\n\n\n// Resolves to a path registered with the namespace \"error\";\n// this example is specific to the Plates engine.\n$content = $renderer->render('error::404');\n\n\n\nYou can provide a namespace when registering a path via an optional second\nargument:\n\n\n// Registers the \"error\" namespace to the path \"templates/error/\"\n$renderer->addPath('templates/error/', 'error');\n\n\n\nRendering\n\n\nTo render a template, call the \nrender()\n method. This method requires the name\nof a template as the first argument:\n\n\n$content = $renderer->render('foo');\n\n\n\nYou can specify a namespaced template using the syntax \nnamespace::template\n;\nthe \ntemplate\n segment of the template name may use additional directory\nseparators when necessary.\n\n\nOne key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to \nrender()\n:\n\n\n$content = $renderer->render('message', [\n    'greeting'  => 'Hello',\n    'recipient' => 'World',\n]);\n\n\n\nIt is up to the underlying template engine to determine how to perform the\ninjections.\n\n\nDefault params\n\n\nThe \nTemplateRendererInterface\n defines the method \naddDefaultParam()\n. This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:\n\n\npublic function addDefaultParam($templateName, $param, $value)\n\n\n\nIf you want a parameter to be used for \nevery\n template, you can specify the\nconstant \nTemplateRendererInterface::TEMPLATE_ALL\n for the \n$templateName\n\nparameter.\n\n\nWhen rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:\n\n\n\n\nDefault parameters specified for all templates.\n\n\nDefault parameters specified for the template specified at rendering.\n\n\nParameters specified when rendering.\n\n\n\n\nAs an example, if we did the following:\n\n\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer->addDefaultParam('example', 'foo', 'template default foo');\n$renderer->addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer->render('example', [\n    'foo' => 'override',\n]);\n\n\n\nThen we can expect the following substitutions will occur when rendering:\n\n\n\n\nReferences to the \"foo\" variable will contain \"override\".\n\n\nReferences to the \"bar\" variable will contain \"template default bar\".\n\n\nReferences to the \"baz\" variable will contain \"bat\".\n\n\n\n\n\n\nSupport for default params\n\n\nThe support for default params will often be renderer-specific. The reason is\nbecause the \nrender()\n signature does not specify a type for \n$params\n, in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given \n$params\n argument does not support it.\n\n\nAt the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.",
            "title": "Template Renderer Interface"
        },
        {
            "location": "/v2/features/template/interface/#the-template-renderer-interface",
            "text": "Expressive defines  Zend\\Expressive\\Template\\TemplateRendererInterface , which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:  namespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param string $name\n     * @param array|object $params\n     * @return string\n     */\n    public function render($name, $params = []);\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     *\n     * @param string $path\n     * @param string $namespace\n     */\n    public function addPath($path, $namespace = null);\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths();\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param string $param Param name.\n     * @param mixed $value\n     */\n    public function addDefaultParam($templateName, $param, $value);\n}",
            "title": "The Template Renderer Interface"
        },
        {
            "location": "/v2/features/template/interface/#namespaces",
            "text": "Unfortunately, namespace syntax varies between different template engine\nimplementations. As an example:   Plates uses the syntax  namespace::template .  Twig uses the syntax  @namespace/template .  zend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.   To make different engines compatible, we require implementations to support\nthe syntax  namespace::template  (where  namespace::  is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.  When using a  TemplateRendererInterface  implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.",
            "title": "Namespaces"
        },
        {
            "location": "/v2/features/template/interface/#paths",
            "text": "Most template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the  addPath()  method to do so:  $renderer->addPath('templates');  Template engines adapted for zend-expressive are also required to allow namespacing  templates; when adding a path, you specify the template namespace  that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.  // Resolves to a path registered with the namespace \"error\";\n// this example is specific to the Plates engine.\n$content = $renderer->render('error::404');  You can provide a namespace when registering a path via an optional second\nargument:  // Registers the \"error\" namespace to the path \"templates/error/\"\n$renderer->addPath('templates/error/', 'error');",
            "title": "Paths"
        },
        {
            "location": "/v2/features/template/interface/#rendering",
            "text": "To render a template, call the  render()  method. This method requires the name\nof a template as the first argument:  $content = $renderer->render('foo');  You can specify a namespaced template using the syntax  namespace::template ;\nthe  template  segment of the template name may use additional directory\nseparators when necessary.  One key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to  render() :  $content = $renderer->render('message', [\n    'greeting'  => 'Hello',\n    'recipient' => 'World',\n]);  It is up to the underlying template engine to determine how to perform the\ninjections.",
            "title": "Rendering"
        },
        {
            "location": "/v2/features/template/interface/#default-params",
            "text": "The  TemplateRendererInterface  defines the method  addDefaultParam() . This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:  public function addDefaultParam($templateName, $param, $value)  If you want a parameter to be used for  every  template, you can specify the\nconstant  TemplateRendererInterface::TEMPLATE_ALL  for the  $templateName \nparameter.  When rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:   Default parameters specified for all templates.  Default parameters specified for the template specified at rendering.  Parameters specified when rendering.   As an example, if we did the following:  $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer->addDefaultParam('example', 'foo', 'template default foo');\n$renderer->addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer->render('example', [\n    'foo' => 'override',\n]);  Then we can expect the following substitutions will occur when rendering:   References to the \"foo\" variable will contain \"override\".  References to the \"bar\" variable will contain \"template default bar\".  References to the \"baz\" variable will contain \"bat\".",
            "title": "Default params"
        },
        {
            "location": "/v2/features/template/interface/#support-for-default-params",
            "text": "The support for default params will often be renderer-specific. The reason is\nbecause the  render()  signature does not specify a type for  $params , in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given  $params  argument does not support it.  At the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.",
            "title": "Support for default params"
        },
        {
            "location": "/v2/features/template/middleware/",
            "text": "Templated Middleware\n\n\nThe primary use case for templating is within middleware, to provide templated\nresponses. To do this, you will:\n\n\n\n\nInject an instance of \nZend\\Expressive\\Template\\TemplateRendererInterface\n into your\n  middleware.\n\n\nPotentially add paths to the templating instance.\n\n\nRender a template.\n\n\nAdd the results of rendering to your response.\n\n\n\n\nInjecting a TemplateRendererInterface\n\n\nWe encourage the use of dependency injection. As such, we recommend writing your\nmiddleware to accept the \nTemplateRendererInterface\n via either the constructor or a\nsetter. As an example:\n\n\nnamespace Acme\\Blog;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware implements MiddlewareInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // ...\n    }\n}\n\n\n\nThis will necessitate having a factory for your middleware:\n\n\nnamespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryMiddleware;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryMiddleware(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}\n\n\n\nAnd, of course, you'll need to tell your container to use the factory; see the\n\ncontainer documentation\n for more information on how you\nmight accomplish that.\n\n\nConsuming templates\n\n\nNow that we have the templating engine injected into our middleware, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:\n\n\nnamespace Acme\\Blog;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware implements MiddlewareInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'entry' => $entry,\n            ])\n        );\n    }\n}",
            "title": "Templated Middleware"
        },
        {
            "location": "/v2/features/template/middleware/#templated-middleware",
            "text": "The primary use case for templating is within middleware, to provide templated\nresponses. To do this, you will:   Inject an instance of  Zend\\Expressive\\Template\\TemplateRendererInterface  into your\n  middleware.  Potentially add paths to the templating instance.  Render a template.  Add the results of rendering to your response.",
            "title": "Templated Middleware"
        },
        {
            "location": "/v2/features/template/middleware/#injecting-a-templaterendererinterface",
            "text": "We encourage the use of dependency injection. As such, we recommend writing your\nmiddleware to accept the  TemplateRendererInterface  via either the constructor or a\nsetter. As an example:  namespace Acme\\Blog;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware implements MiddlewareInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // ...\n    }\n}  This will necessitate having a factory for your middleware:  namespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryMiddleware;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryMiddleware(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}  And, of course, you'll need to tell your container to use the factory; see the container documentation  for more information on how you\nmight accomplish that.",
            "title": "Injecting a TemplateRendererInterface"
        },
        {
            "location": "/v2/features/template/middleware/#consuming-templates",
            "text": "Now that we have the templating engine injected into our middleware, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:  namespace Acme\\Blog;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware implements MiddlewareInterface\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'entry' => $entry,\n            ])\n        );\n    }\n}",
            "title": "Consuming templates"
        },
        {
            "location": "/v2/features/template/plates/",
            "text": "Using Plates\n\n\nPlates\n is a native PHP template system\nmaintained by \nThe League of Extraordinary Packages\n.\nit provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Plates via\n\nZend\\Expressive\\Plates\\PlatesRenderer\n.\n\n\nInstalling Plates\n\n\nTo use the Plates wrapper, you must install the Plates integration:\n\n\n$ composer require zendframework/zend-expressive-platesrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Plates\\PlatesRenderer\n will create\nan instance of the Plates engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Plates\\PlatesRenderer\n constructor:\n\n\nuse League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates->addFolder('error', 'templates/error/');\n$plates->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new PlatesRenderer($plates);",
            "title": "Using Plates"
        },
        {
            "location": "/v2/features/template/plates/#using-plates",
            "text": "Plates  is a native PHP template system\nmaintained by  The League of Extraordinary Packages .\nit provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer .",
            "title": "Using Plates"
        },
        {
            "location": "/v2/features/template/plates/#installing-plates",
            "text": "To use the Plates wrapper, you must install the Plates integration:  $ composer require zendframework/zend-expressive-platesrenderer",
            "title": "Installing Plates"
        },
        {
            "location": "/v2/features/template/plates/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\Plates\\PlatesRenderer  will create\nan instance of the Plates engine, which it will then proxy to.  use Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Plates\\PlatesRenderer  constructor:  use League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates->addFolder('error', 'templates/error/');\n$plates->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new PlatesRenderer($plates);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v2/features/template/twig/",
            "text": "Using Twig\n\n\nTwig\n is a template language and engine provided\nas a standalone component by SensioLabs. It provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Twig via\n\nZend\\Expressive\\Twig\\TwigRenderer\n.\n\n\nInstalling Twig\n\n\nTo use the Twig wrapper, you must first install the Twig integration:\n\n\n$ composer require zendframework/zend-expressive-twigrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Twig\\TwigRenderer\n will create\nan instance of the Twig engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Twig\\TwigRenderer\n constructor:\n\n\nuse Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig->addExtension(new CustomExtension());\n$twig->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);\n\n\n\nIncluded extensions and functions\n\n\nThe included Twig extension adds support for url generation. The extension is\nautomatically activated if the \nUrlHelper\n and\n\nServerUrlHelper\n are registered with the\ncontainer.\n\n\nThe following template functions are exposed:\n\n\n\n\npath\n: Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.\n\n\n\n\n{{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3\n\n\n\n\n\nurl\n: Render the absolute url for a given route with its route parameters,\n  query string arguments, and fragment. If there is no route, it returns the\n  current url.\n\n\n\n\n{{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }}\nGenerates: http://example.com/article/3?foo=bar#fragment\n\n\n\n\n\nabsolute_url\n: Render the absolute url from a given path. If the path is\n  empty, it returns the current url.\n\n\n\n\n{{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something\n\n\n\n\n\nasset\n Render an (optionally versioned) asset url.\n\n\n\n\n{{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3\n\n\n\nTo get the absolute url for an asset:\n\n\n{{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3\n\n\n\nConfiguration\n\n\nThe following details configuration specific to Twig, as consumed by the\n\nTwigRendererFactory\n:\n\n\nreturn [\n    'templates' => [\n        'extension' => 'file extension used by templates; defaults to html.twig',\n        'paths' => [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' => [\n        'cache_dir' => 'path to cached templates',\n        'assets_url' => 'base URL for assets',\n        'assets_version' => 'base version for assets',\n        'extensions' => [\n            // extension service names or instances\n        ],\n        'globals' => [\n            // Global variables passed to twig templates\n            'ga_tracking' => 'UA-XXXXX-X'\n        ],\n    ],\n];\n\n\n\nWhen specifying the \ntwig.extensions\n values, always use fully qualified class\nnames or actual extension instances to ensure compatibility with any version of\nTwig used. Version 2 of Twig \nrequires\n that a fully qualified class name is\nused, and not a short-name alias.",
            "title": "Using Twig"
        },
        {
            "location": "/v2/features/template/twig/#using-twig",
            "text": "Twig  is a template language and engine provided\nas a standalone component by SensioLabs. It provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer .",
            "title": "Using Twig"
        },
        {
            "location": "/v2/features/template/twig/#installing-twig",
            "text": "To use the Twig wrapper, you must first install the Twig integration:  $ composer require zendframework/zend-expressive-twigrenderer",
            "title": "Installing Twig"
        },
        {
            "location": "/v2/features/template/twig/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\Twig\\TwigRenderer  will create\nan instance of the Twig engine, which it will then proxy to.  use Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Twig\\TwigRenderer  constructor:  use Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig->addExtension(new CustomExtension());\n$twig->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v2/features/template/twig/#included-extensions-and-functions",
            "text": "The included Twig extension adds support for url generation. The extension is\nautomatically activated if the  UrlHelper  and ServerUrlHelper  are registered with the\ncontainer.  The following template functions are exposed:   path : Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.   {{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3   url : Render the absolute url for a given route with its route parameters,\n  query string arguments, and fragment. If there is no route, it returns the\n  current url.   {{ url('article_show', {'id': '3'}, {'foo': 'bar'}, 'fragment') }}\nGenerates: http://example.com/article/3?foo=bar#fragment   absolute_url : Render the absolute url from a given path. If the path is\n  empty, it returns the current url.   {{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something   asset  Render an (optionally versioned) asset url.   {{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3  To get the absolute url for an asset:  {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3",
            "title": "Included extensions and functions"
        },
        {
            "location": "/v2/features/template/twig/#configuration",
            "text": "The following details configuration specific to Twig, as consumed by the TwigRendererFactory :  return [\n    'templates' => [\n        'extension' => 'file extension used by templates; defaults to html.twig',\n        'paths' => [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' => [\n        'cache_dir' => 'path to cached templates',\n        'assets_url' => 'base URL for assets',\n        'assets_version' => 'base version for assets',\n        'extensions' => [\n            // extension service names or instances\n        ],\n        'globals' => [\n            // Global variables passed to twig templates\n            'ga_tracking' => 'UA-XXXXX-X'\n        ],\n    ],\n];  When specifying the  twig.extensions  values, always use fully qualified class\nnames or actual extension instances to ensure compatibility with any version of\nTwig used. Version 2 of Twig  requires  that a fully qualified class name is\nused, and not a short-name alias.",
            "title": "Configuration"
        },
        {
            "location": "/v2/features/template/zend-view/",
            "text": "Using zend-view\n\n\nzend-view\n provides a native PHP\ntemplate system via its \nPhpRenderer\n, and is maintained by Zend Framework. It\nprovides:\n\n\n\n\nLayout facilities.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for zend-view's\n\nPhpRenderer\n via \nZend\\Expressive\\ZendView\\ZendViewRenderer\n.\n\n\nInstalling zend-view\n\n\nTo use the zend-view wrapper, you must first install the zend-view integration:\n\n\n$ composer require zendframework/zend-expressive-zendviewrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\ZendView\\ZendViewRenderer\n will create\nan instance of the \nPhpRenderer\n, which it will then proxy to.\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\ZendView\\ZendViewRenderer\n constructor:\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver->attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver->attach(\n    (new Resolver\\TemplatePathStack())\n    ->setPaths(include 'config/template_paths.php')\n);\n$renderer->setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);\n\n\n\n\n\nNamespaced path resolving\n\n\nExpressive defines a custom zend-view resolver,\n\nZend\\Expressive\\ZendView\\NamespacedPathStackResolver\n. This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the \nnamespace::template\n notation\nrequired of \nTemplateRendererInterface\n implementations.\n\n\nThe \nZendView\n adapter ensures that:\n\n\n\n\nAn \nAggregateResolver\n is registered with the renderer. If the registered\n  resolver is not an \nAggregateResolver\n, it creates one and adds the original\n  resolver to it.\n\n\nA \nNamespacedPathStackResolver\n is registered with the \nAggregateResolver\n, at\n  a low priority (0), ensuring attempts to resolve hit it later.\n\n\n\n\nWith resolvers such as the \nTemplateMapResolver\n, you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!\n\n\n\n\nLayouts\n\n\nUnlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:\n\n\n\n\nYou may pass a layout template name or \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout as the second argument to the constructor.\n\n\nYou may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.\n\n\n\n\nIn each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.\n\n\n\n\nSince 1.3: You may also pass a boolean \nfalse\n value to either\n  \naddDefaultParam()\n or via the template variables for the \nlayout\n key; doing\n  so will disable the layout.\n\n\n\n\nLayout name passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');\n\n\n\nLayout view model passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/prod/',\n]);\n$layout->setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);\n\n\n\nProvide a layout name when rendering\n\n\n$content = $renderer->render('blog/entry', [\n    'layout' => 'layout::blog',\n    'entry'  => $entry,\n]);\n\n\n\nProvide a layout view model when rendering\n\n\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/blog/',\n]);\n$layout->setTemplate('layout::layout');\n\n$content = $renderer->render('blog/entry', [\n    'layout' => $layout,\n    'entry'  => $entry,\n]);\n\n\n\nHelpers\n\n\nExpressive provides overrides of specific view helpers in order to better\nintegrate with \nPSR-7\n. These include:\n\n\n\n\nZend\\Expressive\\ZendView\\UrlHelper\n. This helper consumes the\n  application's \nZend\\Expressive\\Router\\RouterInterface\n instance in order\n  to generate URIs. Its signature is:\n  \nurl($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = [])\n\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n. This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  Its signature is: \nserverUrl($path = null)\n.\n\n\n\n\nTo use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:\n\n\n$serverUrlHelper->setUri($request->getUri());\n\n\n\nWe recommend doing this within a pre-pipeline middleware.\n\n\nRecommendations\n\n\nWe recommend the following practices when using the zend-view adapter:\n\n\n\n\nIf using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.\n\n\nWhile we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.",
            "title": "Using zend-view"
        },
        {
            "location": "/v2/features/template/zend-view/#using-zend-view",
            "text": "zend-view  provides a native PHP\ntemplate system via its  PhpRenderer , and is maintained by Zend Framework. It\nprovides:   Layout facilities.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for zend-view's PhpRenderer  via  Zend\\Expressive\\ZendView\\ZendViewRenderer .",
            "title": "Using zend-view"
        },
        {
            "location": "/v2/features/template/zend-view/#installing-zend-view",
            "text": "To use the zend-view wrapper, you must first install the zend-view integration:  $ composer require zendframework/zend-expressive-zendviewrenderer",
            "title": "Installing zend-view"
        },
        {
            "location": "/v2/features/template/zend-view/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\ZendView\\ZendViewRenderer  will create\nan instance of the  PhpRenderer , which it will then proxy to.  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\ZendView\\ZendViewRenderer  constructor:  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver->attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver->attach(\n    (new Resolver\\TemplatePathStack())\n    ->setPaths(include 'config/template_paths.php')\n);\n$renderer->setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v2/features/template/zend-view/#namespaced-path-resolving",
            "text": "Expressive defines a custom zend-view resolver, Zend\\Expressive\\ZendView\\NamespacedPathStackResolver . This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the  namespace::template  notation\nrequired of  TemplateRendererInterface  implementations.  The  ZendView  adapter ensures that:   An  AggregateResolver  is registered with the renderer. If the registered\n  resolver is not an  AggregateResolver , it creates one and adds the original\n  resolver to it.  A  NamespacedPathStackResolver  is registered with the  AggregateResolver , at\n  a low priority (0), ensuring attempts to resolve hit it later.   With resolvers such as the  TemplateMapResolver , you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!",
            "title": "Namespaced path resolving"
        },
        {
            "location": "/v2/features/template/zend-view/#layouts",
            "text": "Unlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:   You may pass a layout template name or  Zend\\View\\Model\\ModelInterface \n  instance representing the layout as the second argument to the constructor.  You may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a  Zend\\View\\Model\\ModelInterface \n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.   In each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.   Since 1.3: You may also pass a boolean  false  value to either\n   addDefaultParam()  or via the template variables for the  layout  key; doing\n  so will disable the layout.",
            "title": "Layouts"
        },
        {
            "location": "/v2/features/template/zend-view/#layout-name-passed-to-constructor",
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');",
            "title": "Layout name passed to constructor"
        },
        {
            "location": "/v2/features/template/zend-view/#layout-view-model-passed-to-constructor",
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/prod/',\n]);\n$layout->setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);",
            "title": "Layout view model passed to constructor"
        },
        {
            "location": "/v2/features/template/zend-view/#provide-a-layout-name-when-rendering",
            "text": "$content = $renderer->render('blog/entry', [\n    'layout' => 'layout::blog',\n    'entry'  => $entry,\n]);",
            "title": "Provide a layout name when rendering"
        },
        {
            "location": "/v2/features/template/zend-view/#provide-a-layout-view-model-when-rendering",
            "text": "use Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/blog/',\n]);\n$layout->setTemplate('layout::layout');\n\n$content = $renderer->render('blog/entry', [\n    'layout' => $layout,\n    'entry'  => $entry,\n]);",
            "title": "Provide a layout view model when rendering"
        },
        {
            "location": "/v2/features/template/zend-view/#helpers",
            "text": "Expressive provides overrides of specific view helpers in order to better\nintegrate with  PSR-7 . These include:   Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the\n  application's  Zend\\Expressive\\Router\\RouterInterface  instance in order\n  to generate URIs. Its signature is:\n   url($routeName, array $routeParams = [], array $queryParams = [], $fragmentIdentifier = null, array $options = [])  Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  Its signature is:  serverUrl($path = null) .   To use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:  $serverUrlHelper->setUri($request->getUri());  We recommend doing this within a pre-pipeline middleware.",
            "title": "Helpers"
        },
        {
            "location": "/v2/features/template/zend-view/#recommendations",
            "text": "We recommend the following practices when using the zend-view adapter:   If using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.  While we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.",
            "title": "Recommendations"
        },
        {
            "location": "/v2/features/error-handling/",
            "text": "Error Handling\n\n\nWe recommend that your code raise exceptions for conditions where it cannot\ngracefully recover. Additionally, we recommend that you have a reasonable PHP\n\nerror_reporting\n setting that includes warnings and fatal errors:\n\n\nerror_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE);\n\n\n\nIf you follow these guidelines, you can then write or use middleware that does\nthe following:\n\n\n\n\nsets an error handler that converts PHP errors to \nErrorException\n instances.\n\n\nwraps execution of the delegate (\n$delegate->process()\n) with a try/catch block.\n\n\n\n\nAs an example:\n\n\nfunction ($request, DelegateInterface $delegate)\n{\n    set_error_handler(function ($errno, $errstr, $errfile, $errline) {\n        if (! (error_reporting() & $errno)) {\n            // Error is not in mask\n            return;\n        }\n        throw new ErrorException($errstr, 0, $errno, $errfile, $errline);\n    });\n\n    try {\n        $response = $delegate->process($request);\n        return $response;\n    } catch (Throwable $e) {\n    } catch (Exception $e) {\n    }\n\n    restore_error_handler();\n\n    $response = new TextResponse(sprintf(\n        \"[%d] %s\\n\\n%s\",\n        $e->getCode(),\n        $e->getMessage(),\n        $e->getTraceAsString()\n    ), 500);\n}\n\n\n\nYou would then pipe this as the outermost (or close to outermost) layer of your\napplication:\n\n\n$app->pipe($errorMiddleware);\n\n\n\nSo that you do not need to do this, we provide an error handler for you, via\nzend-stratigility: \nZend\\Stratigility\\Middleware\\ErrorHandler\n.\n\n\nThis implementation allows you to both:\n\n\n\n\nprovide a response generator, invoked when an error is caught; and\n\n\nregister listeners to trigger when errors are caught.\n\n\n\n\nWe provide the factory \nZend\\Expressive\\Container\\ErrorHandlerFactory\n for\ngenerating the instance; it should be mapped to the service\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n.\n\n\nWe provide two error response generators for you:\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n, which optionally will\n  accept a \nZend\\Expressive\\Template\\TemplateRendererInterface\n instance, and a\n  template name. When present, these will be used to generate response content;\n  otherwise, a plain text response is generated that notes the request method\n  and URI.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator\n, which uses\n  \nwhoops\n to present detailed exception\n  and request information; this implementation is intended for development\n  purposes.\n\n\n\n\n\n\nEach also has an accompanying factory for generating the instance:\n\n\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory\n\n\nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory\n\n\n\n\nMap the service \nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n to one of\nthese two factories in your configuration:\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];\n\n\n\n\n\nUse development mode configuration to enable whoops\n\n\nYou can specify the above in one of your \nconfig/autoload/*.global.php\n files,\nto ensure you have a production-capable error response generator.\n\n\nIf you are using \nzf-development-mode\n\nin your application (which is provided by default in the skeleton\napplication), you can toggle usage of whoops by adding configuration to the file\n\nconfig/autoload/development.local.php.dist\n:\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Middleware\\WhoopsErrorResponseGenerator::class => Container\\WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];\n\n\n\nWhen you enable development mode, whoops will then be enabled; when you\ndisable development mode, you'll be using your production generator.\n\n\nIf you are not using zf-development-mode, you can define a\n\nconfig/autoload/*.local.php\n file with the above configuration whenever you\nwant to enable whoops.\n\n\n\n\nListening for errors\n\n\nWhen errors occur, you may want to \nlisten\n for them in order to provide\nfeatures such as logging. \nZend\\Stratigility\\Middleware\\ErrorHandler\n provides\nthe ability to do so via its \nattachListener()\n method.\n\n\nThis method accepts a callable with the following signature:\n\n\nfunction (\n    Throwable|Exception $error,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void\n\n\n\nThe response provided is the response returned by your error response generator,\nallowing the listener the ability to introspect the generated response as well.\n\n\nAs an example, you could create a logging listener as follows:\n\n\nnamespace Acme;\n\nuse Exception;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass LoggingErrorListener\n{\n    /**\n     * Log format for messages:\n     *\n     * STATUS [METHOD] path: message\n     */\n    const LOG_FORMAT = '%d [%s] %s: %s';\n\n    private $logger;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke($error, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $this->logger->error(sprintf(\n            self::LOG_FORMAT,\n            $response->getStatusCode(),\n            $request->getMethod(),\n            (string) $request->getUri(),\n            $error->getMessage()\n        ));\n    }\n}\n\n\n\nYou could then use a \ndelegator factory\n to\ncreate your logger listener and attach it to your error handler:\n\n\nnamespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass LoggingErrorListenerDelegatorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $name\n     * @param callable $callback\n     * @return ErrorHandler\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback)\n    {\n        $listener = new LoggingErrorListener($container->get(LoggerInterface::class));\n        $errorHandler = $callback();\n        $errorHandler->attachListener($listener);\n        return $errorHandler;\n    }\n}\n\n\n\nHandling more specific error types\n\n\nYou could also write more specific error handlers. As an example, you might want\nto catch \nUnauthorizedException\n instances specifically, and display a login\npage:\n\n\nfunction ($request, DelegateInterface $delegate) use ($renderer)\n{\n    try {\n        $response = $delegate->process($request);\n        return $response;\n    } catch (UnauthorizedException $e) {\n    }\n\n    return new HtmlResponse(\n        $renderer->render('error::unauthorized'),\n        401\n    );\n}\n\n\n\nYou could then push this into a middleware pipe only when it's needed:\n\n\n$app->get('/dashboard', [\n    $unauthorizedHandlerMiddleware,\n    $middlewareThatChecksForAuthorization,\n    $middlewareBehindAuthorizationWall,\n], 'dashboard');\n\n\n\nDefault delegates\n\n\nZend\\Expressive\\Application\n manages an internal middleware pipeline; when you\ncall \n$delegate->process()\n, \nApplication\n is popping off the next middleware in\nthe queue and dispatching it.\n\n\nWhat happens when that queue is exhausted?\n\n\nThat situation indicates an error condition: no middleware was capable of\nreturning a response. This could either mean a problem with the request (HTTP\n400 \"Bad Request\" status) or inability to route the request (HTTP 404 \"Not\nFound\" status).\n\n\nIn order to report that information, \nZend\\Expressive\\Application\n composes a\n\"default delegate\": a delegate it will invoke once the queue is exhausted and no\nresponse returned. By default, it uses a custom implementation,\n\nZend\\Expressive\\Delegate\\NotFoundDelegate\n, which will report a 404 response,\noptionally using a composed template renderer to do so.\n\n\nWe provide a factory, \nZend\\Expressive\\Container\\NotFoundDelegateFactory\n, for\ncreating an instance, and this should be mapped to the\n\nZend\\Expressive\\Delegate\\NotFoundDelegate\n service, and aliased to the\n\nZend\\Expressive\\Delegate\\DefaultDelegate\n service:\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Delegate;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            'Zend\\Expressive\\Delegate\\DefaultDelegate' => Delegate\\NotFoundDelegate::class,\n        ],\n        'factories' => [\n            Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class,\n        ],\n    ],\n];\n\n\n\nThe factory will consume the following services:\n\n\n\n\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n (optional): if present,\n  the renderer will be used to render a template for use as the response\n  content.\n\n\n\n\n\n\nconfig\n (optional): if present, it will use the\n  \n$config['zend-expressive']['error_handler']['template_404']\n value\n  as the template to use when rendering; if not provided, defaults to\n  \nerror::404\n.\n\n\n\n\n\n\nIf you wish to provide an alternate response status or use a canned response,\nyou should provide your own default delegate, and expose it via the\n\nZend\\Expressive\\Delegate\\DefaultDelegate\n service.\n\n\nPage not found\n\n\nError handlers work at the outermost layer, and are used to catch exceptions and\nerrors in your application. At the \ninnermost\n layer of your application, you\nshould ensure you have middleware that is \nguaranteed\n to return a response;\nthis will prevent the default delegate from needing to execute by ensuring that\nthe middleware queue never fully depletes. This in turn allows you to fully\ncraft what sort of response is returned.\n\n\nGenerally speaking, reaching the innermost middleware layer indicates that no\nmiddleware was capable of handling the request, and thus an HTTP 404 Not Found\ncondition.\n\n\nTo simplify such responses, we provide \nZend\\Expressive\\Middleware\\NotFoundHandler\n,\nwith an accompanying \nZend\\Expressive\\Container\\NotFoundHandlerFactory\n. This\nmiddleware composes and proxies to the \nNotFoundDelegate\n detailed in the\nprevious section, and, as such, requires that that service be present.\n\n\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Delegate;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'factories' => [\n        Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class,\n        Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class,\n    ],\n];\n\n\n\nWhen registered, you should then pipe it as the innermost layer of your\napplication:\n\n\n// A basic application:\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);",
            "title": "Error Handling"
        },
        {
            "location": "/v2/features/error-handling/#error-handling",
            "text": "We recommend that your code raise exceptions for conditions where it cannot\ngracefully recover. Additionally, we recommend that you have a reasonable PHP error_reporting  setting that includes warnings and fatal errors:  error_reporting(E_ALL & ~E_USER_DEPRECATED & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE);  If you follow these guidelines, you can then write or use middleware that does\nthe following:   sets an error handler that converts PHP errors to  ErrorException  instances.  wraps execution of the delegate ( $delegate->process() ) with a try/catch block.   As an example:  function ($request, DelegateInterface $delegate)\n{\n    set_error_handler(function ($errno, $errstr, $errfile, $errline) {\n        if (! (error_reporting() & $errno)) {\n            // Error is not in mask\n            return;\n        }\n        throw new ErrorException($errstr, 0, $errno, $errfile, $errline);\n    });\n\n    try {\n        $response = $delegate->process($request);\n        return $response;\n    } catch (Throwable $e) {\n    } catch (Exception $e) {\n    }\n\n    restore_error_handler();\n\n    $response = new TextResponse(sprintf(\n        \"[%d] %s\\n\\n%s\",\n        $e->getCode(),\n        $e->getMessage(),\n        $e->getTraceAsString()\n    ), 500);\n}  You would then pipe this as the outermost (or close to outermost) layer of your\napplication:  $app->pipe($errorMiddleware);  So that you do not need to do this, we provide an error handler for you, via\nzend-stratigility:  Zend\\Stratigility\\Middleware\\ErrorHandler .  This implementation allows you to both:   provide a response generator, invoked when an error is caught; and  register listeners to trigger when errors are caught.   We provide the factory  Zend\\Expressive\\Container\\ErrorHandlerFactory  for\ngenerating the instance; it should be mapped to the service Zend\\Stratigility\\Middleware\\ErrorHandler .  We provide two error response generators for you:    Zend\\Expressive\\Middleware\\ErrorResponseGenerator , which optionally will\n  accept a  Zend\\Expressive\\Template\\TemplateRendererInterface  instance, and a\n  template name. When present, these will be used to generate response content;\n  otherwise, a plain text response is generated that notes the request method\n  and URI.    Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator , which uses\n   whoops  to present detailed exception\n  and request information; this implementation is intended for development\n  purposes.    Each also has an accompanying factory for generating the instance:   Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory  Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory   Map the service  Zend\\Expressive\\Middleware\\ErrorResponseGenerator  to one of\nthese two factories in your configuration:  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];",
            "title": "Error Handling"
        },
        {
            "location": "/v2/features/error-handling/#use-development-mode-configuration-to-enable-whoops",
            "text": "You can specify the above in one of your  config/autoload/*.global.php  files,\nto ensure you have a production-capable error response generator.  If you are using  zf-development-mode \nin your application (which is provided by default in the skeleton\napplication), you can toggle usage of whoops by adding configuration to the file config/autoload/development.local.php.dist :  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Middleware\\WhoopsErrorResponseGenerator::class => Container\\WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];  When you enable development mode, whoops will then be enabled; when you\ndisable development mode, you'll be using your production generator.  If you are not using zf-development-mode, you can define a config/autoload/*.local.php  file with the above configuration whenever you\nwant to enable whoops.",
            "title": "Use development mode configuration to enable whoops"
        },
        {
            "location": "/v2/features/error-handling/#listening-for-errors",
            "text": "When errors occur, you may want to  listen  for them in order to provide\nfeatures such as logging.  Zend\\Stratigility\\Middleware\\ErrorHandler  provides\nthe ability to do so via its  attachListener()  method.  This method accepts a callable with the following signature:  function (\n    Throwable|Exception $error,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : void  The response provided is the response returned by your error response generator,\nallowing the listener the ability to introspect the generated response as well.  As an example, you could create a logging listener as follows:  namespace Acme;\n\nuse Exception;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Throwable;\n\nclass LoggingErrorListener\n{\n    /**\n     * Log format for messages:\n     *\n     * STATUS [METHOD] path: message\n     */\n    const LOG_FORMAT = '%d [%s] %s: %s';\n\n    private $logger;\n\n    public function __construct(LoggerInterface $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke($error, ServerRequestInterface $request, ResponseInterface $response)\n    {\n        $this->logger->error(sprintf(\n            self::LOG_FORMAT,\n            $response->getStatusCode(),\n            $request->getMethod(),\n            (string) $request->getUri(),\n            $error->getMessage()\n        ));\n    }\n}  You could then use a  delegator factory  to\ncreate your logger listener and attach it to your error handler:  namespace Acme;\n\nuse Psr\\Container\\ContainerInterface;\nuse Psr\\Log\\LoggerInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass LoggingErrorListenerDelegatorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $name\n     * @param callable $callback\n     * @return ErrorHandler\n     */\n    public function __invoke(ContainerInterface $container, $name, callable $callback)\n    {\n        $listener = new LoggingErrorListener($container->get(LoggerInterface::class));\n        $errorHandler = $callback();\n        $errorHandler->attachListener($listener);\n        return $errorHandler;\n    }\n}",
            "title": "Listening for errors"
        },
        {
            "location": "/v2/features/error-handling/#handling-more-specific-error-types",
            "text": "You could also write more specific error handlers. As an example, you might want\nto catch  UnauthorizedException  instances specifically, and display a login\npage:  function ($request, DelegateInterface $delegate) use ($renderer)\n{\n    try {\n        $response = $delegate->process($request);\n        return $response;\n    } catch (UnauthorizedException $e) {\n    }\n\n    return new HtmlResponse(\n        $renderer->render('error::unauthorized'),\n        401\n    );\n}  You could then push this into a middleware pipe only when it's needed:  $app->get('/dashboard', [\n    $unauthorizedHandlerMiddleware,\n    $middlewareThatChecksForAuthorization,\n    $middlewareBehindAuthorizationWall,\n], 'dashboard');",
            "title": "Handling more specific error types"
        },
        {
            "location": "/v2/features/error-handling/#default-delegates",
            "text": "Zend\\Expressive\\Application  manages an internal middleware pipeline; when you\ncall  $delegate->process() ,  Application  is popping off the next middleware in\nthe queue and dispatching it.  What happens when that queue is exhausted?  That situation indicates an error condition: no middleware was capable of\nreturning a response. This could either mean a problem with the request (HTTP\n400 \"Bad Request\" status) or inability to route the request (HTTP 404 \"Not\nFound\" status).  In order to report that information,  Zend\\Expressive\\Application  composes a\n\"default delegate\": a delegate it will invoke once the queue is exhausted and no\nresponse returned. By default, it uses a custom implementation, Zend\\Expressive\\Delegate\\NotFoundDelegate , which will report a 404 response,\noptionally using a composed template renderer to do so.  We provide a factory,  Zend\\Expressive\\Container\\NotFoundDelegateFactory , for\ncreating an instance, and this should be mapped to the Zend\\Expressive\\Delegate\\NotFoundDelegate  service, and aliased to the Zend\\Expressive\\Delegate\\DefaultDelegate  service:  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Delegate;\n\nreturn [\n    'dependencies' => [\n        'aliases' => [\n            'Zend\\Expressive\\Delegate\\DefaultDelegate' => Delegate\\NotFoundDelegate::class,\n        ],\n        'factories' => [\n            Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class,\n        ],\n    ],\n];  The factory will consume the following services:    Zend\\Expressive\\Template\\TemplateRendererInterface  (optional): if present,\n  the renderer will be used to render a template for use as the response\n  content.    config  (optional): if present, it will use the\n   $config['zend-expressive']['error_handler']['template_404']  value\n  as the template to use when rendering; if not provided, defaults to\n   error::404 .    If you wish to provide an alternate response status or use a canned response,\nyou should provide your own default delegate, and expose it via the Zend\\Expressive\\Delegate\\DefaultDelegate  service.",
            "title": "Default delegates"
        },
        {
            "location": "/v2/features/error-handling/#page-not-found",
            "text": "Error handlers work at the outermost layer, and are used to catch exceptions and\nerrors in your application. At the  innermost  layer of your application, you\nshould ensure you have middleware that is  guaranteed  to return a response;\nthis will prevent the default delegate from needing to execute by ensuring that\nthe middleware queue never fully depletes. This in turn allows you to fully\ncraft what sort of response is returned.  Generally speaking, reaching the innermost middleware layer indicates that no\nmiddleware was capable of handling the request, and thus an HTTP 404 Not Found\ncondition.  To simplify such responses, we provide  Zend\\Expressive\\Middleware\\NotFoundHandler ,\nwith an accompanying  Zend\\Expressive\\Container\\NotFoundHandlerFactory . This\nmiddleware composes and proxies to the  NotFoundDelegate  detailed in the\nprevious section, and, as such, requires that that service be present.  use Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Delegate;\nuse Zend\\Expressive\\Middleware;\n\nreturn [\n    'factories' => [\n        Delegate\\NotFoundDelegate::class => Container\\NotFoundDelegateFactory::class,\n        Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class,\n    ],\n];  When registered, you should then pipe it as the innermost layer of your\napplication:  // A basic application:\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);",
            "title": "Page not found"
        },
        {
            "location": "/v2/features/modular-applications/",
            "text": "Modular applications\n\n\nZend Framework 2+ applications have a concept of \nmodules\n, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.\n\n\nExpressive provides similar functionality by incorporating two packages within\nthe default skeleton application:\n\n\n\n\nzendframework/zend-config-aggregator\n,\n  which provides features for aggregating configuration from a variety of\n  sources, including:\n\n\nPHP files globbed from the filesystem that return an array of configuration.\n\n\nzend-config\n-compatible\n  configuration files globbed from the filesystem.\n\n\nConfiguration provider classes; these are invokable classes which return an\n  array of configuration.\n\n\n\n\n\n\nzendframework/zend-component-installer\n,\n  a Composer plugin that looks for an \nextra.zf.config-provider\n entry in a\n  package to install, and, if found, adds an entry for that provider to the\n  \nconfig/config.php\n file (if it uses zend-config-aggregator).\n\n\n\n\nThese features allow you to install packages via composer and expose their\nconfiguration \u2014 which may include dependency information \u2014 to your\napplication.\n\n\nMaking your application modular\n\n\nWhen using the Expressive installer via the skeleton application, the first\nquestion asked is the installation type, which includes the options:\n\n\n\n\nMinimal (no default middleware, templates, or assets; configuration only)\n\n\nFlat (flat source code structure; default selection)\n\n\nModular (modular source code structure; recommended)\n\n\n\n\nWe recommend choosing the \"Modular\" option from the outset.\n\n\nIf you do not, you can still create and use modules in your application;\nhowever, the initial \"App\" module will not be modular.\n\n\nModule structure\n\n\nExpressive does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nWe generally recommend that a module have a \nPSR-4\n\nstructure, and that the module contain a \nsrc/\n directory at the minimum, along\nwith directories for other module-specific content, such as templates, tests, and\nassets:\n\n\nsrc/\n  Acme/\n    src/\n      ConfigProvider.php\n      Container/\n        VerifyUserFactory.php\n      Helper/\n        AuthorizationHelper.php\n      Middleware/\n        VerifyUser.php\n    templates/\n      verify-user.php\n    test/\n      Helper/\n        AuthorizationHelperTest.php\n      Middleware/\n        VerifyUserTest.php\n\n\n\nIf you use the above structure, you would then add an entry in your\n\ncomposer.json\n file to provide autoloading:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Acme\\\\\": \"src/Acme/src/\"\n    }\n}\n\n\n\nDon't forget to execute \ncomposer dump-autoload\n after making the change!\n\n\nCreating and enabling a module\n\n\nThe only \nrequirement\n for creating a module is that you define a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nGenerally, a config provider will return dependency information, and\nmodule-specific configuration:\n\n\nnamespace Acme;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'acme' => [\n                'some-setting' => 'default value',\n            ],\n            'templates' => [\n                'paths' => [\n                    'acme' => [__DIR__ . '/../templates'],\n                ],\n            ]\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'invokables' => [\n                Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class,\n            ],\n            'factories' => [\n                Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class,\n            ],\n        ];\n    }\n}\n\n\n\nYou would then add the config provider to the top (or towards the top) of your\n\nconfig/config.php\n:\n\n\n$aggregator = new ConfigAggregator([\n    Acme\\ConfigProvider::class,\n    /* ... */\n\n\n\nThis approach allows your \nconfig/autoload/*\n files to take precedence over the\nmodule configuration, allowing you to override the values.\n\n\nCaching configuration\n\n\nIn order to provide configuration caching, two things must occur:\n\n\n\n\nFirst, you must define a \nconfig_cache_enabled\n key in your configuration\n  somewhere.\n\n\nSecond, you must pass a second argument to the \nConfigManager\n, the location\n  of the cache file to use.\n\n\n\n\nThe \nconfig_cache_enabled\n key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:\n\n\n\n\nconfig/autoload/global.php\n should define the value to \ntrue\n, as the\n  production setting.\n\n\nconfig/autoload/local.php\n should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be \nfalse\n.\n\n\n\n\n// config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];\n\n\n\nYou would then alter your \nconfig/config.php\n file to add the second argument.\nThe following example builds on the previous, and demonstrates having the\n\nAppConfig\n entry enabled. The configuration will be cached to\n\ndata/config-cache.php\n in the application root:\n\n\n$configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');\n\n\n\nWhen the configuration cache path is present, if the \nconfig_cache_enabled\n flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.\n\n\nFinal notes\n\n\nThis approach may look simple, but it is flexible and powerful:\n\n\n\n\nYou pass a list of config providers to the \nConfigAggregator\n constructor.\n\n\nConfiguration is merged in the same order as it is passed, with later entries\n  having precedence.\n\n\nYou can override module configuration using \n*.global.php\n and \n*.local.php\n files.\n\n\nIf cached config is found, \nConfigAggregator\n does not iterate over provider list.\n\n\n\n\nFor more details, please refer to the \nzend-config-aggregator\ndocumentation\n.",
            "title": "Modular Applications"
        },
        {
            "location": "/v2/features/modular-applications/#modular-applications",
            "text": "Zend Framework 2+ applications have a concept of  modules , independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.  Expressive provides similar functionality by incorporating two packages within\nthe default skeleton application:   zendframework/zend-config-aggregator ,\n  which provides features for aggregating configuration from a variety of\n  sources, including:  PHP files globbed from the filesystem that return an array of configuration.  zend-config -compatible\n  configuration files globbed from the filesystem.  Configuration provider classes; these are invokable classes which return an\n  array of configuration.    zendframework/zend-component-installer ,\n  a Composer plugin that looks for an  extra.zf.config-provider  entry in a\n  package to install, and, if found, adds an entry for that provider to the\n   config/config.php  file (if it uses zend-config-aggregator).   These features allow you to install packages via composer and expose their\nconfiguration \u2014 which may include dependency information \u2014 to your\napplication.",
            "title": "Modular applications"
        },
        {
            "location": "/v2/features/modular-applications/#making-your-application-modular",
            "text": "When using the Expressive installer via the skeleton application, the first\nquestion asked is the installation type, which includes the options:   Minimal (no default middleware, templates, or assets; configuration only)  Flat (flat source code structure; default selection)  Modular (modular source code structure; recommended)   We recommend choosing the \"Modular\" option from the outset.  If you do not, you can still create and use modules in your application;\nhowever, the initial \"App\" module will not be modular.",
            "title": "Making your application modular"
        },
        {
            "location": "/v2/features/modular-applications/#module-structure",
            "text": "Expressive does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  We generally recommend that a module have a  PSR-4 \nstructure, and that the module contain a  src/  directory at the minimum, along\nwith directories for other module-specific content, such as templates, tests, and\nassets:  src/\n  Acme/\n    src/\n      ConfigProvider.php\n      Container/\n        VerifyUserFactory.php\n      Helper/\n        AuthorizationHelper.php\n      Middleware/\n        VerifyUser.php\n    templates/\n      verify-user.php\n    test/\n      Helper/\n        AuthorizationHelperTest.php\n      Middleware/\n        VerifyUserTest.php  If you use the above structure, you would then add an entry in your composer.json  file to provide autoloading:  \"autoload\": {\n    \"psr-4\": {\n        \"Acme\\\\\": \"src/Acme/src/\"\n    }\n}  Don't forget to execute  composer dump-autoload  after making the change!",
            "title": "Module structure"
        },
        {
            "location": "/v2/features/modular-applications/#creating-and-enabling-a-module",
            "text": "The only  requirement  for creating a module is that you define a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  Generally, a config provider will return dependency information, and\nmodule-specific configuration:  namespace Acme;\n\nclass ConfigProvider\n{\n    public function __invoke()\n    {\n        return [\n            'dependencies' => $this->getDependencies(),\n            'acme' => [\n                'some-setting' => 'default value',\n            ],\n            'templates' => [\n                'paths' => [\n                    'acme' => [__DIR__ . '/../templates'],\n                ],\n            ]\n        ];\n    }\n\n    public function getDependencies()\n    {\n        return [\n            'invokables' => [\n                Helper\\AuthorizationHelper::class => Helper\\AuthorizationHelper::class,\n            ],\n            'factories' => [\n                Middleware\\VerifyUser::class => Container\\VerifyUserFactory::class,\n            ],\n        ];\n    }\n}  You would then add the config provider to the top (or towards the top) of your config/config.php :  $aggregator = new ConfigAggregator([\n    Acme\\ConfigProvider::class,\n    /* ... */  This approach allows your  config/autoload/*  files to take precedence over the\nmodule configuration, allowing you to override the values.",
            "title": "Creating and enabling a module"
        },
        {
            "location": "/v2/features/modular-applications/#caching-configuration",
            "text": "In order to provide configuration caching, two things must occur:   First, you must define a  config_cache_enabled  key in your configuration\n  somewhere.  Second, you must pass a second argument to the  ConfigManager , the location\n  of the cache file to use.   The  config_cache_enabled  key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:   config/autoload/global.php  should define the value to  true , as the\n  production setting.  config/autoload/local.php  should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be  false .   // config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];  You would then alter your  config/config.php  file to add the second argument.\nThe following example builds on the previous, and demonstrates having the AppConfig  entry enabled. The configuration will be cached to data/config-cache.php  in the application root:  $configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');  When the configuration cache path is present, if the  config_cache_enabled  flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.",
            "title": "Caching configuration"
        },
        {
            "location": "/v2/features/modular-applications/#final-notes",
            "text": "This approach may look simple, but it is flexible and powerful:   You pass a list of config providers to the  ConfigAggregator  constructor.  Configuration is merged in the same order as it is passed, with later entries\n  having precedence.  You can override module configuration using  *.global.php  and  *.local.php  files.  If cached config is found,  ConfigAggregator  does not iterate over provider list.   For more details, please refer to the  zend-config-aggregator\ndocumentation .",
            "title": "Final notes"
        },
        {
            "location": "/v2/features/middleware/implicit-methods-middleware/",
            "text": "ImplicitHeadMiddleware and ImplicitOptionsMiddleware\n\n\nExpressive offers middleware for implicitly supporting \nHEAD\n and \nOPTIONS\n\nrequests. The HTTP/1.1 specifications indicate that all server implementations\n\nmust\n support \nHEAD\n requests for any given URI, and that they \nshould\n support\n\nOPTIONS\n requests. To make this possible, we have added features to our routing\nlayer, and middleware that can detect \nimplicit\n  support for these methods\n(i.e., the route was not registered \nexplicitly\n with the method).\n\n\n\n\nVersions prior to 2.2\n\n\nIf you are using Expressive versions earlier than 2.2, you may define a\n\nZend\\Expressive\\Middleware\\ImplicitHeadMiddleware\n or\n\nZend\\Expressive\\Middleware\\ImplicitOptionsMiddleware\n service under the\n\ninvokables\n service configuration.\n\n\nHowever, starting in version 2.2, these classes are deprecated in favor of their\nequivalents that are now offered in the zend-expressive-router v2.4+ releases,\nunder the namespace \nZend\\Expressive\\Router\\Middleware\n.\n\n\nThe documentation here has been updated to reflect usage under Expressive 2.2+.\n\n\n\n\nImplicitHeadMiddleware\n\n\nZend\\Expressive\\Middleware\\ImplicitHeadMiddleware\n provides support for\nhandling \nHEAD\n requests to routed middleware when the route does not expliclity\nallow for the method. It should be registered \nbetween\n the routing and dispatch\nmiddleware.\n\n\nTo use it, it must first be registered with your container. The easiest way to\ndo that is to register the zend-expressive-router \nConfigProvider\n in your\n\nconfig/config.php\n:\n\n\n$aggregator = new ConfigAggregator([\n    \\Zend\\Expressive\\Router\\ConfigProvider::class,\n\n\n\nAlternately, add the following dependency configuration in one of your\n\nconfig/autoload/\n configuration files or a \nConfigProvider\n class:\n\n\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddlewareFactory;\n\n'dependencies' => [\n    'factories' => [\n        ImplicitHeadMiddleware::class => ImplicitHeadMiddlewareFactory::class,\n    ],\n],\n\n\n\nWithin your application pipeline, add the middleware between the routing and\ndispatch middleware:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipe(ImplicitHeadMiddleware::class);\n// ...\n$app->pipeDispatchMiddleware();\n\n\n\n(Note: if you used the \nexpressive-pipeline-from-config\n tool to create your\nprogrammatic pipeline, or if you used the Expressive skeleton, this middleware\nis likely already in your pipeline, as is a dependency entry.)\n\n\nWhen in place, it will do the following:\n\n\n\n\nIf the request method is \nHEAD\n, AND\n\n\nthe request composes a \nRouteResult\n attribute, AND\n\n\nthe route result composes a \nRoute\n instance, AND\n\n\nthe route returns true for the \nimplicitHead()\n method, THEN\n\n\nthe middleware will return a response.\n\n\n\n\nIn all other cases, it returns the result of delegating to the next middleware\nlayer.\n\n\nWhen \nimplicitHead()\n is matched, one of two things may occur. First, if the\nroute does not support the \nGET\n method, then the middleware returns the\ncomposed response (either the one injected at instantiation, or an empty\ninstance). However, if \nGET\n is supported, it will dispatch the next layer, but\nwith a \nGET\n request instead of \nHEAD\n; additionally, it will inject the\nreturned response with an empty response body before returning it.\n\n\nDetecting forwarded requests\n\n\n\n\nSince 2.1.0\n\n\n\n\nWhen the next layer is dispatched, the request will have an additional\nattribute, \nZend\\Expressive\\Middleware\\ImplicitHeadMiddleware::FORWARDED_HTTP_METHOD_ATTRIBUTE\n,\nwith a value of \nHEAD\n. As such, you can check for this value in order to vary\nthe headers returned if desired.\n\n\nImplicitOptionsMiddleware\n\n\nZend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware\n provides support for\nhandling \nOPTIONS\n requests to routed middleware when the route does not\nexpliclity allow for the method. Like the \nImplicitHeadMiddleware\n, it should be\nregistered \nbetween\n the routing and dispatch middleware.\n\n\nTo use it, it must first be registered with your container. The easiest way to\ndo that is to register the zend-expressive-router \nConfigProvider\n in your\n\nconfig/config.php\n:\n\n\n$aggregator = new ConfigAggregator([\n    \\Zend\\Expressive\\Router\\ConfigProvider::class,\n\n\n\nAlternately, add the following dependency configuration in one of your\n\nconfig/autoload/\n configuration files or a \nConfigProvider\n class:\n\n\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddlewareFactory;\n\n'dependencies' => [\n    'factories' => [\n        ImplicitOptionsMiddleware::class => ImplicitOptionsMiddlewareFactory::class,\n    ],\n],\n\n\n\nWithin your application pipeline, add the middleware between the routing and\ndispatch middleware:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipe(ImplicitOptionsMiddleware::class);\n// ...\n$app->pipeDispatchMiddleware();\n\n\n\n(Note: if you used the \nexpressive-pipeline-from-config\n tool to create your\nprogrammatic pipeline, or if you used the Expressive skeleton, this middleware\nis likely already in your pipeline, as is a dependency entry.)\n\n\nWhen in place, it will do the following:\n\n\n\n\nIf the request method is \nOPTIONS\n, AND\n\n\nthe request composes a \nRouteResult\n attribute, AND\n\n\nthe route result composes a \nRoute\n instance, AND\n\n\nthe route returns true for the \nimplicitOptions()\n method, THEN\n\n\nthe middleware will return a response with an \nAllow\n header indicating\n  methods the route allows.\n\n\n\n\nIn all other cases, it returns the result of delegating to the next middleware\nlayer.\n\n\nOne thing to note: the allowed methods reported by the route and/or route\nresult, and returned via the \nAllow\n header,  may vary based on router\nimplementation. In most cases, it should be an aggregate of all routes using the\nsame path specification; however, it \ncould\n be only the methods supported\nexplicitly by the matched route.",
            "title": "Implicit HEAD and OPTIONS Middleware"
        },
        {
            "location": "/v2/features/middleware/implicit-methods-middleware/#implicitheadmiddleware-and-implicitoptionsmiddleware",
            "text": "Expressive offers middleware for implicitly supporting  HEAD  and  OPTIONS \nrequests. The HTTP/1.1 specifications indicate that all server implementations must  support  HEAD  requests for any given URI, and that they  should  support OPTIONS  requests. To make this possible, we have added features to our routing\nlayer, and middleware that can detect  implicit   support for these methods\n(i.e., the route was not registered  explicitly  with the method).",
            "title": "ImplicitHeadMiddleware and ImplicitOptionsMiddleware"
        },
        {
            "location": "/v2/features/middleware/implicit-methods-middleware/#versions-prior-to-22",
            "text": "If you are using Expressive versions earlier than 2.2, you may define a Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware  or Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware  service under the invokables  service configuration.  However, starting in version 2.2, these classes are deprecated in favor of their\nequivalents that are now offered in the zend-expressive-router v2.4+ releases,\nunder the namespace  Zend\\Expressive\\Router\\Middleware .  The documentation here has been updated to reflect usage under Expressive 2.2+.",
            "title": "Versions prior to 2.2"
        },
        {
            "location": "/v2/features/middleware/implicit-methods-middleware/#implicitheadmiddleware",
            "text": "Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware  provides support for\nhandling  HEAD  requests to routed middleware when the route does not expliclity\nallow for the method. It should be registered  between  the routing and dispatch\nmiddleware.  To use it, it must first be registered with your container. The easiest way to\ndo that is to register the zend-expressive-router  ConfigProvider  in your config/config.php :  $aggregator = new ConfigAggregator([\n    \\Zend\\Expressive\\Router\\ConfigProvider::class,  Alternately, add the following dependency configuration in one of your config/autoload/  configuration files or a  ConfigProvider  class:  use Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddlewareFactory;\n\n'dependencies' => [\n    'factories' => [\n        ImplicitHeadMiddleware::class => ImplicitHeadMiddlewareFactory::class,\n    ],\n],  Within your application pipeline, add the middleware between the routing and\ndispatch middleware:  $app->pipeRoutingMiddleware();\n$app->pipe(ImplicitHeadMiddleware::class);\n// ...\n$app->pipeDispatchMiddleware();  (Note: if you used the  expressive-pipeline-from-config  tool to create your\nprogrammatic pipeline, or if you used the Expressive skeleton, this middleware\nis likely already in your pipeline, as is a dependency entry.)  When in place, it will do the following:   If the request method is  HEAD , AND  the request composes a  RouteResult  attribute, AND  the route result composes a  Route  instance, AND  the route returns true for the  implicitHead()  method, THEN  the middleware will return a response.   In all other cases, it returns the result of delegating to the next middleware\nlayer.  When  implicitHead()  is matched, one of two things may occur. First, if the\nroute does not support the  GET  method, then the middleware returns the\ncomposed response (either the one injected at instantiation, or an empty\ninstance). However, if  GET  is supported, it will dispatch the next layer, but\nwith a  GET  request instead of  HEAD ; additionally, it will inject the\nreturned response with an empty response body before returning it.",
            "title": "ImplicitHeadMiddleware"
        },
        {
            "location": "/v2/features/middleware/implicit-methods-middleware/#detecting-forwarded-requests",
            "text": "Since 2.1.0   When the next layer is dispatched, the request will have an additional\nattribute,  Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware::FORWARDED_HTTP_METHOD_ATTRIBUTE ,\nwith a value of  HEAD . As such, you can check for this value in order to vary\nthe headers returned if desired.",
            "title": "Detecting forwarded requests"
        },
        {
            "location": "/v2/features/middleware/implicit-methods-middleware/#implicitoptionsmiddleware",
            "text": "Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware  provides support for\nhandling  OPTIONS  requests to routed middleware when the route does not\nexpliclity allow for the method. Like the  ImplicitHeadMiddleware , it should be\nregistered  between  the routing and dispatch middleware.  To use it, it must first be registered with your container. The easiest way to\ndo that is to register the zend-expressive-router  ConfigProvider  in your config/config.php :  $aggregator = new ConfigAggregator([\n    \\Zend\\Expressive\\Router\\ConfigProvider::class,  Alternately, add the following dependency configuration in one of your config/autoload/  configuration files or a  ConfigProvider  class:  use Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddlewareFactory;\n\n'dependencies' => [\n    'factories' => [\n        ImplicitOptionsMiddleware::class => ImplicitOptionsMiddlewareFactory::class,\n    ],\n],  Within your application pipeline, add the middleware between the routing and\ndispatch middleware:  $app->pipeRoutingMiddleware();\n$app->pipe(ImplicitOptionsMiddleware::class);\n// ...\n$app->pipeDispatchMiddleware();  (Note: if you used the  expressive-pipeline-from-config  tool to create your\nprogrammatic pipeline, or if you used the Expressive skeleton, this middleware\nis likely already in your pipeline, as is a dependency entry.)  When in place, it will do the following:   If the request method is  OPTIONS , AND  the request composes a  RouteResult  attribute, AND  the route result composes a  Route  instance, AND  the route returns true for the  implicitOptions()  method, THEN  the middleware will return a response with an  Allow  header indicating\n  methods the route allows.   In all other cases, it returns the result of delegating to the next middleware\nlayer.  One thing to note: the allowed methods reported by the route and/or route\nresult, and returned via the  Allow  header,  may vary based on router\nimplementation. In most cases, it should be an aggregate of all routes using the\nsame path specification; however, it  could  be only the methods supported\nexplicitly by the matched route.",
            "title": "ImplicitOptionsMiddleware"
        },
        {
            "location": "/v2/features/helpers/intro/",
            "text": "Helpers\n\n\nSome tasks and features will be common to many if not all applications. For\nthose, Expressive provides \nhelpers\n. These are typically utility classes that\nmay integrate features or simply provide standalone benefits.\n\n\nCurrently, these include:\n\n\n\n\nBody Parsing Middleware\n\n\nContent-Length Middleware\n (since zend-expressive-helpers 4.1.0)\n\n\nUrlHelper\n\n\nServerUrlHelper\n\n\n\n\nInstallation\n\n\nIf you started your project using the Expressive skeleton package, the helpers\nare already installed.\n\n\nIf not, you can install them as follows:\n\n\n$ composer require zendframework/zend-expressive-helpers",
            "title": "Introduction"
        },
        {
            "location": "/v2/features/helpers/intro/#helpers",
            "text": "Some tasks and features will be common to many if not all applications. For\nthose, Expressive provides  helpers . These are typically utility classes that\nmay integrate features or simply provide standalone benefits.  Currently, these include:   Body Parsing Middleware  Content-Length Middleware  (since zend-expressive-helpers 4.1.0)  UrlHelper  ServerUrlHelper",
            "title": "Helpers"
        },
        {
            "location": "/v2/features/helpers/intro/#installation",
            "text": "If you started your project using the Expressive skeleton package, the helpers\nare already installed.  If not, you can install them as follows:  $ composer require zendframework/zend-expressive-helpers",
            "title": "Installation"
        },
        {
            "location": "/v2/features/helpers/url-helper/",
            "text": "UrlHelper\n\n\nZend\\Expressive\\Helper\\UrlHelper\n provides the ability to generate a URI path\nbased on a given route defined in the \nZend\\Expressive\\Router\\RouterInterface\n.\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper->generate('resource', ['id' => 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' => 'sha1']);\n\n\n\nThe signature for both is:\n\n\nfunction (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string\n\n\n\nWhere:\n\n\n\n\n$routeName\n is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.\n\n\n$routeParams\n is an array of substitutions to use for the provided route, with the\n  following behavior:\n\n\nIf a \nRouteResult\n is composed in the helper, and the \n$routeName\n matches\n  it, the provided \n$params\n will be merged with any matched parameters, with\n  those provided taking precedence.\n\n\nIf a \nRouteResult\n is not composed, or if the composed result does not match\n  the provided \n$routeName\n, then only the \n$params\n provided will be used\n  for substitutions.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n matches the currently\n  matched route, then any matched parameters found will be used.\n  parameters found will be used.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n does not match the\n  currently matched route, or if no route result is present, then no\n  substitutions will be made.\n\n\n\n\n\n\n$queryParams\n is an array of query string arguments to include in the\n  generated URI.\n\n\n$fragmentIdentifier\n is a string to use as the URI fragment.\n\n\n$options\n is an array of options to provide to the router for purposes of\n  controlling URI generation. As an example, zend-router can consume \"translator\"\n  and \"text_domain\" options in order to provide translated URIs.\n\n\n\n\nEach method will raise an exception if:\n\n\n\n\nNo \n$routeName\n is provided, and no \nRouteResult\n is composed.\n\n\nNo \n$routeName\n is provided, a \nRouteResult\n is composed, but that result\n  represents a matching failure.\n\n\nThe given \n$routeName\n is not defined in the router.\n\n\n\n\n\n\nSignature changes\n\n\nThe signature listed above is current as of version 3.0.0 of\nzendframework/zend-expressive-helpers. Prior to that version, the helper only\naccepted the route name and route parameters.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to instantiate it with the current\n\nRouterInterface\n. The factory \nZend\\Expressive\\Helper\\UrlHelperFactory\n has\nbeen provided for this purpose, and can be used trivially with most\ndependency injection containers implementing\n\nPSR-11 Container\n. Additionally,\nit is most useful when injected with the current results of routing, which\nrequires registering middleware with the application that can inject the route\nresult. The following steps should be followed to register and configure the helper:\n\n\n\n\nRegister the \nUrlHelper\n as a service in your container, using the provided\n  factory.\n\n\nRegister the \nUrlHelperMiddleware\n as a service in your container, using the\n  provided factory.\n\n\nRegister the \nUrlHelperMiddleware\n as pipeline middleware, immediately\n  following the routing middleware.\n\n\n\n\nRegistering the helper service\n\n\nThe following examples demonstrate programmatic registration of the \nUrlHelper\n\nservice in your selected dependency injection container.\n\n\nuse Zend\\Expressive\\Helper\\UrlHelper;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\n\n// zend-servicemanager:\n$services->setFactory(UrlHelper::class, UrlHelperFactory::class);\n\n// Pimple:\n$pimple[UrlHelper::class] = function ($container) {\n    $factory = new UrlHelperFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(UrlHelperFactory::class, $container->lazyNew(UrlHelperFactory::class));\n$container->set(\n    UrlHelper::class,\n    $container->lazyGetCall(UrlHelperFactory::class, '__invoke', $container)\n);\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn ['dependencies' => [\n    'factories' => [\n        UrlHelper::class => UrlHelperFactory::class,\n    ],\n]]\n\n\n\n\n\nUrlHelperFactory requires RouterInterface\n\n\nThe factory requires that a service named \nZend\\Expressive\\Router\\RouterInterface\n is present,\nand will raise an exception if the service is not found.\n\n\n\n\nRegistering the pipeline middleware\n\n\nTo register the \nUrlHelperMiddleware\n as pipeline middleware following the\nrouting middleware:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n//         ['middleware' => UrlHelperMiddleware::class],\n//         Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n//         /* ... */\n//     ],\n// ]\n//\n// Alternately, create a nested middleware pipeline for the routing, UrlHelper,\n// and dispatch middleware:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         'routing' => [\n//             'middleware' => [\n//                 Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n//                 UrlHelperMiddleware::class\n//                 Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n//             ],\n//             'priority' => 1,\n//         ],\n//         /* ... */\n//     ],\n// ]\n\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n        ['middleware' => UrlHelperMiddleware::class],\n        Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n    ],\n];\n\n// OR:\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n                UrlHelperMiddleware::class,\n                Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n    ],\n];\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nUrlHelper\n and \nUrlHelperMiddleware\n factories are already registered for\nyou, as is the \nUrlHelperMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response->withHeader(\n            'Link',\n            $this->helper->generate('resource', ['id' => 'sha1'])\n        );\n        return $next($request, $response);\n    }\n}\n\n\n\nBase Path support\n\n\nIf your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the \nbase path\n, and thus be invalid. To\naccommodate this, the \nUrlHelper\n supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.\n\n\nAs an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the \nUrlHelper\n with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $uri = $request->getUri();\n        $path = $uri->getPath();\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $delegate->process($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $delegate->process($request->withUri(\n            $uri->withPath(substr($path, (strlen($locale) + 1)))\n        ));\n    }\n}\n\n\n\n(Note: if the base path injected is not prefixed with \n/\n, the helper will add\nthe slash.)\n\n\nPaths generated by the \nUriHelper\n from this point forward will have the\ndetected language prefix.",
            "title": "UrlHelper"
        },
        {
            "location": "/v2/features/helpers/url-helper/#urlhelper",
            "text": "Zend\\Expressive\\Helper\\UrlHelper  provides the ability to generate a URI path\nbased on a given route defined in the  Zend\\Expressive\\Router\\RouterInterface .\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.",
            "title": "UrlHelper"
        },
        {
            "location": "/v2/features/helpers/url-helper/#usage",
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper->generate('resource', ['id' => 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' => 'sha1']);  The signature for both is:  function (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string  Where:   $routeName  is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.  $routeParams  is an array of substitutions to use for the provided route, with the\n  following behavior:  If a  RouteResult  is composed in the helper, and the  $routeName  matches\n  it, the provided  $params  will be merged with any matched parameters, with\n  those provided taking precedence.  If a  RouteResult  is not composed, or if the composed result does not match\n  the provided  $routeName , then only the  $params  provided will be used\n  for substitutions.  If no  $params  are provided, and the  $routeName  matches the currently\n  matched route, then any matched parameters found will be used.\n  parameters found will be used.  If no  $params  are provided, and the  $routeName  does not match the\n  currently matched route, or if no route result is present, then no\n  substitutions will be made.    $queryParams  is an array of query string arguments to include in the\n  generated URI.  $fragmentIdentifier  is a string to use as the URI fragment.  $options  is an array of options to provide to the router for purposes of\n  controlling URI generation. As an example, zend-router can consume \"translator\"\n  and \"text_domain\" options in order to provide translated URIs.   Each method will raise an exception if:   No  $routeName  is provided, and no  RouteResult  is composed.  No  $routeName  is provided, a  RouteResult  is composed, but that result\n  represents a matching failure.  The given  $routeName  is not defined in the router.",
            "title": "Usage"
        },
        {
            "location": "/v2/features/helpers/url-helper/#signature-changes",
            "text": "The signature listed above is current as of version 3.0.0 of\nzendframework/zend-expressive-helpers. Prior to that version, the helper only\naccepted the route name and route parameters.",
            "title": "Signature changes"
        },
        {
            "location": "/v2/features/helpers/url-helper/#creating-an-instance",
            "text": "In order to use the helper, you will need to instantiate it with the current RouterInterface . The factory  Zend\\Expressive\\Helper\\UrlHelperFactory  has\nbeen provided for this purpose, and can be used trivially with most\ndependency injection containers implementing PSR-11 Container . Additionally,\nit is most useful when injected with the current results of routing, which\nrequires registering middleware with the application that can inject the route\nresult. The following steps should be followed to register and configure the helper:   Register the  UrlHelper  as a service in your container, using the provided\n  factory.  Register the  UrlHelperMiddleware  as a service in your container, using the\n  provided factory.  Register the  UrlHelperMiddleware  as pipeline middleware, immediately\n  following the routing middleware.",
            "title": "Creating an instance"
        },
        {
            "location": "/v2/features/helpers/url-helper/#registering-the-helper-service",
            "text": "The following examples demonstrate programmatic registration of the  UrlHelper \nservice in your selected dependency injection container.  use Zend\\Expressive\\Helper\\UrlHelper;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\n\n// zend-servicemanager:\n$services->setFactory(UrlHelper::class, UrlHelperFactory::class);\n\n// Pimple:\n$pimple[UrlHelper::class] = function ($container) {\n    $factory = new UrlHelperFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(UrlHelperFactory::class, $container->lazyNew(UrlHelperFactory::class));\n$container->set(\n    UrlHelper::class,\n    $container->lazyGetCall(UrlHelperFactory::class, '__invoke', $container)\n);  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return ['dependencies' => [\n    'factories' => [\n        UrlHelper::class => UrlHelperFactory::class,\n    ],\n]]",
            "title": "Registering the helper service"
        },
        {
            "location": "/v2/features/helpers/url-helper/#urlhelperfactory-requires-routerinterface",
            "text": "The factory requires that a service named  Zend\\Expressive\\Router\\RouterInterface  is present,\nand will raise an exception if the service is not found.",
            "title": "UrlHelperFactory requires RouterInterface"
        },
        {
            "location": "/v2/features/helpers/url-helper/#registering-the-pipeline-middleware",
            "text": "To register the  UrlHelperMiddleware  as pipeline middleware following the\nrouting middleware:  use Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n//         ['middleware' => UrlHelperMiddleware::class],\n//         Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n//         /* ... */\n//     ],\n// ]\n//\n// Alternately, create a nested middleware pipeline for the routing, UrlHelper,\n// and dispatch middleware:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         'routing' => [\n//             'middleware' => [\n//                 Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n//                 UrlHelperMiddleware::class\n//                 Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n//             ],\n//             'priority' => 1,\n//         ],\n//         /* ... */\n//     ],\n// ]  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n        ['middleware' => UrlHelperMiddleware::class],\n        Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n    ],\n];\n\n// OR:\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n                UrlHelperMiddleware::class,\n                Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n    ],\n];",
            "title": "Registering the pipeline middleware"
        },
        {
            "location": "/v2/features/helpers/url-helper/#skeleton-configures-helpers",
            "text": "If you started your project using the Expressive skeleton package, the UrlHelper  and  UrlHelperMiddleware  factories are already registered for\nyou, as is the  UrlHelperMiddleware  pipeline middleware.",
            "title": "Skeleton configures helpers"
        },
        {
            "location": "/v2/features/helpers/url-helper/#using-the-helper-in-middleware",
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response->withHeader(\n            'Link',\n            $this->helper->generate('resource', ['id' => 'sha1'])\n        );\n        return $next($request, $response);\n    }\n}",
            "title": "Using the helper in middleware"
        },
        {
            "location": "/v2/features/helpers/url-helper/#base-path-support",
            "text": "If your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the  base path , and thus be invalid. To\naccommodate this, the  UrlHelper  supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.  As an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the  UrlHelper  with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $uri = $request->getUri();\n        $path = $uri->getPath();\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $delegate->process($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $delegate->process($request->withUri(\n            $uri->withPath(substr($path, (strlen($locale) + 1)))\n        ));\n    }\n}  (Note: if the base path injected is not prefixed with  / , the helper will add\nthe slash.)  Paths generated by the  UriHelper  from this point forward will have the\ndetected language prefix.",
            "title": "Base Path support"
        },
        {
            "location": "/v2/features/helpers/server-url-helper/",
            "text": "ServerUrlHelper\n\n\nZend\\Expressive\\Helper\\ServerUrlHelper\n provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent \nPsr\\Http\\Message\\UriInterface\n instance provided to it in order to\ngenerate a fully qualified URI.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper->generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');\n\n\n\nThe helper is particularly useful when used in conjunction with the\n\nUrlHelper\n, as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:\n\n\n$url = $serverUrl($url('resource', ['id' => 'sha1']));\n\n\n\nThe signature for the ServerUrlHelper \ngenerate()\n and \n__invoke()\n methods is:\n\n\nfunction ($path = null) : string\n\n\n\nWhere:\n\n\n\n\n$path\n, when provided, can be a string path to use to generate a URI.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to inject it with the current\n\nUriInterface\n from the request instance. To automate this, we provide\n\nZend\\Expressive\\Helper\\ServerUrlMiddleware\n, which composes a \nServerUrl\n\ninstance, and, when invoked, injects it with the URI instance.\n\n\nAs such, you will need to:\n\n\n\n\nRegister the \nServerUrlHelper\n as a service in your container.\n\n\nRegister the \nServerUrlMiddleware\n as a service in your container.\n\n\nRegister the \nServerUrlMiddleware\n as pipeline middleware, anytime\n  before the routing middleware.\n\n\n\n\nThe following examples demonstrate registering the services.\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory;\n\n// zend-servicemanager:\n$services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class);\n$services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class);\n\n// Pimple:\n$pimple[ServerUrlHelper::class] = function ($container) {\n    return new ServerUrlHelper();\n};\n$pimple[ServerUrlMiddleware::class] = function ($container) {\n    $factory = new ServerUrlMiddlewareFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class));\n$container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class));\n$container->set(\n    ServerUrlMiddleware::class,\n    $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container)\n);\n\n\n\nTo register the \nServerUrlMiddleware\n as pipeline middleware anytime before the\nrouting middleware:\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n//         /* ... */\n//     ],\n// ]\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            ServerUrlHelper::class => ServerUrlHelper::class,\n        ],\n        'factories' => [\n            ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n        /* ... */\n    ],\n];\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nServerUrlHelper\n and \nServerUrlMiddleware\n factories are already registered\nfor you, as is the \nServerUrlMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader(\n            'Link',\n            $this->helper->generate() . '; rel=\"self\"'\n        );\n    }\n}",
            "title": "ServerUrlHelper"
        },
        {
            "location": "/v2/features/helpers/server-url-helper/#serverurlhelper",
            "text": "Zend\\Expressive\\Helper\\ServerUrlHelper  provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent  Psr\\Http\\Message\\UriInterface  instance provided to it in order to\ngenerate a fully qualified URI.",
            "title": "ServerUrlHelper"
        },
        {
            "location": "/v2/features/helpers/server-url-helper/#usage",
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper->generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');  The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:  $url = $serverUrl($url('resource', ['id' => 'sha1']));  The signature for the ServerUrlHelper  generate()  and  __invoke()  methods is:  function ($path = null) : string  Where:   $path , when provided, can be a string path to use to generate a URI.",
            "title": "Usage"
        },
        {
            "location": "/v2/features/helpers/server-url-helper/#creating-an-instance",
            "text": "In order to use the helper, you will need to inject it with the current UriInterface  from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a  ServerUrl \ninstance, and, when invoked, injects it with the URI instance.  As such, you will need to:   Register the  ServerUrlHelper  as a service in your container.  Register the  ServerUrlMiddleware  as a service in your container.  Register the  ServerUrlMiddleware  as pipeline middleware, anytime\n  before the routing middleware.   The following examples demonstrate registering the services.  use Zend\\Expressive\\Helper\\ServerUrlHelper;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory;\n\n// zend-servicemanager:\n$services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class);\n$services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class);\n\n// Pimple:\n$pimple[ServerUrlHelper::class] = function ($container) {\n    return new ServerUrlHelper();\n};\n$pimple[ServerUrlMiddleware::class] = function ($container) {\n    $factory = new ServerUrlMiddlewareFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class));\n$container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class));\n$container->set(\n    ServerUrlMiddleware::class,\n    $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container)\n);  To register the  ServerUrlMiddleware  as pipeline middleware anytime before the\nrouting middleware:  use Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n//         /* ... */\n//     ],\n// ]  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return [\n    'dependencies' => [\n        'invokables' => [\n            ServerUrlHelper::class => ServerUrlHelper::class,\n        ],\n        'factories' => [\n            ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n        /* ... */\n    ],\n];",
            "title": "Creating an instance"
        },
        {
            "location": "/v2/features/helpers/server-url-helper/#skeleton-configures-helpers",
            "text": "If you started your project using the Expressive skeleton package, the ServerUrlHelper  and  ServerUrlMiddleware  factories are already registered\nfor you, as is the  ServerUrlMiddleware  pipeline middleware.",
            "title": "Skeleton configures helpers"
        },
        {
            "location": "/v2/features/helpers/server-url-helper/#using-the-helper-in-middleware",
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader(\n            'Link',\n            $this->helper->generate() . '; rel=\"self\"'\n        );\n    }\n}",
            "title": "Using the helper in middleware"
        },
        {
            "location": "/v2/features/helpers/body-parse/",
            "text": "Body Parsing Middleware\n\n\nZend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware\n provides generic\n\nPSR-7\n middleware for parsing the request\nbody into parameters, and returning a new request instance that composes them.\nThe subcomponent provides a strategy pattern around matching the request\n\nContent-Type\n, and then parsing it, giving you a flexible approach that can\ngrow with your accepted content types.\n\n\nBy default, this middleware will detect the following content types:\n\n\n\n\napplication/x-www-form-urlencoded\n (standard web-based forms, without file\n  uploads)\n\n\napplication/json\n, \napplication/*+json\n (JSON payloads)\n\n\n\n\nRegistering the middleware\n\n\nYou can register it programmatically:\n\n\n$app->pipe(BodyParamsMiddleware::class);\n\n\n\nAlternately, register it via configuration, if using configuration-based applications:\n\n\n// config/autoload/middleware-pipeline.global.php\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nSince body parsing does not necessarily need to happen for every request, you\ncan also choose to incorporate it in route-specific middleware pipelines:\n\n\n$app->post('/login', [\n    BodyParamsMiddleware::class,\n    LoginMiddleware::class,\n]);\n\n\n\nIf using a configuration-based application:\n\n\n// config/autoload/routes.global.php\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'routes' => [\n        [\n            'name' => 'contact:process',\n            'path' => '/contact/process',\n            'middleware' => [\n                BodyParamsMiddleware::class,\n                Contact\\Process::class,\n            ],\n            'allowed_methods' => ['POST'],\n        ]\n    ],\n];\n\n\n\nUsing route-based middleware pipelines has the advantage of ensuring that the\nbody parsing middleware only executes for routes that require the processing.\nWhile the middleware has some checks to ensure it only triggers for HTTP\nmethods that accept bodies, those checks are still overhead that you might want\nto avoid; the above strategy of using the middleware only with specific routes\ncan accomplish that.\n\n\nStrategies\n\n\nIf you want to intercept and parse other payload types, you can add \nstrategies\n\nto the middleware. Strategies implement \nZend\\Expressive\\Helper\\BodyParams\\StrategyInterface\n:\n\n\nnamespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     *\n     * @param string $contentType\n     * @return bool Whether or not the strategy matches.\n     */\n    public function match($contentType);\n\n    /**\n     * Parse the body content and return a new response.\n     *\n     * @param ServerRequestInterface $request\n     * @return ServerRequestInterface\n     */\n    public function parse(ServerRequestInterface $request);\n}\n\n\n\nYou then register them with the middleware using the \naddStrategy()\n method:\n\n\n$bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n\n\n\nTo automate the registration, we recommend writing a factory for the\n\nBodyParamsMiddleware\n, and replacing the \ninvokables\n registration with a\nregistration in the \nfactories\n section of the \nmiddleware-pipeline.config.php\n\nfile:\n\n\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nRemoving the default strategies\n\n\nBy default, \nBodyParamsMiddleware\n composes the following strategies:\n\n\n\n\nZend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy\n\n\nZend\\Expressive\\Helper\\BodyParams\\JsonStrategy\n\n\n\n\nThese provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \u2014\n\napplication/x-www-form-urlencoded\n \u2014 matches first, as the middleware\ndelegates parsing to the first match.\n\n\nIf you do not want to use these default strategies, you can clear them from the\nmiddleware using \nclearStrategies()\n:\n\n\n$bodyParamsMiddleware->clearStrategies();\n\n\n\nNote: if you do this, \nall\n strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.",
            "title": "Body Parsing Middleware"
        },
        {
            "location": "/v2/features/helpers/body-parse/#body-parsing-middleware",
            "text": "Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware  provides generic PSR-7  middleware for parsing the request\nbody into parameters, and returning a new request instance that composes them.\nThe subcomponent provides a strategy pattern around matching the request Content-Type , and then parsing it, giving you a flexible approach that can\ngrow with your accepted content types.  By default, this middleware will detect the following content types:   application/x-www-form-urlencoded  (standard web-based forms, without file\n  uploads)  application/json ,  application/*+json  (JSON payloads)",
            "title": "Body Parsing Middleware"
        },
        {
            "location": "/v2/features/helpers/body-parse/#registering-the-middleware",
            "text": "You can register it programmatically:  $app->pipe(BodyParamsMiddleware::class);  Alternately, register it via configuration, if using configuration-based applications:  // config/autoload/middleware-pipeline.global.php\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];  Since body parsing does not necessarily need to happen for every request, you\ncan also choose to incorporate it in route-specific middleware pipelines:  $app->post('/login', [\n    BodyParamsMiddleware::class,\n    LoginMiddleware::class,\n]);  If using a configuration-based application:  // config/autoload/routes.global.php\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'routes' => [\n        [\n            'name' => 'contact:process',\n            'path' => '/contact/process',\n            'middleware' => [\n                BodyParamsMiddleware::class,\n                Contact\\Process::class,\n            ],\n            'allowed_methods' => ['POST'],\n        ]\n    ],\n];  Using route-based middleware pipelines has the advantage of ensuring that the\nbody parsing middleware only executes for routes that require the processing.\nWhile the middleware has some checks to ensure it only triggers for HTTP\nmethods that accept bodies, those checks are still overhead that you might want\nto avoid; the above strategy of using the middleware only with specific routes\ncan accomplish that.",
            "title": "Registering the middleware"
        },
        {
            "location": "/v2/features/helpers/body-parse/#strategies",
            "text": "If you want to intercept and parse other payload types, you can add  strategies \nto the middleware. Strategies implement  Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface :  namespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     *\n     * @param string $contentType\n     * @return bool Whether or not the strategy matches.\n     */\n    public function match($contentType);\n\n    /**\n     * Parse the body content and return a new response.\n     *\n     * @param ServerRequestInterface $request\n     * @return ServerRequestInterface\n     */\n    public function parse(ServerRequestInterface $request);\n}  You then register them with the middleware using the  addStrategy()  method:  $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());  To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the  invokables  registration with a\nregistration in the  factories  section of the  middleware-pipeline.config.php \nfile:  use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];",
            "title": "Strategies"
        },
        {
            "location": "/v2/features/helpers/body-parse/#removing-the-default-strategies",
            "text": "By default,  BodyParamsMiddleware  composes the following strategies:   Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy  Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy   These provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded  \u2014 matches first, as the middleware\ndelegates parsing to the first match.  If you do not want to use these default strategies, you can clear them from the\nmiddleware using  clearStrategies() :  $bodyParamsMiddleware->clearStrategies();  Note: if you do this,  all  strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.",
            "title": "Removing the default strategies"
        },
        {
            "location": "/v2/features/helpers/content-length/",
            "text": "Content-Length Middleware\n\n\n\n\nAvailable since zend-expressive-helpers version 4.1.0.\n\n\n\n\nIn some cases, you may want to include an explicit \nContent-Length\n response\nheader, without having to inject it manually. To facilitate this, we provide\n\nZend\\Expressive\\Helper\\ContentLengthMiddleware\n.\n\n\n\n\nWhen to use this middleware\n\n\nIn most cases, you do not need to provide an explicit Content-Length value\nin your responses. While the HTTP/1.1 specification indicates the header\nSHOULD be provided, most clients will not degrade to HTTP/1.0 if the header\nis omitted.\n\n\nThe one exception that has been reported is when working with\n\nNew Relic\n, which requires valid \nContent-Length\n\nheaders for some of its analytics; in such cases, enabling this middleware\nwill fix those situations.\n\n\n\n\nThis middleware delegates the request, and operates on the returned response. It\nwill return a new response with the \nContent-Length\n header injected under the\nfollowing conditions:\n\n\n\n\nNo \nContent-Length\n header is already present AND\n\n\nthe body size is non-null.\n\n\n\n\nTo register it in your application, you will need to do two things: register the\nmiddleware with the container, and register the middleware in either your\napplication pipeline, or within routed middleware.\n\n\nTo add it to your container, add the following configuration:\n\n\n// In a `config/autoload/*.global.php` file, or a `ConfigProvider` class:\n\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\ContentLengthMiddleware::class => Helper\\ContentLengthMiddleware::class,\n        ],\n    ],\n];\n\n\n\nTo register it as pipeline middleware to execute on any request:\n\n\n// In `config/pipeline.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->pipe(Helper\\ContentLengthMiddleware::class);\n\n\n\nTo register it within a routed middleware pipeline:\n\n\n// In `config/routes.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->get('/download/tarball', [\n    Helper\\ContentLengthMiddleware::class,\n    Download\\Tarball::class,\n], 'download-tar');\n\n\n\nCaveats\n\n\nOne caveat to note is that if you use this middleware, but also write directly\nto the output buffer (e.g., via a \nvar_dump\n, or if \ndisplay_errors\n is on and\nan uncaught error or exception occurs), the output will not appear as you\nexpect. Generally in such situations, the contents of the output buffer will\nappear, up to the specified \nContent-Length\n value. This can lead to truncated\nerror content and/or truncated application content.\n\n\nWe recommend that if you use this feature, you also use a PHP error and/or\nexception handler that logs errors in order to prevent truncated output.",
            "title": "Content-Length Middleware"
        },
        {
            "location": "/v2/features/helpers/content-length/#content-length-middleware",
            "text": "Available since zend-expressive-helpers version 4.1.0.   In some cases, you may want to include an explicit  Content-Length  response\nheader, without having to inject it manually. To facilitate this, we provide Zend\\Expressive\\Helper\\ContentLengthMiddleware .",
            "title": "Content-Length Middleware"
        },
        {
            "location": "/v2/features/helpers/content-length/#when-to-use-this-middleware",
            "text": "In most cases, you do not need to provide an explicit Content-Length value\nin your responses. While the HTTP/1.1 specification indicates the header\nSHOULD be provided, most clients will not degrade to HTTP/1.0 if the header\nis omitted.  The one exception that has been reported is when working with New Relic , which requires valid  Content-Length \nheaders for some of its analytics; in such cases, enabling this middleware\nwill fix those situations.   This middleware delegates the request, and operates on the returned response. It\nwill return a new response with the  Content-Length  header injected under the\nfollowing conditions:   No  Content-Length  header is already present AND  the body size is non-null.   To register it in your application, you will need to do two things: register the\nmiddleware with the container, and register the middleware in either your\napplication pipeline, or within routed middleware.  To add it to your container, add the following configuration:  // In a `config/autoload/*.global.php` file, or a `ConfigProvider` class:\n\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\ContentLengthMiddleware::class => Helper\\ContentLengthMiddleware::class,\n        ],\n    ],\n];  To register it as pipeline middleware to execute on any request:  // In `config/pipeline.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->pipe(Helper\\ContentLengthMiddleware::class);  To register it within a routed middleware pipeline:  // In `config/routes.php`:\n\nuse Zend\\Expressive\\Helper;\n\n$app->get('/download/tarball', [\n    Helper\\ContentLengthMiddleware::class,\n    Download\\Tarball::class,\n], 'download-tar');",
            "title": "When to use this middleware"
        },
        {
            "location": "/v2/features/helpers/content-length/#caveats",
            "text": "One caveat to note is that if you use this middleware, but also write directly\nto the output buffer (e.g., via a  var_dump , or if  display_errors  is on and\nan uncaught error or exception occurs), the output will not appear as you\nexpect. Generally in such situations, the contents of the output buffer will\nappear, up to the specified  Content-Length  value. This can lead to truncated\nerror content and/or truncated application content.  We recommend that if you use this feature, you also use a PHP error and/or\nexception handler that logs errors in order to prevent truncated output.",
            "title": "Caveats"
        },
        {
            "location": "/v2/features/emitters/",
            "text": "Emitters\n\n\nTo simplify the usage of Expressive, we added the \nrun()\n method, which handles\nthe incoming request, and emits a response.\n\n\nThe latter aspect, emitting the response, is the responsibility of an\n\nemitter\n.\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.\n\n\nDiactoros defines an \nEmitterInterface\n, and \u2014 as of the time we write this \u2014 a\nsingle emitter implementation, \nZend\\Diactoros\\Response\\SapiEmitter\n, which\nsends headers and output using PHP's standard SAPI mechanisms (the \nheader()\n\nmethod and the output buffer).\n\n\nWe recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use \nReact\n, the SAPI\nemitter will likely not work for you.\n\n\nTo facilitate alternate emitters, we offer two facilities:\n\n\n\n\nFirst, \nApplication\n composes an emitter, and you can specify an alternate\n  emitter during instantiation, or via the \nZend\\Diactoros\\Response\\EmitterInterface\n\n  service when using the container factory.\n\n\nSecond, we provide \nZend\\Expressive\\Emitter\\EmitterStack\n, which allows you to\n  compose multiple emitter strategies; the first to return a value other than\n  boolean \nfalse\n will cause execution of the stack to short-circuit.\n  \nApplication\n composes an \nEmitterStack\n by default, with an \nSapiEmitter\n\n  composed at the bottom of the stack.\n\n\n\n\nEmitterStack\n\n\nThe \nEmitterStack\n is an \nSplStack\n extension that implements\n\nEmitterInterface\n. You can add emitters to the stack by pushing them on:\n\n\n$stack->push($emitterInstance);\n\n\n\nAs a stack, execution is in LIFO (last in, first out) order; the first emitter\non the stack will be evaluated last.\n\n\n\n\nDeprecated with version 2.2\n\n\nStarting in version 2.2, the \nEmitterStack\n is deprecated, and moved, along with the\nzend-diactoros \nEmitterInterface\n and implementations, to a new package,\n\nzend-httphandlerrunner\n.\n\n\nThe interface and the \nEmitterStack\n are roughly identical to what is present in\nversion 2; if you are defining a \nZend\\Diactoros\\Emitter\\EmitterInterface\n\nservice of your own, you will need to update it in that version.",
            "title": "Emitters"
        },
        {
            "location": "/v2/features/emitters/#emitters",
            "text": "To simplify the usage of Expressive, we added the  run()  method, which handles\nthe incoming request, and emits a response.  The latter aspect, emitting the response, is the responsibility of an emitter .\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.  Diactoros defines an  EmitterInterface , and \u2014 as of the time we write this \u2014 a\nsingle emitter implementation,  Zend\\Diactoros\\Response\\SapiEmitter , which\nsends headers and output using PHP's standard SAPI mechanisms (the  header() \nmethod and the output buffer).  We recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use  React , the SAPI\nemitter will likely not work for you.  To facilitate alternate emitters, we offer two facilities:   First,  Application  composes an emitter, and you can specify an alternate\n  emitter during instantiation, or via the  Zend\\Diactoros\\Response\\EmitterInterface \n  service when using the container factory.  Second, we provide  Zend\\Expressive\\Emitter\\EmitterStack , which allows you to\n  compose multiple emitter strategies; the first to return a value other than\n  boolean  false  will cause execution of the stack to short-circuit.\n   Application  composes an  EmitterStack  by default, with an  SapiEmitter \n  composed at the bottom of the stack.",
            "title": "Emitters"
        },
        {
            "location": "/v2/features/emitters/#emitterstack",
            "text": "The  EmitterStack  is an  SplStack  extension that implements EmitterInterface . You can add emitters to the stack by pushing them on:  $stack->push($emitterInstance);  As a stack, execution is in LIFO (last in, first out) order; the first emitter\non the stack will be evaluated last.",
            "title": "EmitterStack"
        },
        {
            "location": "/v2/features/emitters/#deprecated-with-version-22",
            "text": "Starting in version 2.2, the  EmitterStack  is deprecated, and moved, along with the\nzend-diactoros  EmitterInterface  and implementations, to a new package, zend-httphandlerrunner .  The interface and the  EmitterStack  are roughly identical to what is present in\nversion 2; if you are defining a  Zend\\Diactoros\\Emitter\\EmitterInterface \nservice of your own, you will need to update it in that version.",
            "title": "Deprecated with version 2.2"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/",
            "text": "How can I autowire routes and pipelines?\n\n\nExpressive 2.0 switched to \nprogrammatic\n pipelines and routes, versus\n\nconfiguration-driven\n pipelines and routing as used in version 1. One drawback\nis that with configuration-driven approaches, users could provide configuration\nvia a module \nConfigProvider\n, and automatically expose new pipeline middleware\nor routes; with a programmatic approach, this is no longer possible.\n\n\nOr is it?\n\n\nDelegator Factories\n\n\nOne possibility available to version 2 applications is to use \ndelegator\nfactories\n on the \nZend\\Expressive\\Application\n instance in order to inject\nthese items.\n\n\nA \ndelegator factory\n is a factory that \ndelegates\n creation of an instance to a\ncallback, and then operates on that instance for the purpose of altering the\ninstance or providing a replacement (e.g., a decorator or proxy). The delegate\ncallback usually wraps a service factory, or, because delegator factories\n\nalso\n return an instance, additional delegator factories. As such, you assign\ndelegator \nfactories\n, plural, to instances, allowing multiple delegator\nfactories to intercept processing of the service initialization.\n\n\nFor the purposes of this particular example, we will use delegator factories to\nboth \npipe\n middleware as well as \nroute\n middleware.\n\n\nTo demonstrate, we'll take the default pipeline and routing from the skeleton\napplication, and provide it via a delegator factory instead.\n\n\nFirst, we'll create the class \nApp\\Factory\\PipelineAndRoutesDelegator\n, with\nthe following contents:\n\n\n<?php\n\nnamespace App\\Factory;\n\nuse App\\Action;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass PipelineAndRoutesDelegator\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $serviceName Name of the service being created.\n     * @param callable $callback Creates and returns the service.\n     * @return Application\n     */\n    public function __invoke(ContainerInterface $container, $serviceName, callable $callback)\n    {\n        /** @var $app Application */\n        $app = $callback();\n\n        // Setup pipeline:\n        $app->pipe(ErrorHandler::class);\n        $app->pipe(ServerUrlMiddleware::class);\n        $app->pipeRoutingMiddleware();\n        $app->pipe(ImplicitHeadMiddleware::class);\n        $app->pipe(ImplicitOptionsMiddleware::class);\n        $app->pipe(UrlHelperMiddleware::class);\n        $app->pipeDispatchMiddleware();\n        $app->pipe(NotFoundHandler::class);\n\n        // Setup routes:\n        $app->get('/', Action\\HomePageAction::class, 'home');\n        $app->get('/api/ping', Action\\PingAction::class, 'api.ping');\n\n        return $app;\n    }\n}\n\n\n\n\n\nWhere to put the factory\n\n\nYou will place the factory class in one of the following locations:\n\n\n\n\nsrc/App/Factory/PipelineAndRoutesDelegator.php\n if using the default, flat,\n  application structure.\n\n\nsrc/App/src/Factory/PipelineAndRoutesDelegator.php\n if using the\n  recommended, modular, application structure.\n\n\n\n\n\n\nOnce you've created this, edit the class \nApp\\ConfigProvider\n; in it, we'll\nupdate the \ngetDependencies()\n method to add the delegator factory:\n\n\npublic function getDependencies()\n{\n    return [\n        /* . . . */\n        'delegators' => [\n            \\Zend\\Expressive\\Application::class => [\n                Factory\\PipelineAndRoutesDelegator::class,\n            ],\n        ],\n    ];\n}\n\n\n\n\n\nWhere is the ConfigProvider class?\n\n\nThe \nConfigProvider\n class is in one of the following locations:\n\n\n\n\nsrc/App/ConfigProvider.php\n if using the default, flat, application\n  structure.\n\n\nsrc/App/src/ConfigProvider.php\n using the recommended, modular, application\n  structure.\n\n\n\n\nWhy is an array assigned?\n\n\nAs noted above in the description of delegator factories, since each delegator\nfactory returns an instance, you can nest multiple delegator factories in\norder to shape initialization of a service. As such, they are assigned as an\n\narray\n to the service.\n\n\n\n\nOnce you've done this, you can remove:\n\n\n\n\nconfig/pipeline.php\n\n\nconfig/routes.php\n\n\nThe following lines from \npublic/index.php\n:\n\n\n\n\n// Import programmatic/declarative middleware pipeline and routing\n// configuration statements\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n\n\nIf you reload your application at this point, you should see that everything\ncontinues to work as expected!\n\n\nCaution: pipelines\n\n\nUsing delegator factories is a nice way to keep your routing and pipeline\nconfiguration close to the modules in which they are defined. However, there is\na caveat: you likely should \nnot\n register pipeline middleware in a delegator\nfactory \nother than within your root application module\n.\n\n\nThe reason for this is simple: pipelines are linear, and specific to your\napplication. If one module pipes in middleware, there's no guarantee it will be\npiped before or after your main pipeline, and no way to pipe the middleware at a\nposition in the middle of the pipeline!\n\n\nAs such:\n\n\n\n\nUse a \nconfig/pipeline.php\n file for your pipeline, \nOR\n\n\nEnsure you only define the pipeline in a \nsingle\n delegator factory on your\n  \nApplication\n instance.\n\n\n\n\nCaution: third-party, distributed modules\n\n\nIf you are developing a module to distribute as a package via\n\nComposer\n, \nyou should not autowire any delegator\nfactories that inject pipeline middleware or routes in the \nApplication\n.\n\n\nWhy?\n\n\nAs noted in the above section, pipelines should be created exactly once, at\nthe application level. Registering pipeline middleware within a distributable\npackage will very likely not have the intended consequences.\n\n\nIf you ship with pipeline middleware, we suggest that you:\n\n\n\n\nDocument the middleware, and where you anticipate it being used in the\n  middleware pipeline.\n\n\nDocument how to add the middleware service to dependency configuration, or\n  provide the dependency configuration via your module's \nConfigProvider\n.\n\n\n\n\nWith regards to routes, there are other considerations:\n\n\n\n\n\n\nRoutes defined by the package might conflict with the application, or with\n  other packages used by the application.\n\n\n\n\n\n\nRouting definitions are typically highly specific to the router implementation\n  in use. As an example, each of the currently supported router implementations\n  has a different syntax for placeholders:\n\n\n\n\n/user/:id\n + \"constraints\" configuration to define constraints (zend-router)\n\n\n/user/{id}\n + \"tokens\" configuration to define constraints (Aura.Router)\n\n\n/user/{id:\\d+}\n (FastRoute)\n\n\n\n\n\n\n\n\nYour application may have specific routing considerations or design.\n\n\n\n\n\n\nYou could, of course, detect what router is in use, and provide routing for each\nknown, supported router implementation within your delegator factory. We even\nrecommend doing exactly that. However, we note that such an approach does not\nsolve the other two points above.\n\n\nHowever, we still recommend \nshipping\n a delegator factory that would register\nyour routes, since routes \nare\n often a part of module design; just \ndo not\nautowire\n that delegator factory. This way, end-users who \ncan\n use the\ndefaults do not need to cut-and-paste routing definitions from your\ndocumentation into their own applications; they will instead opt-in to your\ndelegator factory by wiring it into their own configuration.\n\n\nSynopsis\n\n\n\n\nWe recommend using delegator factories for the purpose of autowiring routes,\n  and, with caveats, pipeline middleware:\n\n\nThe pipeline should be created exactly once, so calls to \npipe()\n should\n  occur in exactly \none\n delegator factory.\n\n\n\n\n\n\nDistributable packages should create a delegator factory for \nroutes only\n,\n  but \nshould not\n register the delegator factory by default.\n\n\n\n\nApplicationConfigInjectionDelegator\n\n\n\n\nSince version 2.2\n\n\n\n\nZend\\Expressive\\Container\\ApplicationConfigInjectionDelegator\n allows you to\ndefine configuration that is then used to call \npipe()\n or the various routing\nmethods of \nZend\\Expressive\\Application\n. This is particularly useful for\ninjecting \nroutes\n.\n\n\nThe format of routes configuration is as follows:\n\n\nreturn [\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware Service Name',\n            'allowed_methods' => ['GET', 'POST', 'PATCH'],\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n];\n\n\n\nAll your various modules could provide route configuration, and you could then\nuse a single delegator to add all of them at once.",
            "title": "Autowiring routes and pipeline middleware"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#how-can-i-autowire-routes-and-pipelines",
            "text": "Expressive 2.0 switched to  programmatic  pipelines and routes, versus configuration-driven  pipelines and routing as used in version 1. One drawback\nis that with configuration-driven approaches, users could provide configuration\nvia a module  ConfigProvider , and automatically expose new pipeline middleware\nor routes; with a programmatic approach, this is no longer possible.  Or is it?",
            "title": "How can I autowire routes and pipelines?"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#delegator-factories",
            "text": "One possibility available to version 2 applications is to use  delegator\nfactories  on the  Zend\\Expressive\\Application  instance in order to inject\nthese items.  A  delegator factory  is a factory that  delegates  creation of an instance to a\ncallback, and then operates on that instance for the purpose of altering the\ninstance or providing a replacement (e.g., a decorator or proxy). The delegate\ncallback usually wraps a service factory, or, because delegator factories also  return an instance, additional delegator factories. As such, you assign\ndelegator  factories , plural, to instances, allowing multiple delegator\nfactories to intercept processing of the service initialization.  For the purposes of this particular example, we will use delegator factories to\nboth  pipe  middleware as well as  route  middleware.  To demonstrate, we'll take the default pipeline and routing from the skeleton\napplication, and provide it via a delegator factory instead.  First, we'll create the class  App\\Factory\\PipelineAndRoutesDelegator , with\nthe following contents:  <?php\n\nnamespace App\\Factory;\n\nuse App\\Action;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware;\nuse Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware;\nuse Zend\\Expressive\\Middleware\\NotFoundHandler;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass PipelineAndRoutesDelegator\n{\n    /**\n     * @param ContainerInterface $container\n     * @param string $serviceName Name of the service being created.\n     * @param callable $callback Creates and returns the service.\n     * @return Application\n     */\n    public function __invoke(ContainerInterface $container, $serviceName, callable $callback)\n    {\n        /** @var $app Application */\n        $app = $callback();\n\n        // Setup pipeline:\n        $app->pipe(ErrorHandler::class);\n        $app->pipe(ServerUrlMiddleware::class);\n        $app->pipeRoutingMiddleware();\n        $app->pipe(ImplicitHeadMiddleware::class);\n        $app->pipe(ImplicitOptionsMiddleware::class);\n        $app->pipe(UrlHelperMiddleware::class);\n        $app->pipeDispatchMiddleware();\n        $app->pipe(NotFoundHandler::class);\n\n        // Setup routes:\n        $app->get('/', Action\\HomePageAction::class, 'home');\n        $app->get('/api/ping', Action\\PingAction::class, 'api.ping');\n\n        return $app;\n    }\n}",
            "title": "Delegator Factories"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#where-to-put-the-factory",
            "text": "You will place the factory class in one of the following locations:   src/App/Factory/PipelineAndRoutesDelegator.php  if using the default, flat,\n  application structure.  src/App/src/Factory/PipelineAndRoutesDelegator.php  if using the\n  recommended, modular, application structure.    Once you've created this, edit the class  App\\ConfigProvider ; in it, we'll\nupdate the  getDependencies()  method to add the delegator factory:  public function getDependencies()\n{\n    return [\n        /* . . . */\n        'delegators' => [\n            \\Zend\\Expressive\\Application::class => [\n                Factory\\PipelineAndRoutesDelegator::class,\n            ],\n        ],\n    ];\n}",
            "title": "Where to put the factory"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#where-is-the-configprovider-class",
            "text": "The  ConfigProvider  class is in one of the following locations:   src/App/ConfigProvider.php  if using the default, flat, application\n  structure.  src/App/src/ConfigProvider.php  using the recommended, modular, application\n  structure.",
            "title": "Where is the ConfigProvider class?"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#why-is-an-array-assigned",
            "text": "As noted above in the description of delegator factories, since each delegator\nfactory returns an instance, you can nest multiple delegator factories in\norder to shape initialization of a service. As such, they are assigned as an array  to the service.   Once you've done this, you can remove:   config/pipeline.php  config/routes.php  The following lines from  public/index.php :   // Import programmatic/declarative middleware pipeline and routing\n// configuration statements\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';  If you reload your application at this point, you should see that everything\ncontinues to work as expected!",
            "title": "Why is an array assigned?"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#caution-pipelines",
            "text": "Using delegator factories is a nice way to keep your routing and pipeline\nconfiguration close to the modules in which they are defined. However, there is\na caveat: you likely should  not  register pipeline middleware in a delegator\nfactory  other than within your root application module .  The reason for this is simple: pipelines are linear, and specific to your\napplication. If one module pipes in middleware, there's no guarantee it will be\npiped before or after your main pipeline, and no way to pipe the middleware at a\nposition in the middle of the pipeline!  As such:   Use a  config/pipeline.php  file for your pipeline,  OR  Ensure you only define the pipeline in a  single  delegator factory on your\n   Application  instance.",
            "title": "Caution: pipelines"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#caution-third-party-distributed-modules",
            "text": "If you are developing a module to distribute as a package via Composer ,  you should not autowire any delegator\nfactories that inject pipeline middleware or routes in the  Application .  Why?  As noted in the above section, pipelines should be created exactly once, at\nthe application level. Registering pipeline middleware within a distributable\npackage will very likely not have the intended consequences.  If you ship with pipeline middleware, we suggest that you:   Document the middleware, and where you anticipate it being used in the\n  middleware pipeline.  Document how to add the middleware service to dependency configuration, or\n  provide the dependency configuration via your module's  ConfigProvider .   With regards to routes, there are other considerations:    Routes defined by the package might conflict with the application, or with\n  other packages used by the application.    Routing definitions are typically highly specific to the router implementation\n  in use. As an example, each of the currently supported router implementations\n  has a different syntax for placeholders:   /user/:id  + \"constraints\" configuration to define constraints (zend-router)  /user/{id}  + \"tokens\" configuration to define constraints (Aura.Router)  /user/{id:\\d+}  (FastRoute)     Your application may have specific routing considerations or design.    You could, of course, detect what router is in use, and provide routing for each\nknown, supported router implementation within your delegator factory. We even\nrecommend doing exactly that. However, we note that such an approach does not\nsolve the other two points above.  However, we still recommend  shipping  a delegator factory that would register\nyour routes, since routes  are  often a part of module design; just  do not\nautowire  that delegator factory. This way, end-users who  can  use the\ndefaults do not need to cut-and-paste routing definitions from your\ndocumentation into their own applications; they will instead opt-in to your\ndelegator factory by wiring it into their own configuration.",
            "title": "Caution: third-party, distributed modules"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#synopsis",
            "text": "We recommend using delegator factories for the purpose of autowiring routes,\n  and, with caveats, pipeline middleware:  The pipeline should be created exactly once, so calls to  pipe()  should\n  occur in exactly  one  delegator factory.    Distributable packages should create a delegator factory for  routes only ,\n  but  should not  register the delegator factory by default.",
            "title": "Synopsis"
        },
        {
            "location": "/v2/cookbook/autowiring-routes-and-pipelines/#applicationconfiginjectiondelegator",
            "text": "Since version 2.2   Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator  allows you to\ndefine configuration that is then used to call  pipe()  or the various routing\nmethods of  Zend\\Expressive\\Application . This is particularly useful for\ninjecting  routes .  The format of routes configuration is as follows:  return [\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware Service Name',\n            'allowed_methods' => ['GET', 'POST', 'PATCH'],\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n];  All your various modules could provide route configuration, and you could then\nuse a single delegator to add all of them at once.",
            "title": "ApplicationConfigInjectionDelegator"
        },
        {
            "location": "/v2/cookbook/common-prefix-for-routes/",
            "text": "How can I prepend a common path to all my routes?\n\n\nYou may have multiple middleware in your project, each providing their own\nfunctionality:\n\n\n$middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$app = AppFactory::create();\n$app->pipe($middleware1);\n$app->pipe($middleware2);\n\n$app->run();\n\n\n\nLet's assume the above represents an API.\n\n\nAs your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path \n/api\n.\n\n\nThis is essentially the same problem as addressed in the\n\n\"Segregating your application to a subpath\"\n example.\n\n\nTo accomplish it:\n\n\n\n\nCreate a new application.\n\n\nPipe the previous application to the new one, under the path \n/api\n.\n\n\n\n\n$middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$api = AppFactory::create();\n$api->pipe($middleware1);\n$api->pipe($middleware2);\n\n$app = AppFactory::create();\n$app->pipe('/api', $api);\n\n$app->run();\n\n\n\nThe above works, because every \nApplication\n instance is itself middleware, and, more specifically,\nan instance of \nStratigility's \nMiddlewarePipe\n,\nwhich provides the ability to compose middleware.",
            "title": "Prepending a common path to all routes"
        },
        {
            "location": "/v2/cookbook/common-prefix-for-routes/#how-can-i-prepend-a-common-path-to-all-my-routes",
            "text": "You may have multiple middleware in your project, each providing their own\nfunctionality:  $middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$app = AppFactory::create();\n$app->pipe($middleware1);\n$app->pipe($middleware2);\n\n$app->run();  Let's assume the above represents an API.  As your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path  /api .  This is essentially the same problem as addressed in the \"Segregating your application to a subpath\"  example.  To accomplish it:   Create a new application.  Pipe the previous application to the new one, under the path  /api .   $middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$api = AppFactory::create();\n$api->pipe($middleware1);\n$api->pipe($middleware2);\n\n$app = AppFactory::create();\n$app->pipe('/api', $api);\n\n$app->run();  The above works, because every  Application  instance is itself middleware, and, more specifically,\nan instance of  Stratigility's  MiddlewarePipe ,\nwhich provides the ability to compose middleware.",
            "title": "How can I prepend a common path to all my routes?"
        },
        {
            "location": "/v2/cookbook/route-specific-pipeline/",
            "text": "How can I specify a route-specific middleware pipeline?\n\n\nSometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:\n\n\n\n\ncheck for authentication credentials\n\n\ncheck for authorization for the selected action\n\n\nparse the incoming body\n\n\nvalidate the parsed body parameters\n\n\n\n\nbefore\n you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.\n\n\nYou can accomplish this in one of two ways:\n\n\n\n\nHave your middleware service resolve to a \nMiddlewarePipe\n instance that\n  composes the various middlewares.\n\n\nSpecify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a \nMiddlewarePipe\n.\n\n\n\n\nResolving to a MiddlewarePipe\n\n\nYou can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($container->get('ApiResource'));\n\n        return $pipeline;\n    }\n}\n\n\n\nThis gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.\n\n\nOne alternative when using zend-servicemanager is to use a \ndelegator factory\n.\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:\n\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($callback());\n\n        return $pipeline;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}\n\n\n\nWhen configuring the container, you'd do something like the following:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            'AuthenticationMiddleware' => '...',\n            'AuthorizationMiddleware' => '...',\n            'BodyParsingMiddleware' => '...',\n            'ValidationMiddleware' => '...',\n            'ApiResourceMiddleware' => '...',\n        ],\n        'delegators' => [\n            'ApiResourceMiddleware' => [\n                'ApiResourcePipelineDelegatorFactory',\n            ],\n        ],\n    ],\n];\n\n\n\nThis approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.\n\n\nMiddleware Arrays\n\n\nIf you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares in your configuration or when routing manually.\n\n\nVia configuration looks like this:\n\n\nreturn [\n    'routes' => [\n        [\n            'name' => 'api-resource',\n            'path' => '/api/resource[/{id:[a-f0-9]{32}}]',\n            'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'],\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n                'ApiResourceMiddleware',\n            ],\n        ],\n    ],\n];\n\n\n\nManual routing looks like this:\n\n\n$app->route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    'AuthenticationMiddleware',\n    'AuthorizationMiddleware',\n    'BodyParsingMiddleware',\n    'ValidationMiddleware',\n    'ApiResourceMiddleware',\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');\n\n\n\nWhen either of these approaches are used, the individual middleware listed\n\nMUST\n be one of the following:\n\n\n\n\nan instance of \nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n;\n\n\na callable middleware (will be decorated as interop middleware);\n\n\na service name of middleware available in the container;\n\n\na fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.\n\n\n\n\nThis approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.\n\n\nWhat about pipeline middleware configuration?\n\n\nWhat if you want to do this with your pipeline middleware configuration? The\nanswer is that the syntax is exactly the same!\n\n\nreturn [\n    'middleware_pipeline' => [\n        'api' => [\n            'path' => '/api',\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n            ],\n            'priority' => 100,\n        ],\n    ],\n];",
            "title": "Route-specific middleware pipelines"
        },
        {
            "location": "/v2/cookbook/route-specific-pipeline/#how-can-i-specify-a-route-specific-middleware-pipeline",
            "text": "Sometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:   check for authentication credentials  check for authorization for the selected action  parse the incoming body  validate the parsed body parameters   before  you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.  You can accomplish this in one of two ways:   Have your middleware service resolve to a  MiddlewarePipe  instance that\n  composes the various middlewares.  Specify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a  MiddlewarePipe .",
            "title": "How can I specify a route-specific middleware pipeline?"
        },
        {
            "location": "/v2/cookbook/route-specific-pipeline/#resolving-to-a-middlewarepipe",
            "text": "You can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.  use Psr\\Container\\ContainerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($container->get('ApiResource'));\n\n        return $pipeline;\n    }\n}  This gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.  One alternative when using zend-servicemanager is to use a  delegator factory .\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:  use Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($callback());\n\n        return $pipeline;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}  When configuring the container, you'd do something like the following:  return [\n    'dependencies' => [\n        'factories' => [\n            'AuthenticationMiddleware' => '...',\n            'AuthorizationMiddleware' => '...',\n            'BodyParsingMiddleware' => '...',\n            'ValidationMiddleware' => '...',\n            'ApiResourceMiddleware' => '...',\n        ],\n        'delegators' => [\n            'ApiResourceMiddleware' => [\n                'ApiResourcePipelineDelegatorFactory',\n            ],\n        ],\n    ],\n];  This approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.",
            "title": "Resolving to a MiddlewarePipe"
        },
        {
            "location": "/v2/cookbook/route-specific-pipeline/#middleware-arrays",
            "text": "If you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares in your configuration or when routing manually.  Via configuration looks like this:  return [\n    'routes' => [\n        [\n            'name' => 'api-resource',\n            'path' => '/api/resource[/{id:[a-f0-9]{32}}]',\n            'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'],\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n                'ApiResourceMiddleware',\n            ],\n        ],\n    ],\n];  Manual routing looks like this:  $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    'AuthenticationMiddleware',\n    'AuthorizationMiddleware',\n    'BodyParsingMiddleware',\n    'ValidationMiddleware',\n    'ApiResourceMiddleware',\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');  When either of these approaches are used, the individual middleware listed MUST  be one of the following:   an instance of  Interop\\Http\\ServerMiddleware\\MiddlewareInterface ;  a callable middleware (will be decorated as interop middleware);  a service name of middleware available in the container;  a fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.   This approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.",
            "title": "Middleware Arrays"
        },
        {
            "location": "/v2/cookbook/route-specific-pipeline/#what-about-pipeline-middleware-configuration",
            "text": "What if you want to do this with your pipeline middleware configuration? The\nanswer is that the syntax is exactly the same!  return [\n    'middleware_pipeline' => [\n        'api' => [\n            'path' => '/api',\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n            ],\n            'priority' => 100,\n        ],\n    ],\n];",
            "title": "What about pipeline middleware configuration?"
        },
        {
            "location": "/v2/cookbook/using-custom-view-helpers/",
            "text": "How do you register custom view helpers when using zend-view?\n\n\nIf you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?\n\n\nAssuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for \nZend\\View\\HelperPluginManager\n, and it will\nbe injected into the \nPhpRenderer\n instance used. Since the \nHelperPluginManager\n\nis available, we can configure it.\n\n\nOpen the file \nconfig/autoload/templates.global.php\n. In that file, you'll see\nthree top-level keys:\n\n\nreturn [\n    'dependencies' => [ /* ... */ ],\n    'templates' => [ /* ... */ ],\n    'view_helpers' => [ /* ... */ ],\n];\n\n\n\nThe last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created.\n\nSee the zend-view custom helpers documentation\n\nfor information on how to populate this configuration.",
            "title": "Registering custom view helpers when using zend-view"
        },
        {
            "location": "/v2/cookbook/using-custom-view-helpers/#how-do-you-register-custom-view-helpers-when-using-zend-view",
            "text": "If you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?  Assuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for  Zend\\View\\HelperPluginManager , and it will\nbe injected into the  PhpRenderer  instance used. Since the  HelperPluginManager \nis available, we can configure it.  Open the file  config/autoload/templates.global.php . In that file, you'll see\nthree top-level keys:  return [\n    'dependencies' => [ /* ... */ ],\n    'templates' => [ /* ... */ ],\n    'view_helpers' => [ /* ... */ ],\n];  The last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created. See the zend-view custom helpers documentation \nfor information on how to populate this configuration.",
            "title": "How do you register custom view helpers when using zend-view?"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/",
            "text": "How can I use zend-form view helpers?\n\n\nIf you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:\n\n\n\n\nzend-form\n\n\nzend-i18n\n\n\nzend-navigation\n\n\n\n\nBy default, only the view helpers directly available in zend-view are available;\nhow can you add the others?\n\n\nConfigProvider\n\n\nWhen you install zend-form, Composer should prompt you if you want to inject one\nor more \nConfigProvider\n classes, including those from zend-hydrator,\nzend-inputfilter, and several others. Always answer \"yes\" to these; when you do,\na Composer plugin will add entries for their \nConfigProvider\n classes to your\n\nconfig/config.php\n file.\n\n\nIf for some reason you are not prompted, or chose \"no\" when answering the\nprompts, you can add them manually. Add the following entries in the array used\nto create your \nConfigAggregator\n instance within \nconfig/config.php\n:\n\n\n    \\Zend\\Form\\ConfigProvider::class,\n    \\Zend\\InputFilter\\ConfigProvider::class,\n    \\Zend\\Filter\\ConfigProvider::class,\n    \\Zend\\Validator\\ConfigProvider::class,\n    \\Zend\\Hydrator\\ConfigProvider::class,\n\n\n\nIf you installed Expressive via the skeleton, the service\n\nZend\\View\\HelperPluginManager\n is registered for you, and represents the helper\nplugin manager injected into the \nPhpRenderer\n instance. This instance gets its\nhelper configuration from the \nview_helpers\n top-level configuration key \u2014\nwhich the zend-form \nConfigProvider\n helps to populate!\n\n\nAt this point, all view helpers provided by zend-form are registered and ready\nto use.\n\n\nAlternative options to configure HelperPluginManager:\n\n\n\n\nReplace the \nHelperPluginManager\n factory with your own; or\n\n\nAdd a delegator factory to or extend the \nHelperPluginManager\n service to\n  inject the additional helper configuration; or\n\n\nAdd pipeline middleware that composes the \nHelperPluginManager\n and configures\n  it.\n\n\n\n\nReplacing the HelperPluginManager factory\n\n\nThe zend-view integration provides \nZend\\Expressive\\ZendView\\HelperPluginManagerFactory\n,\nand the Expressive skeleton registers it be default. The simplest solution for\nadding other helpers is to replace it with your own. In your own factory, you\nwill \nalso\n configure the plugin manager with the configuration from the\nzend-form component (or whichever other components you wish to use).\n\n\nnamespace Your\\Application;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\View\\HelperPluginManager;\n\nclass HelperPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $manager = new HelperPluginManager($container);\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = isset($config['view_helpers']) ? $config['view_helpers'] : [];\n        (new Config($config))->configureServiceManager($manager);\n\n        return $manager;\n    }\n}\n\n\n\nIn your \nconfig/autoload/templates.global.php\n file, change the line that reads:\n\n\nZend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class,\n\n\n\nto instead read as:\n\n\nZend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class,\n\n\n\nThis approach will work for any of the various containers supported.\n\n\nDelegator factories/service extension\n\n\nDelegator factories\n\nand \nservice extension\n\noperate on the same principle: they intercept after the original factory was\ncalled, and then operate on the generated instance, either modifying or\nreplacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the\ntime of writing, we're unaware of a mechanism for doing so in Aura.Di.\n\n\nzend-servicemanager\n\n\nYou'll first need to create a delegator factory:\n\n\nnamespace Your\\Application;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FormHelpersDelegatorFactory\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $helpers = $callback();\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = new Config($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}\n\n\n\nThe above creates an instance of \nZend\\ServiceManager\\Config\n, uses it to\nconfigure the already created \nZend\\View\\HelperPluginManager\n instance, and then\nreturns the plugin manager instance.\n\n\nFrom here, you'll add a \ndelegators\n configuration key in your\n\nconfig/autoload/templates.global.php\n file:\n\n\nreturn [\n    'dependencies' => [\n        'delegators' => [\n            Zend\\View\\HelperPluginManager::class => [\n                Your\\Application\\FormHelpersDelegatorFactory::class,\n            ],\n        ],\n        /* ... */\n    ],\n    'templates' => [\n        /* ... */\n    ],\n    'view_helpers' => [\n        /* ... */\n    ],\n];\n\n\n\nNote: delegator factories are keyed by the service they modify, and the value is\nan \narray\n of delegator factories, to allow multiple such factories to be in\nuse.\n\n\nPimple\n\n\nFor Pimple, we don't currently support configuration of service extensions, so\nyou'll need to edit the main container configuration file,\n\nconfig/container.php\n. Place the following anywhere after the factories and\ninvokables are defined:\n\n\n// The following assumes you've added the following import statements to\n// the start of the file:\n// use Zend\\ServiceManager\\Config as ServiceConfig;\n// use Zend\\View\\HelperPluginManager;\n$container[HelperPluginManager::class] = $container->extend(\n    HelperPluginManager::class,\n    function ($helpers, $container) {\n        $config = isset($container['config']) ? $container['config'] : [];\n        $config = new ServiceConfig($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n);\n\n\n\nPipeline middleware\n\n\nAnother option is to use pipeline middleware. This approach will\nrequire that the middleware execute on every request, which introduces (very\nslight) performance overhead. However, it's a portable method that works\nregardless of the container implementation you choose.\n\n\nFirst, define the middleware:\n\n\nnamespace Your\\Application\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Form\\View\\HelperConfig as FormHelperConfig;\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddleware implements MiddlewareInterface\n{\n    private $helpers;\n\n    public function __construct(HelperPluginManager $helpers)\n    {\n        $this->helpers = $helpers;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $config = new FormHelperConfig();\n        $config->configureServiceManager($this->helpers);\n        return $delegate->process($request);\n    }\n}\n\n\n\nYou'll also need a factory for the middleware, to ensure it receives the\n\nHelperPluginManager\n:\n\n\nnamespace Your\\Application\n\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return new FormHelpersMiddleware(\n            $container->get(HelperPluginManager::class)\n        );\n    }\n}\n\n\n\nNext, register the middleware with its factory in one of\n\nconfig/autoload/middleware-pipeline.global.php\n or\n\nconfig/autoload/dependencies.global.php\n:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIf using programmatic pipelines, pipe the middleware in an appropriate location\nin your pipeline:\n\n\n$app->pipe(FormHelpersMiddleware::class);\n\n// or, perhaps, in a route-specific middleware pipeline:\n$app->post('/register', [\n    FormHelpersMiddleware::class,\n    RegisterMiddleware::class,\n], 'register');\n\n\n\nIf using configuration-driven pipelines or routing:\n\n\n// Via the middleware pipeline:\n'middleware_pipeline' => [\n    ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000],\n],\n\n// Or via routes:\n'routes' => [\n    [\n        'name'            => 'register',\n        'path'            => '/register',\n        'middleware'      => [\n            FormHelpersMiddleware::class,\n            RegisterMiddleware::class,\n        ],\n        'allowed_methods' => ['POST'],\n    ]\n]\n\n\n\nAt that point, you're all set!\n\n\nRegistering more helpers\n\n\nWhat if you need to register helpers from multiple components?\n\n\nYou can do so using the same technique above. Better yet, do them all at once!\n\n\n\n\nIf you chose to use delegator factories/service extension, do all helper\n  configuration registrations for all components in the same factory.\n\n\nIf you chose to use middleware, do all helper configuration registrations for\n  all components in the same middleware.",
            "title": "Using zend-form view helpers"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/#how-can-i-use-zend-form-view-helpers",
            "text": "If you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:   zend-form  zend-i18n  zend-navigation   By default, only the view helpers directly available in zend-view are available;\nhow can you add the others?",
            "title": "How can I use zend-form view helpers?"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/#configprovider",
            "text": "When you install zend-form, Composer should prompt you if you want to inject one\nor more  ConfigProvider  classes, including those from zend-hydrator,\nzend-inputfilter, and several others. Always answer \"yes\" to these; when you do,\na Composer plugin will add entries for their  ConfigProvider  classes to your config/config.php  file.  If for some reason you are not prompted, or chose \"no\" when answering the\nprompts, you can add them manually. Add the following entries in the array used\nto create your  ConfigAggregator  instance within  config/config.php :      \\Zend\\Form\\ConfigProvider::class,\n    \\Zend\\InputFilter\\ConfigProvider::class,\n    \\Zend\\Filter\\ConfigProvider::class,\n    \\Zend\\Validator\\ConfigProvider::class,\n    \\Zend\\Hydrator\\ConfigProvider::class,  If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager  is registered for you, and represents the helper\nplugin manager injected into the  PhpRenderer  instance. This instance gets its\nhelper configuration from the  view_helpers  top-level configuration key \u2014\nwhich the zend-form  ConfigProvider  helps to populate!  At this point, all view helpers provided by zend-form are registered and ready\nto use.  Alternative options to configure HelperPluginManager:   Replace the  HelperPluginManager  factory with your own; or  Add a delegator factory to or extend the  HelperPluginManager  service to\n  inject the additional helper configuration; or  Add pipeline middleware that composes the  HelperPluginManager  and configures\n  it.",
            "title": "ConfigProvider"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/#replacing-the-helperpluginmanager-factory",
            "text": "The zend-view integration provides  Zend\\Expressive\\ZendView\\HelperPluginManagerFactory ,\nand the Expressive skeleton registers it be default. The simplest solution for\nadding other helpers is to replace it with your own. In your own factory, you\nwill  also  configure the plugin manager with the configuration from the\nzend-form component (or whichever other components you wish to use).  namespace Your\\Application;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\View\\HelperPluginManager;\n\nclass HelperPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $manager = new HelperPluginManager($container);\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = isset($config['view_helpers']) ? $config['view_helpers'] : [];\n        (new Config($config))->configureServiceManager($manager);\n\n        return $manager;\n    }\n}  In your  config/autoload/templates.global.php  file, change the line that reads:  Zend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class,  to instead read as:  Zend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class,  This approach will work for any of the various containers supported.",
            "title": "Replacing the HelperPluginManager factory"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/#delegator-factoriesservice-extension",
            "text": "Delegator factories \nand  service extension \noperate on the same principle: they intercept after the original factory was\ncalled, and then operate on the generated instance, either modifying or\nreplacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the\ntime of writing, we're unaware of a mechanism for doing so in Aura.Di.",
            "title": "Delegator factories/service extension"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/#zend-servicemanager",
            "text": "You'll first need to create a delegator factory:  namespace Your\\Application;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FormHelpersDelegatorFactory\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $helpers = $callback();\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = new Config($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}  The above creates an instance of  Zend\\ServiceManager\\Config , uses it to\nconfigure the already created  Zend\\View\\HelperPluginManager  instance, and then\nreturns the plugin manager instance.  From here, you'll add a  delegators  configuration key in your config/autoload/templates.global.php  file:  return [\n    'dependencies' => [\n        'delegators' => [\n            Zend\\View\\HelperPluginManager::class => [\n                Your\\Application\\FormHelpersDelegatorFactory::class,\n            ],\n        ],\n        /* ... */\n    ],\n    'templates' => [\n        /* ... */\n    ],\n    'view_helpers' => [\n        /* ... */\n    ],\n];  Note: delegator factories are keyed by the service they modify, and the value is\nan  array  of delegator factories, to allow multiple such factories to be in\nuse.",
            "title": "zend-servicemanager"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/#pimple",
            "text": "For Pimple, we don't currently support configuration of service extensions, so\nyou'll need to edit the main container configuration file, config/container.php . Place the following anywhere after the factories and\ninvokables are defined:  // The following assumes you've added the following import statements to\n// the start of the file:\n// use Zend\\ServiceManager\\Config as ServiceConfig;\n// use Zend\\View\\HelperPluginManager;\n$container[HelperPluginManager::class] = $container->extend(\n    HelperPluginManager::class,\n    function ($helpers, $container) {\n        $config = isset($container['config']) ? $container['config'] : [];\n        $config = new ServiceConfig($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n);",
            "title": "Pimple"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/#pipeline-middleware",
            "text": "Another option is to use pipeline middleware. This approach will\nrequire that the middleware execute on every request, which introduces (very\nslight) performance overhead. However, it's a portable method that works\nregardless of the container implementation you choose.  First, define the middleware:  namespace Your\\Application\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Form\\View\\HelperConfig as FormHelperConfig;\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddleware implements MiddlewareInterface\n{\n    private $helpers;\n\n    public function __construct(HelperPluginManager $helpers)\n    {\n        $this->helpers = $helpers;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $config = new FormHelperConfig();\n        $config->configureServiceManager($this->helpers);\n        return $delegate->process($request);\n    }\n}  You'll also need a factory for the middleware, to ensure it receives the HelperPluginManager :  namespace Your\\Application\n\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return new FormHelpersMiddleware(\n            $container->get(HelperPluginManager::class)\n        );\n    }\n}  Next, register the middleware with its factory in one of config/autoload/middleware-pipeline.global.php  or config/autoload/dependencies.global.php :  return [\n    'dependencies' => [\n        'factories' => [\n            Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  If using programmatic pipelines, pipe the middleware in an appropriate location\nin your pipeline:  $app->pipe(FormHelpersMiddleware::class);\n\n// or, perhaps, in a route-specific middleware pipeline:\n$app->post('/register', [\n    FormHelpersMiddleware::class,\n    RegisterMiddleware::class,\n], 'register');  If using configuration-driven pipelines or routing:  // Via the middleware pipeline:\n'middleware_pipeline' => [\n    ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000],\n],\n\n// Or via routes:\n'routes' => [\n    [\n        'name'            => 'register',\n        'path'            => '/register',\n        'middleware'      => [\n            FormHelpersMiddleware::class,\n            RegisterMiddleware::class,\n        ],\n        'allowed_methods' => ['POST'],\n    ]\n]  At that point, you're all set!",
            "title": "Pipeline middleware"
        },
        {
            "location": "/v2/cookbook/using-zend-form-view-helpers/#registering-more-helpers",
            "text": "What if you need to register helpers from multiple components?  You can do so using the same technique above. Better yet, do them all at once!   If you chose to use delegator factories/service extension, do all helper\n  configuration registrations for all components in the same factory.  If you chose to use middleware, do all helper configuration registrations for\n  all components in the same middleware.",
            "title": "Registering more helpers"
        },
        {
            "location": "/v2/cookbook/using-a-base-path/",
            "text": "How can I tell my application about a base path?\n\n\nIn some environments, your application may be running in a subdirectory of your\nweb root. For example:\n\n\nvar/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php\n\n\n\nwhere \n/var/www\n is the web root, and your Expressive application is in the\n\nexpressive/\n subdirectory. How can you make your application work correctly in\nthis environment?\n\n\n.htaccess in the application root.\n\n\nIf you are using Apache, your first step is to add an \n.htaccess\n file to your\napplication root, with directives for rewriting to the \npublic/\n directory:\n\n\nRewriteEngine On\nRewriteRule (.*) ./public/$1\n\n\n\n\n\nUsing other web servers\n\n\nIf you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to\n\nour issue tracker\n!\n\n\n\n\nUse middleware to rewrite the path\n\n\nThe above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!\n\n\nTo do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.\n\n\nAt the time of writing, we have two suggestions:\n\n\n\n\nlos/basepath\n provides the basic\n  mechanics of rewriting the URL, and has a stable release.\n\n\nmtymek/blast-base-url\n provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path, but does not have a stable release yet.\n\n\n\n\nlos/basepath\n\n\nTo use \nlos/basepath\n, install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.\n\n\nTo install and copy the configuration:\n\n\n$ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php\n\n\n\nWe recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):\n\n\n$ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php\n\n\n\nThen edit one or both, to change the \nlos_basepath\n settings:\n\n\nreturn [\n    'los_basepath' => '<base path here>',\n    /* ... */\n];\n\n\n\nThe base path should be the portion of the web root leading up to the\n\nindex.php\n of your application. In the above example, this would be\n\n/expressive\n.\n\n\nmtymek/blast-base-url\n\n\nTo use \nmtymek/blast-base-url\n, install it via Composer, and register some\nconfiguration.\n\n\nTo install it:\n\n\n$ composer require mtymek/blast-base-url\n\n\n\nTo configure it, update the file \nconfig/autoload/middleware-pipeline.global.php\n,\nor \nconfig/autoload/dependencies.global.php\n to map the middleware to its factory:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Blast\\BaseUrl\\BaseUrlMiddleware::class => Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIf using programmatic pipelines, pipe the middleware early in your pipeline:\n\n\n$app->pipe(\\Blast\\BaseUrl\\BaseUrlMiddleware::class);\n\n\n\nFor configuration-driven pipelines, add an entry in your\n\nconfig/autoload/middleware-pipeline.global.php\n file:\n\n\n'middleware_pipeline' => [\n    ['middleware' => [Blast\\BaseUrl\\BaseUrlMiddleware::class], 'priority' => 1000],\n    /* ... */\n],\n\n\n\nAt this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.\n\n\nThe primary advantage of \nmtymek/blast-base-url\n is in its additional features:\n\n\n\n\nit injects \nZend\\Expressive\\Helper\\UrlHelper\n with the base path, allowing you\n  to create relative route-based URLs.\n\n\nit provides a new helper, \nBlast\\BaseUrl\\BasePathHelper\n, which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.\n\n\n\n\nTo enable these features, we'll add some configuration to\n\nconfig/autoload/dependencies.global.php\n file:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Blast\\BaseUrl\\BasePathHelper::class => Blast\\BaseUrl\\BasePathHelper::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nFinally, if you're using zend-view, you can register a new \"basePath\" helper in\nyour \nconfig/autoload/templates.global.php\n:\n\n\nreturn [\n    /* ... */\n    'view_helpers' => [\n        'factories' => [\n            'basePath' => Blast\\BaseUrl\\BasePathViewHelperFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nUsage of the \nBasePath\n helper is as follows:\n\n\n// where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this->basePath('/icons/favicon.ico');",
            "title": "Using Expressive from a subdirectory"
        },
        {
            "location": "/v2/cookbook/using-a-base-path/#how-can-i-tell-my-application-about-a-base-path",
            "text": "In some environments, your application may be running in a subdirectory of your\nweb root. For example:  var/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php  where  /var/www  is the web root, and your Expressive application is in the expressive/  subdirectory. How can you make your application work correctly in\nthis environment?",
            "title": "How can I tell my application about a base path?"
        },
        {
            "location": "/v2/cookbook/using-a-base-path/#htaccess-in-the-application-root",
            "text": "If you are using Apache, your first step is to add an  .htaccess  file to your\napplication root, with directives for rewriting to the  public/  directory:  RewriteEngine On\nRewriteRule (.*) ./public/$1",
            "title": ".htaccess in the application root."
        },
        {
            "location": "/v2/cookbook/using-a-base-path/#using-other-web-servers",
            "text": "If you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to our issue tracker !",
            "title": "Using other web servers"
        },
        {
            "location": "/v2/cookbook/using-a-base-path/#use-middleware-to-rewrite-the-path",
            "text": "The above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!  To do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.  At the time of writing, we have two suggestions:   los/basepath  provides the basic\n  mechanics of rewriting the URL, and has a stable release.  mtymek/blast-base-url  provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path, but does not have a stable release yet.",
            "title": "Use middleware to rewrite the path"
        },
        {
            "location": "/v2/cookbook/using-a-base-path/#losbasepath",
            "text": "To use  los/basepath , install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.  To install and copy the configuration:  $ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php  We recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):  $ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php  Then edit one or both, to change the  los_basepath  settings:  return [\n    'los_basepath' => '<base path here>',\n    /* ... */\n];  The base path should be the portion of the web root leading up to the index.php  of your application. In the above example, this would be /expressive .",
            "title": "los/basepath"
        },
        {
            "location": "/v2/cookbook/using-a-base-path/#mtymekblast-base-url",
            "text": "To use  mtymek/blast-base-url , install it via Composer, and register some\nconfiguration.  To install it:  $ composer require mtymek/blast-base-url  To configure it, update the file  config/autoload/middleware-pipeline.global.php ,\nor  config/autoload/dependencies.global.php  to map the middleware to its factory:  return [\n    'dependencies' => [\n        'factories' => [\n            Blast\\BaseUrl\\BaseUrlMiddleware::class => Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  If using programmatic pipelines, pipe the middleware early in your pipeline:  $app->pipe(\\Blast\\BaseUrl\\BaseUrlMiddleware::class);  For configuration-driven pipelines, add an entry in your config/autoload/middleware-pipeline.global.php  file:  'middleware_pipeline' => [\n    ['middleware' => [Blast\\BaseUrl\\BaseUrlMiddleware::class], 'priority' => 1000],\n    /* ... */\n],  At this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.  The primary advantage of  mtymek/blast-base-url  is in its additional features:   it injects  Zend\\Expressive\\Helper\\UrlHelper  with the base path, allowing you\n  to create relative route-based URLs.  it provides a new helper,  Blast\\BaseUrl\\BasePathHelper , which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.   To enable these features, we'll add some configuration to config/autoload/dependencies.global.php  file:  return [\n    'dependencies' => [\n        'invokables' => [\n            Blast\\BaseUrl\\BasePathHelper::class => Blast\\BaseUrl\\BasePathHelper::class,\n            /* ... */\n        ],\n    ],\n];  Finally, if you're using zend-view, you can register a new \"basePath\" helper in\nyour  config/autoload/templates.global.php :  return [\n    /* ... */\n    'view_helpers' => [\n        'factories' => [\n            'basePath' => Blast\\BaseUrl\\BasePathViewHelperFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Usage of the  BasePath  helper is as follows:  // where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this->basePath('/icons/favicon.ico');",
            "title": "mtymek/blast-base-url"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/",
            "text": "How can I setup the locale depending on a routing parameter?\n\n\nLocalized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.\n\n\n\n\nRouting parameters\n\n\nUsing the approach in this chapter requires that you add a \n/:locale\n (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non \nsetting the locale without routing parameters\n.\n\n\n\n\nSetting up the route\n\n\nIf you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.\n\n\nIn the following examples, we use the \nlocale\n parameter, which should consist\nof two lowercase alphabetical characters.\n\n\nDependency configuration\n\n\nThe examples assume the following middleware dependency configuration:\n\n\nuse Application\\Action;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Action\\HomePageAction::class    => Action\\HomePageFactory::class,\n            Action\\ContactPageAction::class => Action\\ContactPageFactory::class,\n        ],\n    ],\n];\n\n\n\nProgrammatic routes\n\n\nThe following describes routing configuration for use when using a\nprogrammatic application.\n\n\nuse Application\\Action\\ContactPageAction;\nuse Application\\Action\\HomePageAction;\n\n$localeOptions = ['locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)'];\n\n$app->get('/:locale', HomePageAction::class, 'home')\n    ->setOptions($localeOptions);\n$app->get('/:locale/contact', ContactPageAction::class, 'contact')\n    ->setOptions($localeOptions);\n\n\n\nConfiguration-based routes\n\n\nThe following describes routing configuration for use when using a\nconfiguration-driven application.\n\n\nreturn [\n    'routes' => [\n        [\n            'name' => 'home',\n            'path' => '/:locale',\n            'middleware' => Application\\Action\\HomePageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n        [\n            'name' => 'contact',\n            'path' => '/:locale/contact',\n            'middleware' => Application\\Action\\ContactPageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nNote: Routing may differ based on router\n\n\nThe routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.\n\n\nFor Aura.Router, the 'home' route as listed above would read:\n\n\n[\n    'name' => 'home',\n    'path' => '/{locale}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n    'options'         => [\n        'constraints' => [\n            'tokens' => [\n                'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n            ],\n        ],\n    ],\n]\n\n\n\nFor FastRoute:\n\n\n[\n    'name' => 'home',\n    'path' => '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n]\n\n\n\nAs such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.\n\n\n\n\nCreate a route result middleware class for localization\n\n\nTo make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.\n\n\nSuch a \nLocalizationMiddleware\n class could look similar to this:\n\n\n<?php\n\nnamespace Application\\I18n;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass LocalizationMiddleware implements MiddlewareInterface\n{\n    const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request->getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $delegate->process($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale));\n    }\n}\n\n\n\n\n\nLocale::setDefault is unsafe\n\n\nDo not use \nLocale::setDefault($locale)\n to set a global static locale.\nPSR-7 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.\n\n\nUse a request parameter as detailed above instead, as the request is created\nspecific to each process.\n\n\n\n\nRegister this new middleware in either \nconfig/autoload/middleware-pipeline.global.php\n\nor \nconfig/autoload/dependencies.global.php\n:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            LocalizationMiddleware::class => LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIf using a programmatic pipeline, pipe it immediately after your routing middleware:\n\n\nuse Application\\I18n\\LocalizationMiddleware;\n\n/* ... */\n$app->pipeRoutingMiddleware();\n$app->pipe(LocalizationMiddleware::class);\n/* ... */\n\n\n\nIf using a configuration-driven application, register it within your\n\nconfig/autoload/middleware-pipeline.global.php\n file, injecting it\ninto the pipeline following the routing middleware:\n\n\nreturn [\n    'middleware_pipeline' => [\n        /* ... */\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                LocalizationMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];",
            "title": "Setting a locale based on a routing parameter"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#how-can-i-setup-the-locale-depending-on-a-routing-parameter",
            "text": "Localized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.",
            "title": "How can I setup the locale depending on a routing parameter?"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#routing-parameters",
            "text": "Using the approach in this chapter requires that you add a  /:locale  (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non  setting the locale without routing parameters .",
            "title": "Routing parameters"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#setting-up-the-route",
            "text": "If you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.  In the following examples, we use the  locale  parameter, which should consist\nof two lowercase alphabetical characters.",
            "title": "Setting up the route"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#dependency-configuration",
            "text": "The examples assume the following middleware dependency configuration:  use Application\\Action;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Action\\HomePageAction::class    => Action\\HomePageFactory::class,\n            Action\\ContactPageAction::class => Action\\ContactPageFactory::class,\n        ],\n    ],\n];",
            "title": "Dependency configuration"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#programmatic-routes",
            "text": "The following describes routing configuration for use when using a\nprogrammatic application.  use Application\\Action\\ContactPageAction;\nuse Application\\Action\\HomePageAction;\n\n$localeOptions = ['locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)'];\n\n$app->get('/:locale', HomePageAction::class, 'home')\n    ->setOptions($localeOptions);\n$app->get('/:locale/contact', ContactPageAction::class, 'contact')\n    ->setOptions($localeOptions);",
            "title": "Programmatic routes"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#configuration-based-routes",
            "text": "The following describes routing configuration for use when using a\nconfiguration-driven application.  return [\n    'routes' => [\n        [\n            'name' => 'home',\n            'path' => '/:locale',\n            'middleware' => Application\\Action\\HomePageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n        [\n            'name' => 'contact',\n            'path' => '/:locale/contact',\n            'middleware' => Application\\Action\\ContactPageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Configuration-based routes"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#note-routing-may-differ-based-on-router",
            "text": "The routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.  For Aura.Router, the 'home' route as listed above would read:  [\n    'name' => 'home',\n    'path' => '/{locale}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n    'options'         => [\n        'constraints' => [\n            'tokens' => [\n                'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n            ],\n        ],\n    ],\n]  For FastRoute:  [\n    'name' => 'home',\n    'path' => '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n]  As such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.",
            "title": "Note: Routing may differ based on router"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#create-a-route-result-middleware-class-for-localization",
            "text": "To make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.  Such a  LocalizationMiddleware  class could look similar to this:  <?php\n\nnamespace Application\\I18n;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass LocalizationMiddleware implements MiddlewareInterface\n{\n    const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request->getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] ?? 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $delegate->process($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale));\n    }\n}",
            "title": "Create a route result middleware class for localization"
        },
        {
            "location": "/v2/cookbook/setting-locale-depending-routing-parameter/#localesetdefault-is-unsafe",
            "text": "Do not use  Locale::setDefault($locale)  to set a global static locale.\nPSR-7 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.  Use a request parameter as detailed above instead, as the request is created\nspecific to each process.   Register this new middleware in either  config/autoload/middleware-pipeline.global.php \nor  config/autoload/dependencies.global.php :  return [\n    'dependencies' => [\n        'invokables' => [\n            LocalizationMiddleware::class => LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  If using a programmatic pipeline, pipe it immediately after your routing middleware:  use Application\\I18n\\LocalizationMiddleware;\n\n/* ... */\n$app->pipeRoutingMiddleware();\n$app->pipe(LocalizationMiddleware::class);\n/* ... */  If using a configuration-driven application, register it within your config/autoload/middleware-pipeline.global.php  file, injecting it\ninto the pipeline following the routing middleware:  return [\n    'middleware_pipeline' => [\n        /* ... */\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                LocalizationMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];",
            "title": "Locale::setDefault is unsafe"
        },
        {
            "location": "/v2/cookbook/setting-locale-without-routing-parameter/",
            "text": "How can I setup the locale without routing parameters?\n\n\nLocalized web applications often set the locale (and therefore the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.\n\n\n\n\nDistinguishing between routes that require localization\n\n\nIf your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the\n\n\"Setting a locale based on a routing parameter\" recipe\n.\n\n\n\n\nSetup a middleware to extract the locale from the URI\n\n\nFirst, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If if doesn't find one, it sets a default.\n\n\nIf it does find one, it uses the value to setup the locale. It also:\n\n\n\n\namends the request with a truncated path (removing the locale segment).\n\n\nadds the locale segment as the base path of the \nUrlHelper\n.\n\n\n\n\n<?php\nnamespace Application\\I18n;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $uri = $request->getUri();\n\n        $path = $uri->getPath();\n\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            Locale::setDefault('de_DE');\n            return $delegate->process($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $delegate->process($request->withUri(\n            $uri->withPath(substr($path, strlen($locale)+1))\n        ));\n    }\n}\n\n\n\nThen you will need a factory for the \nSetLocaleMiddleware\n to inject the\n\nUrlHelper\n instance.\n\n\n<?php\nnamespace Application\\I18n;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SetLocaleMiddleware(\n            $container->get(UrlHelper::class)\n        );\n    }\n}\n\n\n\nNext, map the middleware to its factory in either\n\n/config/autoload/dependencies.global.php\n or\n\n/config/autoload/middleware-pipeline.global.php\n:\n\n\nuse Application\\I18n\\SetLocaleMiddleware;\nuse Application\\I18n\\SetLocaleMiddlewareFactory;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nFinally, you will need to configure your middleware pipeline to ensure this\nmiddleware is executed on every request.\n\n\nIf using a programmatic pipeline:\n\n\nuse Application\\I18n\\SetLocaleMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n/* ... */\n$app->pipe(SetLocaleMiddleware::class);\n/* ... */\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n/* ... */\n\n\n\nIf using a configuration-driven application, update\n\n/config/autoload/middleware-pipeline.global.php\n to add the middleware:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [\n            'middleware' => [\n                Application\\I18n\\SetLocaleMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 1000,\n        ],\n\n        /* ... */\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        /* ... */\n    ],\n];\n\n\n\nUrl generation in the view\n\n\nSince the \nUrlHelper\n has the locale set as a base path, you don't need\nto worry about generating URLs within your view. Just use the helper to\ngenerate a URL and it will do the rest.\n\n\n<?php echo $this->url('your-route') ?>\n\n\n\n\n\nHelpers differ between template renderers\n\n\nThe above example is specific to zend-view; syntax will differ for\nTwig and Plates.\n\n\n\n\nRedirecting within your middleware\n\n\nIf you want to add the locale parameter when creating URIs within your\naction middleware, you just need to inject the \nUrlHelper\n into your\nmiddleware and use it for URL generation:\n\n\n<?php\nnamespace Application\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectAction implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param DelegateInterface      $delegate\n     * @return RedirectResponse\n     */\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this->helper->generate('your-route', $routeParams)\n        );\n    }\n}\n\n\n\nInjecting the \nUrlHelper\n into your middleware will also require that the\nmiddleware have a factory that manages the injection. As an example, the\nfollowing would work for the above middleware:\n\n\nnamespace Application\\Action;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectAction(\n            $container->get(UrlHelper::class)\n        );\n    }\n}",
            "title": "Setting a locale without a routing parameter"
        },
        {
            "location": "/v2/cookbook/setting-locale-without-routing-parameter/#how-can-i-setup-the-locale-without-routing-parameters",
            "text": "Localized web applications often set the locale (and therefore the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.",
            "title": "How can I setup the locale without routing parameters?"
        },
        {
            "location": "/v2/cookbook/setting-locale-without-routing-parameter/#distinguishing-between-routes-that-require-localization",
            "text": "If your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the \"Setting a locale based on a routing parameter\" recipe .",
            "title": "Distinguishing between routes that require localization"
        },
        {
            "location": "/v2/cookbook/setting-locale-without-routing-parameter/#setup-a-middleware-to-extract-the-locale-from-the-uri",
            "text": "First, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If if doesn't find one, it sets a default.  If it does find one, it uses the value to setup the locale. It also:   amends the request with a truncated path (removing the locale segment).  adds the locale segment as the base path of the  UrlHelper .   <?php\nnamespace Application\\I18n;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Locale;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $uri = $request->getUri();\n\n        $path = $uri->getPath();\n\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            Locale::setDefault('de_DE');\n            return $delegate->process($request);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $delegate->process($request->withUri(\n            $uri->withPath(substr($path, strlen($locale)+1))\n        ));\n    }\n}  Then you will need a factory for the  SetLocaleMiddleware  to inject the UrlHelper  instance.  <?php\nnamespace Application\\I18n;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SetLocaleMiddleware(\n            $container->get(UrlHelper::class)\n        );\n    }\n}  Next, map the middleware to its factory in either /config/autoload/dependencies.global.php  or /config/autoload/middleware-pipeline.global.php :  use Application\\I18n\\SetLocaleMiddleware;\nuse Application\\I18n\\SetLocaleMiddlewareFactory;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            SetLocaleMiddleware::class => SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ],\n];  Finally, you will need to configure your middleware pipeline to ensure this\nmiddleware is executed on every request.  If using a programmatic pipeline:  use Application\\I18n\\SetLocaleMiddleware;\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n/* ... */\n$app->pipe(SetLocaleMiddleware::class);\n/* ... */\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n/* ... */  If using a configuration-driven application, update /config/autoload/middleware-pipeline.global.php  to add the middleware:  return [\n    'middleware_pipeline' => [\n        [\n            'middleware' => [\n                Application\\I18n\\SetLocaleMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 1000,\n        ],\n\n        /* ... */\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        /* ... */\n    ],\n];",
            "title": "Setup a middleware to extract the locale from the URI"
        },
        {
            "location": "/v2/cookbook/setting-locale-without-routing-parameter/#url-generation-in-the-view",
            "text": "Since the  UrlHelper  has the locale set as a base path, you don't need\nto worry about generating URLs within your view. Just use the helper to\ngenerate a URL and it will do the rest.  <?php echo $this->url('your-route') ?>",
            "title": "Url generation in the view"
        },
        {
            "location": "/v2/cookbook/setting-locale-without-routing-parameter/#helpers-differ-between-template-renderers",
            "text": "The above example is specific to zend-view; syntax will differ for\nTwig and Plates.",
            "title": "Helpers differ between template renderers"
        },
        {
            "location": "/v2/cookbook/setting-locale-without-routing-parameter/#redirecting-within-your-middleware",
            "text": "If you want to add the locale parameter when creating URIs within your\naction middleware, you just need to inject the  UrlHelper  into your\nmiddleware and use it for URL generation:  <?php\nnamespace Application\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectAction implements MiddlewareInterface\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param DelegateInterface      $delegate\n     * @return RedirectResponse\n     */\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this->helper->generate('your-route', $routeParams)\n        );\n    }\n}  Injecting the  UrlHelper  into your middleware will also require that the\nmiddleware have a factory that manages the injection. As an example, the\nfollowing would work for the above middleware:  namespace Application\\Action;\n\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectAction(\n            $container->get(UrlHelper::class)\n        );\n    }\n}",
            "title": "Redirecting within your middleware"
        },
        {
            "location": "/v2/cookbook/debug-toolbars/",
            "text": "How can I get a debug toolbar for my Expressive application?\n\n\nMany modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?\n\n\nZend Server Z-Ray\n\n\nZend Server\n ships with a tool\ncalled \nZ-Ray\n, which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently \navailable as a standalone technology\npreview\n, and can be added\nas an extension to an existing PHP installation.\n\n\nWhen using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the\n\nZ-Ray documentation\n\nfor full usage details.\n\n\nbitExpert/prophiler-psr7-middleware\n\n\nAnother option is bitExpert's \nprophiler-psr7-middleware\n.\nThis package wraps \nfabfuel/prophiler\n,\nwhich provides a PHP-based profiling tool and toolbar; the bitExpert package\nwraps this in PSR-7 middleware to make consumption in those paradigms trivial.\n\n\nTo add the toolbar middleware to your application, use composer:\n\n\n$ composer require bitExpert/prophiler-psr7-middleware\n\n\n\nFrom there, you will need to create a factory for the middleware, and add it to\nyour middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written\na \npost detailing these steps\n.\n\n\n\n\nUse locally!\n\n\nOne minor change we recommend over the directions Stephan provides is that you\nconfigure the factory and middleware in the\n\nconfig/autoload/middleware-pipeline.local.php\n file, vs the \n.global\n version.\nDoing so enables the middleware and toolbar only in the local environment\n\u2014 and not in production, where you likely do not want to expose such\ninformation!\n\n\n\n\nphp-middleware/php-debug-bar\n\n\nphp-middleware/php-debug-bar\n\nprovides a PSR-7 middleware wrapper around \nmaximebf/php-debugbar\n,\na popular framework-agnostic debug bar for PHP projects.\n\n\nFirst, install the middleware in your application:\n\n\n$ composer require php-middleware/php-debug-bar\n\n\n\nThis package supplies a config provider, which could be added to your\n\nconfig/config.php\n when using zend-config-aggregator or\nexpressive-config-manager. However, because it should only be enabled in\ndevelopment, we recommend creating a \"local\" configuration file (e.g.,\n\nconfig/autoload/php-debugbar.local.php\n) when you need to enable it, with the\nfollowing contents:\n\n\n<?php\nuse PhpMiddleware\\PhpDebugBar\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();\n\n\n\n\n\nUse locally!\n\n\nRemember to enable \nPhpMiddleware\\PhpDebugBar\\ConfigProvider\n only in your\ndevelopment enviroments!",
            "title": "Enabling debug toolbars"
        },
        {
            "location": "/v2/cookbook/debug-toolbars/#how-can-i-get-a-debug-toolbar-for-my-expressive-application",
            "text": "Many modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?",
            "title": "How can I get a debug toolbar for my Expressive application?"
        },
        {
            "location": "/v2/cookbook/debug-toolbars/#zend-server-z-ray",
            "text": "Zend Server  ships with a tool\ncalled  Z-Ray , which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently  available as a standalone technology\npreview , and can be added\nas an extension to an existing PHP installation.  When using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the Z-Ray documentation \nfor full usage details.",
            "title": "Zend Server Z-Ray"
        },
        {
            "location": "/v2/cookbook/debug-toolbars/#bitexpertprophiler-psr7-middleware",
            "text": "Another option is bitExpert's  prophiler-psr7-middleware .\nThis package wraps  fabfuel/prophiler ,\nwhich provides a PHP-based profiling tool and toolbar; the bitExpert package\nwraps this in PSR-7 middleware to make consumption in those paradigms trivial.  To add the toolbar middleware to your application, use composer:  $ composer require bitExpert/prophiler-psr7-middleware  From there, you will need to create a factory for the middleware, and add it to\nyour middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written\na  post detailing these steps .",
            "title": "bitExpert/prophiler-psr7-middleware"
        },
        {
            "location": "/v2/cookbook/debug-toolbars/#use-locally",
            "text": "One minor change we recommend over the directions Stephan provides is that you\nconfigure the factory and middleware in the config/autoload/middleware-pipeline.local.php  file, vs the  .global  version.\nDoing so enables the middleware and toolbar only in the local environment\n\u2014 and not in production, where you likely do not want to expose such\ninformation!",
            "title": "Use locally!"
        },
        {
            "location": "/v2/cookbook/debug-toolbars/#php-middlewarephp-debug-bar",
            "text": "php-middleware/php-debug-bar \nprovides a PSR-7 middleware wrapper around  maximebf/php-debugbar ,\na popular framework-agnostic debug bar for PHP projects.  First, install the middleware in your application:  $ composer require php-middleware/php-debug-bar  This package supplies a config provider, which could be added to your config/config.php  when using zend-config-aggregator or\nexpressive-config-manager. However, because it should only be enabled in\ndevelopment, we recommend creating a \"local\" configuration file (e.g., config/autoload/php-debugbar.local.php ) when you need to enable it, with the\nfollowing contents:  <?php\nuse PhpMiddleware\\PhpDebugBar\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();",
            "title": "php-middleware/php-debug-bar"
        },
        {
            "location": "/v2/cookbook/debug-toolbars/#use-locally_1",
            "text": "Remember to enable  PhpMiddleware\\PhpDebugBar\\ConfigProvider  only in your\ndevelopment enviroments!",
            "title": "Use locally!"
        },
        {
            "location": "/v2/cookbook/using-routed-middleware-class-as-controller/",
            "text": "Handling multiple routes in a single class\n\n\nTypically, in Expressive, we would define one middleware class per route. For a\nstandard CRUD-style application, however, this leads to multiple related\nclasses:\n\n\n\n\nAlbumPageIndex\n\n\nAlbumPageEdit\n\n\nAlbumPageAdd\n\n\n\n\nIf you are familiar with frameworks that provide controllers capable of handling\nmultiple \"actions\", such as those found in Zend Framework's MVC layer, Symfony,\nCodeIgniter, CakePHP, and other popular frameworks, you may want to apply a\nsimilar pattern when using Expressive.\n\n\nIn other words, what if we want to use only one middleware class to facilitate\nall three of the above?\n\n\nIn the following example, we'll use an \naction\n routing parameter which our\nmiddleware class will use in order to determine which internal method to invoke.\n\n\nConsider the following route configuration:\n\n\nuse Album\\Action\\AlbumPage;\n\n// Programmatic:\n$app->get('/album[/{action:add|edit}[/{id}]]', AlbumPage::class, 'album');\n\n// Config-driven:\nreturn [\n    /* ... */\n    'routes' => [\n        /* ... */\n        [\n            'name'            => 'album',\n            'path'            => '/album[/{action:add|edit}[/{id}]]',\n            'middleware'      => AlbumPage::class,\n            'allowed_methods' => ['GET'],\n        ],\n        /* ... */\n    ],\n];\n\nThe above each define a route that will match any of the following:\n\n\n\n\n/album\n\n\n/album/add\n\n\n/album/edit/3\n\n\n\n\nThe \naction\n attribute can thus be one of \nadd\n or \nedit\n, and we can optionally\nalso receive an \nid\n attribute (in the latter example, it would be \n3\n).\n\n\n\n\nRouting definitions may vary\n\n\nDepending on the router you chose when starting your project, your routing\ndefinition may differ. The above example uses the default \nFastRoute\n\nimplementation.\n\n\n\n\nWe might then implement \nAlbum\\Action\\AlbumPage\n as follows:\n\n\n<?php\nnamespace Album\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage implements MiddlewareInterface\n{\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        switch ($request->getAttribute('action', 'index')) {\n            case 'index':\n                return $this->indexAction($request, $delegate);\n            case 'add':\n                return $this->addAction($request, $delegate);\n            case 'edit':\n                return $this->editAction($request, $delegate);\n            default:\n                // Invalid; thus, a 404!\n                return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n    }\n\n    public function indexAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new HtmlResponse($this->template->render('album::album-page'));\n    }\n\n    public function addAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new HtmlResponse($this->template->render('album::album-page-add'));\n    }\n\n    public function editAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new \\InvalidArgumentException('id parameter must be provided');\n        }\n\n        return new HtmlResponse(\n            $this->template->render('album::album-page-edit', ['id' => $id])\n        );\n    }\n}\n\n\n\nThis allows us to have the same dependencies for a set of related actions, and,\nif desired, even have common internal methods each can utilize.\n\n\nThis approach is reasonable, but requires that I create a similar \nprocess()\n\nimplementation every time I want to accomplish a similar workflow. Let's create\na generic implementation, via an \nAbstractPage\n class:\n\n\n<?php\nnamespace App\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\n\nabstract class AbstractPage implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n\n        return $this->$action($request, $delegate);\n    }\n}\n\n\n\nThe above abstract class pulls the \naction\n attribute on invocation, and\nconcatenates it with the word \nAction\n. It then uses this value to determine if\na corresponding method exists in the current class, and, if so, calls it with\nthe arguments it received; otherwise, it returns an empty 404 response.\n\n\nOur original \nAlbumPage\n implementation could then be modified to extend\n\nAbstractPage\n:\n\n\nnamespace Album\\Action;\n\nuse App\\Action\\AbstractPage;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage extends AbstractPage\n{\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}\n\n\n\n\n\nOr use a trait\n\n\nAs an alternative to an abstract class, you could define the \n__invoke()\n\nlogic in a trait, which you then compose into your middleware:\n\n\n<?php\nnamespace App\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\n\ntrait ActionBasedInvocation\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n\n        return $this->$action($request, $delegate);\n    }\n}\n\n\n\nYou would then compose it into a class as follows:\n\n\n<?php\nnamespace Album\\Action;\n\nuse App\\Action\\ActionBasedInvocation;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    use ActionBasedInvocation;\n\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Handling multiple routes in a single class"
        },
        {
            "location": "/v2/cookbook/using-routed-middleware-class-as-controller/#handling-multiple-routes-in-a-single-class",
            "text": "Typically, in Expressive, we would define one middleware class per route. For a\nstandard CRUD-style application, however, this leads to multiple related\nclasses:   AlbumPageIndex  AlbumPageEdit  AlbumPageAdd   If you are familiar with frameworks that provide controllers capable of handling\nmultiple \"actions\", such as those found in Zend Framework's MVC layer, Symfony,\nCodeIgniter, CakePHP, and other popular frameworks, you may want to apply a\nsimilar pattern when using Expressive.  In other words, what if we want to use only one middleware class to facilitate\nall three of the above?  In the following example, we'll use an  action  routing parameter which our\nmiddleware class will use in order to determine which internal method to invoke.  Consider the following route configuration:  use Album\\Action\\AlbumPage;\n\n// Programmatic:\n$app->get('/album[/{action:add|edit}[/{id}]]', AlbumPage::class, 'album');\n\n// Config-driven:\nreturn [\n    /* ... */\n    'routes' => [\n        /* ... */\n        [\n            'name'            => 'album',\n            'path'            => '/album[/{action:add|edit}[/{id}]]',\n            'middleware'      => AlbumPage::class,\n            'allowed_methods' => ['GET'],\n        ],\n        /* ... */\n    ],\n]; \nThe above each define a route that will match any of the following:   /album  /album/add  /album/edit/3   The  action  attribute can thus be one of  add  or  edit , and we can optionally\nalso receive an  id  attribute (in the latter example, it would be  3 ).",
            "title": "Handling multiple routes in a single class"
        },
        {
            "location": "/v2/cookbook/using-routed-middleware-class-as-controller/#routing-definitions-may-vary",
            "text": "Depending on the router you chose when starting your project, your routing\ndefinition may differ. The above example uses the default  FastRoute \nimplementation.   We might then implement  Album\\Action\\AlbumPage  as follows:  <?php\nnamespace Album\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage implements MiddlewareInterface\n{\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        switch ($request->getAttribute('action', 'index')) {\n            case 'index':\n                return $this->indexAction($request, $delegate);\n            case 'add':\n                return $this->addAction($request, $delegate);\n            case 'edit':\n                return $this->editAction($request, $delegate);\n            default:\n                // Invalid; thus, a 404!\n                return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n    }\n\n    public function indexAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new HtmlResponse($this->template->render('album::album-page'));\n    }\n\n    public function addAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        return new HtmlResponse($this->template->render('album::album-page-add'));\n    }\n\n    public function editAction(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new \\InvalidArgumentException('id parameter must be provided');\n        }\n\n        return new HtmlResponse(\n            $this->template->render('album::album-page-edit', ['id' => $id])\n        );\n    }\n}  This allows us to have the same dependencies for a set of related actions, and,\nif desired, even have common internal methods each can utilize.  This approach is reasonable, but requires that I create a similar  process() \nimplementation every time I want to accomplish a similar workflow. Let's create\na generic implementation, via an  AbstractPage  class:  <?php\nnamespace App\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\n\nabstract class AbstractPage implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n\n        return $this->$action($request, $delegate);\n    }\n}  The above abstract class pulls the  action  attribute on invocation, and\nconcatenates it with the word  Action . It then uses this value to determine if\na corresponding method exists in the current class, and, if so, calls it with\nthe arguments it received; otherwise, it returns an empty 404 response.  Our original  AlbumPage  implementation could then be modified to extend AbstractPage :  namespace Album\\Action;\n\nuse App\\Action\\AbstractPage;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage extends AbstractPage\n{\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Routing definitions may vary"
        },
        {
            "location": "/v2/cookbook/using-routed-middleware-class-as-controller/#or-use-a-trait",
            "text": "As an alternative to an abstract class, you could define the  __invoke() \nlogic in a trait, which you then compose into your middleware:  <?php\nnamespace App\\Action;\n\nuse Fig\\Http\\Message\\StatusCodeInterface as StatusCode;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\EmptyResponse;\n\ntrait ActionBasedInvocation\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return new EmptyResponse(StatusCode::STATUS_NOT_FOUND);\n        }\n\n        return $this->$action($request, $delegate);\n    }\n}  You would then compose it into a class as follows:  <?php\nnamespace Album\\Action;\n\nuse App\\Action\\ActionBasedInvocation;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    use ActionBasedInvocation;\n\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Or use a trait"
        },
        {
            "location": "/v2/cookbook/flash-messengers/",
            "text": "How Can I Implement Flash Messages?\n\n\nFlash messages\n are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a\n\nPost/Redirect/Get (PRG)\n\nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.\n\n\nExpressive does not provide native session facilities out-of-the-box, which\nmeans you will need:\n\n\n\n\nSession functionality.\n\n\nFlash message functionality, for handling message expiry from the session\n  after first access.\n\n\n\n\nA number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are slim/flash and\ndamess/expressive-session-middleware.\n\n\nslim/flash\n\n\nSlim's \nFlash messages service provider\n can be\nused in Expressive. It uses PHP's native session support.\n\n\nFirst, you'll need to add it to your application:\n\n\n$ composer require slim/flash\n\n\n\nSecond, create middleware that will add the flash message provider to the request:\n\n\n<?php\nnamespace App;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Start the session whenever we use this!\n        session_start();\n\n        return $delegate->process(\n            $request->withAttribute('flash', new Messages())\n        );\n    }\n}\n\n\n\nThird, we will register the new middleware with our container as an invokable.\nEdit either the file \nconfig/autoload/dependencies.global.php\n or\n\nconfig/autoload/middleware-pipeline.global.php\n to add the following:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nFinally, let's register it with our middleware pipeline. For programmatic\npipelines, pipe the middleware somewhere, generally before the routing middleware:\n\n\n$app->pipe(App\\SlimFlashMiddleware::class);\n\n\n\nOr as part of a routed middleware pipeline:\n\n\n$app->post('/form/handler', [\n    App\\SlimFlashMiddleware::class,\n    FormHandlerMiddleware::class,\n]);\n\n\n\nIf using configuration-driven pipelines, edit\n\nconfig/autoload/middleware-pipeline.global.php\n to make the following\nadditions:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\nWhere to register the flash middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead, as demonstrated\nin the programmatic pipelines above.\n\n\n\n\nFrom here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $flash = $request->getAttribute('flash');\n    $flash->addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\nAnd middleware consuming the message might read:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $flash = $request->getAttribute('flash');\n    $messages = $flash->getMessages();\n    // ...\n}\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.\n\n\ndamess/expressive-session-middleware and Aura.Session\n\n\ndamess/expressive-session-middleware\n\nprovides middleware for initializing an\n\nAura.Session\n instance; Aura.Session\nprovides flash messaging capabilities as part of its featureset.\n\n\nInstall it via Composer:\n\n\n$ composer require damess/expressive-session-middleware\n\n\n\nIn \nconfig/autoload/dependencies.global.php\n, add an entry for Aura.Session:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIn either \nconfig/autoload/dependencies.global.php\n or\n\nconfig/autoload/middleware-pipeline.global.php\n, add a factory entry for the\n\ndamess/expressive-session-middleware\n:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nFinally, add it to your middleware pipeline. For programmatic pipelines:\n\n\nuse DaMess\\Http\\SessionMiddleware;\n\n$app->pipe(SessionMiddleware::class);\n/* ... */\n\n\n\nIf using configuration-driven pipelines, edit \nconfig/autoload/middleware-pipeline.global.php\n\nand add an entry for the new middleware:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                DaMess\\Http\\SessionMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\nWhere to register the session middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the session\nmiddleware enabled for every request. If this is the case, add the session\nmiddleware as part of a route-specific pipeline instead.\n\n\n\n\nOnce enabled, the \nSessionMiddleware\n will inject the Aura.Session instance into\nthe request as the \nsession\n attribute; you can thus retrieve it within\nmiddleware using the following:\n\n\n$session = $request->getAttribute('session');\n\n\n\nTo create and consume flash messages, use Aura.Session's\n\nflash values\n. As\nan example, the middleware that is processing a POST request might set a flash\nmessage:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $session = $request->getAttribute('session');\n    $session->getSegment(__NAMESPACE__)\n            ->setFlash('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\nAnother middleware, to which the original middleware redirects, might look like\nthis:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $session = $request->getAttribute('session');\n    $message = $session->getSegment(__NAMESPACE__)\n                       ->getFlash('message');\n    // ...\n}\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.",
            "title": "Flash Messengers"
        },
        {
            "location": "/v2/cookbook/flash-messengers/#how-can-i-implement-flash-messages",
            "text": "Flash messages  are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) \nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.  Expressive does not provide native session facilities out-of-the-box, which\nmeans you will need:   Session functionality.  Flash message functionality, for handling message expiry from the session\n  after first access.   A number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are slim/flash and\ndamess/expressive-session-middleware.",
            "title": "How Can I Implement Flash Messages?"
        },
        {
            "location": "/v2/cookbook/flash-messengers/#slimflash",
            "text": "Slim's  Flash messages service provider  can be\nused in Expressive. It uses PHP's native session support.  First, you'll need to add it to your application:  $ composer require slim/flash  Second, create middleware that will add the flash message provider to the request:  <?php\nnamespace App;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Start the session whenever we use this!\n        session_start();\n\n        return $delegate->process(\n            $request->withAttribute('flash', new Messages())\n        );\n    }\n}  Third, we will register the new middleware with our container as an invokable.\nEdit either the file  config/autoload/dependencies.global.php  or config/autoload/middleware-pipeline.global.php  to add the following:  return [\n    'dependencies' => [\n        'invokables' => [\n            App\\SlimFlashMiddleware::class => App\\SlimFlashMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Finally, let's register it with our middleware pipeline. For programmatic\npipelines, pipe the middleware somewhere, generally before the routing middleware:  $app->pipe(App\\SlimFlashMiddleware::class);  Or as part of a routed middleware pipeline:  $app->post('/form/handler', [\n    App\\SlimFlashMiddleware::class,\n    FormHandlerMiddleware::class,\n]);  If using configuration-driven pipelines, edit config/autoload/middleware-pipeline.global.php  to make the following\nadditions:  return [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];",
            "title": "slim/flash"
        },
        {
            "location": "/v2/cookbook/flash-messengers/#where-to-register-the-flash-middleware",
            "text": "Sessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead, as demonstrated\nin the programmatic pipelines above.   From here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $flash = $request->getAttribute('flash');\n    $flash->addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  And middleware consuming the message might read:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $flash = $request->getAttribute('flash');\n    $messages = $flash->getMessages();\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.",
            "title": "Where to register the flash middleware"
        },
        {
            "location": "/v2/cookbook/flash-messengers/#damessexpressive-session-middleware-and-aurasession",
            "text": "damess/expressive-session-middleware \nprovides middleware for initializing an Aura.Session  instance; Aura.Session\nprovides flash messaging capabilities as part of its featureset.  Install it via Composer:  $ composer require damess/expressive-session-middleware  In  config/autoload/dependencies.global.php , add an entry for Aura.Session:  return [\n    'dependencies' => [\n        'factories' => [\n            Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  In either  config/autoload/dependencies.global.php  or config/autoload/middleware-pipeline.global.php , add a factory entry for the damess/expressive-session-middleware :  return [\n    'dependencies' => [\n        'factories' => [\n            DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Finally, add it to your middleware pipeline. For programmatic pipelines:  use DaMess\\Http\\SessionMiddleware;\n\n$app->pipe(SessionMiddleware::class);\n/* ... */  If using configuration-driven pipelines, edit  config/autoload/middleware-pipeline.global.php \nand add an entry for the new middleware:  return [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                DaMess\\Http\\SessionMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];",
            "title": "damess/expressive-session-middleware and Aura.Session"
        },
        {
            "location": "/v2/cookbook/flash-messengers/#where-to-register-the-session-middleware",
            "text": "Sessions can sometimes be expensive. As such, you may not want the session\nmiddleware enabled for every request. If this is the case, add the session\nmiddleware as part of a route-specific pipeline instead.   Once enabled, the  SessionMiddleware  will inject the Aura.Session instance into\nthe request as the  session  attribute; you can thus retrieve it within\nmiddleware using the following:  $session = $request->getAttribute('session');  To create and consume flash messages, use Aura.Session's flash values . As\nan example, the middleware that is processing a POST request might set a flash\nmessage:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $session = $request->getAttribute('session');\n    $session->getSegment(__NAMESPACE__)\n            ->setFlash('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  Another middleware, to which the original middleware redirects, might look like\nthis:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\n\nfunction($request, DelegateInterface $delegate)\n{\n    $session = $request->getAttribute('session');\n    $message = $session->getSegment(__NAMESPACE__)\n                       ->getFlash('message');\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.",
            "title": "Where to register the session middleware"
        },
        {
            "location": "/v2/cookbook/passing-data-between-middleware/",
            "text": "Passing Data Between Middleware\n\n\nA frequently asked question is how to pass data between middleware.\n\n\nThe answer is present in every middleware: via request object attributes.\n\n\nMiddleware is always executed in the order in which it is piped to the\napplication. This way you can ensure the request object in middleware receiving\ndata contains an attribute containing data passed by outer middleware.\n\n\nIn the following example, \nPassingDataMiddleware\n prepares data to pass as a\nrequest attribute to nested middleware. We use the fully qualified class name\nfor the attribute name to ensure uniqueness, but you can name it anything you\nwant.\n\n\nnamespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass PassingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Do something first\n        $data = [\n            'foo' => 'bar',\n        ];\n\n        // Step 2: Inject data into the request, call the next middleware and wait for the response\n        $response = $delegate->process($request->withAttribute(self::class, $data));\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}\n\n\n\nLater, \nReceivingDataMiddleware\n grabs the data and processes it:\n\n\nnamespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass ReceivingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Grab the data from the request and use it\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n\n        // Step 2: Call the next middleware and wait for the response\n        $response = $delegate->process($request);\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}\n\n\n\nOf course, you could also use the data in routed middleware, which is usually at\nthe innermost layer of your application. The \nExampleAction\n below takes that\ninformation and passes it to the template renderer to create an \nHtmlResponse\n:\n\n\nnamespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass ExampleAction implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Grab the data from the request\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n        $id = $request->getAttribute('id');\n\n        // Step 2: Do some more stuff\n\n        // Step 3: Return a Response\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'data' => $data,\n                'id' => $id,\n            ])\n        );\n    }\n}",
            "title": "Passing data between middleware"
        },
        {
            "location": "/v2/cookbook/passing-data-between-middleware/#passing-data-between-middleware",
            "text": "A frequently asked question is how to pass data between middleware.  The answer is present in every middleware: via request object attributes.  Middleware is always executed in the order in which it is piped to the\napplication. This way you can ensure the request object in middleware receiving\ndata contains an attribute containing data passed by outer middleware.  In the following example,  PassingDataMiddleware  prepares data to pass as a\nrequest attribute to nested middleware. We use the fully qualified class name\nfor the attribute name to ensure uniqueness, but you can name it anything you\nwant.  namespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass PassingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Do something first\n        $data = [\n            'foo' => 'bar',\n        ];\n\n        // Step 2: Inject data into the request, call the next middleware and wait for the response\n        $response = $delegate->process($request->withAttribute(self::class, $data));\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}  Later,  ReceivingDataMiddleware  grabs the data and processes it:  namespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass ReceivingDataMiddleware implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Grab the data from the request and use it\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n\n        // Step 2: Call the next middleware and wait for the response\n        $response = $delegate->process($request);\n\n        // Step 3: Optionally, do something (with the response) before returning the response\n\n        // Step 4: Return the response\n        return $response;\n    }\n}  Of course, you could also use the data in routed middleware, which is usually at\nthe innermost layer of your application. The  ExampleAction  below takes that\ninformation and passes it to the template renderer to create an  HtmlResponse :  namespace App\\Action;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\n\nclass ExampleAction implements MiddlewareInterface\n{\n    // ...\n\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // Step 1: Grab the data from the request\n        $data = $request->getAttribute(PassingDataMiddleware::class);\n        $id = $request->getAttribute('id');\n\n        // Step 2: Do some more stuff\n\n        // Step 3: Return a Response\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'data' => $data,\n                'id' => $id,\n            ])\n        );\n    }\n}",
            "title": "Passing Data Between Middleware"
        },
        {
            "location": "/v2/why-expressive/",
            "text": "Should You Choose zend-expressive Over zend-mvc?\n\n\nWe recommend that you choose Expressive for any new project \u2014 \nif the\nchoice is yours to make\n.\n\n\nWhy Use zend-mvc?\n\n\nzend-mvc is a proven platform, with more than half a decade of development\nbehind it. It is stable and battle-tested in production platforms.\n\n\nBecause it is opinionated about project structure and architecture, fewer\ndecisions need be made up front; developers know where new code goes, and how it\nwill wire into the overall application.\n\n\nAdditionally, a number of training courses exist, including \nofferings by\nZend\n, allowing you\nor your team to fully learn the framework and take advantage of all its features.\n\n\nFinally, zend-mvc has a lively \nmodule ecosystem\n,\nallowing you to add features and capabilities to your application without\nneeding to develop them from scratch.\n\n\nWe Recommend Expressive\n\n\nzend-mvc\n has many preconceptions\nabout how things work, yet they're very broad and general. What\u2019s more, it\nalso has several pre-wired structures in place that may either aid you \u2014\nor get in your way.\n\n\nAs a result, you are required to know a lot of what those things are \u2014 \nif\n you\nwant to use it optimally. And to acquire that depth of knowledge, you\u2019re going\nto need to spend a lot of time digging deep into zend-mvc\u2019s internals before\nyou begin to get the most out of it.\n\n\nTo quote Zend Framework project lead, \nMatthew Weier O\u2019Phinney\n:\n\n\n\n\nThe problem is that zend-mvc is anything but beginner-friendly at this point.\nYou're required to deep dive into the event manager, service manager, and\nmodule system \u2014 right from the outset; And to do this you need more than a\npassing understanding of object-oriented programming and a range of design\npatterns.\n\n\n\n\nExpressive (specifically applications based on\n\nthe Expressive Skeleton Installer\n)\non the other hand, comes with barely any of these assumptions and requirements.\n\n\nIt provides a very minimalist structure. Essentially all you have to become\nfamiliar with are five core components. These are:\n\n\n\n\nA DI container.\n\n\nA router.\n\n\nAn error handler for development.\n\n\nA template engine (if you\u2019re not creating an API).\n\n\nPSR-7 messages and http-interop (future PSR-15) middleware.\n\n\n\n\nIn many cases, these are provided for you by the skeleton, and do not require\nany additional knowledge on your part. Given that, you can quickly get up to\nspeed with the framework and begin creating the application that you need. We\nbelieve that this approach \u2014 in contrast to the zend-mvc approach \u2014\nis more flexible and accommodating.\n\n\nWhat\u2019s more, you can mix and match the types of applications that you create.\n\n\n\n\nDo you just need an API? Great; you can do that quite quickly.\n\n\nDo you want an HTML-based front-end? That\u2019s available too.\n\n\n\n\nWhen building applications with Expressive, you can make use of the various Zend\ncomponents, or any third-party components or middleware. You can pick and\nchoose what you need, as and when you need it. You\u2019re not bound by many, if\nany, constraints and design decisions.\n\n\nIn Conclusion\n\n\nFor what it\u2019s worth, we\u2019re \nnot\n saying that zend-mvc is a poor choice!  What\nwe are saying is:\n\n\n\n\nThe learning curve, from getting started to building the first application,\n   is \nsignificantly\n lower with Expressive\n\n\nThe ways in which you can create applications, whether through multiple\n   pieces of middleware or by combining multiple Expressive apps, into one\n   larger one, is a much more efficient and fluid way to work\n\n\n\n\nUltimately, the choice is always up to you, your team, and your project\u2019s needs.\nWe just want to ensure that you\u2019ve got all the information you need, to make an\ninformed decision.",
            "title": "Why choose Expressive?"
        },
        {
            "location": "/v2/why-expressive/#should-you-choose-zend-expressive-over-zend-mvc",
            "text": "We recommend that you choose Expressive for any new project \u2014  if the\nchoice is yours to make .",
            "title": "Should You Choose zend-expressive Over zend-mvc?"
        },
        {
            "location": "/v2/why-expressive/#why-use-zend-mvc",
            "text": "zend-mvc is a proven platform, with more than half a decade of development\nbehind it. It is stable and battle-tested in production platforms.  Because it is opinionated about project structure and architecture, fewer\ndecisions need be made up front; developers know where new code goes, and how it\nwill wire into the overall application.  Additionally, a number of training courses exist, including  offerings by\nZend , allowing you\nor your team to fully learn the framework and take advantage of all its features.  Finally, zend-mvc has a lively  module ecosystem ,\nallowing you to add features and capabilities to your application without\nneeding to develop them from scratch.",
            "title": "Why Use zend-mvc?"
        },
        {
            "location": "/v2/why-expressive/#we-recommend-expressive",
            "text": "zend-mvc  has many preconceptions\nabout how things work, yet they're very broad and general. What\u2019s more, it\nalso has several pre-wired structures in place that may either aid you \u2014\nor get in your way.  As a result, you are required to know a lot of what those things are \u2014  if  you\nwant to use it optimally. And to acquire that depth of knowledge, you\u2019re going\nto need to spend a lot of time digging deep into zend-mvc\u2019s internals before\nyou begin to get the most out of it.  To quote Zend Framework project lead,  Matthew Weier O\u2019Phinney :   The problem is that zend-mvc is anything but beginner-friendly at this point.\nYou're required to deep dive into the event manager, service manager, and\nmodule system \u2014 right from the outset; And to do this you need more than a\npassing understanding of object-oriented programming and a range of design\npatterns.   Expressive (specifically applications based on the Expressive Skeleton Installer )\non the other hand, comes with barely any of these assumptions and requirements.  It provides a very minimalist structure. Essentially all you have to become\nfamiliar with are five core components. These are:   A DI container.  A router.  An error handler for development.  A template engine (if you\u2019re not creating an API).  PSR-7 messages and http-interop (future PSR-15) middleware.   In many cases, these are provided for you by the skeleton, and do not require\nany additional knowledge on your part. Given that, you can quickly get up to\nspeed with the framework and begin creating the application that you need. We\nbelieve that this approach \u2014 in contrast to the zend-mvc approach \u2014\nis more flexible and accommodating.  What\u2019s more, you can mix and match the types of applications that you create.   Do you just need an API? Great; you can do that quite quickly.  Do you want an HTML-based front-end? That\u2019s available too.   When building applications with Expressive, you can make use of the various Zend\ncomponents, or any third-party components or middleware. You can pick and\nchoose what you need, as and when you need it. You\u2019re not bound by many, if\nany, constraints and design decisions.",
            "title": "We Recommend Expressive"
        },
        {
            "location": "/v2/why-expressive/#in-conclusion",
            "text": "For what it\u2019s worth, we\u2019re  not  saying that zend-mvc is a poor choice!  What\nwe are saying is:   The learning curve, from getting started to building the first application,\n   is  significantly  lower with Expressive  The ways in which you can create applications, whether through multiple\n   pieces of middleware or by combining multiple Expressive apps, into one\n   larger one, is a much more efficient and fluid way to work   Ultimately, the choice is always up to you, your team, and your project\u2019s needs.\nWe just want to ensure that you\u2019ve got all the information you need, to make an\ninformed decision.",
            "title": "In Conclusion"
        },
        {
            "location": "/v2/reference/cli-tooling/",
            "text": "Command Line Tooling\n\n\nExpressive offers a number of tools for assisting in project development. This\npage catalogues each.\n\n\nDevelopment Mode\n\n\nThe package \nzfcampus/zf-development-mode\n\nprovides a simple way to toggle in and out of \ndevelopment mode\n. Doing so\nallows you to ship known development-specific settings within your repository,\nwhile ensuring they are not enabled in production. The tooling essentially\nenables optional, development-specific configuration in your application by:\n\n\n\n\nCopying the file \nconfig/development.config.php.dist\n to\n  \nconfig/development.config.php\n; this can be used to enable\n  development-specific modules or settings (such as the \ndebug\n flag).\n\n\nCopying the file \nconfig/autoload/development.local.php.dist\n to\n  \nconfig/autoload/development.local.php\n; this can be used to provide local\n  overrides of a number of configuration settings.\n\n\n\n\nThe package provides the tooling via \nvendor/bin/zf-development-mode\n. If you\nare using the Expressive skeleton, it provides aliases via Composer:\n\n\n$ composer development-enable\n$ composer development-disable\n$ composer development-status\n\n\n\nAdd settings to your \ndevelopment.*.php.dist\n files, and commit those files to\nyour repository; always toggle out of and into development mode after making\nchanges, to ensure they pick up in your development environment.\n\n\nExpressive command-line tool\n\n\nThe package \nzendframework/zend-expressive-tooling\n\nprovides the script \nvendor/bin/expressive\n, which contains a number of commands\nrelated to migration, modules, and middleware.\n\n\nYou can install it if it is not already present in your application:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nIf you installed the Expressive skeleton prior to version 2.0.2, you will want\nto update the tooling to get the latest release, which contains the \nexpressive\n\nbinary, as follows:\n\n\n$ composer require --dev \"zendframework/zend-expressive-tooling:^0.4.1\"\n\n\n\nOnce installed, invoking the binary without arguments will give a listing of\navailable tools:\n\n\n$ ./vendor/bin/expressive\n\n\n\nCommands supported include:\n\n\n\n\n\n\nmiddleware:create <middleware>\n: Create a class file for the named\n  middleware class. The class \nmust\n use a namespace already declared in your\n  application, and will be created relative to the path associated with that\n  namespace.\n\n\n\n\n\n\nmigrate:error-middleware-scanner [--dir|-d]\n: Scan the associated\n  directory (defaults to \nsrc\n) for declarations of legacy Stratigility v1 error\n  middleware, or invocations of \n$next()\n that provide an error argument. See\n  the \nsection on detecting legacy error middleware\n\n  for more details.\n\n\n\n\n\n\nmigrate:original-messages [--src|-s]\n: Scan the associated source directory\n  (defaults to \nsrc\n) for \ngetOriginal*()\n method calls and replace them with\n  \ngetAttribute()\n calls. See the \nsection on detecting legacy\n  calls\n for more details.\n\n\n\n\n\n\nmigrate:pipeline [--config-file|-c]\n: Convert configuration-driven\n  pipelines and routing to programmatic declarations. See the \nsection on\n  migrating to programmatic pipelines\n for\n  more details.\n\n\n\n\n\n\nmodule:create [--composer|-c] [--modules-path|-p] <module>\n: Create the\n  named module, add and generate autoloading rules for it, and register the\n  module's \nConfigProvider\n with your application.\n\n\n\n\n\n\nmodule:register [--composer|-c] [--modules-path|-p] <module>\n: Add and\n  generate autoloading rules for the named module,  and register the module's\n  \nConfigProvider\n with your application.\n\n\n\n\n\n\nmodule:deregister [--composer|-c] [--modules-path|-p] <module>\n: Remove\n  autoloading rules for the named module and regenerate autoloading rules;\n  remove the module's \nConfigProvider\n from the application configuration.\n\n\n\n\n\n\nYou may obtain full help for each command by invoking:\n\n\n$ ./vendor/bin/expressive help <command>\n\n\n\nModules\n\n\n\n\nDeprecated since zend-expressive-tooling 0.4.0; see the \nExpressive CLI tool\n  section above\n.\n\n\n\n\nThe package \nzendframework/zend-expressive-tooling\n\nprovides the binary \nvendor/bin/expressive-module\n, which allows you to create,\nregister, and deregister modules, assuming you are using a \nmodular application\nlayout\n.\n\n\nFor instance, if you wish to create a new module for managing users, you might\nexecute the following:\n\n\n$ ./vendor/bin/expressive-module create User\n\n\n\nWhich would create the following tree:\n\n\nsrc/\n  User/\n    src/\n      ConfigProvider.php\n    templates/\n\n\n\nIt would also create an autoloading rule within your \ncomposer.json\n for the\n\nUser\n namespace, pointing it at the \nsrc/User/src/\n tree (and updating the\nautoloader in the process), and register the new module's \nConfigProvider\n\nwithin your \nconfig/config.php\n.\n\n\nThe \nregister\n command will take an existing module and:\n\n\n\n\nAdd an autoloading rule for it to your \ncomposer.json\n, if necessary.\n\n\nAdd an entry for the module's \nConfigProvider\n class to your\n  \nconfig/config.php\n, if possible.\n\n\n\n\n$ ./vendor/bin/expressive-module register Account\n\n\n\nThe \nderegister\n command does the opposite of \nregister\n.\n\n\n$ ./vendor/bin/expressive-module deregister Account\n\n\n\nMigrate to programmatic pipelines\n\n\n\n\nDeprecated since zend-expressive-tooling 0.4.0; see the \nExpressive CLI tool\n  section above\n.\n\n\n\n\nWe recommend using \nprogrammatic pipelines\n, versus configuration-defined\npipelines. For those upgrading their applications from 1.X versions, we provide\na tool that will read their application configuration and generate:\n\n\n\n\nconfig/pipeline.php\n, with the middleware pipeline\n\n\nconfig/routes.php\n, with routing directives\n\n\nconfig/autoload/zend-expressive.global.php\n, with settings to ensure\n  programmatic pipelines are used, and new middleware provided for Expressive\n  2.0 is registered.\n\n\ndirectives within \npublic/index.php\n for using the generated pipeline and\n  routes directives.\n\n\n\n\nTo use this feature, you will need to first install\nzendframework/zend-expressive-tooling:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nInvoke it as follows:\n\n\n$ ./vendor/bin/expressive-pipeline-from-config generate\n\n\n\nThe tool will notify you of any errors, including whether or not it found (and\nskipped) Stratigility v1-style \"error middleware\".\n\n\nDetect usage of legacy getOriginal*() calls\n\n\n\n\nDeprecated since zend-expressive-tooling 0.4.0; see the \nExpressive CLI tool\n  section above\n.\n\n\n\n\nWhen upgrading to version 2.0, you will also receive an upgrade to\nzendframework/zend-stratigility 2.0. That version eliminates internal decorator\nclasses for the request and response instances, which were used to provide\naccess to the outermost request/response; internal layers could use these to\ndetermine the full URI that resulted in their invocation, which is useful when\nyou pipe using a path argument (as the path provided during piping is stripped\nfrom the URI when invoking the matched middleware).\n\n\nThis affects the following methods:\n\n\n\n\nRequest::getOriginalRequest()\n\n\nRequest::getOriginalUri()\n\n\nResponse::getOriginalResponse()\n\n\n\n\nTo provide equivalent functionality, we provide a couple of tools.\n\n\nFirst, Stratigility provides middleware, \nZend\\Stratigility\\Middleware\\OriginalMessages\n,\nwhich will inject the current request, its URI, and, if invoked as double-pass\nmiddleware, current response, as \nrequest attributes\n, named, respectively,\n\noriginalRequest\n, \noriginalUri\n, and \noriginalResponse\n. (Since Expressive 2.0\ndecorates double-pass middleware using a wrapper that composes a response, the\n\"original response\" will be the response prototype composed in the \nApplication\n\ninstance.) This should be registered as the outermost middleware layer.\nMiddleware that needs access to these instances can then use the following\nsyntax to retrieve them:\n\n\n$originalRequest = $request->getAttribute('originalRequest', $request);\n$originalUri = $request->getAttribute('originalUri', $request->getUri();\n$originalResponse = $request->getAttribute('originalResponse') ?: new Response();\n\n\n\n\n\nOriginal response is not trustworthy\n\n\nAs noted above, the \"original response\" will likely be injected with the\nresponse prototype from the \nApplication\n instance. We recommend not using it,\nand instead either composing a pristine response instance in your middleware,\nor creating a new instance on-the-fly.\n\n\n\n\nTo aid you in migrating your existing code to use the new \ngetAttribute()\n\nsyntax, zendframework/zend-expressive-tooling provides a binary,\n\nvendor/bin/expressive-migrate-original-messages\n. First, install that package:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nThen invoke it as follows:\n\n\n$ ./vendor/bin/expressive-migrate-original-messages scan\n\n\n\nThis script will update any \ngetOriginalRequest()\n and \ngetOriginalUri()\n calls,\nand notify you of any \ngetOriginalResponse()\n calls, providing you with details\non how to correct those manually.\n\n\nDetect usage of legacy error middleware\n\n\n\n\nDeprecated since zend-expressive-tooling 0.4.0; see the \nExpressive CLI tool\n  section above\n.\n\n\n\n\nWhen upgrading to version 2.0, you will also receive an upgrade to\nzendframework/zend-stratigility 2.0. That version eliminates what was known as\n\"error middleware\", middleware that either implemented\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n, or duck-typed it by implementing\nthe signature \nfunction ($error, $request, $response, callable $next)\n.\n\n\nSuch \"error middleware\" allowed other middleware to invoke the \n$next\n argument\nwith an additional, third argument representing an error condition; when that\noccurred, Stratigility/Expressive would start iterating through error middleware\nuntil one was able to return a response. Each would receive the error as the\nfirst argument, and determine how to act upon it.\n\n\nWith version 2.0 of each project, such middleware is now no longer accepted, and\nusers should instead be using \nthe new error handling\nfeatures\n. However, you may find that:\n\n\n\n\nYou have defined error middleware in your application.\n\n\nYou have standard middleware in your application that invokes \n$next\n with the\n  third, error argument.\n\n\n\n\nTo help you identify such instances, zendframework/zend-expressive-tooling\nprovides the script \nvendor/bin/expressive-scan-for-error-middleware\n. First,\ninstall that package:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nThen invoke it as follows:\n\n\n$ ./vendor/bin/expressive-scan-for-error-middleware scan\n\n\n\nThe script will notify you of any places where it finds either use case, and\nprovide feedback on how to update your application.",
            "title": "CLI Tooling"
        },
        {
            "location": "/v2/reference/cli-tooling/#command-line-tooling",
            "text": "Expressive offers a number of tools for assisting in project development. This\npage catalogues each.",
            "title": "Command Line Tooling"
        },
        {
            "location": "/v2/reference/cli-tooling/#development-mode",
            "text": "The package  zfcampus/zf-development-mode \nprovides a simple way to toggle in and out of  development mode . Doing so\nallows you to ship known development-specific settings within your repository,\nwhile ensuring they are not enabled in production. The tooling essentially\nenables optional, development-specific configuration in your application by:   Copying the file  config/development.config.php.dist  to\n   config/development.config.php ; this can be used to enable\n  development-specific modules or settings (such as the  debug  flag).  Copying the file  config/autoload/development.local.php.dist  to\n   config/autoload/development.local.php ; this can be used to provide local\n  overrides of a number of configuration settings.   The package provides the tooling via  vendor/bin/zf-development-mode . If you\nare using the Expressive skeleton, it provides aliases via Composer:  $ composer development-enable\n$ composer development-disable\n$ composer development-status  Add settings to your  development.*.php.dist  files, and commit those files to\nyour repository; always toggle out of and into development mode after making\nchanges, to ensure they pick up in your development environment.",
            "title": "Development Mode"
        },
        {
            "location": "/v2/reference/cli-tooling/#expressive-command-line-tool",
            "text": "The package  zendframework/zend-expressive-tooling \nprovides the script  vendor/bin/expressive , which contains a number of commands\nrelated to migration, modules, and middleware.  You can install it if it is not already present in your application:  $ composer require --dev zendframework/zend-expressive-tooling  If you installed the Expressive skeleton prior to version 2.0.2, you will want\nto update the tooling to get the latest release, which contains the  expressive \nbinary, as follows:  $ composer require --dev \"zendframework/zend-expressive-tooling:^0.4.1\"  Once installed, invoking the binary without arguments will give a listing of\navailable tools:  $ ./vendor/bin/expressive  Commands supported include:    middleware:create <middleware> : Create a class file for the named\n  middleware class. The class  must  use a namespace already declared in your\n  application, and will be created relative to the path associated with that\n  namespace.    migrate:error-middleware-scanner [--dir|-d] : Scan the associated\n  directory (defaults to  src ) for declarations of legacy Stratigility v1 error\n  middleware, or invocations of  $next()  that provide an error argument. See\n  the  section on detecting legacy error middleware \n  for more details.    migrate:original-messages [--src|-s] : Scan the associated source directory\n  (defaults to  src ) for  getOriginal*()  method calls and replace them with\n   getAttribute()  calls. See the  section on detecting legacy\n  calls  for more details.    migrate:pipeline [--config-file|-c] : Convert configuration-driven\n  pipelines and routing to programmatic declarations. See the  section on\n  migrating to programmatic pipelines  for\n  more details.    module:create [--composer|-c] [--modules-path|-p] <module> : Create the\n  named module, add and generate autoloading rules for it, and register the\n  module's  ConfigProvider  with your application.    module:register [--composer|-c] [--modules-path|-p] <module> : Add and\n  generate autoloading rules for the named module,  and register the module's\n   ConfigProvider  with your application.    module:deregister [--composer|-c] [--modules-path|-p] <module> : Remove\n  autoloading rules for the named module and regenerate autoloading rules;\n  remove the module's  ConfigProvider  from the application configuration.    You may obtain full help for each command by invoking:  $ ./vendor/bin/expressive help <command>",
            "title": "Expressive command-line tool"
        },
        {
            "location": "/v2/reference/cli-tooling/#modules",
            "text": "Deprecated since zend-expressive-tooling 0.4.0; see the  Expressive CLI tool\n  section above .   The package  zendframework/zend-expressive-tooling \nprovides the binary  vendor/bin/expressive-module , which allows you to create,\nregister, and deregister modules, assuming you are using a  modular application\nlayout .  For instance, if you wish to create a new module for managing users, you might\nexecute the following:  $ ./vendor/bin/expressive-module create User  Which would create the following tree:  src/\n  User/\n    src/\n      ConfigProvider.php\n    templates/  It would also create an autoloading rule within your  composer.json  for the User  namespace, pointing it at the  src/User/src/  tree (and updating the\nautoloader in the process), and register the new module's  ConfigProvider \nwithin your  config/config.php .  The  register  command will take an existing module and:   Add an autoloading rule for it to your  composer.json , if necessary.  Add an entry for the module's  ConfigProvider  class to your\n   config/config.php , if possible.   $ ./vendor/bin/expressive-module register Account  The  deregister  command does the opposite of  register .  $ ./vendor/bin/expressive-module deregister Account",
            "title": "Modules"
        },
        {
            "location": "/v2/reference/cli-tooling/#migrate-to-programmatic-pipelines",
            "text": "Deprecated since zend-expressive-tooling 0.4.0; see the  Expressive CLI tool\n  section above .   We recommend using  programmatic pipelines , versus configuration-defined\npipelines. For those upgrading their applications from 1.X versions, we provide\na tool that will read their application configuration and generate:   config/pipeline.php , with the middleware pipeline  config/routes.php , with routing directives  config/autoload/zend-expressive.global.php , with settings to ensure\n  programmatic pipelines are used, and new middleware provided for Expressive\n  2.0 is registered.  directives within  public/index.php  for using the generated pipeline and\n  routes directives.   To use this feature, you will need to first install\nzendframework/zend-expressive-tooling:  $ composer require --dev zendframework/zend-expressive-tooling  Invoke it as follows:  $ ./vendor/bin/expressive-pipeline-from-config generate  The tool will notify you of any errors, including whether or not it found (and\nskipped) Stratigility v1-style \"error middleware\".",
            "title": "Migrate to programmatic pipelines"
        },
        {
            "location": "/v2/reference/cli-tooling/#detect-usage-of-legacy-getoriginal-calls",
            "text": "Deprecated since zend-expressive-tooling 0.4.0; see the  Expressive CLI tool\n  section above .   When upgrading to version 2.0, you will also receive an upgrade to\nzendframework/zend-stratigility 2.0. That version eliminates internal decorator\nclasses for the request and response instances, which were used to provide\naccess to the outermost request/response; internal layers could use these to\ndetermine the full URI that resulted in their invocation, which is useful when\nyou pipe using a path argument (as the path provided during piping is stripped\nfrom the URI when invoking the matched middleware).  This affects the following methods:   Request::getOriginalRequest()  Request::getOriginalUri()  Response::getOriginalResponse()   To provide equivalent functionality, we provide a couple of tools.  First, Stratigility provides middleware,  Zend\\Stratigility\\Middleware\\OriginalMessages ,\nwhich will inject the current request, its URI, and, if invoked as double-pass\nmiddleware, current response, as  request attributes , named, respectively, originalRequest ,  originalUri , and  originalResponse . (Since Expressive 2.0\ndecorates double-pass middleware using a wrapper that composes a response, the\n\"original response\" will be the response prototype composed in the  Application \ninstance.) This should be registered as the outermost middleware layer.\nMiddleware that needs access to these instances can then use the following\nsyntax to retrieve them:  $originalRequest = $request->getAttribute('originalRequest', $request);\n$originalUri = $request->getAttribute('originalUri', $request->getUri();\n$originalResponse = $request->getAttribute('originalResponse') ?: new Response();",
            "title": "Detect usage of legacy getOriginal*() calls"
        },
        {
            "location": "/v2/reference/cli-tooling/#original-response-is-not-trustworthy",
            "text": "As noted above, the \"original response\" will likely be injected with the\nresponse prototype from the  Application  instance. We recommend not using it,\nand instead either composing a pristine response instance in your middleware,\nor creating a new instance on-the-fly.   To aid you in migrating your existing code to use the new  getAttribute() \nsyntax, zendframework/zend-expressive-tooling provides a binary, vendor/bin/expressive-migrate-original-messages . First, install that package:  $ composer require --dev zendframework/zend-expressive-tooling  Then invoke it as follows:  $ ./vendor/bin/expressive-migrate-original-messages scan  This script will update any  getOriginalRequest()  and  getOriginalUri()  calls,\nand notify you of any  getOriginalResponse()  calls, providing you with details\non how to correct those manually.",
            "title": "Original response is not trustworthy"
        },
        {
            "location": "/v2/reference/cli-tooling/#detect-usage-of-legacy-error-middleware",
            "text": "Deprecated since zend-expressive-tooling 0.4.0; see the  Expressive CLI tool\n  section above .   When upgrading to version 2.0, you will also receive an upgrade to\nzendframework/zend-stratigility 2.0. That version eliminates what was known as\n\"error middleware\", middleware that either implemented Zend\\Stratigility\\ErrorMiddlewareInterface , or duck-typed it by implementing\nthe signature  function ($error, $request, $response, callable $next) .  Such \"error middleware\" allowed other middleware to invoke the  $next  argument\nwith an additional, third argument representing an error condition; when that\noccurred, Stratigility/Expressive would start iterating through error middleware\nuntil one was able to return a response. Each would receive the error as the\nfirst argument, and determine how to act upon it.  With version 2.0 of each project, such middleware is now no longer accepted, and\nusers should instead be using  the new error handling\nfeatures . However, you may find that:   You have defined error middleware in your application.  You have standard middleware in your application that invokes  $next  with the\n  third, error argument.   To help you identify such instances, zendframework/zend-expressive-tooling\nprovides the script  vendor/bin/expressive-scan-for-error-middleware . First,\ninstall that package:  $ composer require --dev zendframework/zend-expressive-tooling  Then invoke it as follows:  $ ./vendor/bin/expressive-scan-for-error-middleware scan  The script will notify you of any places where it finds either use case, and\nprovide feedback on how to update your application.",
            "title": "Detect usage of legacy error middleware"
        },
        {
            "location": "/v2/reference/usage-examples/",
            "text": "Usage Examples\n\n\nBelow are several usage examples, covering a variety of ways of creating and\nmanaging an application.\n\n\nIn all examples, the assumption is the following directory structure:\n\n\n.\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 public\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 vendor\n\n\n\nWe assume also that:\n\n\n\n\nYou have installed zend-expressive per the \ninstallation instructions\n.\n\n\npublic/\n will be the document root of your application.\n\n\nYour own classes are under \nsrc/\n with the top-level namespace \nApp\n,\n  and you have configured \nautoloading\n\n  in your \ncomposer.json\n for those classes (this should be done for you during\n  installation).\n\n\n\n\n\n\nUsing the built-in web server\n\n\nYou can use the built-in web server to run the examples. Run:\n\n\n$ php -S 0.0.0.0:8080 -t public\n\n\n\nfrom the application root to start up a web server running on port 8080, and\nthen browse to http://localhost:8080/. If you used the Expressive installer,\nthe following is equivalent:\n\n\n$ composer run --timeout=0 serve\n\n\n\nSetting up autoloading for the Application namespace\n\n\nIn your \ncomposer.json\n file, place the following:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"src/\"\n    }\n},\n\n\n\nOnce done, run:\n\n\n$ composer dump-autoload\n\n\n\n\n\nRouting\n\n\nAs noted in the \nApplication documentation\n,\nrouting is abstracted and can be accomplished by calling any of the following\nmethods:\n\n\n\n\nroute($path, $middleware, array $methods = null, $name = null)\n to route to a\n  path and match any HTTP method, multiple HTTP methods, or custom HTTP methods.\n\n\nget($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the GET HTTP method.\n\n\npost($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the POST HTTP method.\n\n\nput($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the PUT HTTP method.\n\n\npatch($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the PATCH HTTP method.\n\n\ndelete($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the DELETE HTTP method.\n\n\n\n\nAll methods return a \nZend\\Expressive\\Router\\Route\n method, which allows you to\nspecify additional options to associate with the route (e.g., for specifying\ncriteria, default values to match, etc.).\n\n\nAs examples:\n\n\n// GET\n// This demonstrates passing a middleware instance (assuming $helloWorld is\n// valid middleware)\n$app->get('/', $helloWorld);\n\n// POST\n// This example specifies the middleware as a service name instead of as\n// actual executable middleware.\n$app->post('/trackback', 'TrackBack');\n\n// PUT\n// This example shows operating on the returned route. In this case, it's adding\n// regex tokens to restrict what values for {id} will match. (The tokens feature\n// is specific to Aura.Router.)\n$app->put('/post/{id}', 'ReplacePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// PATCH\n// This example builds on the one above. Expressive allows you to specify\n// the same path for a route matching on a different HTTP method, and\n// corresponding to different middleware.\n$app->patch('/post/{id}', 'UpdatePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// DELETE\n$app->delete('/post/{id}', 'DeletePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// Matching ALL HTTP methods\n// If the underlying router supports matching any HTTP method, the following\n// will do so. Note: FastRoute *requires* you to specify the HTTP methods\n// allowed explicitly, and does not support wildcard routes. As such, the\n// following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH,\n// PUT, TRACE, and DELETE.\n// Just like the previous examples, it returns a Route instance that you can\n// further manipulate.\n$app->route('/post/{id}', 'HandlePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// Matching multiple HTTP methods\n// You can pass an array of HTTP methods as a third argument to route(); in such\n// cases, routing will match if any of the specified HTTP methods are provided.\n$app->route('/post', 'HandlePostCollection', ['GET', 'POST']);\n\n// Matching NO HTTP methods\n// Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be\n// honored. (In FastRoute, GET is also honored.)\n$app->route('/post', 'WillThisHandlePost', []);\n\n\n\nFinally, if desired, you can create a \nZend\\Expressive\\Router\\Route\n instance\nmanually and pass it to \nroute()\n as the sole argument:\n\n\n$route = new Route('/post', 'HandlePost', ['GET', 'POST']);\n$route->setOptions($options);\n\n$app->route($route);\n\n\n\nHello World using a Container\n\n\nExpressive works with \nPSR-11 Containers\n,\nthough it's an optional feature. By default, if you use the \nAppFactory\n, it\nwill use \nzend-servicemanager\n\nso long as that package is installed.\n\n\nIn the following example, we'll populate the container with our middleware, and\nthe application will pull it from there when matched.\n\n\nEdit your \npublic/index.php\n to read as follows:\n\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$container = new ServiceManager();\n\n$container->setFactory('HelloWorld', function ($container) {\n    return function ($request, DelegateInterface $delegate) {\n        return new TextResponse('Hello, world!');\n    };\n});\n\n$container->setFactory('Ping', function ($container) {\n    return function ($request, DelegateInterface $delegate) {\n        return new JsonResponse(['ack' => time()]);\n    };\n});\n\n$app = AppFactory::create($container);\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n$app->run();\n\n\n\nIn the example above, we pass our container to \nAppFactory\n. We could have also\ndone this instead:\n\n\n$app = AppFactory::create();\n$container = $app->getContainer();\n\n\n\nand then added our service definitions. We recommend passing the container to\nthe factory instead; if we ever change which container we use by default, your\ncode might not work!\n\n\nThe following two lines are the ones of interest:\n\n\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n\n\nThese map the two paths to \nservice names\n instead of callables. When routing\nmatches a path, it does the following:\n\n\n\n\nIf the middleware provided when defining the route is callable, it uses it\n  directly.\n\n\nIf the middleware is a valid service name in the container, it pulls it from\n  the container. \nThis is what happens in this example.\n\n\nFinally, if no container is available, or the service name is not found in the\n  container, it checks to see if it's a valid class name; if so, it instantiates\n  and returns the class instance.\n\n\n\n\nIf you fire up your web server, you'll find that the \n/\n and \n/ping\n paths\ncontinue to work.\n\n\nOne other approach you could take would be to define the application itself in\nthe container, and then pull it from there:\n\n\n$container->setFactory('Zend\\Expressive\\Application', function ($container) {\n    $app = AppFactory::create($container);\n    $app->get('/', 'HelloWorld');\n    $app->get('/ping', 'Ping');\n    return $app;\n});\n\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();\n\n\n\nThis is a nice way to encapsulate the application creation. You could then\npotentially move all service configuration to another file! (We already\n\ndocument an ApplicationFactory for exactly this scenario.\n)\n\n\nHello World using a Configuration-Driven Container\n\n\nIn the above example, we configured our middleware as services, and then passed\nour service container to the application. At the end, we hinted that you could\npotentially define the application itself as a service.\n\n\nExpressive already provides a service factory for the application instance\nto provide fine-grained control over your application. In this example, we'll\nleverage it, defining our routes via configuration.\n\n\nFirst, we're going to leverage zend-config to merge configuration files. This is\nimportant, as it allows us to define local, environment-specific configuration\nin files that we then can exclude from our repository. This practice ensures\nthat things like credentials are not accidentally published in a public\nrepository, and also provides a mechanism for slip-streaming in\nconfiguration based on our environment (you might use different settings in\ndevelopment than in production, after all!).\n\n\nFirst, install zend-config and zend-stdlib:\n\n\n$ composer require zendframework/zend-config zendframework/zend-stdlib\n\n\n\nNow we can start creating our configuration files and container factories.\n\n\nIn \nconfig/config.php\n, place the following:\n\n\n<?php\n\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Stdlib\\Glob;\n\n$config = [];\n// Load configuration from autoload path\nforeach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) {\n    $config = ArrayUtils::merge($config, include $file);\n}\n\n// Return an ArrayObject so we can inject the config as a service in Aura.Di\n// and still use array checks like ``is_array``.\nreturn new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS);\n\n\n\nIn \nconfig/container.php\n, place the following:\n\n\n<?php\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// Load configuration\n$config = require __DIR__.'/config.php';\n\n// Build container\n$container = new ServiceManager();\n(new Config($config['dependencies']))->configureServiceManager($container);\n\n// Inject config\n$container->setService('config', $config);\n\nreturn $container;\n\n\n\nIn \nconfig/autoload/dependencies.global.php\n, place the following:\n\n\n<?php\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            \\Application\\HelloWorldAction::class => InvokableFactory::class,\n            \\Application\\PingAction::class => InvokableFactory::class,\n        ],\n        'factories' => [\n            \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class,\n        ],\n    ]\n];\n\n\n\nIn \nconfig/autoload/routes.global.php\n, place the following:\n\n\n<?php\n\nreturn [\n    'routes' => [\n        [\n            'path' => '/',\n            'middleware' => \\Application\\HelloWorldAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n        [\n            'path' => '/ping',\n            'middleware' => \\Application\\PingAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n    ],\n];\n\n\n\nIn \nsrc/Application/HelloWorld.php\n, place the following:\n\n\n<?php\nnamespace Application;\n\nclass HelloWorld\n{\n    public function __invoke($req, $res, $next)\n    {\n        $res->getBody()->write('Hello, world!');\n        return $res;\n    }\n}\n\n\n\nIn \nsrc/Application/Ping.php\n, place the following:\n\n\n<?php\nnamespace Application;\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass Ping\n{\n    public function __invoke($req, $res, $next)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\nAfter that\u2019s done run:\n\n\ncomposer dump-autoload\n\n\n\nFinally, in \npublic/index.php\n, place the following:\n\n\n<?php\n// Change to the project root, to simplify resolving paths\nchdir(dirname(__DIR__));\n\n// Setup autoloading\nrequire 'vendor/autoload.php';\n\n$container = include 'config/container.php';\n$app       = $container->get(Zend\\Expressive\\Application::class);\n$app->run();\n\n\n\nNotice that our index file now doesn't have any code related to setting up the\napplication any longer! All it does is setup autoloading, retrieve our service\ncontainer, pull the application from it, and run it. Our choices for container,\nrouter, etc. are all abstracted, and if we change our mind later, this code will\ncontinue to work.\n\n\nFiring up the web server, you'll see the same responses as the previous\nexamples.\n\n\nHybrid Container and Programmatic Creation\n\n\nThe above example may look a little daunting at first. By making everything\nconfiguration-driven, you sometimes lose a sense for how the code all fits\ntogether.\n\n\nFortunately, you can mix the two. Building on the example above, we'll add a new\nroute and middleware. Between pulling the application from the container and\ncalling \n$app->run()\n, add the following in your \npublic/index.php\n:\n\n\n$app->post('/post', function ($request, \\Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) {\n    return new \\Zend\\Diactoros\\Response\\TextResponse('IN POST!');\n});\n\n\n\nNote that we're using \npost()\n here; that means you'll have to use cURL, HTTPie,\nPostman, or some other tool to test making a POST request to the path:\n\n\n$ curl -X POST http://localhost:8080/post\n\n\n\nYou should see \nIN POST!\n for the response!\n\n\nUsing this approach, you can build re-usable applications that are\ncontainer-driven, and add one-off routes and middleware as needed.\n\n\nUsing the container to register middleware\n\n\nIf you use a container to fetch your application instance, you have an\nadditional option for specifying middleware for the pipeline: configuration:\n\n\n<?php\nreturn [\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware Service Name or Callable',\n            'allowed_methods' => ['GET', 'POST', 'PATCH'],\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n    'middleware_pipeline' => [\n        // See specification below\n    ],\n];\n\n\n\nThe key to note is \nmiddleware_pipeline\n, which is an array of middlewares to\nregister in the pipeline; each will each be \npipe()\n'd to the Application in the\norder specified.\n\n\nEach middleware specified must be in the following form:\n\n\n[\n    // required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // optional:\n    'path'  => '/path/to/match',\n    'priority' => 1, // Integer\n]\n\n\n\nPriority should be an integer, and follows the semantics of\n\nSplPriorityQueue\n: higher numbers indicate\nhigher priority (top of the queue; executed earliest), while lower numbers\nindicated lower priority (bottom of the queue, executed last); \nnegative values\nare low priority\n. Items of the same priority are executed in the order in which\nthey are attached.\n\n\nThe default priority is 1, and this priority is used by the routing and dispatch\nmiddleware. To indicate that middleware should execute \nbefore\n these, use a\npriority higher than 1.\n\n\nThe above specification can be used for all middleware, with one exception:\nregistration of the \nrouting\n and/or \ndispatch\n middleware that Expressive\nprovides. In these cases, use the following constants, which will be caught by\nthe factory and expanded:\n\n\n\n\nZend\\Expressive\\Application::ROUTING_MIDDLEWARE\n for the\n  routing middleware; this should always come before the dispatch middleware.\n\n\nZend\\Expressive\\Application::DISPATCH_MIDDLEWARE\n for the\n  dispatch middleware.\n\n\n\n\nAs an example:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n        Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n        [ /* ... */ ],\n    ],\n];\n\n\n\n\n\nPlace routing middleware correctly\n\n\nIf you are defining routes \nand\n defining other middleware for the pipeline,\nyou \nmust\n add the routing middleware. When you do so, make sure you put\nit at the appropriate location in the pipeline.\n\n\nTypically, you will place any middleware you want to execute on all requests\nprior to the routing middleware. This includes utilities for bootstrapping\nthe application (such as injection of the \nServerUrlHelper\n),\nutilities for injecting common response headers (such as CORS support), etc.\nMake sure these middleware specifications include the \npriority\n key, and that\nthe value of this key is greater than 1.\n\n\nUse priority to shape the specific workflow you want for your middleware.\n\n\n\n\nMiddleware items may be any \nvalid middleware\n,\nincluding \narrays\n of middleware, which indicate a nested middleware pipeline;\nthese may even contain the routing and dispatch middleware constants:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n                /* ... middleware that introspects routing results ... */\n                Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        [ /* ... */ ],\n    ],\n];\n\n\n\n\n\nPipeline keys are ignored\n\n\nKeys in a \nmiddleware_pipeline\n specification are ignored. However, they can\nbe useful when merging several configurations; if multiple configuration files\nspecify the same key, then those entries will be merged. Be aware, however,\nthat the \nmiddleware\n entry for each, since it is an indexed array, will\nmerge arrays by appending; in other words, order will not be guaranteed within\nthat array after merging. If order is critical, define a middleware spec with\n\npriority\n keys.\n\n\n\n\nThe path, if specified, can only be a literal path to match, and is typically\nused for segregating middleware applications or applying rules to subsets of an\napplication that match a common path root.\n\n\nSegregating your application to a subpath\n\n\nOne benefit of a middleware-based application is the ability to compose\nmiddleware and segregate them by paths. \nZend\\Expressive\\Application\n is itself\nmiddleware, allowing you to do exactly that if desired.\n\n\nIn the following example, we'll assume that \n$api\n and \n$blog\n are\n\nZend\\Expressive\\Application\n instances, and compose them into a\n\nZend\\Stratigility\\MiddlewarePipe\n.\n\n\nuse Zend\\Diactoros\\Server;\nuse Zend\\Diactoros\\ServerRequestFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$server = Server::createServerFromRequest(\n    $app,\n    ServerRequestFactory::fromGlobals()\n);\n$server->listen();\n\n\n\nYou could also compose them in an \nApplication\n instance, and utilize \nrun()\n:\n\n\n$app = AppFactory::create();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$app->run();\n\n\n\nThis approach allows you to develop discrete applications and compose them\ntogether to create a website.",
            "title": "Examples"
        },
        {
            "location": "/v2/reference/usage-examples/#usage-examples",
            "text": "Below are several usage examples, covering a variety of ways of creating and\nmanaging an application.  In all examples, the assumption is the following directory structure:  .\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 public\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 vendor  We assume also that:   You have installed zend-expressive per the  installation instructions .  public/  will be the document root of your application.  Your own classes are under  src/  with the top-level namespace  App ,\n  and you have configured  autoloading \n  in your  composer.json  for those classes (this should be done for you during\n  installation).",
            "title": "Usage Examples"
        },
        {
            "location": "/v2/reference/usage-examples/#using-the-built-in-web-server",
            "text": "You can use the built-in web server to run the examples. Run:  $ php -S 0.0.0.0:8080 -t public  from the application root to start up a web server running on port 8080, and\nthen browse to http://localhost:8080/. If you used the Expressive installer,\nthe following is equivalent:  $ composer run --timeout=0 serve",
            "title": "Using the built-in web server"
        },
        {
            "location": "/v2/reference/usage-examples/#setting-up-autoloading-for-the-application-namespace",
            "text": "In your  composer.json  file, place the following:  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"src/\"\n    }\n},  Once done, run:  $ composer dump-autoload",
            "title": "Setting up autoloading for the Application namespace"
        },
        {
            "location": "/v2/reference/usage-examples/#routing",
            "text": "As noted in the  Application documentation ,\nrouting is abstracted and can be accomplished by calling any of the following\nmethods:   route($path, $middleware, array $methods = null, $name = null)  to route to a\n  path and match any HTTP method, multiple HTTP methods, or custom HTTP methods.  get($path, $middleware, $name = null)  to route to a path that will only\n  respond to the GET HTTP method.  post($path, $middleware, $name = null)  to route to a path that will only\n  respond to the POST HTTP method.  put($path, $middleware, $name = null)  to route to a path that will only\n  respond to the PUT HTTP method.  patch($path, $middleware, $name = null)  to route to a path that will only\n  respond to the PATCH HTTP method.  delete($path, $middleware, $name = null)  to route to a path that will only\n  respond to the DELETE HTTP method.   All methods return a  Zend\\Expressive\\Router\\Route  method, which allows you to\nspecify additional options to associate with the route (e.g., for specifying\ncriteria, default values to match, etc.).  As examples:  // GET\n// This demonstrates passing a middleware instance (assuming $helloWorld is\n// valid middleware)\n$app->get('/', $helloWorld);\n\n// POST\n// This example specifies the middleware as a service name instead of as\n// actual executable middleware.\n$app->post('/trackback', 'TrackBack');\n\n// PUT\n// This example shows operating on the returned route. In this case, it's adding\n// regex tokens to restrict what values for {id} will match. (The tokens feature\n// is specific to Aura.Router.)\n$app->put('/post/{id}', 'ReplacePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// PATCH\n// This example builds on the one above. Expressive allows you to specify\n// the same path for a route matching on a different HTTP method, and\n// corresponding to different middleware.\n$app->patch('/post/{id}', 'UpdatePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// DELETE\n$app->delete('/post/{id}', 'DeletePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// Matching ALL HTTP methods\n// If the underlying router supports matching any HTTP method, the following\n// will do so. Note: FastRoute *requires* you to specify the HTTP methods\n// allowed explicitly, and does not support wildcard routes. As such, the\n// following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH,\n// PUT, TRACE, and DELETE.\n// Just like the previous examples, it returns a Route instance that you can\n// further manipulate.\n$app->route('/post/{id}', 'HandlePost')\n    ->setOptions([\n        'tokens' => ['id' => '\\d+'],\n    ]);\n\n// Matching multiple HTTP methods\n// You can pass an array of HTTP methods as a third argument to route(); in such\n// cases, routing will match if any of the specified HTTP methods are provided.\n$app->route('/post', 'HandlePostCollection', ['GET', 'POST']);\n\n// Matching NO HTTP methods\n// Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be\n// honored. (In FastRoute, GET is also honored.)\n$app->route('/post', 'WillThisHandlePost', []);  Finally, if desired, you can create a  Zend\\Expressive\\Router\\Route  instance\nmanually and pass it to  route()  as the sole argument:  $route = new Route('/post', 'HandlePost', ['GET', 'POST']);\n$route->setOptions($options);\n\n$app->route($route);",
            "title": "Routing"
        },
        {
            "location": "/v2/reference/usage-examples/#hello-world-using-a-container",
            "text": "Expressive works with  PSR-11 Containers ,\nthough it's an optional feature. By default, if you use the  AppFactory , it\nwill use  zend-servicemanager \nso long as that package is installed.  In the following example, we'll populate the container with our middleware, and\nthe application will pull it from there when matched.  Edit your  public/index.php  to read as follows:  use Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Diactoros\\Response\\TextResponse;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$container = new ServiceManager();\n\n$container->setFactory('HelloWorld', function ($container) {\n    return function ($request, DelegateInterface $delegate) {\n        return new TextResponse('Hello, world!');\n    };\n});\n\n$container->setFactory('Ping', function ($container) {\n    return function ($request, DelegateInterface $delegate) {\n        return new JsonResponse(['ack' => time()]);\n    };\n});\n\n$app = AppFactory::create($container);\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n$app->run();  In the example above, we pass our container to  AppFactory . We could have also\ndone this instead:  $app = AppFactory::create();\n$container = $app->getContainer();  and then added our service definitions. We recommend passing the container to\nthe factory instead; if we ever change which container we use by default, your\ncode might not work!  The following two lines are the ones of interest:  $app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');  These map the two paths to  service names  instead of callables. When routing\nmatches a path, it does the following:   If the middleware provided when defining the route is callable, it uses it\n  directly.  If the middleware is a valid service name in the container, it pulls it from\n  the container.  This is what happens in this example.  Finally, if no container is available, or the service name is not found in the\n  container, it checks to see if it's a valid class name; if so, it instantiates\n  and returns the class instance.   If you fire up your web server, you'll find that the  /  and  /ping  paths\ncontinue to work.  One other approach you could take would be to define the application itself in\nthe container, and then pull it from there:  $container->setFactory('Zend\\Expressive\\Application', function ($container) {\n    $app = AppFactory::create($container);\n    $app->get('/', 'HelloWorld');\n    $app->get('/ping', 'Ping');\n    return $app;\n});\n\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();  This is a nice way to encapsulate the application creation. You could then\npotentially move all service configuration to another file! (We already document an ApplicationFactory for exactly this scenario. )",
            "title": "Hello World using a Container"
        },
        {
            "location": "/v2/reference/usage-examples/#hello-world-using-a-configuration-driven-container",
            "text": "In the above example, we configured our middleware as services, and then passed\nour service container to the application. At the end, we hinted that you could\npotentially define the application itself as a service.  Expressive already provides a service factory for the application instance\nto provide fine-grained control over your application. In this example, we'll\nleverage it, defining our routes via configuration.  First, we're going to leverage zend-config to merge configuration files. This is\nimportant, as it allows us to define local, environment-specific configuration\nin files that we then can exclude from our repository. This practice ensures\nthat things like credentials are not accidentally published in a public\nrepository, and also provides a mechanism for slip-streaming in\nconfiguration based on our environment (you might use different settings in\ndevelopment than in production, after all!).  First, install zend-config and zend-stdlib:  $ composer require zendframework/zend-config zendframework/zend-stdlib  Now we can start creating our configuration files and container factories.  In  config/config.php , place the following:  <?php\n\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Stdlib\\Glob;\n\n$config = [];\n// Load configuration from autoload path\nforeach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) {\n    $config = ArrayUtils::merge($config, include $file);\n}\n\n// Return an ArrayObject so we can inject the config as a service in Aura.Di\n// and still use array checks like ``is_array``.\nreturn new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS);  In  config/container.php , place the following:  <?php\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// Load configuration\n$config = require __DIR__.'/config.php';\n\n// Build container\n$container = new ServiceManager();\n(new Config($config['dependencies']))->configureServiceManager($container);\n\n// Inject config\n$container->setService('config', $config);\n\nreturn $container;  In  config/autoload/dependencies.global.php , place the following:  <?php\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            \\Application\\HelloWorldAction::class => InvokableFactory::class,\n            \\Application\\PingAction::class => InvokableFactory::class,\n        ],\n        'factories' => [\n            \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class,\n        ],\n    ]\n];  In  config/autoload/routes.global.php , place the following:  <?php\n\nreturn [\n    'routes' => [\n        [\n            'path' => '/',\n            'middleware' => \\Application\\HelloWorldAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n        [\n            'path' => '/ping',\n            'middleware' => \\Application\\PingAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n    ],\n];  In  src/Application/HelloWorld.php , place the following:  <?php\nnamespace Application;\n\nclass HelloWorld\n{\n    public function __invoke($req, $res, $next)\n    {\n        $res->getBody()->write('Hello, world!');\n        return $res;\n    }\n}  In  src/Application/Ping.php , place the following:  <?php\nnamespace Application;\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass Ping\n{\n    public function __invoke($req, $res, $next)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}  After that\u2019s done run:  composer dump-autoload  Finally, in  public/index.php , place the following:  <?php\n// Change to the project root, to simplify resolving paths\nchdir(dirname(__DIR__));\n\n// Setup autoloading\nrequire 'vendor/autoload.php';\n\n$container = include 'config/container.php';\n$app       = $container->get(Zend\\Expressive\\Application::class);\n$app->run();  Notice that our index file now doesn't have any code related to setting up the\napplication any longer! All it does is setup autoloading, retrieve our service\ncontainer, pull the application from it, and run it. Our choices for container,\nrouter, etc. are all abstracted, and if we change our mind later, this code will\ncontinue to work.  Firing up the web server, you'll see the same responses as the previous\nexamples.",
            "title": "Hello World using a Configuration-Driven Container"
        },
        {
            "location": "/v2/reference/usage-examples/#hybrid-container-and-programmatic-creation",
            "text": "The above example may look a little daunting at first. By making everything\nconfiguration-driven, you sometimes lose a sense for how the code all fits\ntogether.  Fortunately, you can mix the two. Building on the example above, we'll add a new\nroute and middleware. Between pulling the application from the container and\ncalling  $app->run() , add the following in your  public/index.php :  $app->post('/post', function ($request, \\Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) {\n    return new \\Zend\\Diactoros\\Response\\TextResponse('IN POST!');\n});  Note that we're using  post()  here; that means you'll have to use cURL, HTTPie,\nPostman, or some other tool to test making a POST request to the path:  $ curl -X POST http://localhost:8080/post  You should see  IN POST!  for the response!  Using this approach, you can build re-usable applications that are\ncontainer-driven, and add one-off routes and middleware as needed.",
            "title": "Hybrid Container and Programmatic Creation"
        },
        {
            "location": "/v2/reference/usage-examples/#using-the-container-to-register-middleware",
            "text": "If you use a container to fetch your application instance, you have an\nadditional option for specifying middleware for the pipeline: configuration:  <?php\nreturn [\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware Service Name or Callable',\n            'allowed_methods' => ['GET', 'POST', 'PATCH'],\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n    'middleware_pipeline' => [\n        // See specification below\n    ],\n];  The key to note is  middleware_pipeline , which is an array of middlewares to\nregister in the pipeline; each will each be  pipe() 'd to the Application in the\norder specified.  Each middleware specified must be in the following form:  [\n    // required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // optional:\n    'path'  => '/path/to/match',\n    'priority' => 1, // Integer\n]  Priority should be an integer, and follows the semantics of SplPriorityQueue : higher numbers indicate\nhigher priority (top of the queue; executed earliest), while lower numbers\nindicated lower priority (bottom of the queue, executed last);  negative values\nare low priority . Items of the same priority are executed in the order in which\nthey are attached.  The default priority is 1, and this priority is used by the routing and dispatch\nmiddleware. To indicate that middleware should execute  before  these, use a\npriority higher than 1.  The above specification can be used for all middleware, with one exception:\nregistration of the  routing  and/or  dispatch  middleware that Expressive\nprovides. In these cases, use the following constants, which will be caught by\nthe factory and expanded:   Zend\\Expressive\\Application::ROUTING_MIDDLEWARE  for the\n  routing middleware; this should always come before the dispatch middleware.  Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE  for the\n  dispatch middleware.   As an example:  return [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n        Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n        [ /* ... */ ],\n    ],\n];",
            "title": "Using the container to register middleware"
        },
        {
            "location": "/v2/reference/usage-examples/#place-routing-middleware-correctly",
            "text": "If you are defining routes  and  defining other middleware for the pipeline,\nyou  must  add the routing middleware. When you do so, make sure you put\nit at the appropriate location in the pipeline.  Typically, you will place any middleware you want to execute on all requests\nprior to the routing middleware. This includes utilities for bootstrapping\nthe application (such as injection of the  ServerUrlHelper ),\nutilities for injecting common response headers (such as CORS support), etc.\nMake sure these middleware specifications include the  priority  key, and that\nthe value of this key is greater than 1.  Use priority to shape the specific workflow you want for your middleware.   Middleware items may be any  valid middleware ,\nincluding  arrays  of middleware, which indicate a nested middleware pipeline;\nthese may even contain the routing and dispatch middleware constants:  return [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Application::ROUTING_MIDDLEWARE,\n                /* ... middleware that introspects routing results ... */\n                Zend\\Expressive\\Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        [ /* ... */ ],\n    ],\n];",
            "title": "Place routing middleware correctly"
        },
        {
            "location": "/v2/reference/usage-examples/#pipeline-keys-are-ignored",
            "text": "Keys in a  middleware_pipeline  specification are ignored. However, they can\nbe useful when merging several configurations; if multiple configuration files\nspecify the same key, then those entries will be merged. Be aware, however,\nthat the  middleware  entry for each, since it is an indexed array, will\nmerge arrays by appending; in other words, order will not be guaranteed within\nthat array after merging. If order is critical, define a middleware spec with priority  keys.   The path, if specified, can only be a literal path to match, and is typically\nused for segregating middleware applications or applying rules to subsets of an\napplication that match a common path root.",
            "title": "Pipeline keys are ignored"
        },
        {
            "location": "/v2/reference/usage-examples/#segregating-your-application-to-a-subpath",
            "text": "One benefit of a middleware-based application is the ability to compose\nmiddleware and segregate them by paths.  Zend\\Expressive\\Application  is itself\nmiddleware, allowing you to do exactly that if desired.  In the following example, we'll assume that  $api  and  $blog  are Zend\\Expressive\\Application  instances, and compose them into a Zend\\Stratigility\\MiddlewarePipe .  use Zend\\Diactoros\\Server;\nuse Zend\\Diactoros\\ServerRequestFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$server = Server::createServerFromRequest(\n    $app,\n    ServerRequestFactory::fromGlobals()\n);\n$server->listen();  You could also compose them in an  Application  instance, and utilize  run() :  $app = AppFactory::create();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$app->run();  This approach allows you to develop discrete applications and compose them\ntogether to create a website.",
            "title": "Segregating your application to a subpath"
        },
        {
            "location": "/v2/reference/expressive-projects/",
            "text": "Projects powered by zend-expressive\n\n\nzend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.\n\n\nSample Code & Tutorials\n\n\n\n\nExpressive Tutorial (WIP) - \nsource\n\n\nAstroSplash\n - \nsource\n\n  (Also, read the \nrelated article on sitepoint\n)\n\n\nphp-ddd-cargo-sample\n - \nsource\n\n\n\n\nPersonal Sites\n\n\n\n\nmwop.net\n - \nsource\n\n\nxtreamwayz.com\n - \nsource\n\n\nalejandrocelaya.com\n - \nsource\n\n\nzimuel.it\n - \nsource",
            "title": "Expressive Projects"
        },
        {
            "location": "/v2/reference/expressive-projects/#projects-powered-by-zend-expressive",
            "text": "zend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.",
            "title": "Projects powered by zend-expressive"
        },
        {
            "location": "/v2/reference/expressive-projects/#sample-code-tutorials",
            "text": "Expressive Tutorial (WIP) -  source  AstroSplash  -  source \n  (Also, read the  related article on sitepoint )  php-ddd-cargo-sample  -  source",
            "title": "Sample Code &amp; Tutorials"
        },
        {
            "location": "/v2/reference/expressive-projects/#personal-sites",
            "text": "mwop.net  -  source  xtreamwayz.com  -  source  alejandrocelaya.com  -  source  zimuel.it  -  source",
            "title": "Personal Sites"
        },
        {
            "location": "/v2/reference/migration/",
            "text": "Migration to Expressive 2.0\n\n\nExpressive 2.0 should not result in many upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:\n\n\n\n\nSignature changes\n\n\nRemoved functionality\n\n\nDeprecated functionality\n\n\nPSR-11 support\n\n\nUsage of http-interop middleware\n\n\nOriginal request and response messages\n\n\nError handling\n\n\nFinal handlers become default delegates\n\n\nProgrammatic middleware pipelines\n\n\nImplicit handling of \nHEAD\n and \nOPTIONS\n requests\n\n\nRouterInterface changes\n\n\nURL helper changes\n\n\nzend-view renderer changes\n\n\nTwig renderer changes\n\n\nAdopting a modular architecture\n\n\n\n\nSignature changes\n\n\nThe following signature changes were made that could affect \nclass extensions\n:\n\n\n\n\nZend\\Expressive\\Application::__call($method, array $args)\n: previously, the\n  \n$args\n argument was not typehinted; it now is. If you are extending this\n  class and overriding that method, you will need to update your method\n  signature accordingly.\n\n\n\n\nAdditionally, a number of signatures change due to updating Expressive to\nsupport \nPSR-11\n instead of\n\ncontainer-interop\n\n(which was the basis for PSR-11). Essentially, these were a matter of updating\ntypehints on \nInterop\\Container\\ContainerInterface\n to\n\nPsr\\Container\\ContainerInterface\n. Signatures affected include:\n\n\n\n\nZend\\Expressive\\AppFactory::create()\n\n\nZend\\Expressive\\Application::__construct()\n\n\nZend\\Expressive\\Container\\ApplicationFactory::__invoke()\n\n\nZend\\Expressive\\Container\\ErrorHandlerFactory::__invoke()\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory::__invoke()\n\n\nZend\\Expressive\\Container\\NotFoundDelegateFactory::__invoke()\n\n\nZend\\Expressive\\Container\\NotFoundHandlerFactory::__invoke()\n\n\nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::__invoke()\n\n\nZend\\Expressive\\Container\\WhoopsFactory::__invoke()\n\n\nZend\\Expressive\\Container\\WhoopsPageHandlerFactory::__invoke()\n\n\n\n\nIn each of the above cases, updating your import statements from\n\nInterop\\Container\\ContainerInterface\n to \nPsr\\Container\\ContainerInterface\n\nwill make your code work again.\n\n\nThe following exceptions now implement PSR-11 exception interfaces instead of container-interop variants:\n\n\n\n\nZend\\Expressive\\Container\\Exception\\InvalidServiceException\n\n\n\n\nIn the above case, if you were previously catching the container-interop\nexception on which it was based, your code should still work so long as you\nhave container-interop installed. You should likely update it to catch the more\ngeneral \nPsr\\Container\\ContainerExceptionInterface\n instead, however.\n\n\nRemoved functionality\n\n\nThe following classes and/or methods were removed for the Expressive 2.0\nrelease:\n\n\n\n\n\n\nZend\\Expressive\\Application::pipeErrorHandler()\n. Stratigility 2.0 dropped\n  its \nErrorMiddlewareInterface\n and the concept of error middleware (middleware\n  supporting an additional \n$error\n argument in its signature); this method was\n  thus no longer relevant.\n\n\n\n\n\n\nZend\\Expressive\\Application::routeMiddleware()\n. Routing middleware was\n  extracted to the class \nZend\\Expressive\\Middleware\\RouteMiddleware\n.\n\n\n\n\n\n\nZend\\Expressive\\Application::dispatchMiddleware()\n. Dispatch middleware was\n  extracted to the class \nZend\\Expressive\\Middleware\\DispatchMiddleware\n.\n\n\n\n\n\n\nZend\\Expressive\\Application::getFinalHandler()\n. Stratigility 2 supports the\n  http-interop/http-middleware project, and now uses \ndelegates\n. This method\n  was renamed to \ngetDefaultDelegate()\n, and now returns an\n  \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instance.\n\n\n\n\n\n\nZend\\Expressive\\Container\\Exception\\InvalidArgumentException\n. This exception\n  was thrown by \nZend\\Expressive\\Container\\ApplicationFactory\n previously; that\n  class now throws \nZend\\Expressive\\Exception\\InvalidArgumentException\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Container\\Exception\\NotFoundException\n. This exception type\n  was never used internally.\n\n\n\n\n\n\nZend\\Expressive\\ErrorMiddlewarePipe\n. With the removal of Stratigility 1\n  error middleware, this specialized \nMiddlewarePipe\n no longer has any use.\n\n\n\n\n\n\nZend\\Expressive\\Container\\TemplatedErrorHandlerFactory\n. See the section on\n  \nfinal handler changes\n for more\n  information.\n\n\n\n\n\n\nZend\\Expressive\\Container\\WhoopsErrorHandlerFactory\n. See the section on\n  \nfinal handler changes\n for more\n  information.\n\n\n\n\n\n\nZend\\Expressive\\TemplatedErrorHandler\n. See the section on\n  \nfinal handler changes\n for more\n  information.\n\n\n\n\n\n\nZend\\Expressive\\WhoopsErrorHandler\n. See the section on\n  \nfinal handler changes\n for more\n  information.\n\n\n\n\n\n\nDeprecated functionality\n\n\n\n\nZend\\Expressive\\Application::raiseThrowables()\n. Stratigility 2.0 makes the\n  method a no-op, as exceptions are no longer caught by the middleware\n  dispatcher. As such, the \nraise_throwables\n configuration argument now is no\n  longer used, either.\n\n\n\n\nPSR-11 support\n\n\nIn previous versions of Expressive, we consumed\n\ncontainer-interop\n,\nwhich provides \nInterop\\Container\\ContainerInterface\n, a shared interface for\ndependency injection containers. container-interop served as a working group for the\n\nPSR-11\n specification.\n\n\nIn the weeks prior to the Expressive 2.0 release, PSR-11 was formally accepted,\nand the package \npsr/container\n was released. As such, we have updated\nExpressive to consume the interfaces PSR-11 exposes.\n\n\nNo supported implementations currently directly implement PSR-11, however.\nFortunately, the container-interop 1.2.0 release acts as a\nforwards-compatibility measure by altering every interface it exposes to extend\nthose from PSR-11, making existing container-interop implementations \nde facto\n\nPSR-11 implementations!\n\n\nThe result is a (mostly) transparent upgrade for users of Expressive. As newer\nversions of container implementations are released supporting PSR-11 directly,\nyou will be able to upgrade immediately; we will also periodically update the\nskeleton to pick up these new versions when present. (The one caveat to\nupgrading is \nsignature changes\n within Expressive classes\nbased on the new psr/container interface names.)\n\n\nAs long as you have container-interop 1.2.0 installed, your existing factories\nthat typehint against its interface will continue to work. However, we\nrecommend updating them to instead typehint against PSR-11, which will allow\nyou to drop the container-interop requirement once your chosen container\nimplementation no longer requires it.\n\n\n\n\nDo not update blindly!\n\n\nIf you are implementing interfaces from other packages in your factory\nimplementations, be sure to check and see if those interfaces update to PSR-11\nbefore making changes.\n\n\nAs an example, zend-servicemanager v3 does not update\n\nZend\\ServiceManager\\Factory\\FactoryInterface\n and siblings to typehint\nagainst PSR-11, as doing so would break backwards compatibility.\n\n\n\n\nhttp-interop\n\n\nStratigility 2.0 provides the ability to work with \nhttp-interop middleware\n0.4.1\n.\n\n\nThis specification, which is being developed as the basis of\n\nPSR-15\n, defines what is known as \nlambda\n\nor \nsingle-pass\n middleware, vs the \ndouble-pass\n middleware traditionally used\nby Stratigility and Expressive.\n\n\nDouble-pass refers to the fact that two arguments are passed to the delegation\nfunction \n$next\n: the request and response. Lambda or single-pass middleware\nonly pass a single argument, the request.\n\n\nStratigility 2.0 provides support for dispatching either style of middleware.\n\n\nSpecifically, your middleware can now implement:\n\n\n\n\nInterop\\Http\\ServerMiddleware\\MiddlewareInterface\n, which defines a single\n  method, \nprocess(Psr\\Http\\Message\\ServerRequestInterface $request,\n  Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate)\n.\n\n\nCallable middleware that follows the above signature (the typehint for the\n  request argument is optional).\n\n\n\n\nBoth styles of middleware may be piped directly to the middleware pipeline or as\nrouted middleware within Expressive. In each case, you can invoke the\nnext middleware layer using \n$delegate->process($request)\n.\n\n\nIn Expressive 2.0, \nApplication\n will continue to accept the legacy double-pass\nsignature, but will require that you either:\n\n\n\n\nProvide a \n$responsePrototype\n (a \nResponseInterface\n instance) to the\n  \nApplication\n instance prior to piping or routing such middleware.\n\n\nDecorate the middleware in a \nZend\\Stratigility\\Middleware\\CallableMiddlewareWrapper\n\n  instance (which also requires a \n$responsePrototype\n).\n\n\n\n\nIf you use \nZend\\Expressive\\Container\\ApplicationFactory\n to create your\n\nApplication\n instance, a response prototype will be injected for you from the\noutset.\n\n\nWe recommend that you begin writing middleware to follow the http-interop\nstandard at this time. As an example:\n\n\nnamespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass XClacksOverheadMiddleware implements MiddlewareInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n}\n\n\n\nAlternately, you can write this as a callable:\n\n\nnamespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass XClacksOverheadMiddleware\n{\n    /**\n     * @param ServerRequestInterface $request\n     * @param DelegateInterface $delegate\n     * @return ResponseInterface\n     */\n    public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n}\n\n\n\nOriginal messages\n\n\nIn the \nmigration to version 1.1 guide\n, we detail the fact that\nStratigility 1.3 deprecated its internal request and response decorators.\nStratigility 2.0, on which Expressive 2.0 is based, removes them entirely.\n\n\nIf your code relied on the various \ngetOriginal*()\n methods those decorators\nexposed, you will need to update your code in two ways:\n\n\n\n\nYou will need to add \nZend\\Stratigility\\Middleware\\OriginalMessages\n to your\n  middleware pipeline, as the outermost (or close to outermost) layer.\n\n\nYou will need to update your code to call on the request instance's\n  \ngetAttribute()\n method with one of \noriginalRequest\n, \noriginalUri\n, or\n  \noriginalResponse\n to retrieve the values.\n\n\n\n\nTo address the first point, see the \nExpressive 1.1 migration\ndocumentation\n, which\ndetails how to update your configuration or programmatic pipeline.\n\n\nFor the second point, we provide a tool via the\n\nzendframework/zend-expressive-tooling\n\npackage which will help you in this latter part of the migration. Install it as\na development requirement via composer:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nAnd then execute it via:\n\n\n$ ./vendor/bin/expressive-migrate-original-messages\n\n\n\nThis tool will update calls to \ngetOriginalRequest()\n and \ngetOriginalUri()\n to\ninstead use the new request attributes that the \nOriginalMessages\n middleware\ninjects:\n\n\n\n\ngetOriginalRequest()\n becomes \ngetAttribute('originalRequest', $request)\n\n\ngetOriginalUri()\n becomes \ngetAttribute('originalUri', $request->getUri())\n\n\n\n\nIn both cases, \n$request\n will be replaced with whatever variable name you used\nfor the request instance.\n\n\nFor \ngetOriginalResponse()\n calls, which happen on the response instance, the\ntool will instead tell you what files had such calls, and detail how you can\nupdate those calls to use the \noriginalResponse\n request attribute.\n\n\nError handling\n\n\nAs noted in the \nExpressive 1.1 migration docs\n,\nStratigility 1.3 introduced the ability to tell it to no longer catch exceptions\ninternally, paving the way for middleware-based error handling. Additionally, it\ndeprecated its own \nErrorMiddlewareInterface\n and duck-typed implementations of\nthe interface in favor of middleware-based error handling. Finally, it\ndeprecated the \n$e\n/\n$error\n argument to \"final handlers\", as that argument\nwould be used only when attempting to invoke \nErrorMiddlewareInterface\n\ninstances.\n\n\nStratigility 2.0, on which Expressive 2.0 is based, no longer catches exceptions\ninternally, removes the \nErrorMiddlewareInterface\n entirely, and thus the\n\n$e\n/\n$error\n argument to final handlers.\n\n\nAs such, you \nMUST\n provide your own error handling with Expressive 2.0.\n\n\nError handling middleware will typically introduce a try/catch block:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    try {\n        $response = $next($request, $response);\n        return $response;\n    } catch (\\Throwable $exception) {\n        // caught PHP 7 throwable\n    } catch (\\Exception $exception) {\n        // caught PHP 5 exception\n    }\n\n    // ...\n    // do something with $exception and generate a response\n    // ...\n\n    return $response;\n}\n\n\n\nAdditionally, you will need middleware registered as your innermost layer that\nis guaranteed to return a response. Generally, if you hit that layer, no other\nmiddleware is capable of handling the request, indicating a 400 (Bad Request) or\n404 (Not Found) HTTP status. With the combination of an error handler at the\noutermost layer, and a \"not found\" handler at the innermost layer, you can\nhandle any error in your application.\n\n\nStratigility 1.3 and 2.0 provide an error handler implementation via\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n. In addition to the try/catch block,\nit also sets up a PHP error handler that will catch any PHP error types in the\ncurrent \nerror_reporting\n mask; the error handler will raise exceptions of the\ntype \nErrorException\n with the PHP error details.\n\n\nErrorHandler\n allows injection of an \"error response generator\", which allows\nyou to alter how the error response is generated based on the current\nenvironment. Error response generators are callables with the signature:\n\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nExpressive 2.0 provides the following functionality to assist with your error\nhandling needs:\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\ErrorResponseGenerator\n will output a canned\n  plain/text message, or use a supplied template renderer to generate content\n  for the response. It accepts the following arguments to its constructor:\n\n\n\n\n\n\n$isDevelopmentMode = false\n: whether or not the application is in\n  development mode. If so, it will output stack traces when no template\n  renderer is used (see below), or supply the exception to the template via\n  the \nerror\n variable if a renderer is present.\n\n\n\n\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface $renderer\n: if\n  supplied, the results of rendering a template will be injected into\n  the response. Templates are passed the following variables:\n\n\n\n\nresponse\n: the response at the time of rendering\n\n\nrequest\n: the request at the time of rendering\n\n\nuri\n: the URI at the time of rendering\n\n\nstatus\n: the response status code\n\n\nreason\n: the response reason phrase\n\n\nerror\n: the exception; this is only provided when in development mode.\n\n\n\n\n\n\n\n\n$template = 'error::error'\n: the template to render, with a default value\n  if none is provided.\n\n\n\n\n\n\n\n\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory\n can create an\n  instance of the \nErrorResponseGenerator\n using the following:\n\n\n\n\n\n\nThe \ndebug\n top-level configuration value is used to set the\n  \n$isDevelopmentMode\n flag.\n\n\n\n\n\n\nIf a \nZend\\Expressive\\Template\\TemplateRendererInterface\n service is\n  registered, it will be provided to the constructor.\n\n\n\n\n\n\nThe value of \nzend-expressive.error_handler.template_error\n, if present,\n  will be used to seed the \n$template\n argument.\n\n\n\n\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator\n uses Whoops to\n  generate the error response. Its constructor takes a single argument, a\n  \nWhoops\\Run\n instance. If a \nWhoops\\Handler\\PrettyPageHandler\n is registered\n  with the instance, it will add a data table with request details derived from\n  the \nServerRequestInterface\n instance.\n\n  \nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory\n can create an\n  instance, and will use the \nZend\\Expressive\\Whoops\n service to seed the\n  \nWhoops\\Run\n argument.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\NotFoundHandler\n can be used as the innermost\n  layer of your pipeline in order to return a 404 response. (Typically, if you\n  get to the innermost layer, no middleware was able to handle the request,\n  indicating a 404.) By default, it will produce a canned plaintext response.\n  However, you can also provide an optional \nTemplateRendererInterface\n instance\n  and \n$template\n in order to provided templated content.\n\n  The constructor arguments are:\n\n\n\n\n\n\nResponseInterface $responsePrototype\n: this is an empty response on which\n  to set the 404 status and inject the 404 content.\n\n\n\n\n\n\nTemplateRendererInterface $renderer\n: optionally, you may provide a\n  renderer to use in order to provide templated response content.\n\n\n\n\n\n\n$template = 'error::404'`: optionally, you may provide a\n  template to render; if none is provided, a sane default is used.\n\n\n\n\n\n\n\n\n\n\nZend\\Expressive\\Container\\NotFoundHandlerFactory\n can create an instance of\n  the \nNotFoundHandler\n for you, and will use the following to do so:\n\n\n\n\n\n\nThe \nZend\\Expressive\\Template\\TemplateRendererInterface\n service, if\n  available.\n\n\n\n\n\n\nThe \nzend-expressive.error_handler.template_404\n configuration value, if\n  available, will be used for the \n$template\n.\n\n\n\n\n\n\n\n\n\n\nZend\\Expressive\\Container\\ErrorHandlerFactory\n will create an instance of\n  \nZend\\Stratigility\\Middleware\\ErrorHandler\n, and use the\n  \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n service to seed\n  it.\n\n  As such, register one of the following as a factory for the\n  \nZend\\Stratigility\\Middleware\\ErrorResponseGenerator\n service:\n\n\n\n\nZend\\Expressive\\Container\\ErrorResponseGeneratorFactory\n\n\nZend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory\n\n\n\n\n\n\n\n\nError handler configuration example\n\n\nIf you are using configuration-driven middleware, your middleware pipeline\nconfiguration may look like this in order to make use of the new error handling\nfacilities:\n\n\n// config/autoload/middleware-pipeline.global.php\n\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    // Add the following section to enable the new error handling:\n    'zend-expressive' => [\n        'raise_throwables' => true,\n    ],\n\n    'dependencies' => [\n        'invokables' => [\n            // See above section on \"Original messages\":\n            OriginalMessages::class => OriginalMessages::class,\n        ],\n        'factories' => [\n            Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class,\n            Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class,\n\n            // Add the following three entries:\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n            Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class,\n        ],\n    ],\n\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                OriginalMessages::class,\n                Helper\\ServerUrlMiddleware::class,\n                ErrorHandler::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n\n        'routing' => [\n            'middleware' => [\n                Application::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        'not-found' => [\n            'middleware' => Middleware\\NotFoundHandler::class,\n            'priority' => 0,\n        ],\n\n        // Remove the section \"error\"\"\n    ],\n];\n\n\n\nIf you are defining a programmatic pipeline (see more below on this), the\npipeline might look like:\n\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(Helper\\UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(Middleware\\NotFoundHandler::class);\n\n\n\nError handling and PHP errors\n\n\nAs noted above, \nZend\\Stratigility\\Middleware\\ErrorHandler\n also creates a PHP\nerror handler that casts PHP errors to \nErrorException\n instances. More\nspecifically, it uses the current \nerror_reporting\n value to determine \nwhich\n\nerrors it should cast this way.\n\n\nThis can be problematic when deprecation errors are triggered.  If they are cast\nto exceptions, code that would normally run will now result in error pages.\n\n\nWe recommend adding the following line to your \npublic/index.php\n towards the\ntop of the file:\n\n\nerror_reporting(error_reporting() & ~E_USER_DEPRECATED);\n\n\n\nThis will prevent the error handler from casting deprecation notices to\nexceptions, while keeping the rest of your error reporting mask intact.\n\n\nRemoving legacy error middleware\n\n\nStratigility version 1-style error middleware (middleware implementing\n\nZend\\Stratigility\\ErrorMiddlewareInterface\n, or duck-typing its signature,\nwhich included an \n$error\n argument as the first argument to the middleware) is\nno longer supported with Stratigility version 2 and Expressive 2.0. You will\nneed to find any instances of them in your application, or cases where your\nmiddleware invokes error middleware via the third argument to \n$next()\n.\n\n\nWe provide a tool to assist you with that via the package\n\nzendframework/zend-expressive-tooling\n:\n\nvendor/bin/expressive-scan-for-error-middleware\n. Run the command from your\nproject root, optionally passing the \nhelp\n, \n--help\n, or \n-h\n commands for\nusage. The tool will detect each of these for you, flagging them for you to\nupdate or remove.\n\n\nFinal handlers become default delegates\n\n\nOne ramification of supporting \nhttp-interop middleware\n is that\nthe concept of \"final handlers\" changes. In Stratigility 1.X and Expressive 1.X,\na \"final handler\" was invoked when the middleware pipeline was exhausted;\nhowever, due to how Stratigility caught exceptions, this also meant that the\nfinal handler often acted as the application error handler, reporting errors to\nend users.\n\n\nWith the \nerror handling changes noted above\n, error handling\nis moved to dedicated middleware. However, there is still a need to have\nsomething that can execute once the middleware pipeline is exhausted. Such a\nsituation typically indicates no middleware was able to handle the request, or\nthat the request was somehow malformed.\n\n\nIn Expressive 2.0, we have removed final handlers, and replaced them with the\nconcept of \"default delegates\". \nDelegates\n are\n\nInterop\\Http\\ServerMiddleware\\DelegateInterface\n instances, which are invoked\nby middleware when they wish to \ndelegate\n processing of the request to\nsomething else. Internally, Stratigility 2.0 and Expressive 2.0 use a delegate\nto iterate through the middleware pipeline. For Expressive 2.0, a \ndefault\ndelegate\n is a delegate executed when the application's internal middleware\npipeline is exhausted.\n\n\nThe ramifications for end users are as follows:\n\n\n\n\n\n\nThe \n$finalHandler\n argument to \nApplication\n's constructor, which previously\n  was a \ncallable\n, is now called \n$defaultDelegate\n, and needs to be a\n  \nDelegateInterface\n instance.\n\n\n\n\n\n\ngetFinalHandler()\n no longer exists; we have \nadded\n \ngetDefaultDelegate()\n.\n\n\n\n\n\n\nThe service \nZend\\Expressive\\FinalHandler\n is no longer used. A new service,\n  \nZend\\Expressive\\Delegate\\DefaultDelegate\n, is used by \nApplicationFactory\n,\n  and, if present, will be used to inject the \n$defaultDelegate\n argument of the\n  \nApplication\n constructor.\n\n\n\n\n\n\nWe have removed the following classes, which either provided final handlers,\n  or acted as factories for them:\n\n\n\n\nZend\\Expressive\\TemplatedErrorHandler\n\n\nZend\\Expressive\\WhoopsErrorHandler\n\n\nZend\\Expressive\\Container\\TemplatedErrorHandlerFactory\n\n\nZend\\Expressive\\Container\\WhoopsErrorHandlerFactory\n\n\n\n\n\n\n\n\nIf you use the \nvendor/bin/expressive-pipeline-from-config\n tool to migrate your\napplication to programmatic pipelines, as described below, the \nDefaultDelegate\n\nservice will be mapped to \nZend\\Expressive\\Container\\NotFoundDelegateFactory\n,\nwhich will provide an instance of \nZend\\Expressive\\Delegate\\NotFoundDelegate\n.\nThis new class will produce a 404 response, using a template if the\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n service is present, but\notherwise producing a plain text response.\n\n\nApplication's built using the 2.0 version of the skeleton application will have\nthese features enabled by default.\n\n\n\n\nNotFoundDelegate and NotFoundHandler\n\n\nZend\\Expressive\\Middleware\\NotFoundHandler\n, which is intended as innermost\nmiddleware for producing a 404 response, composes and proxies to a\n\nNotFoundDelegate\n instance to produce its response.\n\n\n\n\nProgrammatic middleware pipelines\n\n\nStarting with Expressive 1.1, we recommended \nprogrammatic creation of\npipelines and routing\n; the \nExpressive 1.1 migration\nguide\n\nprovides more detail.\n\n\nWith Expressive 2.0, this is now the \ndefault\n option shipped in the skeleton.\n\n\nIf you are upgrading from version 1 and are not currently using programmatic\npipelines, we provide a migration tool that will convert your application to do\nso. The tool is available via the package\n\nzendframework/zend-expressive-tooling\n.\nYou may install this package in one of the following ways:\n\n\n\n\nVia the vendor binary \n./vendor/bin/expressive-tooling\n:\n\n\n\n\n$ ./vendor/bin/expressive-tooling        # install\n$ ./vendor/bin/expressive-tooling remove # uninstall\n\n\n\n\n\nUsing Composer:\n\n\n\n\n$ composer require --dev zendframework/zend-expressive-tooling # install\n$ composer remove --dev zendframework/zend-expressive-tooling  # uninstall\n\n\n\nOnce installed, you will use the \nvendor/bin/expressive-pipeline-from-config\n\ncommand.\n\n\nThis command does the following:\n\n\n\n\n\n\nReads your \nmiddleware_pipeline\n configuration, and generates a programmatic\n  pipeline for you, which is then stored in \nconfig/pipeline.php\n. The generated\n  pipeline contains the following additions:\n\n\n\n\n\n\nThe first middleware in the pipeline is \nZend\\Stratigility\\Middleware\\OriginalMessages\n,\n  which injects the incoming request, URI, and response as the request\n  attributes \noriginalRequest\n, \noriginalUri\n, and \noriginalResponse\n,\n  respectively. (This can aid URI generation in nested middleware later.)\n\n\n\n\n\n\nThe second middleware in the pipeline is \nZend\\Stratigility\\Middleware\\ErrorHandler\n.\n\n\n\n\n\n\nThe last middleware in the pipeline is \nZend\\Expressive\\Middleware\\NotFoundHandler\n.\n\n\n\n\n\n\n\n\n\n\nReads your \nroutes\n configuration, and generates a programmatic\n  routing table for you, which is then stored in \nconfig/routes.php\n.\n\n\n\n\n\n\nAdds a new configuration file, \nconfig/autoload/programmatic-pipeline.global.php\n,\n  which enables the \nprogrammatic_pipelines\n configuration flag. Additionally,\n  it adds dependency configuration for the new error handlers.\n\n\n\n\n\n\nInserts two lines before the \n$app->run()\n statement of your\n  \npublic/index.php\n, one each to require \nconfig/pipeline.php\n and\n  \nconfig/routes.php\n.\n\n\n\n\n\n\nYour \nmiddleware_pipeline\n and \nroutes\n configuration are not removed at this\ntime, to allow you to test and verify your application first; however, due to\nthe configuration in \nconfig/autoload/programmatic-pipeline.global.php\n, these\nare now ignored.\n\n\nIf you wish to use Whoops in your development environment, you may add the\nfollowing to a local configuration file (e.g., \nconfig/autoload/local.php\n):\n\n\nuse Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory;\nuse Zend\\Expressive\\Middleware\\ErrorResponseGenerator;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorResponseGenerator::class => WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];\n\n\n\nOther things you may want to do:\n\n\n\n\n\n\nThe \nErrorHandler\n entry could potentially be moved inwards a few layers. As\n  an example, the \nServerUrlMiddleware\n has no possibility of raising an\n  exception or error, and could be moved outwards; you could do similarly for\n  any middleware that only injects additional response headers.\n\n\n\n\n\n\nRemove any Stratigility-style error middleware (middleware expecting an error\n  as the first argument). If any specialized error handling should occur, add\n  additional middleware into the pipeline that can catch exceptions, and have\n  that middleware re-throw for exceptions it cannot handle. (Use the\n  \nvendor/bin/expressive-scan-for-error-middleware\n command from\n  zendframework/zend-expressive-tooling to assist in this.)\n\n\n\n\n\n\nConsider providing your own \nZend\\Stratigility\\NoopFinalHandler\n\n  implementation; this will now only be invoked if the queue is exhausted, and\n  could return a generic 404 page, raise an exception, etc.\n\n\n\n\n\n\nHandling HEAD and OPTIONS requests\n\n\nPrior to 2.0, it was possible to route middleware that could not handle \nHEAD\n\nand/or \nOPTIONS\n requests. Per \nRFC 7231, section 4.1\n,\n\"all general-purpose servers MUST support the methods GET and HEAD. All other\nmethods are OPTIONAL.\" Additionally, most servers and implementors agree that\n\nOPTIONS\n \nshould\n be supported for any given resource, so that consumers can\ndetermine what methods are allowed for the given resource.\n\n\nTo make this happen, the Expressive project implemented several features.\n\n\nFirst, zend-expressive-router 1.3.0 introduced several features in both\n\nZend\\Expressive\\Router\\Route\n and \nZend\\Expressive\\Router\\RouteResult\n to help\nconsumers implement support for \nHEAD\n and \nOPTIONS\n in an automated way. The\n\nRoute\n class now has two new methods, \nimplicitHead()\n and \nimplicitOptions()\n;\nthese each return a boolean \ntrue\n value if support for those methods is\n\nimplicit\n \u2014 i.e., not defined explicitly for the route. The \nRouteResult\n\nclass now introduces a new factory method, \nfromRoute()\n, that will create an\ninstance from a \nRoute\n instance; this then allows consumers of a \nRouteResult\n\nto query the \nRoute\n to see if a matched \nHEAD\n or \nOPTIONS\n request needs\nautomated handling. Each of the supported router implementations were updated to\nuse this method, as well as to return a successful routing result if \nHEAD\n\nand/or \nOPTIONS\n requests are submitted, but the route does not explicitly\nsupport the method.\n\n\nWithin Expressive itself, we now offer two new middleware to provide this\nautomation:\n\n\n\n\nZend\\Expressive\\Middleware\\ImplicitHeadMiddleware\n\n\nZend\\Expressive\\Middleware\\ImplicitOptionsMiddleware\n\n\n\n\nIf you want to support these methods automatically, each of these should be\nenabled between the routing and dispatch middleware. If you use the\n\nexpressive-pipeline-from-config\n tool as documented in the\n\nprogrammatic pipeline migration section\n,\nentries for each will be injected into your generated pipeline.\n\n\nPlease see the \nchapter on the implicit methods middleware\n\nfor more information on each.\n\n\nRouter interface changes\n\n\nExpressive 2.0 uses zendframework/zend-expressive-router 2.1+. Version 2.0 of\nthat package introduced a change to the \nZend\\Expressive\\Router\\RouterInterface::generateUri()\n\nmethod; it now accepts an additional, optional, third argument, \narray $options = []\n,\nwhich can be used to pass router-specific options when generating a URI. As an\nexample, the implementation that uses zendframework/zend-router might use these\noptions to pass a translator instance in order to translate a path segment to\nthe currently selected locale.\n\n\nFor consumers, his represents no backwards-incompatible change; consumers may\nopt-in to the new argument at will. For those implementing the interface,\nupgrading will require updating your router implementation's signature to match\nthe new interface:\n\n\npublic function generateUri(\n    string $name,\n    array $substitutions = [],\n    array $options = []\n) : string\n\n\n\nURL helper changes\n\n\nExpressive 2.0 uses zendframework/zend-expressive-helpers version 3.0+. This new\nversion updates the signature of the \nZend\\Expressive\\Helper\\UrlHelper\n from:\n\n\nfunction (\n    $routeName,\n    array $routeParams = []\n) : string\n\n\n\nto:\n\n\nfunction (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string\n\n\n\nFor consumers, this should represent a widening of features, and will not\nrequire any changes, unless you wish to opt-in to the new arguments. See the\n\nUrlHelper documentation\n for information\non each argument.\n\n\nFor any users who were \nextending\n the class, you will need to update your\nextension accordingly.\n\n\nzend-view renderer changes\n\n\nExpressive 2.0 will use zend-expressive-zendviewrenderer 1.3+ if that renderer\nis chosen. Starting with 1.3.0 of that renderer, you may now pass a boolean\n\nfalse\n value for the \nlayout\n variable when calling either \naddDefaultParam()\n\nor \nrender()\n on the renderer instance in order to disable the layout.\n\n\nTwig renderer changes\n\n\nExpressive 2.0 will use zend-expressive-twigrenderer 1.3+ if that renderer\nis chosen. Starting with 1.3.0 of that renderer, Twig 2.1+ is now supported.\n\n\nAdopting a modular architecture\n\n\nExpressive 2.0 ships with support for modular architectures from the outset, as\ndetailed in the \nchapter on modules\n.\n\n\nIf you wish to update your application to use these features, you will need to\ninstall the following packages:\n\n\n\n\nzendframework/zend-config-aggregator\n\n\nzendframework/zend-component-installer\n\n\n\n\nAs an example:\n\n\n$ composer require zendframework/zend-config-aggregator \\\n> zendframework/zend-component-installer\n\n\n\nOnce installed, you should update your \nconfig/config.php\n file to read as\nfollows:\n\n\n<?php\n\nuse Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n// To enable or disable caching, set the `ConfigAggregator::ENABLE_CACHE` boolean in\n// `config/autoload/local.php`.\n$cacheConfig = [\n    'config_cache_path' => 'data/config-cache.php',\n];\n\n$aggregator = new ConfigAggregator([\n    // Include cache configuration\n    new ArrayProvider($cacheConfig),\n\n    // Default App module config\n    App\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], $cacheConfig['config_cache_path']);\n\nreturn $aggregator->getMergedConfig();\n\n\n\nThe above should mimic what you already had in place; if it does not, check to\nsee if there are additional paths you were globbing previously.",
            "title": "To version 2"
        },
        {
            "location": "/v2/reference/migration/#migration-to-expressive-20",
            "text": "Expressive 2.0 should not result in many upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:   Signature changes  Removed functionality  Deprecated functionality  PSR-11 support  Usage of http-interop middleware  Original request and response messages  Error handling  Final handlers become default delegates  Programmatic middleware pipelines  Implicit handling of  HEAD  and  OPTIONS  requests  RouterInterface changes  URL helper changes  zend-view renderer changes  Twig renderer changes  Adopting a modular architecture",
            "title": "Migration to Expressive 2.0"
        },
        {
            "location": "/v2/reference/migration/#signature-changes",
            "text": "The following signature changes were made that could affect  class extensions :   Zend\\Expressive\\Application::__call($method, array $args) : previously, the\n   $args  argument was not typehinted; it now is. If you are extending this\n  class and overriding that method, you will need to update your method\n  signature accordingly.   Additionally, a number of signatures change due to updating Expressive to\nsupport  PSR-11  instead of container-interop \n(which was the basis for PSR-11). Essentially, these were a matter of updating\ntypehints on  Interop\\Container\\ContainerInterface  to Psr\\Container\\ContainerInterface . Signatures affected include:   Zend\\Expressive\\AppFactory::create()  Zend\\Expressive\\Application::__construct()  Zend\\Expressive\\Container\\ApplicationFactory::__invoke()  Zend\\Expressive\\Container\\ErrorHandlerFactory::__invoke()  Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory::__invoke()  Zend\\Expressive\\Container\\NotFoundDelegateFactory::__invoke()  Zend\\Expressive\\Container\\NotFoundHandlerFactory::__invoke()  Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory::__invoke()  Zend\\Expressive\\Container\\WhoopsFactory::__invoke()  Zend\\Expressive\\Container\\WhoopsPageHandlerFactory::__invoke()   In each of the above cases, updating your import statements from Interop\\Container\\ContainerInterface  to  Psr\\Container\\ContainerInterface \nwill make your code work again.  The following exceptions now implement PSR-11 exception interfaces instead of container-interop variants:   Zend\\Expressive\\Container\\Exception\\InvalidServiceException   In the above case, if you were previously catching the container-interop\nexception on which it was based, your code should still work so long as you\nhave container-interop installed. You should likely update it to catch the more\ngeneral  Psr\\Container\\ContainerExceptionInterface  instead, however.",
            "title": "Signature changes"
        },
        {
            "location": "/v2/reference/migration/#removed-functionality",
            "text": "The following classes and/or methods were removed for the Expressive 2.0\nrelease:    Zend\\Expressive\\Application::pipeErrorHandler() . Stratigility 2.0 dropped\n  its  ErrorMiddlewareInterface  and the concept of error middleware (middleware\n  supporting an additional  $error  argument in its signature); this method was\n  thus no longer relevant.    Zend\\Expressive\\Application::routeMiddleware() . Routing middleware was\n  extracted to the class  Zend\\Expressive\\Middleware\\RouteMiddleware .    Zend\\Expressive\\Application::dispatchMiddleware() . Dispatch middleware was\n  extracted to the class  Zend\\Expressive\\Middleware\\DispatchMiddleware .    Zend\\Expressive\\Application::getFinalHandler() . Stratigility 2 supports the\n  http-interop/http-middleware project, and now uses  delegates . This method\n  was renamed to  getDefaultDelegate() , and now returns an\n   Interop\\Http\\ServerMiddleware\\DelegateInterface  instance.    Zend\\Expressive\\Container\\Exception\\InvalidArgumentException . This exception\n  was thrown by  Zend\\Expressive\\Container\\ApplicationFactory  previously; that\n  class now throws  Zend\\Expressive\\Exception\\InvalidArgumentException  instead.    Zend\\Expressive\\Container\\Exception\\NotFoundException . This exception type\n  was never used internally.    Zend\\Expressive\\ErrorMiddlewarePipe . With the removal of Stratigility 1\n  error middleware, this specialized  MiddlewarePipe  no longer has any use.    Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory . See the section on\n   final handler changes  for more\n  information.    Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory . See the section on\n   final handler changes  for more\n  information.    Zend\\Expressive\\TemplatedErrorHandler . See the section on\n   final handler changes  for more\n  information.    Zend\\Expressive\\WhoopsErrorHandler . See the section on\n   final handler changes  for more\n  information.",
            "title": "Removed functionality"
        },
        {
            "location": "/v2/reference/migration/#deprecated-functionality",
            "text": "Zend\\Expressive\\Application::raiseThrowables() . Stratigility 2.0 makes the\n  method a no-op, as exceptions are no longer caught by the middleware\n  dispatcher. As such, the  raise_throwables  configuration argument now is no\n  longer used, either.",
            "title": "Deprecated functionality"
        },
        {
            "location": "/v2/reference/migration/#psr-11-support",
            "text": "In previous versions of Expressive, we consumed container-interop ,\nwhich provides  Interop\\Container\\ContainerInterface , a shared interface for\ndependency injection containers. container-interop served as a working group for the PSR-11  specification.  In the weeks prior to the Expressive 2.0 release, PSR-11 was formally accepted,\nand the package  psr/container  was released. As such, we have updated\nExpressive to consume the interfaces PSR-11 exposes.  No supported implementations currently directly implement PSR-11, however.\nFortunately, the container-interop 1.2.0 release acts as a\nforwards-compatibility measure by altering every interface it exposes to extend\nthose from PSR-11, making existing container-interop implementations  de facto \nPSR-11 implementations!  The result is a (mostly) transparent upgrade for users of Expressive. As newer\nversions of container implementations are released supporting PSR-11 directly,\nyou will be able to upgrade immediately; we will also periodically update the\nskeleton to pick up these new versions when present. (The one caveat to\nupgrading is  signature changes  within Expressive classes\nbased on the new psr/container interface names.)  As long as you have container-interop 1.2.0 installed, your existing factories\nthat typehint against its interface will continue to work. However, we\nrecommend updating them to instead typehint against PSR-11, which will allow\nyou to drop the container-interop requirement once your chosen container\nimplementation no longer requires it.",
            "title": "PSR-11 support"
        },
        {
            "location": "/v2/reference/migration/#do-not-update-blindly",
            "text": "If you are implementing interfaces from other packages in your factory\nimplementations, be sure to check and see if those interfaces update to PSR-11\nbefore making changes.  As an example, zend-servicemanager v3 does not update Zend\\ServiceManager\\Factory\\FactoryInterface  and siblings to typehint\nagainst PSR-11, as doing so would break backwards compatibility.",
            "title": "Do not update blindly!"
        },
        {
            "location": "/v2/reference/migration/#http-interop",
            "text": "Stratigility 2.0 provides the ability to work with  http-interop middleware\n0.4.1 .  This specification, which is being developed as the basis of PSR-15 , defines what is known as  lambda \nor  single-pass  middleware, vs the  double-pass  middleware traditionally used\nby Stratigility and Expressive.  Double-pass refers to the fact that two arguments are passed to the delegation\nfunction  $next : the request and response. Lambda or single-pass middleware\nonly pass a single argument, the request.  Stratigility 2.0 provides support for dispatching either style of middleware.  Specifically, your middleware can now implement:   Interop\\Http\\ServerMiddleware\\MiddlewareInterface , which defines a single\n  method,  process(Psr\\Http\\Message\\ServerRequestInterface $request,\n  Interop\\Http\\ServerMiddleware\\DelegateInterface $delegate) .  Callable middleware that follows the above signature (the typehint for the\n  request argument is optional).   Both styles of middleware may be piped directly to the middleware pipeline or as\nrouted middleware within Expressive. In each case, you can invoke the\nnext middleware layer using  $delegate->process($request) .  In Expressive 2.0,  Application  will continue to accept the legacy double-pass\nsignature, but will require that you either:   Provide a  $responsePrototype  (a  ResponseInterface  instance) to the\n   Application  instance prior to piping or routing such middleware.  Decorate the middleware in a  Zend\\Stratigility\\Middleware\\CallableMiddlewareWrapper \n  instance (which also requires a  $responsePrototype ).   If you use  Zend\\Expressive\\Container\\ApplicationFactory  to create your Application  instance, a response prototype will be injected for you from the\noutset.  We recommend that you begin writing middleware to follow the http-interop\nstandard at this time. As an example:  namespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass XClacksOverheadMiddleware implements MiddlewareInterface\n{\n    /**\n     * {@inheritDoc}\n     */\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n}  Alternately, you can write this as a callable:  namespace App\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass XClacksOverheadMiddleware\n{\n    /**\n     * @param ServerRequestInterface $request\n     * @param DelegateInterface $delegate\n     * @return ResponseInterface\n     */\n    public function __invoke(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        $response = $delegate->process($request);\n        return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n    }\n}",
            "title": "http-interop"
        },
        {
            "location": "/v2/reference/migration/#original-messages",
            "text": "In the  migration to version 1.1 guide , we detail the fact that\nStratigility 1.3 deprecated its internal request and response decorators.\nStratigility 2.0, on which Expressive 2.0 is based, removes them entirely.  If your code relied on the various  getOriginal*()  methods those decorators\nexposed, you will need to update your code in two ways:   You will need to add  Zend\\Stratigility\\Middleware\\OriginalMessages  to your\n  middleware pipeline, as the outermost (or close to outermost) layer.  You will need to update your code to call on the request instance's\n   getAttribute()  method with one of  originalRequest ,  originalUri , or\n   originalResponse  to retrieve the values.   To address the first point, see the  Expressive 1.1 migration\ndocumentation , which\ndetails how to update your configuration or programmatic pipeline.  For the second point, we provide a tool via the zendframework/zend-expressive-tooling \npackage which will help you in this latter part of the migration. Install it as\na development requirement via composer:  $ composer require --dev zendframework/zend-expressive-tooling  And then execute it via:  $ ./vendor/bin/expressive-migrate-original-messages  This tool will update calls to  getOriginalRequest()  and  getOriginalUri()  to\ninstead use the new request attributes that the  OriginalMessages  middleware\ninjects:   getOriginalRequest()  becomes  getAttribute('originalRequest', $request)  getOriginalUri()  becomes  getAttribute('originalUri', $request->getUri())   In both cases,  $request  will be replaced with whatever variable name you used\nfor the request instance.  For  getOriginalResponse()  calls, which happen on the response instance, the\ntool will instead tell you what files had such calls, and detail how you can\nupdate those calls to use the  originalResponse  request attribute.",
            "title": "Original messages"
        },
        {
            "location": "/v2/reference/migration/#error-handling",
            "text": "As noted in the  Expressive 1.1 migration docs ,\nStratigility 1.3 introduced the ability to tell it to no longer catch exceptions\ninternally, paving the way for middleware-based error handling. Additionally, it\ndeprecated its own  ErrorMiddlewareInterface  and duck-typed implementations of\nthe interface in favor of middleware-based error handling. Finally, it\ndeprecated the  $e / $error  argument to \"final handlers\", as that argument\nwould be used only when attempting to invoke  ErrorMiddlewareInterface \ninstances.  Stratigility 2.0, on which Expressive 2.0 is based, no longer catches exceptions\ninternally, removes the  ErrorMiddlewareInterface  entirely, and thus the $e / $error  argument to final handlers.  As such, you  MUST  provide your own error handling with Expressive 2.0.  Error handling middleware will typically introduce a try/catch block:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    try {\n        $response = $next($request, $response);\n        return $response;\n    } catch (\\Throwable $exception) {\n        // caught PHP 7 throwable\n    } catch (\\Exception $exception) {\n        // caught PHP 5 exception\n    }\n\n    // ...\n    // do something with $exception and generate a response\n    // ...\n\n    return $response;\n}  Additionally, you will need middleware registered as your innermost layer that\nis guaranteed to return a response. Generally, if you hit that layer, no other\nmiddleware is capable of handling the request, indicating a 400 (Bad Request) or\n404 (Not Found) HTTP status. With the combination of an error handler at the\noutermost layer, and a \"not found\" handler at the innermost layer, you can\nhandle any error in your application.  Stratigility 1.3 and 2.0 provide an error handler implementation via Zend\\Stratigility\\Middleware\\ErrorHandler . In addition to the try/catch block,\nit also sets up a PHP error handler that will catch any PHP error types in the\ncurrent  error_reporting  mask; the error handler will raise exceptions of the\ntype  ErrorException  with the PHP error details.  ErrorHandler  allows injection of an \"error response generator\", which allows\nyou to alter how the error response is generated based on the current\nenvironment. Error response generators are callables with the signature:  function (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  Expressive 2.0 provides the following functionality to assist with your error\nhandling needs:    Zend\\Expressive\\Middleware\\ErrorResponseGenerator  will output a canned\n  plain/text message, or use a supplied template renderer to generate content\n  for the response. It accepts the following arguments to its constructor:    $isDevelopmentMode = false : whether or not the application is in\n  development mode. If so, it will output stack traces when no template\n  renderer is used (see below), or supply the exception to the template via\n  the  error  variable if a renderer is present.    Zend\\Expressive\\Template\\TemplateRendererInterface $renderer : if\n  supplied, the results of rendering a template will be injected into\n  the response. Templates are passed the following variables:   response : the response at the time of rendering  request : the request at the time of rendering  uri : the URI at the time of rendering  status : the response status code  reason : the response reason phrase  error : the exception; this is only provided when in development mode.     $template = 'error::error' : the template to render, with a default value\n  if none is provided.      Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory  can create an\n  instance of the  ErrorResponseGenerator  using the following:    The  debug  top-level configuration value is used to set the\n   $isDevelopmentMode  flag.    If a  Zend\\Expressive\\Template\\TemplateRendererInterface  service is\n  registered, it will be provided to the constructor.    The value of  zend-expressive.error_handler.template_error , if present,\n  will be used to seed the  $template  argument.      Zend\\Expressive\\Middleware\\WhoopsErrorResponseGenerator  uses Whoops to\n  generate the error response. Its constructor takes a single argument, a\n   Whoops\\Run  instance. If a  Whoops\\Handler\\PrettyPageHandler  is registered\n  with the instance, it will add a data table with request details derived from\n  the  ServerRequestInterface  instance. \n   Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory  can create an\n  instance, and will use the  Zend\\Expressive\\Whoops  service to seed the\n   Whoops\\Run  argument.    Zend\\Expressive\\Middleware\\NotFoundHandler  can be used as the innermost\n  layer of your pipeline in order to return a 404 response. (Typically, if you\n  get to the innermost layer, no middleware was able to handle the request,\n  indicating a 404.) By default, it will produce a canned plaintext response.\n  However, you can also provide an optional  TemplateRendererInterface  instance\n  and  $template  in order to provided templated content. \n  The constructor arguments are:    ResponseInterface $responsePrototype : this is an empty response on which\n  to set the 404 status and inject the 404 content.    TemplateRendererInterface $renderer : optionally, you may provide a\n  renderer to use in order to provide templated response content.    $template = 'error::404'`: optionally, you may provide a\n  template to render; if none is provided, a sane default is used.      Zend\\Expressive\\Container\\NotFoundHandlerFactory  can create an instance of\n  the  NotFoundHandler  for you, and will use the following to do so:    The  Zend\\Expressive\\Template\\TemplateRendererInterface  service, if\n  available.    The  zend-expressive.error_handler.template_404  configuration value, if\n  available, will be used for the  $template .      Zend\\Expressive\\Container\\ErrorHandlerFactory  will create an instance of\n   Zend\\Stratigility\\Middleware\\ErrorHandler , and use the\n   Zend\\Stratigility\\Middleware\\ErrorResponseGenerator  service to seed\n  it. \n  As such, register one of the following as a factory for the\n   Zend\\Stratigility\\Middleware\\ErrorResponseGenerator  service:   Zend\\Expressive\\Container\\ErrorResponseGeneratorFactory  Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory",
            "title": "Error handling"
        },
        {
            "location": "/v2/reference/migration/#error-handler-configuration-example",
            "text": "If you are using configuration-driven middleware, your middleware pipeline\nconfiguration may look like this in order to make use of the new error handling\nfacilities:  // config/autoload/middleware-pipeline.global.php\n\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Expressive\\Middleware;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    // Add the following section to enable the new error handling:\n    'zend-expressive' => [\n        'raise_throwables' => true,\n    ],\n\n    'dependencies' => [\n        'invokables' => [\n            // See above section on \"Original messages\":\n            OriginalMessages::class => OriginalMessages::class,\n        ],\n        'factories' => [\n            Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class,\n            Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class,\n\n            // Add the following three entries:\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Middleware\\ErrorResponseGenerator::class => Container\\ErrorResponseGeneratorFactory::class,\n            Middleware\\NotFoundHandler::class => Container\\NotFoundHandlerFactory::class,\n        ],\n    ],\n\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                OriginalMessages::class,\n                Helper\\ServerUrlMiddleware::class,\n                ErrorHandler::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n\n        'routing' => [\n            'middleware' => [\n                Application::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Application::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        'not-found' => [\n            'middleware' => Middleware\\NotFoundHandler::class,\n            'priority' => 0,\n        ],\n\n        // Remove the section \"error\"\"\n    ],\n];  If you are defining a programmatic pipeline (see more below on this), the\npipeline might look like:  $app->pipe(OriginalMessages::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(Helper\\UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(Middleware\\NotFoundHandler::class);",
            "title": "Error handler configuration example"
        },
        {
            "location": "/v2/reference/migration/#error-handling-and-php-errors",
            "text": "As noted above,  Zend\\Stratigility\\Middleware\\ErrorHandler  also creates a PHP\nerror handler that casts PHP errors to  ErrorException  instances. More\nspecifically, it uses the current  error_reporting  value to determine  which \nerrors it should cast this way.  This can be problematic when deprecation errors are triggered.  If they are cast\nto exceptions, code that would normally run will now result in error pages.  We recommend adding the following line to your  public/index.php  towards the\ntop of the file:  error_reporting(error_reporting() & ~E_USER_DEPRECATED);  This will prevent the error handler from casting deprecation notices to\nexceptions, while keeping the rest of your error reporting mask intact.",
            "title": "Error handling and PHP errors"
        },
        {
            "location": "/v2/reference/migration/#removing-legacy-error-middleware",
            "text": "Stratigility version 1-style error middleware (middleware implementing Zend\\Stratigility\\ErrorMiddlewareInterface , or duck-typing its signature,\nwhich included an  $error  argument as the first argument to the middleware) is\nno longer supported with Stratigility version 2 and Expressive 2.0. You will\nneed to find any instances of them in your application, or cases where your\nmiddleware invokes error middleware via the third argument to  $next() .  We provide a tool to assist you with that via the package zendframework/zend-expressive-tooling : vendor/bin/expressive-scan-for-error-middleware . Run the command from your\nproject root, optionally passing the  help ,  --help , or  -h  commands for\nusage. The tool will detect each of these for you, flagging them for you to\nupdate or remove.",
            "title": "Removing legacy error middleware"
        },
        {
            "location": "/v2/reference/migration/#final-handlers-become-default-delegates",
            "text": "One ramification of supporting  http-interop middleware  is that\nthe concept of \"final handlers\" changes. In Stratigility 1.X and Expressive 1.X,\na \"final handler\" was invoked when the middleware pipeline was exhausted;\nhowever, due to how Stratigility caught exceptions, this also meant that the\nfinal handler often acted as the application error handler, reporting errors to\nend users.  With the  error handling changes noted above , error handling\nis moved to dedicated middleware. However, there is still a need to have\nsomething that can execute once the middleware pipeline is exhausted. Such a\nsituation typically indicates no middleware was able to handle the request, or\nthat the request was somehow malformed.  In Expressive 2.0, we have removed final handlers, and replaced them with the\nconcept of \"default delegates\".  Delegates  are Interop\\Http\\ServerMiddleware\\DelegateInterface  instances, which are invoked\nby middleware when they wish to  delegate  processing of the request to\nsomething else. Internally, Stratigility 2.0 and Expressive 2.0 use a delegate\nto iterate through the middleware pipeline. For Expressive 2.0, a  default\ndelegate  is a delegate executed when the application's internal middleware\npipeline is exhausted.  The ramifications for end users are as follows:    The  $finalHandler  argument to  Application 's constructor, which previously\n  was a  callable , is now called  $defaultDelegate , and needs to be a\n   DelegateInterface  instance.    getFinalHandler()  no longer exists; we have  added   getDefaultDelegate() .    The service  Zend\\Expressive\\FinalHandler  is no longer used. A new service,\n   Zend\\Expressive\\Delegate\\DefaultDelegate , is used by  ApplicationFactory ,\n  and, if present, will be used to inject the  $defaultDelegate  argument of the\n   Application  constructor.    We have removed the following classes, which either provided final handlers,\n  or acted as factories for them:   Zend\\Expressive\\TemplatedErrorHandler  Zend\\Expressive\\WhoopsErrorHandler  Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory  Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory     If you use the  vendor/bin/expressive-pipeline-from-config  tool to migrate your\napplication to programmatic pipelines, as described below, the  DefaultDelegate \nservice will be mapped to  Zend\\Expressive\\Container\\NotFoundDelegateFactory ,\nwhich will provide an instance of  Zend\\Expressive\\Delegate\\NotFoundDelegate .\nThis new class will produce a 404 response, using a template if the Zend\\Expressive\\Template\\TemplateRendererInterface  service is present, but\notherwise producing a plain text response.  Application's built using the 2.0 version of the skeleton application will have\nthese features enabled by default.",
            "title": "Final handlers become default delegates"
        },
        {
            "location": "/v2/reference/migration/#notfounddelegate-and-notfoundhandler",
            "text": "Zend\\Expressive\\Middleware\\NotFoundHandler , which is intended as innermost\nmiddleware for producing a 404 response, composes and proxies to a NotFoundDelegate  instance to produce its response.",
            "title": "NotFoundDelegate and NotFoundHandler"
        },
        {
            "location": "/v2/reference/migration/#programmatic-middleware-pipelines",
            "text": "Starting with Expressive 1.1, we recommended  programmatic creation of\npipelines and routing ; the  Expressive 1.1 migration\nguide \nprovides more detail.  With Expressive 2.0, this is now the  default  option shipped in the skeleton.  If you are upgrading from version 1 and are not currently using programmatic\npipelines, we provide a migration tool that will convert your application to do\nso. The tool is available via the package zendframework/zend-expressive-tooling .\nYou may install this package in one of the following ways:   Via the vendor binary  ./vendor/bin/expressive-tooling :   $ ./vendor/bin/expressive-tooling        # install\n$ ./vendor/bin/expressive-tooling remove # uninstall   Using Composer:   $ composer require --dev zendframework/zend-expressive-tooling # install\n$ composer remove --dev zendframework/zend-expressive-tooling  # uninstall  Once installed, you will use the  vendor/bin/expressive-pipeline-from-config \ncommand.  This command does the following:    Reads your  middleware_pipeline  configuration, and generates a programmatic\n  pipeline for you, which is then stored in  config/pipeline.php . The generated\n  pipeline contains the following additions:    The first middleware in the pipeline is  Zend\\Stratigility\\Middleware\\OriginalMessages ,\n  which injects the incoming request, URI, and response as the request\n  attributes  originalRequest ,  originalUri , and  originalResponse ,\n  respectively. (This can aid URI generation in nested middleware later.)    The second middleware in the pipeline is  Zend\\Stratigility\\Middleware\\ErrorHandler .    The last middleware in the pipeline is  Zend\\Expressive\\Middleware\\NotFoundHandler .      Reads your  routes  configuration, and generates a programmatic\n  routing table for you, which is then stored in  config/routes.php .    Adds a new configuration file,  config/autoload/programmatic-pipeline.global.php ,\n  which enables the  programmatic_pipelines  configuration flag. Additionally,\n  it adds dependency configuration for the new error handlers.    Inserts two lines before the  $app->run()  statement of your\n   public/index.php , one each to require  config/pipeline.php  and\n   config/routes.php .    Your  middleware_pipeline  and  routes  configuration are not removed at this\ntime, to allow you to test and verify your application first; however, due to\nthe configuration in  config/autoload/programmatic-pipeline.global.php , these\nare now ignored.  If you wish to use Whoops in your development environment, you may add the\nfollowing to a local configuration file (e.g.,  config/autoload/local.php ):  use Zend\\Expressive\\Container\\WhoopsErrorResponseGeneratorFactory;\nuse Zend\\Expressive\\Middleware\\ErrorResponseGenerator;\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            ErrorResponseGenerator::class => WhoopsErrorResponseGeneratorFactory::class,\n        ],\n    ],\n];  Other things you may want to do:    The  ErrorHandler  entry could potentially be moved inwards a few layers. As\n  an example, the  ServerUrlMiddleware  has no possibility of raising an\n  exception or error, and could be moved outwards; you could do similarly for\n  any middleware that only injects additional response headers.    Remove any Stratigility-style error middleware (middleware expecting an error\n  as the first argument). If any specialized error handling should occur, add\n  additional middleware into the pipeline that can catch exceptions, and have\n  that middleware re-throw for exceptions it cannot handle. (Use the\n   vendor/bin/expressive-scan-for-error-middleware  command from\n  zendframework/zend-expressive-tooling to assist in this.)    Consider providing your own  Zend\\Stratigility\\NoopFinalHandler \n  implementation; this will now only be invoked if the queue is exhausted, and\n  could return a generic 404 page, raise an exception, etc.",
            "title": "Programmatic middleware pipelines"
        },
        {
            "location": "/v2/reference/migration/#handling-head-and-options-requests",
            "text": "Prior to 2.0, it was possible to route middleware that could not handle  HEAD \nand/or  OPTIONS  requests. Per  RFC 7231, section 4.1 ,\n\"all general-purpose servers MUST support the methods GET and HEAD. All other\nmethods are OPTIONAL.\" Additionally, most servers and implementors agree that OPTIONS   should  be supported for any given resource, so that consumers can\ndetermine what methods are allowed for the given resource.  To make this happen, the Expressive project implemented several features.  First, zend-expressive-router 1.3.0 introduced several features in both Zend\\Expressive\\Router\\Route  and  Zend\\Expressive\\Router\\RouteResult  to help\nconsumers implement support for  HEAD  and  OPTIONS  in an automated way. The Route  class now has two new methods,  implicitHead()  and  implicitOptions() ;\nthese each return a boolean  true  value if support for those methods is implicit  \u2014 i.e., not defined explicitly for the route. The  RouteResult \nclass now introduces a new factory method,  fromRoute() , that will create an\ninstance from a  Route  instance; this then allows consumers of a  RouteResult \nto query the  Route  to see if a matched  HEAD  or  OPTIONS  request needs\nautomated handling. Each of the supported router implementations were updated to\nuse this method, as well as to return a successful routing result if  HEAD \nand/or  OPTIONS  requests are submitted, but the route does not explicitly\nsupport the method.  Within Expressive itself, we now offer two new middleware to provide this\nautomation:   Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware  Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware   If you want to support these methods automatically, each of these should be\nenabled between the routing and dispatch middleware. If you use the expressive-pipeline-from-config  tool as documented in the programmatic pipeline migration section ,\nentries for each will be injected into your generated pipeline.  Please see the  chapter on the implicit methods middleware \nfor more information on each.",
            "title": "Handling HEAD and OPTIONS requests"
        },
        {
            "location": "/v2/reference/migration/#router-interface-changes",
            "text": "Expressive 2.0 uses zendframework/zend-expressive-router 2.1+. Version 2.0 of\nthat package introduced a change to the  Zend\\Expressive\\Router\\RouterInterface::generateUri() \nmethod; it now accepts an additional, optional, third argument,  array $options = [] ,\nwhich can be used to pass router-specific options when generating a URI. As an\nexample, the implementation that uses zendframework/zend-router might use these\noptions to pass a translator instance in order to translate a path segment to\nthe currently selected locale.  For consumers, his represents no backwards-incompatible change; consumers may\nopt-in to the new argument at will. For those implementing the interface,\nupgrading will require updating your router implementation's signature to match\nthe new interface:  public function generateUri(\n    string $name,\n    array $substitutions = [],\n    array $options = []\n) : string",
            "title": "Router interface changes"
        },
        {
            "location": "/v2/reference/migration/#url-helper-changes",
            "text": "Expressive 2.0 uses zendframework/zend-expressive-helpers version 3.0+. This new\nversion updates the signature of the  Zend\\Expressive\\Helper\\UrlHelper  from:  function (\n    $routeName,\n    array $routeParams = []\n) : string  to:  function (\n    $routeName,\n    array $routeParams = [],\n    $queryParams = [],\n    $fragmentIdentifier = null,\n    array $options = []\n) : string  For consumers, this should represent a widening of features, and will not\nrequire any changes, unless you wish to opt-in to the new arguments. See the UrlHelper documentation  for information\non each argument.  For any users who were  extending  the class, you will need to update your\nextension accordingly.",
            "title": "URL helper changes"
        },
        {
            "location": "/v2/reference/migration/#zend-view-renderer-changes",
            "text": "Expressive 2.0 will use zend-expressive-zendviewrenderer 1.3+ if that renderer\nis chosen. Starting with 1.3.0 of that renderer, you may now pass a boolean false  value for the  layout  variable when calling either  addDefaultParam() \nor  render()  on the renderer instance in order to disable the layout.",
            "title": "zend-view renderer changes"
        },
        {
            "location": "/v2/reference/migration/#twig-renderer-changes",
            "text": "Expressive 2.0 will use zend-expressive-twigrenderer 1.3+ if that renderer\nis chosen. Starting with 1.3.0 of that renderer, Twig 2.1+ is now supported.",
            "title": "Twig renderer changes"
        },
        {
            "location": "/v2/reference/migration/#adopting-a-modular-architecture",
            "text": "Expressive 2.0 ships with support for modular architectures from the outset, as\ndetailed in the  chapter on modules .  If you wish to update your application to use these features, you will need to\ninstall the following packages:   zendframework/zend-config-aggregator  zendframework/zend-component-installer   As an example:  $ composer require zendframework/zend-config-aggregator \\\n> zendframework/zend-component-installer  Once installed, you should update your  config/config.php  file to read as\nfollows:  <?php\n\nuse Zend\\ConfigAggregator\\ArrayProvider;\nuse Zend\\ConfigAggregator\\ConfigAggregator;\nuse Zend\\ConfigAggregator\\PhpFileProvider;\n\n// To enable or disable caching, set the `ConfigAggregator::ENABLE_CACHE` boolean in\n// `config/autoload/local.php`.\n$cacheConfig = [\n    'config_cache_path' => 'data/config-cache.php',\n];\n\n$aggregator = new ConfigAggregator([\n    // Include cache configuration\n    new ArrayProvider($cacheConfig),\n\n    // Default App module config\n    App\\ConfigProvider::class,\n\n    // Load application config in a pre-defined order in such a way that local settings\n    // overwrite global settings. (Loaded as first to last):\n    //   - `global.php`\n    //   - `*.global.php`\n    //   - `local.php`\n    //   - `*.local.php`\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n\n    // Load development config if it exists\n    new PhpFileProvider('config/development.config.php'),\n], $cacheConfig['config_cache_path']);\n\nreturn $aggregator->getMergedConfig();  The above should mimic what you already had in place; if it does not, check to\nsee if there are additional paths you were globbing previously.",
            "title": "Adopting a modular architecture"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/",
            "text": "Migration to Expressive 2.2\n\n\nVersion 2.2 exists to message deprecated functionality, and to provide backports\nof functionality from version 3.0 as it makes sense. In most cases, your code\nshould continue to work as it did before, but may now emit deprecation notices.\nThis document details some specific deprecations, and how you can change your\ncode to remove the messages, and, simultaneously, help prepare your code for\nversion 3.\n\n\nConfig providers\n\n\nThe zend-expressive and zend-expressive-router packages now expose \nconfig\nproviders\n. These are dedicated classes that return package-specific\nconfiguration, including dependency information. We suggest you add these to\nyour application's configuration. Add the following two lines in your\n\nconfig/config.php\n file, inside the array passed to the \nConfigAggregator\n\nconstructor:\n\n\n\\Zend\\Expressive\\ConfigProvider::class,\n\\Zend\\Expressive\\Router\\ConfigProvider::class,\n\n\n\n\n\nThe command \n./vendor/bin/expressive migrate:expressive-v2.2\n will do this for\nyou.\n\n\n\n\nRouting and dispatch middleware\n\n\nIn previous releases of Expressive, you would route your routing and dispatch\nmiddleware using the following dedicated methods:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nThese methods are now \ndeprecated\n, and will be removed in version 3.0.\n\n\nInstead, you should use \npipe()\n with the following services:\n\n\n$app->pipe(\\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class);\n\n\n\n\n\nThe command \n./vendor/bin/expressive migrate:expressive-v2.2\n will do this for\nyou.\n\n\n\n\nThis also means you can easily replace these middleware with your own at this\ntime!\n\n\nRouting and dispatch constants\n\n\nIf you are using configuration-driven routes, you are likely using the constants\n\nZend\\Expressive\\Application::ROUTING_MIDDLEWARE\n and \nDISPATCH_MIDDLEWARE\n to\nindicate the routing and dispatch middleware, as follows:\n\n\n'middleware_pipeline' => [\n    Application::ROUTING_MIDDLEWARE,\n    Application::DISPATCH_MIDDLEWARE,\n],\n\n\n\nIn the above section, we detailed deprecation of the methods\n\npipeRoutingMiddleware()\n and \npipeDispatchMiddleware()\n; the constants above\nare the configuration equivalent of calling these methods, and are similarly\ndeprecated.\n\n\nChange these entries to use the same syntax as other pipeline middleware, and\nhave the \nmiddleware\n key indicate the appropriate middleware class as follows:\n\n\n'middleware_pipeline' => [\n    [\n        'middleware' => \\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class,\n    ],\n    [\n        'middleware' => \\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class,\n    ],\n],\n\n\n\nImplicit HEAD and OPTIONS middleware\n\n\nThese middleware have moved to the zend-expressive-router package. While they\nstill exist within the zend-expressive package, we have added deprecation\nnotices indicating their removal in v3. As such, update either of the following\nstatements, if they exist in your application:\n\n\n$app->pipe(\\Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware::class);\n\n\n\nto:\n\n\n$app->pipe(\\Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware::class);\n\n\n\n\n\nThe command \n./vendor/bin/expressive migrate:expressive-v2.2\n will do this for\nyou.\n\n\n\n\nResponse prototypes\n\n\nA number of services expect a \nresponse prototype\n which will be used in order\nto generate and return a response. Previously, we did not expose a service for\nthis, and instead hard-coded factories to create a zend-diactoros \nResponse\n\ninstance when creating a service.\n\n\nIn version 3, we plan to instead compose a \nresponse factory\n in such services.\nThis is done to ensure a unique response prototype instance is generated for\neach use; this is particularly important if you wish to use such services with\nasync web servers such as Swoole, ReactPHP, AMP, etc.\n\n\nTo prepare for that, Expressive 2.2 does the following:\n\n\n\n\n\n\nCreates \nZend\\Expressive\\Container\\ResponseFactoryFactory\n, and maps it to the\n  service name \nPsr\\Http\\Response\\ResponseInterface\n. It returns a \ncallable\n\n  that will generate a zend-diactoros \nResponse\n instance each time it is\n  called.\n\n\n\n\n\n\nCreates \nZend\\Expressive\\Container\\StreamFactoryFactory\n, and maps it to the\n  service name \nPsr\\Http\\Response\\StreamInterface\n. It returns a \ncallable\n\n  that will generate a zend-diactoros \nStream\n instance (backed by a read/write\n  \nphp://temp\n stream) each time it is called.\n\n\n\n\n\n\nThe various factories that hard-coded generation of a response previously now\npull the \nResponseInterface\n service and, if it is callable, call it to produce\na response, but otherwise use the return value.\n\n\nThis change should not affect most applications, \nunless they were defining a\n\nResponseInterface\n service previously\n. In such cases, ensure your factory\nmapping has precedence by placing it in a \nconfig/autoload/\n configuration file.\n\n\nDouble-Pass middleware\n\n\nDouble-pass middleware\n refers to middleware that has the following signature:\n\n\nfunction (\n    ServerReqeustInterface $request,\n    ResponseInterface $response,\n    callable $next\n) : ResponseInterface\n\n\n\nwhere \n$next\n will receive \nboth\n a request \nand\n a response instance (this\nlatter is the origin of the \"double-pass\" phrasing).\n\n\nSuch middleware was used in v1 releases of Expressive, and we have continued to\nsupport it through v2. However, starting in v3, we will no longer allow you to\ndirectly pipe or route such middleware.\n\n\nIf you need to continue using such middleware, you will need to decorate it\nusing \nZend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator()\n. This\ndecorator class accepts the middleware and a response prototype as constructor\narguments, and decorates it to be used as http-interop middleware. (In version\n3, it will decorate it as PSR-15 middleware.)\n\n\nThe zend-stratigility package provides a convenience function,\n\nZend\\Stratigility\\doublePassMiddleware()\n, to simplify this for you:\n\n\nuse Zend\\Diactoros\\Response;\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\n// Piping:\n$app->pipe(doublePassMiddleware($someMiddleware, new Response()));\n\n// Routing:\n$app->get('/foo', doublePassMiddleware($someMiddleware, new Response()));\n\n\n\nOther deprecations\n\n\nThe following classes, traits, and instance methods were deprecated, and will be\nremoved in version 3:\n\n\n\n\n\n\nZend\\Expressive\\AppFactory\n: if you are using this, you will need to switch\n  to direct usage of \nZend\\Expressive\\Application\n or a\n  \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\n\n\nZend\\Expressive\\Application\n: deprecates the following methods:\n\n\n\n\npipeRoutingMiddleware()\n: \nsee the section above\n\n\npipeDispatchMiddleware()\n: \nsee the section above\n\n\ngetContainer()\n: this method is removed in version 3; container access will only be via the bootstrap.\n\n\ngetDefaultDelegate()\n: the concept of a default delegate is removed in version 3.\n\n\ngetEmitter()\n: emitters move to a different collaborator in version 3.\n\n\n\n\ninjectPipelineFromConfig()\n andd \ninjectRoutesFromConfig()\n are methods\n    defined by the \nApplicationConfigInjectionTrait\n, which will be removed in\n    version 3. See the section on the \nApplicationConfigInjectionDelegator\n\n    for an alternate, forwards-compatible, approach.\n\n\n\n\n\n\nZend\\Expressive\\ApplicationConfigInjectionTrait\n: if you are using it, it is\n  marked internal, and deprecated; it will be removed in version 3.\n\n\n\n\n\n\nZend\\Expressive\\Container\\NotFoundDelegateFactory\n: the \nNotFoundDelegate\n\n  will be renamed to \nZend\\Expressive\\Handler\\NotFoundHandler\n in version 3,\n  making this factory obsolete.\n\n\n\n\n\n\nZend\\Expressive\\Delegate\\NotFoundDelegate\n: this class becomes\n  \nZend\\Expressive\\Handler\\NotFoundHandler\n in v3, and the new class is added in\n  version 2.2 as well.\n\n\n\n\n\n\nZend\\Expressive\\Emitter\\EmitterStack\n: the emitter concept is extracted from\n  zend-diactoros to a new component, zend-httphandlerrunner. This latter\n  component is used in version 3, and defines the \nEmitterStack\n class. Unless\n  you are extending it or interacting with it directly, this change should not\n  affect you; the \nZend\\Diactoros\\Response\\EmitterInterface\n service will be\n  directed to the new class in that version.\n\n\n\n\n\n\nZend\\Expressive\\IsCallableInteropMiddlewareTrait\n: if you are using it, it is\n  marked internal, and deprecated; it will be removed in version 3.\n\n\n\n\n\n\nZend\\Expressive\\MarshalMiddlewareTrait\n: if you are using it, it is marked\n  internal, and deprecated; it will be removed in version 3.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\DispatchMiddleware\n: \nsee the section above\n.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\ImplicitHeadMiddleware\n: \nsee the section above\n.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\ImplicitOptionsMiddleware\n: \nsee the section above\n.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\NotFoundHandler\n: this will be removed in version 3, where you can instead pipe \nZend\\Expressive\\Handler\\NotFoundHandler\n directly instead.\n\n\n\n\n\n\nZend\\Expressive\\Middleware\\RouteMiddleware\n: \nsee the section above\n.\n\n\n\n\n\n\nApplicationConfigInjectionDelegator\n\n\nIn addition to the above deprecations, we also provide a new class,\n\nZend\\Expressive\\Container\\ApplicationConfigInjectionDelegator\n. This class\nservices two purposes:\n\n\n\n\nIt can act as a \ndelegator factory\n\n  for the \nZend\\Expressive\\Application\n service; when enabled, it will\n  look for \nmiddleware_pipeline\n and \nroutes\n configuration, and use them to\n  inject the \nApplication\n instance before returning it.\n\n\nIt defines static methods for injecting pipelines and routes to an\n  \nApplication\n instance.\n\n\n\n\nTo enable the delegator as a delegator factory, add the following configuration\nto a \nconfig/autoload/\n configuration file, or a configuration provider class:\n\n\n'dependencies' => [\n    'delegators' => [\n        \\Zend\\Expressive\\Application::class => [\n            \\Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator::class,\n        ],\n    ],\n],\n\n\n\nTo manually inject an \nApplication\n instance, you can do the following:\n\n\nuse Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator;\n\n// assuming $config is the application configuration:\nApplicationConfigInjectionDelegator::injectPipelineFromConfig($app, $config);\nApplicationConfigInjectionDelegator::injectRoutesFromConfig($app, $config);\n\n\n\nThese changes will be forwards-compatible with version 3.",
            "title": "To version 2.2"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#migration-to-expressive-22",
            "text": "Version 2.2 exists to message deprecated functionality, and to provide backports\nof functionality from version 3.0 as it makes sense. In most cases, your code\nshould continue to work as it did before, but may now emit deprecation notices.\nThis document details some specific deprecations, and how you can change your\ncode to remove the messages, and, simultaneously, help prepare your code for\nversion 3.",
            "title": "Migration to Expressive 2.2"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#config-providers",
            "text": "The zend-expressive and zend-expressive-router packages now expose  config\nproviders . These are dedicated classes that return package-specific\nconfiguration, including dependency information. We suggest you add these to\nyour application's configuration. Add the following two lines in your config/config.php  file, inside the array passed to the  ConfigAggregator \nconstructor:  \\Zend\\Expressive\\ConfigProvider::class,\n\\Zend\\Expressive\\Router\\ConfigProvider::class,   The command  ./vendor/bin/expressive migrate:expressive-v2.2  will do this for\nyou.",
            "title": "Config providers"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#routing-and-dispatch-middleware",
            "text": "In previous releases of Expressive, you would route your routing and dispatch\nmiddleware using the following dedicated methods:  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();  These methods are now  deprecated , and will be removed in version 3.0.  Instead, you should use  pipe()  with the following services:  $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class);   The command  ./vendor/bin/expressive migrate:expressive-v2.2  will do this for\nyou.   This also means you can easily replace these middleware with your own at this\ntime!",
            "title": "Routing and dispatch middleware"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#routing-and-dispatch-constants",
            "text": "If you are using configuration-driven routes, you are likely using the constants Zend\\Expressive\\Application::ROUTING_MIDDLEWARE  and  DISPATCH_MIDDLEWARE  to\nindicate the routing and dispatch middleware, as follows:  'middleware_pipeline' => [\n    Application::ROUTING_MIDDLEWARE,\n    Application::DISPATCH_MIDDLEWARE,\n],  In the above section, we detailed deprecation of the methods pipeRoutingMiddleware()  and  pipeDispatchMiddleware() ; the constants above\nare the configuration equivalent of calling these methods, and are similarly\ndeprecated.  Change these entries to use the same syntax as other pipeline middleware, and\nhave the  middleware  key indicate the appropriate middleware class as follows:  'middleware_pipeline' => [\n    [\n        'middleware' => \\Zend\\Expressive\\Router\\Middleware\\RouteMiddleware::class,\n    ],\n    [\n        'middleware' => \\Zend\\Expressive\\Router\\Middleware\\DispatchMiddleware::class,\n    ],\n],",
            "title": "Routing and dispatch constants"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#implicit-head-and-options-middleware",
            "text": "These middleware have moved to the zend-expressive-router package. While they\nstill exist within the zend-expressive package, we have added deprecation\nnotices indicating their removal in v3. As such, update either of the following\nstatements, if they exist in your application:  $app->pipe(\\Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware::class);  to:  $app->pipe(\\Zend\\Expressive\\Router\\Middleware\\ImplicitHeadMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Router\\Middleware\\ImplicitOptionsMiddleware::class);   The command  ./vendor/bin/expressive migrate:expressive-v2.2  will do this for\nyou.",
            "title": "Implicit HEAD and OPTIONS middleware"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#response-prototypes",
            "text": "A number of services expect a  response prototype  which will be used in order\nto generate and return a response. Previously, we did not expose a service for\nthis, and instead hard-coded factories to create a zend-diactoros  Response \ninstance when creating a service.  In version 3, we plan to instead compose a  response factory  in such services.\nThis is done to ensure a unique response prototype instance is generated for\neach use; this is particularly important if you wish to use such services with\nasync web servers such as Swoole, ReactPHP, AMP, etc.  To prepare for that, Expressive 2.2 does the following:    Creates  Zend\\Expressive\\Container\\ResponseFactoryFactory , and maps it to the\n  service name  Psr\\Http\\Response\\ResponseInterface . It returns a  callable \n  that will generate a zend-diactoros  Response  instance each time it is\n  called.    Creates  Zend\\Expressive\\Container\\StreamFactoryFactory , and maps it to the\n  service name  Psr\\Http\\Response\\StreamInterface . It returns a  callable \n  that will generate a zend-diactoros  Stream  instance (backed by a read/write\n   php://temp  stream) each time it is called.    The various factories that hard-coded generation of a response previously now\npull the  ResponseInterface  service and, if it is callable, call it to produce\na response, but otherwise use the return value.  This change should not affect most applications,  unless they were defining a ResponseInterface  service previously . In such cases, ensure your factory\nmapping has precedence by placing it in a  config/autoload/  configuration file.",
            "title": "Response prototypes"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#double-pass-middleware",
            "text": "Double-pass middleware  refers to middleware that has the following signature:  function (\n    ServerReqeustInterface $request,\n    ResponseInterface $response,\n    callable $next\n) : ResponseInterface  where  $next  will receive  both  a request  and  a response instance (this\nlatter is the origin of the \"double-pass\" phrasing).  Such middleware was used in v1 releases of Expressive, and we have continued to\nsupport it through v2. However, starting in v3, we will no longer allow you to\ndirectly pipe or route such middleware.  If you need to continue using such middleware, you will need to decorate it\nusing  Zend\\Stratigility\\Middleware\\DoublePassMiddlewareDecorator() . This\ndecorator class accepts the middleware and a response prototype as constructor\narguments, and decorates it to be used as http-interop middleware. (In version\n3, it will decorate it as PSR-15 middleware.)  The zend-stratigility package provides a convenience function, Zend\\Stratigility\\doublePassMiddleware() , to simplify this for you:  use Zend\\Diactoros\\Response;\nuse function Zend\\Stratigility\\doublePassMiddleware;\n\n// Piping:\n$app->pipe(doublePassMiddleware($someMiddleware, new Response()));\n\n// Routing:\n$app->get('/foo', doublePassMiddleware($someMiddleware, new Response()));",
            "title": "Double-Pass middleware"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#other-deprecations",
            "text": "The following classes, traits, and instance methods were deprecated, and will be\nremoved in version 3:    Zend\\Expressive\\AppFactory : if you are using this, you will need to switch\n  to direct usage of  Zend\\Expressive\\Application  or a\n   Zend\\Stratigility\\MiddlewarePipe  instance.    Zend\\Expressive\\Application : deprecates the following methods:   pipeRoutingMiddleware() :  see the section above  pipeDispatchMiddleware() :  see the section above  getContainer() : this method is removed in version 3; container access will only be via the bootstrap.  getDefaultDelegate() : the concept of a default delegate is removed in version 3.  getEmitter() : emitters move to a different collaborator in version 3.   injectPipelineFromConfig()  andd  injectRoutesFromConfig()  are methods\n    defined by the  ApplicationConfigInjectionTrait , which will be removed in\n    version 3. See the section on the  ApplicationConfigInjectionDelegator \n    for an alternate, forwards-compatible, approach.    Zend\\Expressive\\ApplicationConfigInjectionTrait : if you are using it, it is\n  marked internal, and deprecated; it will be removed in version 3.    Zend\\Expressive\\Container\\NotFoundDelegateFactory : the  NotFoundDelegate \n  will be renamed to  Zend\\Expressive\\Handler\\NotFoundHandler  in version 3,\n  making this factory obsolete.    Zend\\Expressive\\Delegate\\NotFoundDelegate : this class becomes\n   Zend\\Expressive\\Handler\\NotFoundHandler  in v3, and the new class is added in\n  version 2.2 as well.    Zend\\Expressive\\Emitter\\EmitterStack : the emitter concept is extracted from\n  zend-diactoros to a new component, zend-httphandlerrunner. This latter\n  component is used in version 3, and defines the  EmitterStack  class. Unless\n  you are extending it or interacting with it directly, this change should not\n  affect you; the  Zend\\Diactoros\\Response\\EmitterInterface  service will be\n  directed to the new class in that version.    Zend\\Expressive\\IsCallableInteropMiddlewareTrait : if you are using it, it is\n  marked internal, and deprecated; it will be removed in version 3.    Zend\\Expressive\\MarshalMiddlewareTrait : if you are using it, it is marked\n  internal, and deprecated; it will be removed in version 3.    Zend\\Expressive\\Middleware\\DispatchMiddleware :  see the section above .    Zend\\Expressive\\Middleware\\ImplicitHeadMiddleware :  see the section above .    Zend\\Expressive\\Middleware\\ImplicitOptionsMiddleware :  see the section above .    Zend\\Expressive\\Middleware\\NotFoundHandler : this will be removed in version 3, where you can instead pipe  Zend\\Expressive\\Handler\\NotFoundHandler  directly instead.    Zend\\Expressive\\Middleware\\RouteMiddleware :  see the section above .",
            "title": "Other deprecations"
        },
        {
            "location": "/v2/reference/migration-to-v2-2/#applicationconfiginjectiondelegator",
            "text": "In addition to the above deprecations, we also provide a new class, Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator . This class\nservices two purposes:   It can act as a  delegator factory \n  for the  Zend\\Expressive\\Application  service; when enabled, it will\n  look for  middleware_pipeline  and  routes  configuration, and use them to\n  inject the  Application  instance before returning it.  It defines static methods for injecting pipelines and routes to an\n   Application  instance.   To enable the delegator as a delegator factory, add the following configuration\nto a  config/autoload/  configuration file, or a configuration provider class:  'dependencies' => [\n    'delegators' => [\n        \\Zend\\Expressive\\Application::class => [\n            \\Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator::class,\n        ],\n    ],\n],  To manually inject an  Application  instance, you can do the following:  use Zend\\Expressive\\Container\\ApplicationConfigInjectionDelegator;\n\n// assuming $config is the application configuration:\nApplicationConfigInjectionDelegator::injectPipelineFromConfig($app, $config);\nApplicationConfigInjectionDelegator::injectRoutesFromConfig($app, $config);  These changes will be forwards-compatible with version 3.",
            "title": "ApplicationConfigInjectionDelegator"
        },
        {
            "location": "/v1/",
            "text": "Expressive: PSR-7 Middleware in Minutes\n\n\nExpressive builds on \nStratigility\n\nto provide a minimalist \nPSR-7\n middleware\nframework for PHP, with the following features:\n\n\n\n\nRouting. Choose your own router; we support:\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-router\n\n\n\n\n\n\nDI Containers, via \ncontainer-interop\n.\n  All middleware composed in Expressive may be retrieved from the composed\n  container.\n\n\nOptionally, templating. We support:\n\n\nPlates\n\n\nTwig\n\n\nZF2's PhpRenderer\n\n\n\n\n\n\nError handling. Create templated error pages, or use tools like\n  \nwhoops\n for debugging purposes.\n\n\nNested middleware applications. Write an application, and compose it later\n  in another, optionally under a separate subpath.\n\n\nSimplfied installation\n. Our custom\n  \nComposer\n-based installer prompts you for your\n  initial stack choices, giving you exactly the base you want to start from.\n\n\n\n\nEssentially, Expressive allows \nyou\n to develop using the tools \nyou\n prefer,\nand provides minimal structure and facilities to ease your development.\n\n\nShould I choose it over Zend\\Mvc?\nThat\u2019s a good question. \nHere\u2019s what we recommend.\n\n\nIf you\u2019re keen to get started, then \nkeep reading\n\nand get started writing your first middleware application today!",
            "title": "Expressive: PSR-7 Middleware in Minutes"
        },
        {
            "location": "/v1/#expressive-psr-7-middleware-in-minutes",
            "text": "Expressive builds on  Stratigility \nto provide a minimalist  PSR-7  middleware\nframework for PHP, with the following features:   Routing. Choose your own router; we support:  Aura.Router  FastRoute  zend-router    DI Containers, via  container-interop .\n  All middleware composed in Expressive may be retrieved from the composed\n  container.  Optionally, templating. We support:  Plates  Twig  ZF2's PhpRenderer    Error handling. Create templated error pages, or use tools like\n   whoops  for debugging purposes.  Nested middleware applications. Write an application, and compose it later\n  in another, optionally under a separate subpath.  Simplfied installation . Our custom\n   Composer -based installer prompts you for your\n  initial stack choices, giving you exactly the base you want to start from.   Essentially, Expressive allows  you  to develop using the tools  you  prefer,\nand provides minimal structure and facilities to ease your development.  Should I choose it over Zend\\Mvc?\nThat\u2019s a good question.  Here\u2019s what we recommend.  If you\u2019re keen to get started, then  keep reading \nand get started writing your first middleware application today!",
            "title": "Expressive: PSR-7 Middleware in Minutes"
        },
        {
            "location": "/v1/getting-started/features/",
            "text": "Overview\n\n\nExpressive allows you to write \nPSR-7\n\n\nmiddleware\n\napplications for the web.\n\n\nPSR-7 is a standard defining HTTP message interfaces; these are the incoming\nrequest and outgoing response for your application. By using PSR-7, we ensure\nthat your applications will work in other PSR-7 contexts.\n\n\nMiddleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.\n\n\nMiddleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.\n\n\nWith Expressive, you can build PSR-7-based middleware applications:\n\n\n\n\nAPIs\n\n\nWebsites\n\n\nSingle Page Applications\n\n\nand more.\n\n\n\n\nFeatures\n\n\nExpressive builds on \nzend-stratigility\n\nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:\n\n\n\n\nRouting\n\n\n\n\nStratigility provides limited, literal matching only. Expressive allows you\n  to utilize dynamic routing capabilities from a variety of routers, providing\n  much more fine-grained matching capabilities. The routing layer also allows\n  restricting matched routes to specific HTTP methods, and will return \"405 Not\n  Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP\n  methods for invalid requests.\n\n\nRouting is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-mvc router.\n\n\n\n\ncontainer-interop\n\n\n\n\nExpressive encourages the use of Dependency Injection, and defines its\n  \nApplication\n class to compose a container-interop \nContainerInterface\n\n  instance. The container is used to lazy-load middleware, whether it is\n  piped (Stratigility interface) or routed (Expressive).\n\n\n\n\nTemplating\n\n\n\n\nWhile Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.\n\n\n\n\nError Handling\n\n\n\n\nApplications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own \nFinalHandler\n implementation, as well as\n  more advanced error handling via two specialized error handlers: a templated\n  error handler for production, and a Whoops-based error handler for development.\n\n\nFlow Overview\n\n\nBelow is a diagram detailing the workflow used by Expressive.\n\n\n\n\nThe \nApplication\n acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.\n\n\nThe \nApplication\n dispatches each middleware. Each middleware accepts a\n\nrequest\n, a \nresponse\n, and the \nnext\n middleware to dispatch. Internally,\nit's actually receiving the middleware stack itself, which knows which\nmiddleware to invoke next.\n\n\nAny given middleware can return a \nresponse\n, at which point execution winds\nits way back out the onion. Additionally, any given middleware can indicate an\nerror occurred, at which point it can call on the next \nerror handling\nmiddleware\n. These act like regular middleware, but accept an additional error\nargument to act on.\n\n\n\n\nPipelines\n\n\nThe terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a \nqueue\n, which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:\n\n\n\n\nIn most cases, the entire queue \nwill not\n be traversed.\n\n\nThe inner-most layer of the onion represents the last item in the queue.\n\n\nResponses are returned back \nthrough\n the pipeline, in reverse order of\n  traversal.\n\n\n\n\n\n\nThe \nApplication\n allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.\n\n\nYou can attach middleware manually, in which case the pipeline is executed in\nthe order of attachment, or use configuration. When you use configuration, you\nwill specify a priority integer to dictate the order in which middleware should\nbe attached.  Middleware specifying high integer prioritiess are attached (and\nthus executed) earlier, while those specifying lower and/or negative integers\nare attached later. The default priority is 1.\n\n\nExpressive provides a default implementation of \"routing\" and \"dispatch\"\nmiddleware, which you either attach to the middleware pipeline manually, or via\nconfiguration.\n\n\nRouting within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:\n\n\n\n\nmap a GET request to the path \n/api/ping\n to the \nPingMiddleware\n\n\nmap a POST request to the path \n/contact/process\n to the \nHandleContactMiddleware\n\n\netc.\n\n\n\n\nDispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation.\n\n\nThe majority of your application will consist of routing rules that map to\nrouted middleware.\n\n\nMiddleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:\n\n\n\n\nbootstrapping\n\n\nparsing of request body parameters\n\n\naddition of debugging tools\n\n\nembedded Expressive applications that you want to match at a given literal\n  path\n\n\netc.\n\n\n\n\nSuch middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.\n\n\nMiddleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:\n\n\n\n\nrouting failed\n\n\nrouted middleware called on the next middleware instead of returning a response.\n\n\n\n\nAs such, the largest use case for such middleware is for error handling.\nOne possibility is for \nproviding custom 404 handling\n,\nor handling application-specific error conditions (such as authentication or\nauthorization failures).\n\n\nAnother possibility is to provide post-processing on the response before\nreturning it. However, this is typically better handled via middleware piped\nearly, by capturing the response before returning it:\n\n\nfunction ($request, $response, $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n}\n\n\n\nThe main points to remember are:\n\n\n\n\nThe application is a queue, and operates in FIFO order.\n\n\nEach middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.\n\n\nMost of the time, you will be defining \nrouted middleware\n, and the routing\n  rules that map to them.\n\n\nYou\n get to control the workflow of your application by deciding the order in\n  which middleware is queued.",
            "title": "Overview and Features"
        },
        {
            "location": "/v1/getting-started/features/#overview",
            "text": "Expressive allows you to write  PSR-7  middleware \napplications for the web.  PSR-7 is a standard defining HTTP message interfaces; these are the incoming\nrequest and outgoing response for your application. By using PSR-7, we ensure\nthat your applications will work in other PSR-7 contexts.  Middleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.  Middleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.  With Expressive, you can build PSR-7-based middleware applications:   APIs  Websites  Single Page Applications  and more.",
            "title": "Overview"
        },
        {
            "location": "/v1/getting-started/features/#features",
            "text": "Expressive builds on  zend-stratigility \nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:   Routing   Stratigility provides limited, literal matching only. Expressive allows you\n  to utilize dynamic routing capabilities from a variety of routers, providing\n  much more fine-grained matching capabilities. The routing layer also allows\n  restricting matched routes to specific HTTP methods, and will return \"405 Not\n  Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP\n  methods for invalid requests.  Routing is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-mvc router.   container-interop   Expressive encourages the use of Dependency Injection, and defines its\n   Application  class to compose a container-interop  ContainerInterface \n  instance. The container is used to lazy-load middleware, whether it is\n  piped (Stratigility interface) or routed (Expressive).   Templating   While Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.   Error Handling   Applications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own  FinalHandler  implementation, as well as\n  more advanced error handling via two specialized error handlers: a templated\n  error handler for production, and a Whoops-based error handler for development.",
            "title": "Features"
        },
        {
            "location": "/v1/getting-started/features/#flow-overview",
            "text": "Below is a diagram detailing the workflow used by Expressive.   The  Application  acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.  The  Application  dispatches each middleware. Each middleware accepts a request , a  response , and the  next  middleware to dispatch. Internally,\nit's actually receiving the middleware stack itself, which knows which\nmiddleware to invoke next.  Any given middleware can return a  response , at which point execution winds\nits way back out the onion. Additionally, any given middleware can indicate an\nerror occurred, at which point it can call on the next  error handling\nmiddleware . These act like regular middleware, but accept an additional error\nargument to act on.",
            "title": "Flow Overview"
        },
        {
            "location": "/v1/getting-started/features/#pipelines",
            "text": "The terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a  queue , which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:   In most cases, the entire queue  will not  be traversed.  The inner-most layer of the onion represents the last item in the queue.  Responses are returned back  through  the pipeline, in reverse order of\n  traversal.    The  Application  allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.  You can attach middleware manually, in which case the pipeline is executed in\nthe order of attachment, or use configuration. When you use configuration, you\nwill specify a priority integer to dictate the order in which middleware should\nbe attached.  Middleware specifying high integer prioritiess are attached (and\nthus executed) earlier, while those specifying lower and/or negative integers\nare attached later. The default priority is 1.  Expressive provides a default implementation of \"routing\" and \"dispatch\"\nmiddleware, which you either attach to the middleware pipeline manually, or via\nconfiguration.  Routing within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:   map a GET request to the path  /api/ping  to the  PingMiddleware  map a POST request to the path  /contact/process  to the  HandleContactMiddleware  etc.   Dispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation.  The majority of your application will consist of routing rules that map to\nrouted middleware.  Middleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:   bootstrapping  parsing of request body parameters  addition of debugging tools  embedded Expressive applications that you want to match at a given literal\n  path  etc.   Such middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.  Middleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:   routing failed  routed middleware called on the next middleware instead of returning a response.   As such, the largest use case for such middleware is for error handling.\nOne possibility is for  providing custom 404 handling ,\nor handling application-specific error conditions (such as authentication or\nauthorization failures).  Another possibility is to provide post-processing on the response before\nreturning it. However, this is typically better handled via middleware piped\nearly, by capturing the response before returning it:  function ($request, $response, $next)\n{\n    $response = $next($request, $response);\n    return $response->withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n}  The main points to remember are:   The application is a queue, and operates in FIFO order.  Each middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.  Most of the time, you will be defining  routed middleware , and the routing\n  rules that map to them.  You  get to control the workflow of your application by deciding the order in\n  which middleware is queued.",
            "title": "Pipelines"
        },
        {
            "location": "/v1/getting-started/standalone/",
            "text": "Quick Start: Standalone Usage\n\n\nExpressive allows you to get started at your own pace. You can start with\nthe simplest example, detailed below, or move on to a more structured,\nconfiguration-driven approach as detailed in the \nuse case examples\n.\n\n\n1. Create a new project directory\n\n\nFirst, let's create a new project directory and enter it:\n\n\n$ mkdir expressive\n$ cd expressive\n\n\n\n2. Install Expressive\n\n\nIf you haven't already, \ninstall Composer\n. Once you\nhave, we can install Expressive, along with a router and a container:\n\n\n$ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager\n\n\n\n\n\nRouters\n\n\nExpressive needs a routing implementation in order to create routed\nmiddleware. We suggest FastRoute in the quick start, but you can also\ncurrently choose from Aura.Router and zend-router.\n\n\nContainers\n\n\nWe highly recommend using dependency injection containers with Expressive;\nthey allow you to define dependencies for your middleware, as well as to lazy\nload your middleware only when it needs to be executed. We suggest\nzend-servicemanager in the quick start, but you can also use any container\nsupporting \ncontainer-interop\n.\n\n\n\n\n3. Create a web root directory\n\n\nYou'll need a directory from which to serve your application, and for security\nreasons, it's a good idea to keep it separate from your source code. We'll\ncreate a \npublic/\n directory for this:\n\n\n$ mkdir public\n\n\n\n4. Create your bootstrap script\n\n\nNext, we'll create a bootstrap script. Such scripts typically setup the\nenvironment, setup the application, and invoke it. This needs to be in our web\nroot, and we want it to intercept any incoming request; as such, we'll use\n\npublic/index.php\n:\n\n\n<?php\nuse Zend\\Expressive\\AppFactory;\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$app = AppFactory::create();\n\n$app->get('/', function ($request, $response, $next) {\n    $response->getBody()->write('Hello, world!');\n    return $response;\n});\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->run();\n\n\n\n\n\nRewriting URLs\n\n\nMany web servers will not rewrite URLs to the bootstrap script by default. If\nyou use Apache, for instance, you'll need to setup rewrite rules to ensure\nyour bootstrap is invoked for unknown URLs. We'll cover that in a later\nchapter.\n\n\nRouting and dispatching\n\n\nNote the lines from the above:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nExpressive's \nApplication\n class provides two separate middlewares, one for\nrouting, and one for dispatching middleware matched by routing. This allows\nyou to slip in validations between the two activities if desired. They are\nnot automatically piped to the application, however, to allow exactly that\nsituation, which means they must be piped manually.\n\n\n\n\n5. Start a web server\n\n\nSince we're just testing out the basic functionality of our application, we'll\nuse PHP's \nbuilt-in web server\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ php -S 0.0.0.0:8080 -t public/\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\n\n\nTip: Serve via Composer\n\n\nTo simplify starting up a local web server, try adding the following to your\n\ncomposer.json\n:\n\n\n\"scripts\": {\n    \"serve\": \"php -S 0.0.0.0:8080 -t public/\"\n}\n\n\n\nOnce you've added that, you can fire up the web server using:\n\n\n$ composer serve\n\n\n\n\n\nNext steps\n\n\nAt this point, you have a working zend-expressive application, that responds to\na single route. From here, you may want to read up on:\n\n\n\n\nApplications\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling\n\n\n\n\nAdditionally, we have more \nuse case examples\n.",
            "title": "Quick Start: Standalone"
        },
        {
            "location": "/v1/getting-started/standalone/#quick-start-standalone-usage",
            "text": "Expressive allows you to get started at your own pace. You can start with\nthe simplest example, detailed below, or move on to a more structured,\nconfiguration-driven approach as detailed in the  use case examples .",
            "title": "Quick Start: Standalone Usage"
        },
        {
            "location": "/v1/getting-started/standalone/#1-create-a-new-project-directory",
            "text": "First, let's create a new project directory and enter it:  $ mkdir expressive\n$ cd expressive",
            "title": "1. Create a new project directory"
        },
        {
            "location": "/v1/getting-started/standalone/#2-install-expressive",
            "text": "If you haven't already,  install Composer . Once you\nhave, we can install Expressive, along with a router and a container:  $ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager",
            "title": "2. Install Expressive"
        },
        {
            "location": "/v1/getting-started/standalone/#routers",
            "text": "Expressive needs a routing implementation in order to create routed\nmiddleware. We suggest FastRoute in the quick start, but you can also\ncurrently choose from Aura.Router and zend-router.",
            "title": "Routers"
        },
        {
            "location": "/v1/getting-started/standalone/#containers",
            "text": "We highly recommend using dependency injection containers with Expressive;\nthey allow you to define dependencies for your middleware, as well as to lazy\nload your middleware only when it needs to be executed. We suggest\nzend-servicemanager in the quick start, but you can also use any container\nsupporting  container-interop .",
            "title": "Containers"
        },
        {
            "location": "/v1/getting-started/standalone/#3-create-a-web-root-directory",
            "text": "You'll need a directory from which to serve your application, and for security\nreasons, it's a good idea to keep it separate from your source code. We'll\ncreate a  public/  directory for this:  $ mkdir public",
            "title": "3. Create a web root directory"
        },
        {
            "location": "/v1/getting-started/standalone/#4-create-your-bootstrap-script",
            "text": "Next, we'll create a bootstrap script. Such scripts typically setup the\nenvironment, setup the application, and invoke it. This needs to be in our web\nroot, and we want it to intercept any incoming request; as such, we'll use public/index.php :  <?php\nuse Zend\\Expressive\\AppFactory;\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$app = AppFactory::create();\n\n$app->get('/', function ($request, $response, $next) {\n    $response->getBody()->write('Hello, world!');\n    return $response;\n});\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n$app->run();",
            "title": "4. Create your bootstrap script"
        },
        {
            "location": "/v1/getting-started/standalone/#rewriting-urls",
            "text": "Many web servers will not rewrite URLs to the bootstrap script by default. If\nyou use Apache, for instance, you'll need to setup rewrite rules to ensure\nyour bootstrap is invoked for unknown URLs. We'll cover that in a later\nchapter.",
            "title": "Rewriting URLs"
        },
        {
            "location": "/v1/getting-started/standalone/#routing-and-dispatching",
            "text": "Note the lines from the above:  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();  Expressive's  Application  class provides two separate middlewares, one for\nrouting, and one for dispatching middleware matched by routing. This allows\nyou to slip in validations between the two activities if desired. They are\nnot automatically piped to the application, however, to allow exactly that\nsituation, which means they must be piped manually.",
            "title": "Routing and dispatching"
        },
        {
            "location": "/v1/getting-started/standalone/#5-start-a-web-server",
            "text": "Since we're just testing out the basic functionality of our application, we'll\nuse PHP's  built-in web server .  From the project root directory, execute the following:  $ php -S 0.0.0.0:8080 -t public/  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!",
            "title": "5. Start a web server"
        },
        {
            "location": "/v1/getting-started/standalone/#tip-serve-via-composer",
            "text": "To simplify starting up a local web server, try adding the following to your composer.json :  \"scripts\": {\n    \"serve\": \"php -S 0.0.0.0:8080 -t public/\"\n}  Once you've added that, you can fire up the web server using:  $ composer serve",
            "title": "Tip: Serve via Composer"
        },
        {
            "location": "/v1/getting-started/standalone/#next-steps",
            "text": "At this point, you have a working zend-expressive application, that responds to\na single route. From here, you may want to read up on:   Applications  Containers  Routing  Templating  Error Handling   Additionally, we have more  use case examples .",
            "title": "Next steps"
        },
        {
            "location": "/v1/getting-started/skeleton/",
            "text": "Quick Start: Using the Skeleton + Installer\n\n\nThe easiest way to get started with Expressive is to use the \nskeleton\napplication and installer\n.\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.\n\n\n1. Create a new project\n\n\nFirst, we'll create a new project, using Composer's \ncreate-project\n command:\n\n\n$ composer create-project zendframework/zend-expressive-skeleton expressive\n\n\n\nThis will prompt you to choose:\n\n\n\n\nA router. We recommend using the default, FastRoute.\n\n\nA dependency injection container. We recommend using the default, Zend\n  ServiceManager.\n\n\nA template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.\n\n\nAn error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.\n\n\n\n\n2. Start a web server\n\n\nThe Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using \nbuilt-in web\nserver\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ composer serve\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\nNext Steps\n\n\nThe skeleton makes the assumption that you will be writing your middleware as\nclasses, and using configuration to map routes to middleware. It also provides a\ndefault structure for templates, if you choose to use them. Let's see how you\ncan create first vanilla middleware, and then templated middleware.\n\n\nCreating middleware\n\n\nThe easiest way to create middleware is to create a class that defines an\n\n__invoke()\n method accepting a request, response, and callable \"next\" argument\n(for invoking the \"next\" middleware in the queue). The skeleton defines an \nApp\n\nnamespace for you, and suggests placing middleware under the namespace\n\nApp\\Action\n.\n\n\nLet's create a \"Hello\" action. Place the following in\n\nsrc/App/Action/HelloAction.php\n:\n\n\n<?php\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass HelloAction\n{\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n        $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\n\n        $response->getBody()->write(sprintf(\n            '<h1>Hello, %s!</h1>',\n            $target\n        ));\n        return $response->withHeader('Content-Type', 'text/html');\n    }\n}\n\n\n\nThe above looks for a query string parameter \"target\", and uses its value to\nprovide a message, which is then returned in an HTML response.\n\n\nNow we need to inform the application of this middleware, and indicate what\npath will invoke it. Open the file \nconfig/autoload/routes.global.php\n. Inside\nthat file, you should have a structure similar to the following:\n\n\nreturn [\n    'dependencies' => [\n        /* ... */\n    ],\n    'routes' => [\n        /* ... */\n    ],\n];\n\n\n\nWe're going to add an entry under \nroutes\n:\n\n\nreturn [\n    /* ... */\n    'routes' => [\n        /* ... */\n        [\n            'name' => 'hello',\n            'path' => '/hello',\n            'middleware' => App\\Action\\HelloAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n    ],\n];\n\n\n\nOnce you've added the above entry, give it a try by going to each of the\nfollowing URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYou should see the message change as you go between the two URIs!\n\n\nUsing templates\n\n\nYou likely don't want to hardcode HTML into your middleware; so, let's use\ntemplates. This particular exercise assumes you chose to use the\n\nPlates\n integration.\n\n\nTemplates are installed under the \ntemplates/\n subdirectory. By default, we also\nregister the template namespace \napp\n to correspond with the \ntemplates/app\n\nsubdirectory. Create the file \ntemplates/app/hello-world.phtml\n with the\nfollowing contents:\n\n\n<?php $this->layout('layout::default', ['title' => 'Greetings']) ?>\n\n<h2>Hello, <?= $this->e($target) ?></h2>\n\n\n\nNow that we have a template, we need to:\n\n\n\n\nInject a renderer into our action class.\n\n\nUse the renderer to render the contents.\n\n\n\n\nReplace your \nsrc/App/Action/HelloAction.php\n file with the following contents:\n\n\n<?php\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloAction\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        return new HtmlResponse(\n            $this->renderer->render('app::hello-world', ['target' => $target])\n        );\n    }\n}\n\n\n\nThe above modifies the class to accept a renderer to the constructor, and then\ncalls on it to render a template. A few things to note:\n\n\n\n\nWe no longer need to escape our target; the template takes care of that for us.\n\n\nWe're using a specific response type here, from\n  \nDiactoros\n, which is the\n  default PSR-7 implementation Expressive uses. This response type simplifies\n  our response creation.\n\n\n\n\nHow does the template renderer get into the action, however? The answer is\ndependency injection.\n\n\nFor the next part of the example, we'll be creating and wiring a factory for\ncreating the \nHelloAction\n instance; the example assumes you used the default\nselection for a dependency injection container, Zend ServiceManager.\n\n\nLet's create a factory. Create the file \nsrc/App/Action/HelloActionFactory.php\n with\nthe following contents:\n\n\n<?php\nnamespace App\\Action;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new HelloAction(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}\n\n\n\nWith that in place, we'll now update our configuration. Open the file\n\nconfig/autoload/routes.global.php\n; it should have a structure similar to\nthe following:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            /* ... */\n        ],\n    ],\n    'routes' => [\n        /* ... */\n    ],\n];\n\n\n\nWe're going to tell our application that we have a \nfactory\n for our\n\nHelloAction\n class:\n\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            /* ... */\n            App\\Action\\HelloAction::class => App\\Action\\HelloActionFactory::class,\n        ],\n    ],\n    'routes' => [\n        /* ... */\n    ],\n];\n\n\n\nSave that file, and now re-visit the URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYour page should now have the same layout as the landing page of the skeleton\napplication!\n\n\nCongratulations!\n\n\nCongratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:\n\n\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling",
            "title": "Quick Start: Skeleton Installer"
        },
        {
            "location": "/v1/getting-started/skeleton/#quick-start-using-the-skeleton-installer",
            "text": "The easiest way to get started with Expressive is to use the  skeleton\napplication and installer .\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.",
            "title": "Quick Start: Using the Skeleton + Installer"
        },
        {
            "location": "/v1/getting-started/skeleton/#1-create-a-new-project",
            "text": "First, we'll create a new project, using Composer's  create-project  command:  $ composer create-project zendframework/zend-expressive-skeleton expressive  This will prompt you to choose:   A router. We recommend using the default, FastRoute.  A dependency injection container. We recommend using the default, Zend\n  ServiceManager.  A template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.  An error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.",
            "title": "1. Create a new project"
        },
        {
            "location": "/v1/getting-started/skeleton/#2-start-a-web-server",
            "text": "The Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using  built-in web\nserver .  From the project root directory, execute the following:  $ composer serve  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!",
            "title": "2. Start a web server"
        },
        {
            "location": "/v1/getting-started/skeleton/#next-steps",
            "text": "The skeleton makes the assumption that you will be writing your middleware as\nclasses, and using configuration to map routes to middleware. It also provides a\ndefault structure for templates, if you choose to use them. Let's see how you\ncan create first vanilla middleware, and then templated middleware.",
            "title": "Next Steps"
        },
        {
            "location": "/v1/getting-started/skeleton/#creating-middleware",
            "text": "The easiest way to create middleware is to create a class that defines an __invoke()  method accepting a request, response, and callable \"next\" argument\n(for invoking the \"next\" middleware in the queue). The skeleton defines an  App \nnamespace for you, and suggests placing middleware under the namespace App\\Action .  Let's create a \"Hello\" action. Place the following in src/App/Action/HelloAction.php :  <?php\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass HelloAction\n{\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n        $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\n\n        $response->getBody()->write(sprintf(\n            '<h1>Hello, %s!</h1>',\n            $target\n        ));\n        return $response->withHeader('Content-Type', 'text/html');\n    }\n}  The above looks for a query string parameter \"target\", and uses its value to\nprovide a message, which is then returned in an HTML response.  Now we need to inform the application of this middleware, and indicate what\npath will invoke it. Open the file  config/autoload/routes.global.php . Inside\nthat file, you should have a structure similar to the following:  return [\n    'dependencies' => [\n        /* ... */\n    ],\n    'routes' => [\n        /* ... */\n    ],\n];  We're going to add an entry under  routes :  return [\n    /* ... */\n    'routes' => [\n        /* ... */\n        [\n            'name' => 'hello',\n            'path' => '/hello',\n            'middleware' => App\\Action\\HelloAction::class,\n            'allowed_methods' => ['GET'],\n        ],\n    ],\n];  Once you've added the above entry, give it a try by going to each of the\nfollowing URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   You should see the message change as you go between the two URIs!",
            "title": "Creating middleware"
        },
        {
            "location": "/v1/getting-started/skeleton/#using-templates",
            "text": "You likely don't want to hardcode HTML into your middleware; so, let's use\ntemplates. This particular exercise assumes you chose to use the Plates  integration.  Templates are installed under the  templates/  subdirectory. By default, we also\nregister the template namespace  app  to correspond with the  templates/app \nsubdirectory. Create the file  templates/app/hello-world.phtml  with the\nfollowing contents:  <?php $this->layout('layout::default', ['title' => 'Greetings']) ?>\n\n<h2>Hello, <?= $this->e($target) ?></h2>  Now that we have a template, we need to:   Inject a renderer into our action class.  Use the renderer to render the contents.   Replace your  src/App/Action/HelloAction.php  file with the following contents:  <?php\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloAction\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $query  = $request->getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        return new HtmlResponse(\n            $this->renderer->render('app::hello-world', ['target' => $target])\n        );\n    }\n}  The above modifies the class to accept a renderer to the constructor, and then\ncalls on it to render a template. A few things to note:   We no longer need to escape our target; the template takes care of that for us.  We're using a specific response type here, from\n   Diactoros , which is the\n  default PSR-7 implementation Expressive uses. This response type simplifies\n  our response creation.   How does the template renderer get into the action, however? The answer is\ndependency injection.  For the next part of the example, we'll be creating and wiring a factory for\ncreating the  HelloAction  instance; the example assumes you used the default\nselection for a dependency injection container, Zend ServiceManager.  Let's create a factory. Create the file  src/App/Action/HelloActionFactory.php  with\nthe following contents:  <?php\nnamespace App\\Action;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new HelloAction(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}  With that in place, we'll now update our configuration. Open the file config/autoload/routes.global.php ; it should have a structure similar to\nthe following:  return [\n    'dependencies' => [\n        'invokables' => [\n            /* ... */\n        ],\n    ],\n    'routes' => [\n        /* ... */\n    ],\n];  We're going to tell our application that we have a  factory  for our HelloAction  class:  return [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            /* ... */\n            App\\Action\\HelloAction::class => App\\Action\\HelloActionFactory::class,\n        ],\n    ],\n    'routes' => [\n        /* ... */\n    ],\n];  Save that file, and now re-visit the URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   Your page should now have the same layout as the landing page of the skeleton\napplication!",
            "title": "Using templates"
        },
        {
            "location": "/v1/getting-started/skeleton/#congratulations",
            "text": "Congratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:   Containers  Routing  Templating  Error Handling",
            "title": "Congratulations!"
        },
        {
            "location": "/v1/features/application/",
            "text": "Applications\n\n\nIn zend-expressive, you define a \nZend\\Expressive\\Application\n instance and\nexecute it. The \nApplication\n instance is itself \nmiddleware\n\nthat composes:\n\n\n\n\na \nrouter\n, for dynamically routing requests to middleware.\n\n\na \ndependency injection container\n, for retrieving\n  middleware to dispatch.\n\n\na \nfinal handler\n, for handling error conditions raised by\n  the application.\n\n\nan \nemitter\n,\n  for emitting the response when application execution is complete.\n\n\n\n\nYou can define the \nApplication\n instance in several ways:\n\n\n\n\nDirect instantiation, which requires providing several dependencies.\n\n\nThe \nAppFactory\n, which will use some common defaults, but allows injecting alternate\n  container and/or router implementations.\n\n\nVia a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.\n\n\n\n\nRegardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.\n\n\nInstantiation\n\n\nAs noted at the start of this document, we provide several ways to create an\n\nApplication\n instance.\n\n\nConstructor\n\n\nIf you wish to manually instantiate the \nApplication\n instance, it has the\nfollowing constructor:\n\n\n/**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Interop\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|callable $finalHandler Final handler to use when $out is not\n *     provided on invocation.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Interop\\Container\\ContainerInterface $container = null,\n    callable $finalHandler = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);\n\n\n\nIf no container is provided at instantiation, then all routed and piped\nmiddleware \nmust\n be provided as callables.\n\n\nAppFactory\n\n\nZend\\Expressive\\AppFactory\n provides a convenience layer for creating an\n\nApplication\n instance; it makes the assumption that you will use defaults in\nmost situations, and likely only change which container and/or router you wish\nto use. It has the following signature:\n\n\nAppFactory::create(\n    Interop\\Container\\ContainerInterface $container = null,\n    Zend\\Expressive\\Router\\RouterInterface $router = null\n);\n\n\n\nWhen no container or router are provided, it defaults to:\n\n\n\n\nzend-servicemanager for the container.\n\n\nFastRoute for the router.\n\n\n\n\nContainer factory\n\n\nWe also provide a factory that can be consumed by a\n\ncontainer-interop\n\ndependency injection container; see the \ncontainer factories documentation\n\nfor details.\n\n\nAdding routable middleware\n\n\nWe \ndiscuss routing vs piping elsewhere\n; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.\n\n\nRegardless of which \nrouter implementation\n you use, you\ncan use the following methods to provide routable middleware:\n\n\nroute()\n\n\nroute()\n has the following signature:\n\n\npublic function route(\n    $pathOrRoute,\n    $middleware = null,\n    array $methods = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nwhere:\n\n\n\n\n$pathOrRoute\n may be either a string path to match, or a\n  \nZend\\Expressive\\Router\\Route\n instance.\n\n\n$middleware\n \nmust\n be present if \n$pathOrRoute\n is a string path, and\n  \nmust\n be:\n\n\na callable;\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class;\n\n\nan array of any of the above; these will be composed in order into a\n    \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n$methods\n must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.\n\n\n$name\n is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on \nroute naming\n\n  for details.\n\n\n\n\nThis method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.\n\n\nget(), post(), put(), patch(), delete(), any()\n\n\nEach of the methods \nget()\n, \npost()\n, \nput()\n, \npatch()\n, \ndelete()\n, and \nany()\n\nproxies to \nroute()\n and has the signature:\n\n\nfunction (\n    $pathOrRoute,\n    $middleware = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\nEssentially, each calls \nroute()\n and specifies an array consisting solely of\nthe corresponding HTTP method for the \n$methods\n argument.\n\n\nPiping\n\n\nBecause zend-expressive builds on \nzend-stratigility\n,\nand, more specifically, its \nMiddlewarePipe\n definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.\n\n\nThe signature of \npipe()\n is:\n\n\npublic function pipe($pathOrMiddleware, $middleware = null)\n\n\n\nwhere:\n\n\n\n\n$pathOrMiddleware\n is either a string URI path (for path segregation), a\n  callable middleware, or the service name for a middleware to fetch from the\n  composed container.\n\n\n$middleware\n is required if \n$pathOrMiddleware\n is a string URI path. It can\n  be one of:\n\n\na callable;\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class;\n\n\nan array of any of the above; these will be composed in order into a\n    \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\nUnlike \nZend\\Stratigility\\MiddlewarePipe\n, \nApplication::pipe()\n \nallows\nfetching middleware by service name\n. This facility allows lazy-loading of\nmiddleware only when it is invoked. Internally, it wraps the call to fetch and\ndispatch the middleware inside a closure.\n\n\nAdditionally, we define a new method, \npipeErrorHandler()\n, with the following\nsignature:\n\n\npublic function pipeErrorHandler($pathOrMiddleware, $middleware = null)\n\n\n\nIt acts just like \npipe()\n except when the middleware specified is a service\nname; in that particular case, when it wraps the middleware in a closure, it\nuses the error handler signature:\n\n\nfunction ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next);\n\n\n\nRead the section on \npiping vs routing\n for more information.\n\n\nRegistering routing and dispatch middleware\n\n\nRouting is accomplished via a dedicated middleware method,\n\nApplication::routeMiddleware()\n; similarly, dispatching of routed middleware\nhas a corresponding instance middleware method, \nApplication::dispatchMiddleware()\n.\nEach can be piped/registered with other middleware platforms if desired.\n\n\nThese methods \nMUST\n be piped to the application so that the application will\nroute and dispatch routed middleware. This is done using the following methods:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nSee the section on \npiping\n to see how you can register\nnon-routed middleware and create layered middleware applications.\n\n\nRetrieving dependencies\n\n\nAs noted in the intro, the \nApplication\n class has several dependencies. Some of\nthese may allow further configuration, or may be useful on their own, and have\nmethods for retrieving them. They include:\n\n\n\n\ngetContainer()\n: returns the composed \ncontainer-interop\n\n  instance (used to retrieve routed middleware).\n\n\ngetEmitter()\n: returns the composed\n  \nemitter\n,\n  typically a \nZend\\Expressive\\Emitter\\EmitterStack\n instance.\n\n\ngetFinalHandler(ResponseInterface $response = null)\n: retrieves the final\n  handler instance. This is middleware with the signature \nfunction ($request,\n  $response, $error = null)\n, and it is invoked when the middleware pipeline\n  queue is depleted and no response has been returned.\n\n\n\n\nExecuting the application: run()\n\n\nWhen the application is completely setup, you can execute it with the \nrun()\n\nmethod. The method may be called with no arguments, but has the following\nsignature:\n\n\npublic function run(\n    ServerRequestInterface $request = null,\n    ResponseInterface $response = null\n);",
            "title": "Applications"
        },
        {
            "location": "/v1/features/application/#applications",
            "text": "In zend-expressive, you define a  Zend\\Expressive\\Application  instance and\nexecute it. The  Application  instance is itself  middleware \nthat composes:   a  router , for dynamically routing requests to middleware.  a  dependency injection container , for retrieving\n  middleware to dispatch.  a  final handler , for handling error conditions raised by\n  the application.  an  emitter ,\n  for emitting the response when application execution is complete.   You can define the  Application  instance in several ways:   Direct instantiation, which requires providing several dependencies.  The  AppFactory , which will use some common defaults, but allows injecting alternate\n  container and/or router implementations.  Via a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.   Regardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.",
            "title": "Applications"
        },
        {
            "location": "/v1/features/application/#instantiation",
            "text": "As noted at the start of this document, we provide several ways to create an Application  instance.",
            "title": "Instantiation"
        },
        {
            "location": "/v1/features/application/#constructor",
            "text": "If you wish to manually instantiate the  Application  instance, it has the\nfollowing constructor:  /**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Interop\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|callable $finalHandler Final handler to use when $out is not\n *     provided on invocation.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Interop\\Container\\ContainerInterface $container = null,\n    callable $finalHandler = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);  If no container is provided at instantiation, then all routed and piped\nmiddleware  must  be provided as callables.",
            "title": "Constructor"
        },
        {
            "location": "/v1/features/application/#appfactory",
            "text": "Zend\\Expressive\\AppFactory  provides a convenience layer for creating an Application  instance; it makes the assumption that you will use defaults in\nmost situations, and likely only change which container and/or router you wish\nto use. It has the following signature:  AppFactory::create(\n    Interop\\Container\\ContainerInterface $container = null,\n    Zend\\Expressive\\Router\\RouterInterface $router = null\n);  When no container or router are provided, it defaults to:   zend-servicemanager for the container.  FastRoute for the router.",
            "title": "AppFactory"
        },
        {
            "location": "/v1/features/application/#container-factory",
            "text": "We also provide a factory that can be consumed by a container-interop \ndependency injection container; see the  container factories documentation \nfor details.",
            "title": "Container factory"
        },
        {
            "location": "/v1/features/application/#adding-routable-middleware",
            "text": "We  discuss routing vs piping elsewhere ; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.  Regardless of which  router implementation  you use, you\ncan use the following methods to provide routable middleware:",
            "title": "Adding routable middleware"
        },
        {
            "location": "/v1/features/application/#route",
            "text": "route()  has the following signature:  public function route(\n    $pathOrRoute,\n    $middleware = null,\n    array $methods = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route  where:   $pathOrRoute  may be either a string path to match, or a\n   Zend\\Expressive\\Router\\Route  instance.  $middleware   must  be present if  $pathOrRoute  is a string path, and\n   must  be:  a callable;  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class;  an array of any of the above; these will be composed in order into a\n     Zend\\Stratigility\\MiddlewarePipe  instance.  $methods  must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.  $name  is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on  route naming \n  for details.   This method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.",
            "title": "route()"
        },
        {
            "location": "/v1/features/application/#get-post-put-patch-delete-any",
            "text": "Each of the methods  get() ,  post() ,  put() ,  patch() ,  delete() , and  any() \nproxies to  route()  and has the signature:  function (\n    $pathOrRoute,\n    $middleware = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route  Essentially, each calls  route()  and specifies an array consisting solely of\nthe corresponding HTTP method for the  $methods  argument.",
            "title": "get(), post(), put(), patch(), delete(), any()"
        },
        {
            "location": "/v1/features/application/#piping",
            "text": "Because zend-expressive builds on  zend-stratigility ,\nand, more specifically, its  MiddlewarePipe  definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.  The signature of  pipe()  is:  public function pipe($pathOrMiddleware, $middleware = null)  where:   $pathOrMiddleware  is either a string URI path (for path segregation), a\n  callable middleware, or the service name for a middleware to fetch from the\n  composed container.  $middleware  is required if  $pathOrMiddleware  is a string URI path. It can\n  be one of:  a callable;  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class;  an array of any of the above; these will be composed in order into a\n     Zend\\Stratigility\\MiddlewarePipe  instance.   Unlike  Zend\\Stratigility\\MiddlewarePipe ,  Application::pipe()   allows\nfetching middleware by service name . This facility allows lazy-loading of\nmiddleware only when it is invoked. Internally, it wraps the call to fetch and\ndispatch the middleware inside a closure.  Additionally, we define a new method,  pipeErrorHandler() , with the following\nsignature:  public function pipeErrorHandler($pathOrMiddleware, $middleware = null)  It acts just like  pipe()  except when the middleware specified is a service\nname; in that particular case, when it wraps the middleware in a closure, it\nuses the error handler signature:  function ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next);  Read the section on  piping vs routing  for more information.",
            "title": "Piping"
        },
        {
            "location": "/v1/features/application/#registering-routing-and-dispatch-middleware",
            "text": "Routing is accomplished via a dedicated middleware method, Application::routeMiddleware() ; similarly, dispatching of routed middleware\nhas a corresponding instance middleware method,  Application::dispatchMiddleware() .\nEach can be piped/registered with other middleware platforms if desired.  These methods  MUST  be piped to the application so that the application will\nroute and dispatch routed middleware. This is done using the following methods:  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();  See the section on  piping  to see how you can register\nnon-routed middleware and create layered middleware applications.",
            "title": "Registering routing and dispatch middleware"
        },
        {
            "location": "/v1/features/application/#retrieving-dependencies",
            "text": "As noted in the intro, the  Application  class has several dependencies. Some of\nthese may allow further configuration, or may be useful on their own, and have\nmethods for retrieving them. They include:   getContainer() : returns the composed  container-interop \n  instance (used to retrieve routed middleware).  getEmitter() : returns the composed\n   emitter ,\n  typically a  Zend\\Expressive\\Emitter\\EmitterStack  instance.  getFinalHandler(ResponseInterface $response = null) : retrieves the final\n  handler instance. This is middleware with the signature  function ($request,\n  $response, $error = null) , and it is invoked when the middleware pipeline\n  queue is depleted and no response has been returned.",
            "title": "Retrieving dependencies"
        },
        {
            "location": "/v1/features/application/#executing-the-application-run",
            "text": "When the application is completely setup, you can execute it with the  run() \nmethod. The method may be called with no arguments, but has the following\nsignature:  public function run(\n    ServerRequestInterface $request = null,\n    ResponseInterface $response = null\n);",
            "title": "Executing the application: run()"
        },
        {
            "location": "/v1/features/container/intro/",
            "text": "Containers\n\n\nExpressive promotes and advocates the usage of\n\nDependency Injection\n/\nInversion of Control\n\n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:\n\n\n\n\n\n\nDefining \napplication\n dependencies: routers, template engines, error\n  handlers, even the \nApplication\n instance itself.\n\n\n\n\n\n\nDefining \nmiddleware\n and related dependencies.\n\n\n\n\n\n\nThe \nApplication\n instance itself stores a container, from which it fetches\nmiddleware when ready to dispatch it; this encourages the idea of defining\nmiddleware-specific dependencies, and factories for ensuring they are injected.\n\n\nTo facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against \ncontainer-interop\n,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.\n\n\nAt this time, we document support for the following specific containers:\n\n\n\n\nzend-servicemanager\n\n\npimple-interop\n\n\naura.di\n\n\n\n\n\n\nService Names\n\n\nWe recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.\n\n\nFollowing these practices encourages the following:\n\n\n\n\nConsumers have a reasonable idea of what the service should return.\n\n\nUsing interface names as service names promotes re-use and substitution.\n\n\n\n\nIn a few cases, we define \"meta\" names. These are cases where there is no\nclear typehint to follow (e.g., most middleware only uses \ncallable\n as a\ntypehint, or where we want to imply specific configuration is necessary (e.g.,\n\nWhoops\n requires specific configuration to\nwork correctly with Expressive, and thus we do not want a generic service name\nfor it). We try to keep these to a minimum, however.",
            "title": "Introduction"
        },
        {
            "location": "/v1/features/container/intro/#containers",
            "text": "Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control \n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:    Defining  application  dependencies: routers, template engines, error\n  handlers, even the  Application  instance itself.    Defining  middleware  and related dependencies.    The  Application  instance itself stores a container, from which it fetches\nmiddleware when ready to dispatch it; this encourages the idea of defining\nmiddleware-specific dependencies, and factories for ensuring they are injected.  To facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against  container-interop ,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.  At this time, we document support for the following specific containers:   zend-servicemanager  pimple-interop  aura.di",
            "title": "Containers"
        },
        {
            "location": "/v1/features/container/intro/#service-names",
            "text": "We recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.  Following these practices encourages the following:   Consumers have a reasonable idea of what the service should return.  Using interface names as service names promotes re-use and substitution.   In a few cases, we define \"meta\" names. These are cases where there is no\nclear typehint to follow (e.g., most middleware only uses  callable  as a\ntypehint, or where we want to imply specific configuration is necessary (e.g., Whoops  requires specific configuration to\nwork correctly with Expressive, and thus we do not want a generic service name\nfor it). We try to keep these to a minimum, however.",
            "title": "Service Names"
        },
        {
            "location": "/v1/features/container/factories/",
            "text": "Provided Factories\n\n\nExpressive provides several factories compatible with container-interop to\nfacilitate setting up common dependencies. The following is a list of provided\ncontainers, what they will create, the suggested service name, and any\nadditional dependencies they may require.\n\n\nAll factories, unless noted otherwise, are in the \nZend\\Expressive\\Container\n\nnamespace, and define an \n__invoke()\n method that accepts an\n\nInterop\\Container\\ContainerInterface\n instance as the sole argument.\n\n\nApplicationFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Application\n\n\nSuggested Name\n: \nZend\\Expressive\\Application\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n. When provided, the service will\n  be used to construct the \nApplication\n instance; otherwise, an FastRoute router\n  implementation will be used.\n\n\nZend\\Expressive\\FinalHandler\n. This is a meta-service, as the only concrete\n  type required is a callable that can be used as a final middleware in the\n  case that the stack is exhausted before execution ends. By default, an\n  instance of \nZend\\Stratigility\\FinalHandler\n will be used.\n\n\nZend\\Diactoros\\Response\\EmitterInterface\n. If none is provided, an instance\n  of \nZend\\Expressive\\Emitter\\EmitterStack\n composing a\n  \nZend\\Diactoros\\Response\\SapiEmitter\n instance will be used.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  application instance with pre/post pipeline middleware and/or routed\n  middleware (see more below).\n\n\n\n\n\n\n\n\nAdditionally, the container instance itself is injected into the \nApplication\n\ninstance.\n\n\nWhen the \nconfig\n service is present, the factory can utilize several keys in\norder to seed the \nApplication\n instance:\n\n\n\n\nmiddleware_pipeline\n can be used to seed the middleware pipeline:\n\n\n\n\n'middleware_pipeline' => [\n    // An array of middleware to register.\n    [ /* ... */ ],\n    Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n    [ /* ... */ ],\n],\n\n\n\nEach item of the array, other than the entries for routing and dispatch\n  middleware, must be an array itself, with the following structure:\n\n\n[\n    // required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // optional:\n    'path'  => '/path/to/match',\n    'error' => true,\n    'priority' => 1, // Integer\n],\n\n\n\nThe \nmiddleware\n key itself is the middleware to execute, and must be a\n  callable or the name of another defined service. If the \npath\n key is present,\n  that key will be used to segregate the middleware to a specific matched path\n  (in other words, it will not execute if the path is not matched). If the\n  \nerror\n key is present and boolean \ntrue\n, then the middleware will be\n  registered as error middleware. (This is necessary due to the fact that the\n  factory defines a callable wrapper around middleware to enable lazy-loading of\n  middleware.) The \npriority\n defaults to 1, and follows the semantics of\n  \nSplPriorityQueue\n: higher integer values\n  indicate higher priority (will execute earlier), while lower/negative integer\n  values indicate lower priority (will execute last). Default priority is 1; use\n  granular priority values to specify the order in which middleware should be\n  piped to the application.\n\n\nYou \ncan\n specify keys for each middleware specification. These will be\n  ignored by the factory, but can be useful when merging several configurations\n  into one for the application.\n\n\n\n\nroutes\n is used to define routed middleware. The value must be an array,\n  consisting of arrays defining each middleware:\n\n\n\n\n'routes' => [\n    [\n        'path' => '/path/to/match',\n        'middleware' => 'Middleware Service Name or Callable',\n        'allowed_methods' => [ 'GET', 'POST', 'PATCH' ],\n        'options' => [\n            'stuff' => 'to',\n            'pass'  => 'to',\n            'the'   => 'underlying router',\n        ],\n    ],\n    // etc.\n],\n\n\n\nEach route \nrequires\n:\n\n\n- `path`: the path to match. Format will be based on the router you choose for\n  your project.\n\n- `middleware`: a callable or a service name for the middleware to execute\n  when the route matches.\n\n\n\n\nOptionally, the route definition may provide:\n\n\n- `allowed_methods`: an array of allowed HTTP methods. If not provided, the\n  application assumes any method is allowed.\n\n- `name`: if not provided, the path will be used as the route name (and, if\n  specific HTTP methods are allowed, a list of those).\n\n- `options`: a key/value set of additional options to pass to the underlying\n  router implementation for the given route. (Typical use cases include\n  passing constraints or default values.)\n\n\n\n\nTemplatedErrorHandlerFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\TemplatedErrorHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\FinalHandler\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the error\n  handler will not use templated responses.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nTemplatedErrorHandler\n instance with template names to use for errors (see\n  more below).\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize the\n\nzend-expressive\n top-level key, with the \nerror_handler\n second-level key, to\nseed the \nTemplated\n instance:\n\n\n'zend-expressive' => [\n    'error_handler' => [\n        'template_404'   => 'name of 404 template',\n        'template_error' => 'name of error template',\n    ],\n],\n\n\n\nWhoopsErrorHandlerFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\TemplatedErrorHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\FinalHandler\n\n\nRequires\n:\n\n\nZend\\Expressive\\Whoops\n, which should provide a \nWhoops\\Run\n instance.\n\n\nZend\\Expressive\\WhoopsPageHandler\n, which should provide a\n  \nWhoops\\Handler\\PrettyPageHandler\n instance.\n\n\n\n\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the error\n  handler will not use templated responses.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  instance with template names to use for errors (see more below).\n\n\n\n\n\n\n\n\nThis factory uses \nconfig\n in the same way as the\n\nTemplatedErrorHandlerFactory\n.\n\n\nWhoopsFactory\n\n\n\n\nProvides\n: \nWhoops\\Run\n\n\nSuggested Name\n: \nZend\\Expressive\\Whoops\n\n\nRequires\n:\n\n\nZend\\Expressive\\WhoopsPageHandler\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed\n  additional page handlers, specifically the \nJsonResponseHandler\n (see\n  more below).\n\n\n\n\n\n\n\n\nThis factory creates and configures a \nWhoops\\Run\n instance so that it will work\nproperly with \nZend\\Expressive\\Application\n; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The \nPrettyPageHandler\n returned\nfor the \nZend\\Expressive\\WhoopsPageHandler\n service will be injected.\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' => [\n    'json_exceptions' => [\n        'display'    => true,\n        'show_trace' => true,\n        'ajax_only'  => true,\n    ],\n],\n\n\n\nIf no \nwhoops\n top-level key is present in the configuration, a default instance\nwith no \nJsonResponseHandler\n composed will be created.\n\n\nWhoopsPageHandlerFactory\n\n\n\n\nProvides\n: \nWhoops\\Handler\\PrettyPageHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\WhoopsPageHandler\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPrettyPageHandler\n instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' => [\n    'editor' => 'editor name, editor service name, or callable',\n],\n\n\n\nThe \neditor\n value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.\n\n\nPlatesRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\PlatesRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Plates\\PlatesRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPlates\n instance, specifically with the filename extension\n  to use, and paths to inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' => [\n    'extension' => 'file extension used by templates; defaults to html',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nOne note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.\n\n\nTwigRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\TwigRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Twig\\TwigRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n; if found, it will be used to\n  seed a \nZend\\Expressive\\Twig\\TwigExtension\n instance for purposes\n  of rendering application URLs.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nTwig\n instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'debug' => boolean,\n'templates' => [\n    'cache_dir' => 'path to cached templates',\n    'assets_url' => 'base URL for assets',\n    'assets_version' => 'base version for assets',\n    'extension' => 'file extension used by templates; defaults to html.twig',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nWhen \ndebug\n is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The \nassets_*\n values are used to seed\nthe \nTwigExtension\n instance (assuming the router was found).\n\n\nZendViewRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\ZendViewRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\ZendView\\ZendViewRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nZend\\Expressive\\Router\\RouterInterface\n, in order to inject the custom\n  url helper implementation.\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nZendView\n instance, specifically with the layout template\n  name, entries for a \nTemplateMapResolver\n, and and template paths to\n  inject.\n\n\nZend\\View\\HelperPluginManager\n; if present, will be used to inject the\n  \nPhpRenderer\n instance.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' => [\n    'layout' => 'name of layout view to use, if any',\n    'map'    => [\n        // template => filename pairs\n    ],\n    'paths'  => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\nWhen creating the \nPhpRenderer\n instance, it will inject it with a\n\nZend\\View\\HelperPluginManager\n instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers, \nZend\\Expressive\\ZendView\\UrlHelper\n and\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n, respetively.",
            "title": "Container Factories"
        },
        {
            "location": "/v1/features/container/factories/#provided-factories",
            "text": "Expressive provides several factories compatible with container-interop to\nfacilitate setting up common dependencies. The following is a list of provided\ncontainers, what they will create, the suggested service name, and any\nadditional dependencies they may require.  All factories, unless noted otherwise, are in the  Zend\\Expressive\\Container \nnamespace, and define an  __invoke()  method that accepts an Interop\\Container\\ContainerInterface  instance as the sole argument.",
            "title": "Provided Factories"
        },
        {
            "location": "/v1/features/container/factories/#applicationfactory",
            "text": "Provides :  Zend\\Expressive\\Application  Suggested Name :  Zend\\Expressive\\Application  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface . When provided, the service will\n  be used to construct the  Application  instance; otherwise, an FastRoute router\n  implementation will be used.  Zend\\Expressive\\FinalHandler . This is a meta-service, as the only concrete\n  type required is a callable that can be used as a final middleware in the\n  case that the stack is exhausted before execution ends. By default, an\n  instance of  Zend\\Stratigility\\FinalHandler  will be used.  Zend\\Diactoros\\Response\\EmitterInterface . If none is provided, an instance\n  of  Zend\\Expressive\\Emitter\\EmitterStack  composing a\n   Zend\\Diactoros\\Response\\SapiEmitter  instance will be used.  config , an array or  ArrayAccess  instance. This will be used to seed the\n  application instance with pre/post pipeline middleware and/or routed\n  middleware (see more below).     Additionally, the container instance itself is injected into the  Application \ninstance.  When the  config  service is present, the factory can utilize several keys in\norder to seed the  Application  instance:   middleware_pipeline  can be used to seed the middleware pipeline:   'middleware_pipeline' => [\n    // An array of middleware to register.\n    [ /* ... */ ],\n    Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n    [ /* ... */ ],\n],  Each item of the array, other than the entries for routing and dispatch\n  middleware, must be an array itself, with the following structure:  [\n    // required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // optional:\n    'path'  => '/path/to/match',\n    'error' => true,\n    'priority' => 1, // Integer\n],  The  middleware  key itself is the middleware to execute, and must be a\n  callable or the name of another defined service. If the  path  key is present,\n  that key will be used to segregate the middleware to a specific matched path\n  (in other words, it will not execute if the path is not matched). If the\n   error  key is present and boolean  true , then the middleware will be\n  registered as error middleware. (This is necessary due to the fact that the\n  factory defines a callable wrapper around middleware to enable lazy-loading of\n  middleware.) The  priority  defaults to 1, and follows the semantics of\n   SplPriorityQueue : higher integer values\n  indicate higher priority (will execute earlier), while lower/negative integer\n  values indicate lower priority (will execute last). Default priority is 1; use\n  granular priority values to specify the order in which middleware should be\n  piped to the application.  You  can  specify keys for each middleware specification. These will be\n  ignored by the factory, but can be useful when merging several configurations\n  into one for the application.   routes  is used to define routed middleware. The value must be an array,\n  consisting of arrays defining each middleware:   'routes' => [\n    [\n        'path' => '/path/to/match',\n        'middleware' => 'Middleware Service Name or Callable',\n        'allowed_methods' => [ 'GET', 'POST', 'PATCH' ],\n        'options' => [\n            'stuff' => 'to',\n            'pass'  => 'to',\n            'the'   => 'underlying router',\n        ],\n    ],\n    // etc.\n],  Each route  requires :  - `path`: the path to match. Format will be based on the router you choose for\n  your project.\n\n- `middleware`: a callable or a service name for the middleware to execute\n  when the route matches.  Optionally, the route definition may provide:  - `allowed_methods`: an array of allowed HTTP methods. If not provided, the\n  application assumes any method is allowed.\n\n- `name`: if not provided, the path will be used as the route name (and, if\n  specific HTTP methods are allowed, a list of those).\n\n- `options`: a key/value set of additional options to pass to the underlying\n  router implementation for the given route. (Typical use cases include\n  passing constraints or default values.)",
            "title": "ApplicationFactory"
        },
        {
            "location": "/v1/features/container/factories/#templatederrorhandlerfactory",
            "text": "Provides :  Zend\\Expressive\\TemplatedErrorHandler  Suggested Name :  Zend\\Expressive\\FinalHandler  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error\n  handler will not use templated responses.  config , an array or  ArrayAccess  instance. This will be used to seed the\n   TemplatedErrorHandler  instance with template names to use for errors (see\n  more below).     When the  config  service is present, the factory can utilize the zend-expressive  top-level key, with the  error_handler  second-level key, to\nseed the  Templated  instance:  'zend-expressive' => [\n    'error_handler' => [\n        'template_404'   => 'name of 404 template',\n        'template_error' => 'name of error template',\n    ],\n],",
            "title": "TemplatedErrorHandlerFactory"
        },
        {
            "location": "/v1/features/container/factories/#whoopserrorhandlerfactory",
            "text": "Provides :  Zend\\Expressive\\TemplatedErrorHandler  Suggested Name :  Zend\\Expressive\\FinalHandler  Requires :  Zend\\Expressive\\Whoops , which should provide a  Whoops\\Run  instance.  Zend\\Expressive\\WhoopsPageHandler , which should provide a\n   Whoops\\Handler\\PrettyPageHandler  instance.    Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error\n  handler will not use templated responses.  config , an array or  ArrayAccess  instance. This will be used to seed the\n  instance with template names to use for errors (see more below).     This factory uses  config  in the same way as the TemplatedErrorHandlerFactory .",
            "title": "WhoopsErrorHandlerFactory"
        },
        {
            "location": "/v1/features/container/factories/#whoopsfactory",
            "text": "Provides :  Whoops\\Run  Suggested Name :  Zend\\Expressive\\Whoops  Requires :  Zend\\Expressive\\WhoopsPageHandler    Optional :  config , an array or  ArrayAccess  instance. This will be used to seed\n  additional page handlers, specifically the  JsonResponseHandler  (see\n  more below).     This factory creates and configures a  Whoops\\Run  instance so that it will work\nproperly with  Zend\\Expressive\\Application ; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The  PrettyPageHandler  returned\nfor the  Zend\\Expressive\\WhoopsPageHandler  service will be injected.  It consumes the following  config  structure:  'whoops' => [\n    'json_exceptions' => [\n        'display'    => true,\n        'show_trace' => true,\n        'ajax_only'  => true,\n    ],\n],  If no  whoops  top-level key is present in the configuration, a default instance\nwith no  JsonResponseHandler  composed will be created.",
            "title": "WhoopsFactory"
        },
        {
            "location": "/v1/features/container/factories/#whoopspagehandlerfactory",
            "text": "Provides :  Whoops\\Handler\\PrettyPageHandler  Suggested Name :  Zend\\Expressive\\WhoopsPageHandler  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  PrettyPageHandler  instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).     It consumes the following  config  structure:  'whoops' => [\n    'editor' => 'editor name, editor service name, or callable',\n],  The  editor  value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.",
            "title": "WhoopsPageHandlerFactory"
        },
        {
            "location": "/v1/features/container/factories/#platesrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\PlatesRenderer  FactoryName :  Zend\\Expressive\\Plates\\PlatesRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Plates  instance, specifically with the filename extension\n  to use, and paths to inject.     It consumes the following  config  structure:  'templates' => [\n    'extension' => 'file extension used by templates; defaults to html',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  One note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.",
            "title": "PlatesRendererFactory"
        },
        {
            "location": "/v1/features/container/factories/#twigrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\TwigRenderer  FactoryName :  Zend\\Expressive\\Twig\\TwigRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to\n  seed a  Zend\\Expressive\\Twig\\TwigExtension  instance for purposes\n  of rendering application URLs.  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Twig  instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.     It consumes the following  config  structure:  'debug' => boolean,\n'templates' => [\n    'cache_dir' => 'path to cached templates',\n    'assets_url' => 'base URL for assets',\n    'assets_version' => 'base version for assets',\n    'extension' => 'file extension used by templates; defaults to html.twig',\n    'paths' => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When  debug  is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The  assets_*  values are used to seed\nthe  TwigExtension  instance (assuming the router was found).",
            "title": "TwigRendererFactory"
        },
        {
            "location": "/v1/features/container/factories/#zendviewrendererfactory",
            "text": "Provides :  Zend\\Expressive\\Template\\ZendViewRenderer  FactoryName :  Zend\\Expressive\\ZendView\\ZendViewRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Zend\\Expressive\\Router\\RouterInterface , in order to inject the custom\n  url helper implementation.    Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  ZendView  instance, specifically with the layout template\n  name, entries for a  TemplateMapResolver , and and template paths to\n  inject.  Zend\\View\\HelperPluginManager ; if present, will be used to inject the\n   PhpRenderer  instance.     It consumes the following  config  structure:  'templates' => [\n    'layout' => 'name of layout view to use, if any',\n    'map'    => [\n        // template => filename pairs\n    ],\n    'paths'  => [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When creating the  PhpRenderer  instance, it will inject it with a Zend\\View\\HelperPluginManager  instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers,  Zend\\Expressive\\ZendView\\UrlHelper  and Zend\\Expressive\\ZendView\\ServerUrlHelper , respetively.",
            "title": "ZendViewRendererFactory"
        },
        {
            "location": "/v1/features/container/zend-servicemanager/",
            "text": "Using zend-servicemanager\n\n\nzend-servicemanager\n is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:\n\n\n\n\nlazy-loading of invokable (constructor-less) classes.\n\n\nability to define factories for specific classes.\n\n\nability to define generalized factories for classes with identical\n  construction patterns (aka \nabstract factories\n).\n\n\nability to create lazy-loading proxies.\n\n\nability to intercept before or after instantiation to alter the construction\n  workflow (aka \ndelegator factories\n).\n\n\ninterface injection (via \ninitializers\n).\n\n\n\n\nzend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:\n\n\n[\n    'services' => [\n        'service name' => $serviceInstance,\n    ],\n    'invokables' => [\n        'service name' => 'class to instantiate',\n    ],\n    'factories' => [\n        'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' => [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' => [\n        'service name' => [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' => [\n        'class_map' => [\n            'service name' => 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' => [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]\n\n\n\nRead more about zend-servicemanager in \nits documentation\n.\n\n\nInstalling zend-servicemanager\n\n\nTo use zend-servicemanager with zend-expressive, you can install it via\ncomposer:\n\n\n$ composer require zendframework/zend-servicemanager\n\n\n\nConfiguring zend-servicemanager\n\n\nYou can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.\n\n\nProgrammatically\n\n\nTo use zend-servicemanager programatically, you'll need to create a\n\nZend\\ServiceManager\\ServiceManager\n instance, and then start populating it.\n\n\nFor this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in \nconfig/config.php\n, and that that file\nreturns an array.\n\n\nWe'll create a \nconfig/services.php\n file that creates and returns a\n\nZend\\ServiceManager\\ServiceManager\n instance as follows:\n\n\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container->setService('config', include 'config/config.php');\n$container->setFactory(\n    'Zend\\Expressive\\Application',\n    'Zend\\Expressive\\Container\\ApplicationFactory'\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container->setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\AuraRouter'\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container->setInvokableClass(\n    'Zend\\Expressive\\Template\\TemplateRendererInterface',\n    'Zend\\Expressive\\Plates\\PlatesRenderer'\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation:\n$container->setFactory(\n    'Zend\\Expressive\\Whoops',\n    'Zend\\Expressive\\Container\\WhoopsFactory'\n);\n$container->setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory'\n);\n\n// Error Handling\n// If in development:\n$container->setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory'\n);\n\n// If in production:\n$container->setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory'\n);\n\nreturn $container;\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/services.php';\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();\n\n\n\nConfiguration-Driven Container\n\n\nAlternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in \nconfig/config.php\n, and our\n\nconfig/services.php\n file will still return our service manager instance; we'll\ndefine the service configuration in \nconfig/dependencies.php\n:\n\n\nreturn [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'invokables' => [\n        'Zend\\Expressive\\Router\\RouterInterface'     => 'Zend\\Expressive\\Router\\AuraRouter',\n        'Zend\\Expressive\\Template\\TemplateRendererInterface' => 'Zend\\Expressive\\Plates\\PlatesRenderer'\n    ],\n    'factories' => [\n        'Zend\\Expressive\\Application'       => 'Zend\\Expressive\\Container\\ApplicationFactory',\n        'Zend\\Expressive\\Whoops'            => 'Zend\\Expressive\\Container\\WhoopsFactory',\n        'Zend\\Expressive\\WhoopsPageHandler' => 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory',\n    ],\n];\n\n\n\nconfig/services.php\n becomes:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));\n\n\n\nThere is one problem, however: which final handler should you configure? You\nhave two choices on how to approach this:\n\n\n\n\nSelectively inject the factory in the bootstrap.\n\n\nDefine the final handler service in an environment specific file and use file\n  globbing to merge files.\n\n\n\n\nIn the first case, you would change the \nconfig/services.php\n example to look\nlike this:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/services.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        $container->setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory'\n        );\n        break;\n    case 'production':\n    default:\n        $container->setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory'\n        );\n}\nreturn $container;\n\n\n\nIn the second case, you will need to install zend-config:\n\n\n$ composer require zendframework/zend-config\n\n\n\nThen, create the directory \nconfig/autoload/\n, and create two files,\n\ndependencies.global.php\n and \ndependencies.local.php\n. In your \n.gitignore\n,\nadd an entry for \nconfig/autoload/*local.php\n to ensure \"local\"\n(environment-specific) files are excluded from the repository.\n\n\nconfig/dependencies.php\n will look like this:\n\n\nuse Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);\n\n\n\nconfig/autoload/dependencies.global.php\n will look like this:\n\n\nreturn [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'invokables' => [\n        'Zend\\Expressive\\Router\\RouterInterface'     => 'Zend\\Expressive\\Router\\AuraRouter',\n        'Zend\\Expressive\\Template\\TemplateRendererInterface' => 'Zend\\Expressive\\Plates\\PlatesRenderer'\n    ],\n    'factories' => [\n        'Zend\\Expressive\\Application'       => 'Zend\\Expressive\\Container\\ApplicationFactory',\n        'Zend\\Expressive\\FinalHandler'      => 'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory',\n    ],\n];\n\n\n\nconfig/autoload/dependencies.local.php\n on your development machine can look\nlike this:\n\n\nreturn [\n    'factories' => [\n        'Zend\\Expressive\\FinalHandler'      => 'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory',\n        'Zend\\Expressive\\Whoops'            => 'Zend\\Expressive\\Container\\WhoopsFactory',\n        'Zend\\Expressive\\WhoopsPageHandler' => 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory',\n    ],\n];\n\n\n\nUsing the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)",
            "title": "Using zend-servicemanager"
        },
        {
            "location": "/v1/features/container/zend-servicemanager/#using-zend-servicemanager",
            "text": "zend-servicemanager  is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:   lazy-loading of invokable (constructor-less) classes.  ability to define factories for specific classes.  ability to define generalized factories for classes with identical\n  construction patterns (aka  abstract factories ).  ability to create lazy-loading proxies.  ability to intercept before or after instantiation to alter the construction\n  workflow (aka  delegator factories ).  interface injection (via  initializers ).   zend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:  [\n    'services' => [\n        'service name' => $serviceInstance,\n    ],\n    'invokables' => [\n        'service name' => 'class to instantiate',\n    ],\n    'factories' => [\n        'service name' => 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' => [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' => [\n        'service name' => [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' => [\n        'class_map' => [\n            'service name' => 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' => [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]  Read more about zend-servicemanager in  its documentation .",
            "title": "Using zend-servicemanager"
        },
        {
            "location": "/v1/features/container/zend-servicemanager/#installing-zend-servicemanager",
            "text": "To use zend-servicemanager with zend-expressive, you can install it via\ncomposer:  $ composer require zendframework/zend-servicemanager",
            "title": "Installing zend-servicemanager"
        },
        {
            "location": "/v1/features/container/zend-servicemanager/#configuring-zend-servicemanager",
            "text": "You can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.",
            "title": "Configuring zend-servicemanager"
        },
        {
            "location": "/v1/features/container/zend-servicemanager/#programmatically",
            "text": "To use zend-servicemanager programatically, you'll need to create a Zend\\ServiceManager\\ServiceManager  instance, and then start populating it.  For this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in  config/config.php , and that that file\nreturns an array.  We'll create a  config/services.php  file that creates and returns a Zend\\ServiceManager\\ServiceManager  instance as follows:  use Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container->setService('config', include 'config/config.php');\n$container->setFactory(\n    'Zend\\Expressive\\Application',\n    'Zend\\Expressive\\Container\\ApplicationFactory'\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container->setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\AuraRouter'\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container->setInvokableClass(\n    'Zend\\Expressive\\Template\\TemplateRendererInterface',\n    'Zend\\Expressive\\Plates\\PlatesRenderer'\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation:\n$container->setFactory(\n    'Zend\\Expressive\\Whoops',\n    'Zend\\Expressive\\Container\\WhoopsFactory'\n);\n$container->setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory'\n);\n\n// Error Handling\n// If in development:\n$container->setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory'\n);\n\n// If in production:\n$container->setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory'\n);\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/services.php';\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();",
            "title": "Programmatically"
        },
        {
            "location": "/v1/features/container/zend-servicemanager/#configuration-driven-container",
            "text": "Alternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in  config/config.php , and our config/services.php  file will still return our service manager instance; we'll\ndefine the service configuration in  config/dependencies.php :  return [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'invokables' => [\n        'Zend\\Expressive\\Router\\RouterInterface'     => 'Zend\\Expressive\\Router\\AuraRouter',\n        'Zend\\Expressive\\Template\\TemplateRendererInterface' => 'Zend\\Expressive\\Plates\\PlatesRenderer'\n    ],\n    'factories' => [\n        'Zend\\Expressive\\Application'       => 'Zend\\Expressive\\Container\\ApplicationFactory',\n        'Zend\\Expressive\\Whoops'            => 'Zend\\Expressive\\Container\\WhoopsFactory',\n        'Zend\\Expressive\\WhoopsPageHandler' => 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory',\n    ],\n];  config/services.php  becomes:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));  There is one problem, however: which final handler should you configure? You\nhave two choices on how to approach this:   Selectively inject the factory in the bootstrap.  Define the final handler service in an environment specific file and use file\n  globbing to merge files.   In the first case, you would change the  config/services.php  example to look\nlike this:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/services.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        $container->setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory'\n        );\n        break;\n    case 'production':\n    default:\n        $container->setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory'\n        );\n}\nreturn $container;  In the second case, you will need to install zend-config:  $ composer require zendframework/zend-config  Then, create the directory  config/autoload/ , and create two files, dependencies.global.php  and  dependencies.local.php . In your  .gitignore ,\nadd an entry for  config/autoload/*local.php  to ensure \"local\"\n(environment-specific) files are excluded from the repository.  config/dependencies.php  will look like this:  use Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);  config/autoload/dependencies.global.php  will look like this:  return [\n    'services' => [\n        'config' => include __DIR__ . '/config.php',\n    ],\n    'invokables' => [\n        'Zend\\Expressive\\Router\\RouterInterface'     => 'Zend\\Expressive\\Router\\AuraRouter',\n        'Zend\\Expressive\\Template\\TemplateRendererInterface' => 'Zend\\Expressive\\Plates\\PlatesRenderer'\n    ],\n    'factories' => [\n        'Zend\\Expressive\\Application'       => 'Zend\\Expressive\\Container\\ApplicationFactory',\n        'Zend\\Expressive\\FinalHandler'      => 'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory',\n    ],\n];  config/autoload/dependencies.local.php  on your development machine can look\nlike this:  return [\n    'factories' => [\n        'Zend\\Expressive\\FinalHandler'      => 'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory',\n        'Zend\\Expressive\\Whoops'            => 'Zend\\Expressive\\Container\\WhoopsFactory',\n        'Zend\\Expressive\\WhoopsPageHandler' => 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory',\n    ],\n];  Using the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)",
            "title": "Configuration-Driven Container"
        },
        {
            "location": "/v1/features/container/pimple/",
            "text": "Using Pimple\n\n\nPimple\n is a widely used code-driven dependency\ninjection container provided as a standalone component by SensioLabs. It\nfeatures:\n\n\n\n\ncombined parameter and service storage.\n\n\nability to define factories for specific classes.\n\n\nlazy-loading via factories.\n\n\n\n\nPimple only supports programmatic creation at this time.\n\n\nInstalling Pimple\n\n\nPimple does not currently (as of v3) implement\n\ncontainer-interop\n; as\nsuch, you need to install the \nxtreamwayz/pimple-container-interop\n project,\nwhich provides a container-interop wrapper around Pimple v3:\n\n\n$ composer require xtreamwayz/pimple-container-interop\n\n\n\nConfiguring Pimple\n\n\nTo configure Pimple, instantiate it, and then add the factories desired. We\nrecommend doing this in a dedicated script that returns the Pimple instance; in\nthis example, we'll have that in \nconfig/services.php\n.\n\n\nuse Xtreamwayz\\Pimple\\Container as Pimple;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\n$container = new Pimple();\n\n// Application and configuration\n$container['config'] = include 'config/config.php';\n$container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory;\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) {\n    return new Router\\Aura();\n};\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container[TemplateRendererInterface::class] = function ($container) {\n    return new PlatesRenderer();\n};\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation:\n$container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory();\n$container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory();\n\n// Error Handling\n// If in development:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\WhoopsErrorHandlerFactory();\n\n// If in production:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\TemplatedErrorHandlerFactory();\n\nreturn $container;\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\n$container = require 'config/services.php';\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();\n\n\n\n\n\nEnvironments\n\n\nIn the example above, we provide two alternate definitions for the service\n\nZend\\Expressive\\FinalHandler\n, one for development and one for production.\nYou will need to add logic to your file to determine which definition to\nprovide; this could be accomplished via an environment variable.",
            "title": "Using Pimple"
        },
        {
            "location": "/v1/features/container/pimple/#using-pimple",
            "text": "Pimple  is a widely used code-driven dependency\ninjection container provided as a standalone component by SensioLabs. It\nfeatures:   combined parameter and service storage.  ability to define factories for specific classes.  lazy-loading via factories.   Pimple only supports programmatic creation at this time.",
            "title": "Using Pimple"
        },
        {
            "location": "/v1/features/container/pimple/#installing-pimple",
            "text": "Pimple does not currently (as of v3) implement container-interop ; as\nsuch, you need to install the  xtreamwayz/pimple-container-interop  project,\nwhich provides a container-interop wrapper around Pimple v3:  $ composer require xtreamwayz/pimple-container-interop",
            "title": "Installing Pimple"
        },
        {
            "location": "/v1/features/container/pimple/#configuring-pimple",
            "text": "To configure Pimple, instantiate it, and then add the factories desired. We\nrecommend doing this in a dedicated script that returns the Pimple instance; in\nthis example, we'll have that in  config/services.php .  use Xtreamwayz\\Pimple\\Container as Pimple;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\n$container = new Pimple();\n\n// Application and configuration\n$container['config'] = include 'config/config.php';\n$container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory;\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) {\n    return new Router\\Aura();\n};\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container[TemplateRendererInterface::class] = function ($container) {\n    return new PlatesRenderer();\n};\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation:\n$container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory();\n$container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory();\n\n// Error Handling\n// If in development:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\WhoopsErrorHandlerFactory();\n\n// If in production:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\TemplatedErrorHandlerFactory();\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\n$container = require 'config/services.php';\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();",
            "title": "Configuring Pimple"
        },
        {
            "location": "/v1/features/container/pimple/#environments",
            "text": "In the example above, we provide two alternate definitions for the service Zend\\Expressive\\FinalHandler , one for development and one for production.\nYou will need to add logic to your file to determine which definition to\nprovide; this could be accomplished via an environment variable.",
            "title": "Environments"
        },
        {
            "location": "/v1/features/container/aura-di/",
            "text": "Using Aura.Di\n\n\nAura.Di\n provides a serializable dependency\ninjection container with the following features:\n\n\n\n\nconstructor and setter injection.\n\n\ninheritance of constructor parameter and setter method values from parent\n  classes.\n\n\ninheritance of setter method values from interfaces and traits.\n\n\nlazy-loaded instances, services, includes/requires, and values.\n\n\ninstance factories.\n\n\noptional auto-resolution of typehinted constructor parameter values.\n\n\n\n\nInstalling Aura.Di\n\n\nAura.Di only implements \ncontainer-interop\n\nas of version 3 (in beta at the time of writing).\n\n\n$ composer require \"aura/di:3.0.*@beta\"\n\n\n\nConfiguration\n\n\nAura.Di can help you to organize your code better with\n\nContainerConfig classes\n and\n\ntwo step configuration\n.\nIn this example, we'll put that in \nconfig/services.php\n:\n\n\n<?php\nuse Aura\\Di\\ContainerBuilder;\n\n$containerBuilder = new ContainerBuilder();\n\n// Use the builder to create and configure a container using an array of\n// ContainerConfig classes. Make sure the classes can be autoloaded!\nreturn $containerBuilder->newConfiguredInstance([\n    'Application\\Config\\Common',\n]);\n\n\n\nThe bare minimum \nContainerConfig\n code needed to make zend-expressive work is:\n\n\n<?php\n// In src/Config/Common.php:\nnamespace Application\\Config;\n\nuse Aura\\Di\\Container;\nuse Aura\\Di\\ContainerConfig;\nuse Aura\\Router\\Generator;\nuse Aura\\Router\\RouteCollection;\nuse Aura\\Router\\RouteFactory;\nuse Aura\\Router\\Router;\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router\\AuraRouter;\nuse Zend\\Expressive\\Router\\Route;\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass Common extends ContainerConfig\n{\n    public function define(Container $di)\n    {\n        $di->params[RouteCollection::class] = array(\n            'route_factory' => $di->lazyNew(RouteFactory::class),\n        );\n        $di->params[Router::class] = array(\n            'routes' => $di->lazyNew(RouteCollection::class),\n            'generator' => $di->lazyNew(Generator::class),\n        );\n        $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class);\n        $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class));\n        $di->set(Container\\ApplicationFactory::class, $di->lazyNew(Container\\ApplicationFactory::class));\n        $di->set(Application::class, $di->lazyGetCall(Container\\ApplicationFactory::class, '__invoke', $di));\n\n        // Templating\n        // In most cases, you can instantiate the template renderer you want to use\n        // without using a factory:\n        $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class));\n\n        // These next two can be added in any environment; they won't be used unless\n        // you add the WhoopsErrorHandler as the FinalHandler implementation:\n        $di->set(Container\\WhoopsFactory::class, $di->lazyNew(Container\\WhoopsFactory::class));\n        $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(Container\\WhoopsFactory::class, '__invoke', $di));\n        $di->set(Container\\WhoopsPageHandlerFactory::class, $di->lazyNew(Container\\WhoopsPageHandlerFactory::class));\n        $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(Container\\WhoopsPageHandlerFactory::class, '__invoke', $di));\n\n        // Error Handling\n\n        // If in development:\n        $di->set(Container\\WhoopsErrorHandlerFactory::class, $di->lazyNew(Container\\WhoopsErrorHandlerFactory::class));\n        $di->set('Zend\\Expressive\\FinalHandler', $di->lazyGetCall(Container\\WhoopsErrorHandlerFactory::class, '__invoke', $di));\n\n        // If in production:\n        // $di->set('Zend\\Expressive\\FinalHandler', $di->lazyGetCall(Container\\TemplatedErrorHandlerFactory::class, '__invoke', $di));\n    }\n\n    public function modify(Container $di)\n    {\n        /*\n        $router = $di->get(RouterInterface::class);\n        $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) {\n            $escaper = new Escaper();\n            $name = $request->getAttribute('name', 'World');\n            $response->getBody()->write('Hello ' . $escaper->escapeHtml($name));\n            return $response;\n        }, Route::HTTP_METHOD_ANY, 'hello'));\n        */\n    }\n}\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/services.php';\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();",
            "title": "Using Aura.Di"
        },
        {
            "location": "/v1/features/container/aura-di/#using-auradi",
            "text": "Aura.Di  provides a serializable dependency\ninjection container with the following features:   constructor and setter injection.  inheritance of constructor parameter and setter method values from parent\n  classes.  inheritance of setter method values from interfaces and traits.  lazy-loaded instances, services, includes/requires, and values.  instance factories.  optional auto-resolution of typehinted constructor parameter values.",
            "title": "Using Aura.Di"
        },
        {
            "location": "/v1/features/container/aura-di/#installing-auradi",
            "text": "Aura.Di only implements  container-interop \nas of version 3 (in beta at the time of writing).  $ composer require \"aura/di:3.0.*@beta\"",
            "title": "Installing Aura.Di"
        },
        {
            "location": "/v1/features/container/aura-di/#configuration",
            "text": "Aura.Di can help you to organize your code better with ContainerConfig classes  and two step configuration .\nIn this example, we'll put that in  config/services.php :  <?php\nuse Aura\\Di\\ContainerBuilder;\n\n$containerBuilder = new ContainerBuilder();\n\n// Use the builder to create and configure a container using an array of\n// ContainerConfig classes. Make sure the classes can be autoloaded!\nreturn $containerBuilder->newConfiguredInstance([\n    'Application\\Config\\Common',\n]);  The bare minimum  ContainerConfig  code needed to make zend-expressive work is:  <?php\n// In src/Config/Common.php:\nnamespace Application\\Config;\n\nuse Aura\\Di\\Container;\nuse Aura\\Di\\ContainerConfig;\nuse Aura\\Router\\Generator;\nuse Aura\\Router\\RouteCollection;\nuse Aura\\Router\\RouteFactory;\nuse Aura\\Router\\Router;\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router\\AuraRouter;\nuse Zend\\Expressive\\Router\\Route;\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass Common extends ContainerConfig\n{\n    public function define(Container $di)\n    {\n        $di->params[RouteCollection::class] = array(\n            'route_factory' => $di->lazyNew(RouteFactory::class),\n        );\n        $di->params[Router::class] = array(\n            'routes' => $di->lazyNew(RouteCollection::class),\n            'generator' => $di->lazyNew(Generator::class),\n        );\n        $di->params[AuraRouter::class]['router'] = $di->lazyNew(Router::class);\n        $di->set(RouterInterface::class, $di->lazyNew(AuraRouter::class));\n        $di->set(Container\\ApplicationFactory::class, $di->lazyNew(Container\\ApplicationFactory::class));\n        $di->set(Application::class, $di->lazyGetCall(Container\\ApplicationFactory::class, '__invoke', $di));\n\n        // Templating\n        // In most cases, you can instantiate the template renderer you want to use\n        // without using a factory:\n        $di->set(TemplateRendererInterface::class, $di->lazyNew(PlatesRenderer::class));\n\n        // These next two can be added in any environment; they won't be used unless\n        // you add the WhoopsErrorHandler as the FinalHandler implementation:\n        $di->set(Container\\WhoopsFactory::class, $di->lazyNew(Container\\WhoopsFactory::class));\n        $di->set('Zend\\Expressive\\Whoops', $di->lazyGetCall(Container\\WhoopsFactory::class, '__invoke', $di));\n        $di->set(Container\\WhoopsPageHandlerFactory::class, $di->lazyNew(Container\\WhoopsPageHandlerFactory::class));\n        $di->set('Zend\\Expressive\\WhoopsPageHandler', $di->lazyGetCall(Container\\WhoopsPageHandlerFactory::class, '__invoke', $di));\n\n        // Error Handling\n\n        // If in development:\n        $di->set(Container\\WhoopsErrorHandlerFactory::class, $di->lazyNew(Container\\WhoopsErrorHandlerFactory::class));\n        $di->set('Zend\\Expressive\\FinalHandler', $di->lazyGetCall(Container\\WhoopsErrorHandlerFactory::class, '__invoke', $di));\n\n        // If in production:\n        // $di->set('Zend\\Expressive\\FinalHandler', $di->lazyGetCall(Container\\TemplatedErrorHandlerFactory::class, '__invoke', $di));\n    }\n\n    public function modify(Container $di)\n    {\n        /*\n        $router = $di->get(RouterInterface::class);\n        $router->addRoute(new Route('/hello/{name}', function ($request, $response, $next) {\n            $escaper = new Escaper();\n            $name = $request->getAttribute('name', 'World');\n            $response->getBody()->write('Hello ' . $escaper->escapeHtml($name));\n            return $response;\n        }, Route::HTTP_METHOD_ANY, 'hello'));\n        */\n    }\n}  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/services.php';\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();",
            "title": "Configuration"
        },
        {
            "location": "/v1/features/router/intro/",
            "text": "Routing\n\n\nOne fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:\n\n\n\n\n/books\n might return a collection of books\n\n\n/books/zend-expressive\n might return the individual book identified by\n  \"zend-expressive\".\n\n\n\n\nExpressive does not provide routing on its own; you must choose a routing\nadapter that implements \nZend\\Expressive\\Router\\RouterInterface\n and provide it\nto the \nApplication\n instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.\n\n\nRetrieving matched parameters\n\n\nRouting enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as \nattributes\n.\n\n\nIn the example above, let's assume the route was defined as \n/books/:id\n, where\n\nid\n is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the \nid\n attribute to discover what was\nmatched:\n\n\n$id = $request->getAttribute('id');\n\n\n\nRetrieving the matched route\n\n\nWhen routing is successful, the routing middleware injects a\n\nZend\\Expressive\\Router\\RouteResult\n instance as a request attribute, using that\nclass name as the attribute name. The \nRouteResult\n instance provides you access\nto the following:\n\n\n\n\nThe matched route name, via \n$result->getMatchedRouteName()\n.\n\n\nThe matched middleware, via \n$result->getMatchedMiddleware()\n.\n\n\nMatched parameters, via \n$result->getMatchedParams()\n (as noted above, these\n  are also each injected as discrete request attributes).\n\n\nAllowed HTTP methods, via \n$result->getAllowedMethods()\n.\n\n\n\n\nAs an example, you could use middleware similar to the following to return a 403\nresponse if routing was successful, but no \nAuthorization\n header is present:\n\n\nuse Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nfunction ($request, $response, $next) use ($routesRequiringAuthorization, $validator) {\n    if (! ($result = $request->getAttribute(RouteResult::class, false))) {\n        // No route matched; delegate to next middleware\n        return $next($request, $response);\n    }\n\n    if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) {\n        // Not a route requiring authorization\n        return $next($request, $response);\n    }\n\n    $header = $request->getHeaderLine('Authorization');\n    if (! $validator($header)) {\n        return new EmptyResponse(403);\n    }\n\n    return $next($request, $response);\n}\n\n\n\nNote that the first step is to determine if we have a \nRouteResult\n; if we do\nnot have one, we should either delegate to the next middleware, or return some\nsort of response (generally a 404). In the case of Expressive, a later\nmiddleware will generate the 404 response for us, so we can safely delegate.\n\n\nURI generation\n\n\nBecause routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the \nRouterInterface\n,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.\n\n\nAt it's most basic level, you call the \ngenerateUri()\n method with a route name\nand any substitutions you want to make:\n\n\n$uri = $router->generateUri('book', ['id' => 'zend-expressive']);\n\n\n\nSupported implementations\n\n\nExpressive currently ships with adapters for the following routers:\n\n\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-mvc Router",
            "title": "Introduction"
        },
        {
            "location": "/v1/features/router/intro/#routing",
            "text": "One fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:   /books  might return a collection of books  /books/zend-expressive  might return the individual book identified by\n  \"zend-expressive\".   Expressive does not provide routing on its own; you must choose a routing\nadapter that implements  Zend\\Expressive\\Router\\RouterInterface  and provide it\nto the  Application  instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.",
            "title": "Routing"
        },
        {
            "location": "/v1/features/router/intro/#retrieving-matched-parameters",
            "text": "Routing enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as  attributes .  In the example above, let's assume the route was defined as  /books/:id , where id  is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the  id  attribute to discover what was\nmatched:  $id = $request->getAttribute('id');",
            "title": "Retrieving matched parameters"
        },
        {
            "location": "/v1/features/router/intro/#retrieving-the-matched-route",
            "text": "When routing is successful, the routing middleware injects a Zend\\Expressive\\Router\\RouteResult  instance as a request attribute, using that\nclass name as the attribute name. The  RouteResult  instance provides you access\nto the following:   The matched route name, via  $result->getMatchedRouteName() .  The matched middleware, via  $result->getMatchedMiddleware() .  Matched parameters, via  $result->getMatchedParams()  (as noted above, these\n  are also each injected as discrete request attributes).  Allowed HTTP methods, via  $result->getAllowedMethods() .   As an example, you could use middleware similar to the following to return a 403\nresponse if routing was successful, but no  Authorization  header is present:  use Zend\\Diactoros\\Response\\EmptyResponse;\nuse Zend\\Expressive\\Router\\RouteResult;\n\nfunction ($request, $response, $next) use ($routesRequiringAuthorization, $validator) {\n    if (! ($result = $request->getAttribute(RouteResult::class, false))) {\n        // No route matched; delegate to next middleware\n        return $next($request, $response);\n    }\n\n    if (! in_array($result->getMatchedRouteName(), $routesRequiringAuthorization, true)) {\n        // Not a route requiring authorization\n        return $next($request, $response);\n    }\n\n    $header = $request->getHeaderLine('Authorization');\n    if (! $validator($header)) {\n        return new EmptyResponse(403);\n    }\n\n    return $next($request, $response);\n}  Note that the first step is to determine if we have a  RouteResult ; if we do\nnot have one, we should either delegate to the next middleware, or return some\nsort of response (generally a 404). In the case of Expressive, a later\nmiddleware will generate the 404 response for us, so we can safely delegate.",
            "title": "Retrieving the matched route"
        },
        {
            "location": "/v1/features/router/intro/#uri-generation",
            "text": "Because routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the  RouterInterface ,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.  At it's most basic level, you call the  generateUri()  method with a route name\nand any substitutions you want to make:  $uri = $router->generateUri('book', ['id' => 'zend-expressive']);",
            "title": "URI generation"
        },
        {
            "location": "/v1/features/router/intro/#supported-implementations",
            "text": "Expressive currently ships with adapters for the following routers:   Aura.Router  FastRoute  zend-mvc Router",
            "title": "Supported implementations"
        },
        {
            "location": "/v1/features/router/interface/",
            "text": "Routing Interface\n\n\nExpressive defines \nZend\\Expressive\\Router\\RouterInterface\n, which can be\ninjected into and consumed by \nZend\\Expressive\\Application\n in order to provide\ndynamic routing capabilities to middleware. The interface serves as an\nabstraction to allow routers with varying capabilities to be used with an\napplication.\n\n\nThe interface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @param Route $route\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route);\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     *\n     * @param  Request $request\n     * @return RouteResult\n     */\n    public function match(Request $request);\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it.\n     *\n     * @see https://github.com/auraphp/Aura.Router#generating-a-route-path\n     * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html\n     * @param string $name\n     * @param array $substitutions\n     * @return string\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri($name, array $substitutions = []);\n}\n\n\n\nDevelopers may create and use their own implementations. We recommend\nregistering your implementation as the service\n\nZend\\Expressive\\Router\\RouterInterface\n in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.\n\n\nImplementors should also read the following sections detailing the \nRoute\n and\n\nRouteResult\n classes, to ensure that their implementations interoperate\ncorrectly.\n\n\nRoutes\n\n\nRoutes are defined via \nZend\\Expressive\\Router\\Route\n, and aggregate the\nfollowing information:\n\n\n\n\nPath to match.\n\n\nMiddleware to use when the route is matched. This may be a callable or a\n  service name resolving to middleware.\n\n\nHTTP methods allowed for the route; if none are provided, all are assumed.\n\n\nOptionally, a name by which to reference the route.\n\n\n\n\nThe \nRoute\n class has the following signature:\n\n\nnamespace Zend\\Expressive\\Router;\n\nclass Route\n{\n    const HTTP_METHOD_ANY = 0xff;\n    const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param string|callable $middleware Middleware to use when this route is matched.\n     * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param string|null $name the route name\n     * @throws Exception\\InvalidArgumentException for invalid path type.\n     * @throws Exception\\InvalidArgumentException for invalid middleware type.\n     * @throws Exception\\InvalidArgumentException for any invalid HTTP method names.\n     */\n    public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null);\n\n    /**\n     * @return string\n     */\n    public function getPath();\n\n    /**\n     * Set the route name.\n     *\n     * @param string $name\n     */\n    public function setName($name);\n\n    /**\n     * @return string\n     */\n    public function getName();\n\n    /**\n     * @return string|callable\n     */\n    public function getMiddleware();\n\n    /**\n     * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods();\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     * @return bool\n     */\n    public function allowsMethod($method);\n\n    /**\n     * @param array $options\n     */\n    public function setOptions(array $options);\n\n    /**\n     * @return array\n     */\n    public function getOptions();\n}\n\n\n\nTypically, developers will use \nZend\\Expressive\\Application::route()\n (or one of\nthe HTTP-specific routing methods) to create routes, and will not need to\ninteract with \nRoute\n instances. However, that method can \nalso\n accept \nRoute\n\ninstances, allowing more flexibility in defining and configuring them.\n\n\nMatching and RouteResults\n\n\nInternally, \nZend\\Expressive\\Application\n calls on \nRouterInterface::match()\n,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the\n\nHTTPS\n server variable, etc.\n\n\nImplementations are expected to return a \nZend\\Expressive\\Router\\RouteResult\n\ninstance, which the routing middleware then uses to determine if routing\nsucceeded. In the event of success, it will pull any matched parameters from the\nresult and inject them as request attributes, and then pull the matched\nmiddleware and execute it. In the case of failure, it will determine if the\nfailure was due to inability to match, or usage of a disallowed HTTP method; in\nthe former case, it proceeds to the next middleware in the stack, and in the\nlatter, returns a 405 response.\n\n\nThe \nRouteResult\n signature is as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nclass RouteResult\n{\n    /**\n     * Create an instance representing a route success.\n     *\n     * @param string $name Name of matched route.\n     * @param callable|string $middleware Middleware associated with the\n     *     matched route.\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRouteMatch($name, $middleware, array $params);\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|int|array $methods HTTP methods allowed for the current URI, if any\n     * @return static\n     */\n    public static function fromRouteFailure($methods = null);\n\n    /**\n     * Does the result represent successful routing?\n     *\n     * @return bool\n     */\n    public function isSuccess();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Retrieve the matched middleware, if possible.\n     *\n     * @return false|callable|string Returns false if the result represents a\n     *     failure; otherwise, a callable or a string service name.\n     */\n    public function getMatchedMiddleware();\n\n    /**\n     * Returns the matched params.\n     *\n     * Guaranteed to return an array, even if it is simply empty.\n     *\n     * @return array\n     */\n    public function getMatchedParams();\n\n    /**\n     * Is this a routing failure result?\n     *\n     * @return bool\n     */\n    public function isFailure();\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     *\n     * @return bool\n     */\n    public function isMethodFailure();\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods();\n}\n\n\n\nTypically, only those implementing routers will interact with this class.",
            "title": "Routing Interface"
        },
        {
            "location": "/v1/features/router/interface/#routing-interface",
            "text": "Expressive defines  Zend\\Expressive\\Router\\RouterInterface , which can be\ninjected into and consumed by  Zend\\Expressive\\Application  in order to provide\ndynamic routing capabilities to middleware. The interface serves as an\nabstraction to allow routers with varying capabilities to be used with an\napplication.  The interface is defined as follows:  namespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @param Route $route\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route);\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     *\n     * @param  Request $request\n     * @return RouteResult\n     */\n    public function match(Request $request);\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it.\n     *\n     * @see https://github.com/auraphp/Aura.Router#generating-a-route-path\n     * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html\n     * @param string $name\n     * @param array $substitutions\n     * @return string\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri($name, array $substitutions = []);\n}  Developers may create and use their own implementations. We recommend\nregistering your implementation as the service Zend\\Expressive\\Router\\RouterInterface  in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.  Implementors should also read the following sections detailing the  Route  and RouteResult  classes, to ensure that their implementations interoperate\ncorrectly.",
            "title": "Routing Interface"
        },
        {
            "location": "/v1/features/router/interface/#routes",
            "text": "Routes are defined via  Zend\\Expressive\\Router\\Route , and aggregate the\nfollowing information:   Path to match.  Middleware to use when the route is matched. This may be a callable or a\n  service name resolving to middleware.  HTTP methods allowed for the route; if none are provided, all are assumed.  Optionally, a name by which to reference the route.   The  Route  class has the following signature:  namespace Zend\\Expressive\\Router;\n\nclass Route\n{\n    const HTTP_METHOD_ANY = 0xff;\n    const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param string|callable $middleware Middleware to use when this route is matched.\n     * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param string|null $name the route name\n     * @throws Exception\\InvalidArgumentException for invalid path type.\n     * @throws Exception\\InvalidArgumentException for invalid middleware type.\n     * @throws Exception\\InvalidArgumentException for any invalid HTTP method names.\n     */\n    public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null);\n\n    /**\n     * @return string\n     */\n    public function getPath();\n\n    /**\n     * Set the route name.\n     *\n     * @param string $name\n     */\n    public function setName($name);\n\n    /**\n     * @return string\n     */\n    public function getName();\n\n    /**\n     * @return string|callable\n     */\n    public function getMiddleware();\n\n    /**\n     * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods();\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     * @return bool\n     */\n    public function allowsMethod($method);\n\n    /**\n     * @param array $options\n     */\n    public function setOptions(array $options);\n\n    /**\n     * @return array\n     */\n    public function getOptions();\n}  Typically, developers will use  Zend\\Expressive\\Application::route()  (or one of\nthe HTTP-specific routing methods) to create routes, and will not need to\ninteract with  Route  instances. However, that method can  also  accept  Route \ninstances, allowing more flexibility in defining and configuring them.",
            "title": "Routes"
        },
        {
            "location": "/v1/features/router/interface/#matching-and-routeresults",
            "text": "Internally,  Zend\\Expressive\\Application  calls on  RouterInterface::match() ,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the HTTPS  server variable, etc.  Implementations are expected to return a  Zend\\Expressive\\Router\\RouteResult \ninstance, which the routing middleware then uses to determine if routing\nsucceeded. In the event of success, it will pull any matched parameters from the\nresult and inject them as request attributes, and then pull the matched\nmiddleware and execute it. In the case of failure, it will determine if the\nfailure was due to inability to match, or usage of a disallowed HTTP method; in\nthe former case, it proceeds to the next middleware in the stack, and in the\nlatter, returns a 405 response.  The  RouteResult  signature is as follows:  namespace Zend\\Expressive\\Router;\n\nclass RouteResult\n{\n    /**\n     * Create an instance representing a route success.\n     *\n     * @param string $name Name of matched route.\n     * @param callable|string $middleware Middleware associated with the\n     *     matched route.\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRouteMatch($name, $middleware, array $params);\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|int|array $methods HTTP methods allowed for the current URI, if any\n     * @return static\n     */\n    public static function fromRouteFailure($methods = null);\n\n    /**\n     * Does the result represent successful routing?\n     *\n     * @return bool\n     */\n    public function isSuccess();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Retrieve the matched middleware, if possible.\n     *\n     * @return false|callable|string Returns false if the result represents a\n     *     failure; otherwise, a callable or a string service name.\n     */\n    public function getMatchedMiddleware();\n\n    /**\n     * Returns the matched params.\n     *\n     * Guaranteed to return an array, even if it is simply empty.\n     *\n     * @return array\n     */\n    public function getMatchedParams();\n\n    /**\n     * Is this a routing failure result?\n     *\n     * @return bool\n     */\n    public function isFailure();\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     *\n     * @return bool\n     */\n    public function isMethodFailure();\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods();\n}  Typically, only those implementing routers will interact with this class.",
            "title": "Matching and RouteResults"
        },
        {
            "location": "/v1/features/router/uri-generation/",
            "text": "URI Generation\n\n\nOne aspect of the \nZend\\Expressive\\Router\\RouterInterface\n is that it provides a\n\ngenerateUri()\n method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders).\n\n\nNaming routes\n\n\nBy default, routes use a combination of the path and HTTP methods supported as\nthe name:\n\n\n\n\nIf you call \nroute()\n with no HTTP methods, the name is the literal path with\n  no changes.\n\n\n\n\n$app->route('/foo', $middleware); // \"foo\"\n\n\n\n\n\nIf you call \nget()\n, \npost()\n, \nput()\n, \npatch()\n, or \ndelete()\n, the name\n  will be the literal path, followed by a caret (\n^\n), followed by the\n  uppercase HTTP method name:\n\n\n\n\n$app->get('/foo', $middleware); // \"foo^GET\"\n\n\n\nAlternately, these methods return a \nRoute\n instance, and you can set the\n  name on it:\n\n\n$app->get('/foo', $middleware)->setName('foo'); // \"foo\"\n\n\n\n\n\nIf you call \nroute()\n and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret (\n^\n), followed by a colon\n  (\n:\n)-separated list of the uppercase HTTP method names, in the order in which\n  they were added.\n\n\n\n\n$app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n\n\n\nLike the HTTP-specific methods, \nroute()\n also returns a \nRoute\n instance,\n  and you can set the name on it:\n\n\n$route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n$route->setName('foo'); // \"foo\"\n\n\n\nClearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:\n\n\n$app->route('/foo', $middleware, 'foo'); // 'foo'\n$app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'\n\n\n\nAs noted above, these methods also return \nRoute\n instances, allowing you to\nset the name after-the-fact; this is particularly useful with the \nroute()\n\nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:\n\n\n$app->route('/foo', $middleware)->setName('foo'); // 'foo'\n\n\n\nWe recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.\n\n\nGenerating URIs\n\n\nOnce you know the name of a URI you wish to generate, you can do so from the\nrouter instance:\n\n\n$uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\"\n\n\n\nYou can omit the second argument if no substitutions are necessary.\n\n\n\n\nCompose the router\n\n\nFor this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the\n\nZend\\Expressive\\Router\\RouterInterface\n service in these situations.",
            "title": "URI Generation"
        },
        {
            "location": "/v1/features/router/uri-generation/#uri-generation",
            "text": "One aspect of the  Zend\\Expressive\\Router\\RouterInterface  is that it provides a generateUri()  method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders).",
            "title": "URI Generation"
        },
        {
            "location": "/v1/features/router/uri-generation/#naming-routes",
            "text": "By default, routes use a combination of the path and HTTP methods supported as\nthe name:   If you call  route()  with no HTTP methods, the name is the literal path with\n  no changes.   $app->route('/foo', $middleware); // \"foo\"   If you call  get() ,  post() ,  put() ,  patch() , or  delete() , the name\n  will be the literal path, followed by a caret ( ^ ), followed by the\n  uppercase HTTP method name:   $app->get('/foo', $middleware); // \"foo^GET\"  Alternately, these methods return a  Route  instance, and you can set the\n  name on it:  $app->get('/foo', $middleware)->setName('foo'); // \"foo\"   If you call  route()  and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret ( ^ ), followed by a colon\n  ( : )-separated list of the uppercase HTTP method names, in the order in which\n  they were added.   $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"  Like the HTTP-specific methods,  route()  also returns a  Route  instance,\n  and you can set the name on it:  $route = $app->route('/foo', $middleware, ['GET', 'POST']); // \"foo^GET:POST\"\n$route->setName('foo'); // \"foo\"  Clearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:  $app->route('/foo', $middleware, 'foo'); // 'foo'\n$app->get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app->route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'  As noted above, these methods also return  Route  instances, allowing you to\nset the name after-the-fact; this is particularly useful with the  route() \nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:  $app->route('/foo', $middleware)->setName('foo'); // 'foo'  We recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.",
            "title": "Naming routes"
        },
        {
            "location": "/v1/features/router/uri-generation/#generating-uris",
            "text": "Once you know the name of a URI you wish to generate, you can do so from the\nrouter instance:  $uri = $router->generateUri('foo-item', ['id' => 'bar']); // \"/foo/bar\"  You can omit the second argument if no substitutions are necessary.",
            "title": "Generating URIs"
        },
        {
            "location": "/v1/features/router/uri-generation/#compose-the-router",
            "text": "For this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the Zend\\Expressive\\Router\\RouterInterface  service in these situations.",
            "title": "Compose the router"
        },
        {
            "location": "/v1/features/router/piping/",
            "text": "Routing vs Piping\n\n\nExpressive provides two mechanisms for adding middleware to your\napplication:\n\n\n\n\npiping, which is a foundation feature of the underlying\n  \nzend-stratigility\n\n  implementation.\n\n\nrouting, which is an additional feature provided by zend-expressive.\n\n\n\n\nPiping\n\n\nzend-stratigility provides a mechanism termed \npiping\n for composing middleware\nin an application. When you \npipe\n middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\nIf none ever returns a response instance, execution is delegated to a \"final\nhandler\", which determines whether or not to return an error, and, if so, what\nkind of error to return.\n\n\nStratigility also allows you to segregate piped middleware to specific paths. As\nan example:\n\n\n$app->pipe('/api', $apiMiddleware);\n\n\n\nwill execute \n$apiMiddleware\n only if the path matches \n/api\n; otherwise, it\nwill skip over that middleware.\n\n\nThis path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.\n\n\nExpressive uses and exposes piping to users, with one addition: \nmiddleware\nmay be specified by service name, and zend-expressive will lazy-load the service\nonly when the middleware is invoked\n.\n\n\nIn order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch\nthe middleware from the container and to dispatch that middleware inside a\nclosure. This poses a problem for error handling middleware, however, as\nzend-stratigility identifies error handling middleware by its arity (number of\nfunction arguments); as such, zend-expressive defines an additional method for\npiping service-driven error handling middleware, \npipeErrorHandler()\n. The\nmethod has the same signature as \npipe()\n:\n\n\n// Without a path:\n$app->pipeErrorHandler('error handler service name');\n\n// Specific to a path:\n$app->pipeErrorHandler('/api', 'error handler service name');\n\n\n\nThis method will return a closure using the error middleware signature.\n\n\nRouting\n\n\nRouting is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:\n\n\n\n\n/book/:id\n (ZF2)\n\n\n/book/{id}\n (Aura.Router)\n\n\n/book/{id:\\d+}\n (FastRoute)\n\n\n\n\nIn each of the above, if the router determines that the request matches the\ncriteria, it will indicate:\n\n\n\n\nthe route that matched\n\n\nthe \nid\n parameter was matched, and the value matched\n\n\n\n\nMost routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:\n\n\n\n\ndefault values for unmatched parameters\n\n\ncriteria for evaluating a match (such as a regular expression)\n\n\nadditional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)\n\n\n\n\nAs such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).\n\n\nWhen to Pipe\n\n\nIn Expressive, we recommend that you pipe middleware in the following\ncircumstances:\n\n\n\n\nIt should (potentially) run on every execution. Examples for such usage\n  include:\n\n\nLogging requests\n\n\nPerforming content negotiation\n\n\nHandling cookies\n\n\n\n\n\n\nError handling. Typically these should be piped after any normal middleware.\n\n\nApplication segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.\n\n\n\n\nWhen to Route\n\n\nUse routing when:\n\n\n\n\nYour middleware is reacting to a given path.\n\n\nYou want to use dynamic routing.\n\n\nYou want to restrict usage of middleware to specific HTTP methods.\n\n\nYou want to be able to generate URIs to your middleware.\n\n\n\n\nThe above cover most use cases; \nin other words, most middleware should be added\nto the application as routed middleware\n.\n\n\nControlling middleware execution order\n\n\nAs noted in the earlier section on piping, piped middleware is \nqueued\n, meaning\nit has a FIFO (\"first in, first out\") execution order.\n\n\nAdditionally, zend-expressive's routing capabilities are themselves implemented\nas piped middleware.\n\n\nAs such, if you programmatically configure the router and add routes without\nusing \nApplication::route()\n, you may run into issues with the order in which\npiped middleware (middleware added to the application via the \npipe()\n method)\nis executed.\n\n\nTo ensure that everything executes in the correct order, you can call\n\nApplication::pipeRouteMiddleware()\n at any time to pipe it to the application.\nAs an example, after you have created your application instance:\n\n\n$app->pipe($middlewareToExecuteFirst);\n$app->pipeRouteMiddleware();\n$app->pipe($errorMiddleware);\n\n\n\nIf you fail to add any routes via \nApplication::route()\n or to call\n\nApplication::pipeRouteMiddleware()\n, the routing middleware will be called\nwhen executing the application. \nThis means that it will be last in the\nmiddleware pipeline,\n which means that if you registered any error\nmiddleware, it can never be invoked.\n\n\nTo sum:\n\n\n\n\nPipe middleware to execute on every request \nbefore\n routing any middleware\n  and/or \nbefore\n calling \nApplication::pipeRouteMiddleware()\n.\n\n\nPipe error handling middleware \nafter\n defining routes and/or \nafter\n calling\n  \nApplication::pipeRouteMiddleware()\n.\n\n\n\n\nIf you use the provided \nZend\\Expressive\\Container\\ApplicationFactory\n for\nretrieving your \nApplication\n instance, you can do this by defining pre- and\npost-pipeline middleware, and the factory will ensure everything is registered\ncorrectly.",
            "title": "Routing vs Piping"
        },
        {
            "location": "/v1/features/router/piping/#routing-vs-piping",
            "text": "Expressive provides two mechanisms for adding middleware to your\napplication:   piping, which is a foundation feature of the underlying\n   zend-stratigility \n  implementation.  routing, which is an additional feature provided by zend-expressive.",
            "title": "Routing vs Piping"
        },
        {
            "location": "/v1/features/router/piping/#piping",
            "text": "zend-stratigility provides a mechanism termed  piping  for composing middleware\nin an application. When you  pipe  middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\nIf none ever returns a response instance, execution is delegated to a \"final\nhandler\", which determines whether or not to return an error, and, if so, what\nkind of error to return.  Stratigility also allows you to segregate piped middleware to specific paths. As\nan example:  $app->pipe('/api', $apiMiddleware);  will execute  $apiMiddleware  only if the path matches  /api ; otherwise, it\nwill skip over that middleware.  This path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.  Expressive uses and exposes piping to users, with one addition:  middleware\nmay be specified by service name, and zend-expressive will lazy-load the service\nonly when the middleware is invoked .  In order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch\nthe middleware from the container and to dispatch that middleware inside a\nclosure. This poses a problem for error handling middleware, however, as\nzend-stratigility identifies error handling middleware by its arity (number of\nfunction arguments); as such, zend-expressive defines an additional method for\npiping service-driven error handling middleware,  pipeErrorHandler() . The\nmethod has the same signature as  pipe() :  // Without a path:\n$app->pipeErrorHandler('error handler service name');\n\n// Specific to a path:\n$app->pipeErrorHandler('/api', 'error handler service name');  This method will return a closure using the error middleware signature.",
            "title": "Piping"
        },
        {
            "location": "/v1/features/router/piping/#routing",
            "text": "Routing is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:   /book/:id  (ZF2)  /book/{id}  (Aura.Router)  /book/{id:\\d+}  (FastRoute)   In each of the above, if the router determines that the request matches the\ncriteria, it will indicate:   the route that matched  the  id  parameter was matched, and the value matched   Most routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:   default values for unmatched parameters  criteria for evaluating a match (such as a regular expression)  additional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)   As such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).",
            "title": "Routing"
        },
        {
            "location": "/v1/features/router/piping/#when-to-pipe",
            "text": "In Expressive, we recommend that you pipe middleware in the following\ncircumstances:   It should (potentially) run on every execution. Examples for such usage\n  include:  Logging requests  Performing content negotiation  Handling cookies    Error handling. Typically these should be piped after any normal middleware.  Application segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.",
            "title": "When to Pipe"
        },
        {
            "location": "/v1/features/router/piping/#when-to-route",
            "text": "Use routing when:   Your middleware is reacting to a given path.  You want to use dynamic routing.  You want to restrict usage of middleware to specific HTTP methods.  You want to be able to generate URIs to your middleware.   The above cover most use cases;  in other words, most middleware should be added\nto the application as routed middleware .",
            "title": "When to Route"
        },
        {
            "location": "/v1/features/router/piping/#controlling-middleware-execution-order",
            "text": "As noted in the earlier section on piping, piped middleware is  queued , meaning\nit has a FIFO (\"first in, first out\") execution order.  Additionally, zend-expressive's routing capabilities are themselves implemented\nas piped middleware.  As such, if you programmatically configure the router and add routes without\nusing  Application::route() , you may run into issues with the order in which\npiped middleware (middleware added to the application via the  pipe()  method)\nis executed.  To ensure that everything executes in the correct order, you can call Application::pipeRouteMiddleware()  at any time to pipe it to the application.\nAs an example, after you have created your application instance:  $app->pipe($middlewareToExecuteFirst);\n$app->pipeRouteMiddleware();\n$app->pipe($errorMiddleware);  If you fail to add any routes via  Application::route()  or to call Application::pipeRouteMiddleware() , the routing middleware will be called\nwhen executing the application.  This means that it will be last in the\nmiddleware pipeline,  which means that if you registered any error\nmiddleware, it can never be invoked.  To sum:   Pipe middleware to execute on every request  before  routing any middleware\n  and/or  before  calling  Application::pipeRouteMiddleware() .  Pipe error handling middleware  after  defining routes and/or  after  calling\n   Application::pipeRouteMiddleware() .   If you use the provided  Zend\\Expressive\\Container\\ApplicationFactory  for\nretrieving your  Application  instance, you can do this by defining pre- and\npost-pipeline middleware, and the factory will ensure everything is registered\ncorrectly.",
            "title": "Controlling middleware execution order"
        },
        {
            "location": "/v1/features/router/aura/",
            "text": "Using Aura.Router\n\n\nAura.Router\n provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:\n\n\n\n\nA regular expression that applies the same for a given routing match:\n\n\n\n\n// Parameters named \"id\" will only match digits by default:\n$router->addTokens([\n  'id' => '\\d+',\n]);\n\n\n\n\n\nA default parameter and/or its default value to always provide:\n\n\n\n\n// mediatype defaults to \"application/xhtml+xml\" and will be available in all\n// requests:\n$router->addValues([\n  'mediatype' => 'application/xhtml+xml',\n]);\n\n\n\n\n\nOnly match if secure (i.e., under HTTPS):\n\n\n\n\n$router->setSecure(true);\n\n\n\nIn order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling Aura.Router\n\n\nTo use Aura.Router, you will first need to install the Aura.Router integration:\n\n\n$ composer require zendframework/zend-expressive-aurarouter\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\AuraRouter\n instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\AuraRouter\n during instantiation.\n\n\n<?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())->newInstance();\n$auraRouter->setSecure(true);\n$auraRouter->addValues([\n    'mediatype' => 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your Aura.Router implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\AuraRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\AuraRouter'\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nAura\\Router\\Router\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\AuraRouter\n instance composing the\n  \nAura\\Router\\Router\n instance.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n// in src/Application/Container/AuraRouterFactory.php:\nnamespace Application\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Interop\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())->newInstance();\n        $router->setSecure(true);\n        $router->addValues([\n            'mediatype' => 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container->get('Aura\\Router\\Router'));\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'Aura\\Router\\Router',\n    'Application\\Container\\AuraRouterFactory'\n);\n$container->addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'Aura\\Router\\Router' => 'Application\\Container\\AuraRouterFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory',\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\AuraRouterFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['Aura\\Router\\Router'] = new AuraRouterFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();",
            "title": "Using Aura"
        },
        {
            "location": "/v1/features/router/aura/#using-aurarouter",
            "text": "Aura.Router  provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:   A regular expression that applies the same for a given routing match:   // Parameters named \"id\" will only match digits by default:\n$router->addTokens([\n  'id' => '\\d+',\n]);   A default parameter and/or its default value to always provide:   // mediatype defaults to \"application/xhtml+xml\" and will be available in all\n// requests:\n$router->addValues([\n  'mediatype' => 'application/xhtml+xml',\n]);   Only match if secure (i.e., under HTTPS):   $router->setSecure(true);  In order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.",
            "title": "Using Aura.Router"
        },
        {
            "location": "/v1/features/router/aura/#installing-aurarouter",
            "text": "To use Aura.Router, you will first need to install the Aura.Router integration:  $ composer require zendframework/zend-expressive-aurarouter",
            "title": "Installing Aura.Router"
        },
        {
            "location": "/v1/features/router/aura/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\AuraRouter  instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:  use Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/v1/features/router/aura/#programmatic-creation",
            "text": "If you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter  during instantiation.  <?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())->newInstance();\n$auraRouter->setSecure(true);\n$auraRouter->addValues([\n    'mediatype' => 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/v1/features/router/aura/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/v1/features/router/aura/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your Aura.Router implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/v1/features/router/aura/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\AuraRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);  And in Pimple:  $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\AuraRouter'\n);",
            "title": "Basic Router"
        },
        {
            "location": "/v1/features/router/aura/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Aura\\Router\\Router  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\AuraRouter  instance composing the\n   Aura\\Router\\Router  instance.   Sound difficult? It's not; we've essentially done it above already!  // in src/Application/Container/AuraRouterFactory.php:\nnamespace Application\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Interop\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())->newInstance();\n        $router->setSecure(true);\n        $router->addValues([\n            'mediatype' => 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container->get('Aura\\Router\\Router'));\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'Aura\\Router\\Router',\n    'Application\\Container\\AuraRouterFactory'\n);\n$container->addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'Aura\\Router\\Router' => 'Application\\Container\\AuraRouterFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory',\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\AuraRouterFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['Aura\\Router\\Router'] = new AuraRouterFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/v1/features/router/fast-route/",
            "text": "Using FastRoute\n\n\nFastRoute\n provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.\n\n\nInternally, we use the standard route parser (\nFastRoute\\RouterParser\\Std\n) to\nparse routes, a \nRouteCollector\n to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.\n\n\nIf you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the \nZend\\Expressive\\Router\\FastRouteRouter\n class, at instantiation.\n\n\nThe \nFastRouteRouter\n bridge class accepts two arguments at instantiation:\n\n\n\n\nA \nFastRoute\\RouteCollector\n instance\n\n\nA callable that will return a \nFastRoute\\Dispatcher\\RegexBasedAbstract\n\n  instance.\n\n\n\n\nInjection can be done either programmatically or via a factory to use in\nconjunction with your container instance.\n\n\nInstalling FastRoute\n\n\nTo use FastRoute, you will first need to install the FastRoute integration:\n\n\n$ composer require zendframework/zend-expressive-fastroute\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\FastRouteRouter\n instance\nwith no arguments; it will create the underlying FastRoute objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\n$router = new FastRouteRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the FastRoute setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\FastRouteRouter\n during instantiation.\n\n\nTo do so, you will need to setup your \nRouteCollector\n instance and/or\noptionally callable to return your \nRegexBasedAbstract\n instance manually,\ninject them in your \nZend\\Expressive\\Router\\FastRouteRouter\n instance, and inject use\nthat when creating your \nApplication\n instance.\n\n\n<?php\nuse FastRoute;\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\n$fastRoute = new RouteCollector(\n    new RouteParser(),\n    new RouteGenerator()\n);\n$getDispatcher = function ($data) {\n    return new FastRouteDispatcher($data);\n};\n\n\n$router = new FastRouteBridge($fastRoute, $getDispatcher);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your FastRoute implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\FastRouteRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\FastRouteRouter'\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:\n\n\n\n\nA factory to register as and generate a \nFastRoute\\RouteCollector\n instance.\n\n\nA factory to register as \nFastRoute\\DispatcherFactory\n and return a callable\n  factory that returns a \nRegexBasedAbstract\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\FastRouteRouter\n instance composing the\n  two services.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n<?php\n// in src/Application/Container/FastRouteCollectorFactory.php:\nnamespace Application\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Interop\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/Application/Container/FastRouteDispatcherFactory:\nnamespace Application\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Interop\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container->get('FastRoute\\RouteCollector'),\n            $container->get('FastRoute\\DispatcherFactory'),\n        );\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'FastRoute\\RouteCollector',\n    'Application\\Container\\FastRouteCollectorFactory'\n);\n$container->addFactory(\n    'FastRoute\\DispatcherFactory',\n    'Application\\Container\\FastRouteDispatcherFactory'\n);\n$container->addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'FastRoute\\RouteCollector' => 'Application\\Container\\FastRouteCollectorFactory',\n        'FastRoute\\DispatcherFactory' => 'Application\\Container\\FastRouteDispatcherFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory',\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\FastRouteCollectorFactory;\nuse Application\\Container\\FastRouteDispatcherFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['FastRoute\\RouteCollector'] = new FastRouteCollectorFactory();\n$container['FastRoute\\RouteDispatcher'] = new FastRouteDispatcherFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();\n\n\n\nFastRoute caching support\n\n\n\n\nSince zend-expressive-fastroute 1.3.0.\n\n\n\n\nStarting from version 1.3.0, zend-expressive-fastroute comes with support\nfor FastRoute native dispatch data caching.\n\n\nEnabling this feature requires changes to your configuration. Typically, router\nconfiguration occurs in \nconfig/autoload/routes.global.php\n; as such, we will\nreference that file when indicating configuration changes.\n\n\nThe changes required are:\n\n\n\n\n\n\nYou will need to delegate creation of the router instance to a new factory.\n\n\n\n\n\n\nYou will need to add a new configuration entry, \n$config['router']['fastroute']\n.\n  The options in this entry will be used by the factory to build the router\n  instance in order to toggle caching support and to specify a custom cache\n  file.\n\n\n\n\n\n\nAs an example:\n\n\n// File config/autoload/routes.global.php\n\nreturn [\n    'dependencies' => [\n        //..\n        'invokables' => [\n            /* ... */\n            // Comment out or remove the following line:\n            // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n            // Add this line; the specified factory now creates the router instance:\n            Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class,\n            /* ... */\n        ],\n    ],\n\n    // Add the following to enable caching support:\n    'router' => [\n        'fastroute' => [\n             // Enable caching support:\n            'cache_enabled' => true,\n             // Optional (but recommended) cache file path:\n            'cache_file'    => 'data/cache/fastroute.php.cache',\n        ],\n    ],\n\n    'routes' => [ /* ... */ ],\n]\n\n\n\nThe FastRoute-specific caching options are as follows:\n\n\n\n\n\n\ncache_enabled\n (bool) is used to toggle caching support. It's advisable to enable\n  caching in a production environment and leave it disabled for the development\n  environment. Commenting or omitting this option is equivalent to having it set\n  to \nfalse\n. We recommend enabling it in \nconfig/autoload/routes.global.php\n,\n  and, in development, disabling it within \nconfig/autoload/routes.local.php\n or\n  \nconfig/autoload/local.php\n.\n\n\n\n\n\n\ncache_file\n (string) is an optional parameter that represents the path of\n  the dispatch data cache file. It can be provided as an absolute file path or\n  as a path relative to the zend-expressive working directory.\n\n\n\n\n\n\nIt defaults to \ndata/cache/fastroute.php.cache\n, where \ndata/cache/\n is the\n  cache directory defined within the zend-expressive skeleton application.  An\n  explicit absolute file path is recommended since the php \ninclude\n construct\n  will skip searching the \ninclude_path\n and the current directory.\n\n\nIf you choose a custom path, make sure that the directory exists and is\n  writable by the owner of the PHP process. As with any other zend-expressive\n  cached configuration, you will need to purge this file in order to enable any\n  newly added route when FastRoute caching is enabled.",
            "title": "Using FastRoute"
        },
        {
            "location": "/v1/features/router/fast-route/#using-fastroute",
            "text": "FastRoute  provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.  Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to\nparse routes, a  RouteCollector  to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.  If you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the  Zend\\Expressive\\Router\\FastRouteRouter  class, at instantiation.  The  FastRouteRouter  bridge class accepts two arguments at instantiation:   A  FastRoute\\RouteCollector  instance  A callable that will return a  FastRoute\\Dispatcher\\RegexBasedAbstract \n  instance.   Injection can be done either programmatically or via a factory to use in\nconjunction with your container instance.",
            "title": "Using FastRoute"
        },
        {
            "location": "/v1/features/router/fast-route/#installing-fastroute",
            "text": "To use FastRoute, you will first need to install the FastRoute integration:  $ composer require zendframework/zend-expressive-fastroute",
            "title": "Installing FastRoute"
        },
        {
            "location": "/v1/features/router/fast-route/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\FastRouteRouter  instance\nwith no arguments; it will create the underlying FastRoute objects required\nand compose them for you:  use Zend\\Expressive\\Router\\FastRouteRouter;\n\n$router = new FastRouteRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/v1/features/router/fast-route/#programmatic-creation",
            "text": "If you need greater control over the FastRoute setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\FastRouteRouter  during instantiation.  To do so, you will need to setup your  RouteCollector  instance and/or\noptionally callable to return your  RegexBasedAbstract  instance manually,\ninject them in your  Zend\\Expressive\\Router\\FastRouteRouter  instance, and inject use\nthat when creating your  Application  instance.  <?php\nuse FastRoute;\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\n$fastRoute = new RouteCollector(\n    new RouteParser(),\n    new RouteGenerator()\n);\n$getDispatcher = function ($data) {\n    return new FastRouteDispatcher($data);\n};\n\n\n$router = new FastRouteBridge($fastRoute, $getDispatcher);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/v1/features/router/fast-route/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/v1/features/router/fast-route/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your FastRoute implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/v1/features/router/fast-route/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\FastRouteRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);  And in Pimple:  $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\FastRouteRouter'\n);",
            "title": "Basic Router"
        },
        {
            "location": "/v1/features/router/fast-route/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:   A factory to register as and generate a  FastRoute\\RouteCollector  instance.  A factory to register as  FastRoute\\DispatcherFactory  and return a callable\n  factory that returns a  RegexBasedAbstract  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\FastRouteRouter  instance composing the\n  two services.   Sound difficult? It's not; we've essentially done it above already!  <?php\n// in src/Application/Container/FastRouteCollectorFactory.php:\nnamespace Application\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Interop\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/Application/Container/FastRouteDispatcherFactory:\nnamespace Application\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Interop\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container->get('FastRoute\\RouteCollector'),\n            $container->get('FastRoute\\DispatcherFactory'),\n        );\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'FastRoute\\RouteCollector',\n    'Application\\Container\\FastRouteCollectorFactory'\n);\n$container->addFactory(\n    'FastRoute\\DispatcherFactory',\n    'Application\\Container\\FastRouteDispatcherFactory'\n);\n$container->addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'FastRoute\\RouteCollector' => 'Application\\Container\\FastRouteCollectorFactory',\n        'FastRoute\\DispatcherFactory' => 'Application\\Container\\FastRouteDispatcherFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory',\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\FastRouteCollectorFactory;\nuse Application\\Container\\FastRouteDispatcherFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['FastRoute\\RouteCollector'] = new FastRouteCollectorFactory();\n$container['FastRoute\\RouteDispatcher'] = new FastRouteDispatcherFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/v1/features/router/fast-route/#fastroute-caching-support",
            "text": "Since zend-expressive-fastroute 1.3.0.   Starting from version 1.3.0, zend-expressive-fastroute comes with support\nfor FastRoute native dispatch data caching.  Enabling this feature requires changes to your configuration. Typically, router\nconfiguration occurs in  config/autoload/routes.global.php ; as such, we will\nreference that file when indicating configuration changes.  The changes required are:    You will need to delegate creation of the router instance to a new factory.    You will need to add a new configuration entry,  $config['router']['fastroute'] .\n  The options in this entry will be used by the factory to build the router\n  instance in order to toggle caching support and to specify a custom cache\n  file.    As an example:  // File config/autoload/routes.global.php\n\nreturn [\n    'dependencies' => [\n        //..\n        'invokables' => [\n            /* ... */\n            // Comment out or remove the following line:\n            // Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouter::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n            // Add this line; the specified factory now creates the router instance:\n            Zend\\Expressive\\Router\\RouterInterface::class => Zend\\Expressive\\Router\\FastRouteRouterFactory::class,\n            /* ... */\n        ],\n    ],\n\n    // Add the following to enable caching support:\n    'router' => [\n        'fastroute' => [\n             // Enable caching support:\n            'cache_enabled' => true,\n             // Optional (but recommended) cache file path:\n            'cache_file'    => 'data/cache/fastroute.php.cache',\n        ],\n    ],\n\n    'routes' => [ /* ... */ ],\n]  The FastRoute-specific caching options are as follows:    cache_enabled  (bool) is used to toggle caching support. It's advisable to enable\n  caching in a production environment and leave it disabled for the development\n  environment. Commenting or omitting this option is equivalent to having it set\n  to  false . We recommend enabling it in  config/autoload/routes.global.php ,\n  and, in development, disabling it within  config/autoload/routes.local.php  or\n   config/autoload/local.php .    cache_file  (string) is an optional parameter that represents the path of\n  the dispatch data cache file. It can be provided as an absolute file path or\n  as a path relative to the zend-expressive working directory.    It defaults to  data/cache/fastroute.php.cache , where  data/cache/  is the\n  cache directory defined within the zend-expressive skeleton application.  An\n  explicit absolute file path is recommended since the php  include  construct\n  will skip searching the  include_path  and the current directory.  If you choose a custom path, make sure that the directory exists and is\n  writable by the owner of the PHP process. As with any other zend-expressive\n  cached configuration, you will need to purge this file in order to enable any\n  newly added route when FastRoute caching is enabled.",
            "title": "FastRoute caching support"
        },
        {
            "location": "/v1/features/router/zf2/",
            "text": "Using the ZF2 Router\n\n\nzend-mvc\n provides a router\nimplementation; for HTTP applications, the default used in ZF2 applications is\n\nZend\\Mvc\\Router\\Http\\TreeRouteStack\n, which can compose a number of different\nroutes of differing types in order to perform routing.\n\n\nThe ZF2 bridge we provide, \nZend\\Expressive\\Router\\ZendRouter\n, uses the\n\nTreeRouteStack\n, and injects \nSegment\n routes to it; these are in turn injected\nwith \nMethod\n routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.\n\n\nIf you instantiate it with no arguments, it will create an empty\n\nTreeRouteStack\n. Thus, the simplest way to start with this router is:\n\n\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$app = AppFactory::create(null, new ZendRouter());\n\n\n\nThe \nTreeRouteStack\n offers some unique features:\n\n\n\n\nRoute \"prototypes\". These are essentially like child routes that must \nalso\n\n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.\n\n\nBase URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.\n\n\n\n\nTo specify these, you need access to the underlying \nTreeRouteStack\n\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling the ZF2 Router\n\n\nTo use the ZF2 router, you will need to install the zend-mvc router integration:\n\n\n$ composer require zendframework/zend-expressive-zendrouter\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\ZendRouter\n instance\nwith no arguments; it will create the underlying zend-mvc routing objects\nrequired and compose them for you:\n\n\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$router = new ZendRouter();\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the zend-mvc router setup and configuration,\nyou can create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\ZendRouter\n during instantiation.\n\n\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\nuse Zend\\Mvc\\Router\\Http\\TreeRouteStack;\n\n$zendRouter = new TreeRouteStack();\n$zendRouter->addPrototypes(/* ... */);\n$zendRouter->setBaseUrl(/* ... */);\n\n$router = new Zf2Bridge($zendRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your zend-mvc router implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\ZendRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return ZendRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new ZendRouter();\n    }\n}\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container->setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n\n\nAnd in Pimple:\n\n\n$pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container->setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\ZendRouter'\n);\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n\n  instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\ZendRouter\n instance composing the\n  \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n instance.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n// in src/Application/Container/TreeRouteStackFactory.php:\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Http\\Mvc\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router->addPrototypes(/* ... */);\n        $router->setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container->get('Zend\\Mvc\\Router\\Http\\TreeRouteStack'));\n    }\n}\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'Zend\\Mvc\\Router\\Http\\TreeRouteStack',\n    'Application\\Container\\TreeRouteStackFactory'\n);\n$container->addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'Zend\\Mvc\\Router\\Http\\TreeRouteStack' => 'Application\\Container\\TreeRouteStackFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory',\n    ],\n];\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\TreeRouteStackFactory;\nuse Application\\Container\\ZfRouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop;\n\n$container = new PimpleInterop();\n$container['Zend\\Mvc\\Router\\Http\\TreeRouteStackFactory'] = new TreeRouteStackFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();",
            "title": "Using the ZF2 Router"
        },
        {
            "location": "/v1/features/router/zf2/#using-the-zf2-router",
            "text": "zend-mvc  provides a router\nimplementation; for HTTP applications, the default used in ZF2 applications is Zend\\Mvc\\Router\\Http\\TreeRouteStack , which can compose a number of different\nroutes of differing types in order to perform routing.  The ZF2 bridge we provide,  Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects  Segment  routes to it; these are in turn injected\nwith  Method  routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.  If you instantiate it with no arguments, it will create an empty TreeRouteStack . Thus, the simplest way to start with this router is:  use Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$app = AppFactory::create(null, new ZendRouter());  The  TreeRouteStack  offers some unique features:   Route \"prototypes\". These are essentially like child routes that must  also \n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.  Base URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.   To specify these, you need access to the underlying  TreeRouteStack \ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.",
            "title": "Using the ZF2 Router"
        },
        {
            "location": "/v1/features/router/zf2/#installing-the-zf2-router",
            "text": "To use the ZF2 router, you will need to install the zend-mvc router integration:  $ composer require zendframework/zend-expressive-zendrouter",
            "title": "Installing the ZF2 Router"
        },
        {
            "location": "/v1/features/router/zf2/#quick-start",
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\ZendRouter  instance\nwith no arguments; it will create the underlying zend-mvc routing objects\nrequired and compose them for you:  use Zend\\Expressive\\Router\\ZendRouter;\n\n$router = new ZendRouter();",
            "title": "Quick Start"
        },
        {
            "location": "/v1/features/router/zf2/#programmatic-creation",
            "text": "If you need greater control over the zend-mvc router setup and configuration,\nyou can create the instances necessary and inject them into Zend\\Expressive\\Router\\ZendRouter  during instantiation.  use Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\nuse Zend\\Mvc\\Router\\Http\\TreeRouteStack;\n\n$zendRouter = new TreeRouteStack();\n$zendRouter->addPrototypes(/* ... */);\n$zendRouter->setBaseUrl(/* ... */);\n\n$router = new Zf2Bridge($zendRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);",
            "title": "Programmatic Creation"
        },
        {
            "location": "/v1/features/router/zf2/#piping-the-route-middleware",
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!",
            "title": "Piping the route middleware"
        },
        {
            "location": "/v1/features/router/zf2/#factory-driven-creation",
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate\ntwo strategies for creating your zend-mvc router implementation.",
            "title": "Factory-Driven Creation"
        },
        {
            "location": "/v1/features/router/zf2/#basic-router",
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\ZendRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return ZendRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new ZendRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container->setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);  And in Pimple:  $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container->setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\ZendRouter'\n);",
            "title": "Basic Router"
        },
        {
            "location": "/v1/features/router/zf2/#advanced-configuration",
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Zend\\Mvc\\Router\\Http\\TreeRouteStack \n  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\ZendRouter  instance composing the\n   Zend\\Mvc\\Router\\Http\\TreeRouteStack  instance.   Sound difficult? It's not; we've essentially done it above already!  // in src/Application/Container/TreeRouteStackFactory.php:\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Http\\Mvc\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router->addPrototypes(/* ... */);\n        $router->setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container->get('Zend\\Mvc\\Router\\Http\\TreeRouteStack'));\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container->addFactory(\n    'Zend\\Mvc\\Router\\Http\\TreeRouteStack',\n    'Application\\Container\\TreeRouteStackFactory'\n);\n$container->addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' => [\n        'Zend\\Mvc\\Router\\Http\\TreeRouteStack' => 'Application\\Container\\TreeRouteStackFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' => 'Application\\Container\\RouterFactory',\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\TreeRouteStackFactory;\nuse Application\\Container\\ZfRouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop;\n\n$container = new PimpleInterop();\n$container['Zend\\Mvc\\Router\\Http\\TreeRouteStackFactory'] = new TreeRouteStackFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();",
            "title": "Advanced Configuration"
        },
        {
            "location": "/v1/features/template/intro/",
            "text": "Templating\n\n\nBy default, no middleware in Expressive is templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.\n\n\nWe do, however, provide abstraction for templating via the interface\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n, which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:\n\n\n\n\nAll adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation \nnamespace::template\n when rendering.\n\n\nAdapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).\n\n\nAdapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.\n\n\nAdapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.\n\n\n\n\nIn this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.\n\n\nWe currently support:\n\n\n\n\nPlates\n\n\nTwig\n\n\nzend-view\n\n\n\n\nEach has an associated container factory; details are found in the\n\nfactories documentation\n.",
            "title": "Introduction"
        },
        {
            "location": "/v1/features/template/intro/#templating",
            "text": "By default, no middleware in Expressive is templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.  We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:   All adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation  namespace::template  when rendering.  Adapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).  Adapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.  Adapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.   In this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.  We currently support:   Plates  Twig  zend-view   Each has an associated container factory; details are found in the factories documentation .",
            "title": "Templating"
        },
        {
            "location": "/v1/features/template/interface/",
            "text": "The Template Renderer Interface\n\n\nExpressive defines \nZend\\Expressive\\Template\\TemplateRendererInterface\n, which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param string $name\n     * @param array|object $params\n     * @return string\n     */\n    public function render($name, $params = []);\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     *\n     * @param string $path\n     * @param string $namespace\n     */\n    public function addPath($path, $namespace = null);\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths();\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param string $param Param name.\n     * @param mixed $value\n     */\n    public function addDefaultParam($templateName, $param, $value);\n}\n\n\n\n\n\nNamespaces\n\n\nUnfortunately, namespace syntax varies between different template engine\nimplementations. As an example:\n\n\n\n\nPlates uses the syntax \nnamespace::template\n.\n\n\nTwig uses the syntax \n@namespace/template\n.\n\n\nzend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.\n\n\n\n\nTo make different engines compatible, we require implementations to support\nthe syntax \nnamespace::template\n (where \nnamespace::\n is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.\n\n\nWhen using a \nTemplateRendererInterface\n implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.\n\n\n\n\nPaths\n\n\nMost template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the \naddPath()\n method to do so:\n\n\n$renderer->addPath('templates');\n\n\n\nTemplate engines adapted for zend-expressive are also required to allow\n\nnamespacing\n templates; when adding a path, you specify the template\n\nnamespace\n that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.\n\n\n// Resolves to a path registered with the namespace \"error\";\n// this example is specific to the Plates engine.\n$content = $renderer->render('error::404');\n\n\n\nYou can provide a namespace when registering a path via an optional second\nargument:\n\n\n// Registers the \"error\" namespace to the path \"templates/error/\"\n$renderer->addPath('templates/error/', 'error');\n\n\n\nRendering\n\n\nTo render a template, call the \nrender()\n method. This method requires the name\nof a template as the first argument:\n\n\n$content = $renderer->render('foo');\n\n\n\nYou can specify a namespaced template using the syntax \nnamespace::template\n;\nthe \ntemplate\n segment of the template name may use additional directory\nseparators when necessary.\n\n\nOne key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to \nrender()\n:\n\n\n$content = $renderer->render('message', [\n    'greeting'  => 'Hello',\n    'recipient' => 'World',\n]);\n\n\n\nIt is up to the underlying template engine to determine how to perform the\ninjections.\n\n\nDefault params\n\n\nThe \nTemplateRendererInterface\n defines the method \naddDefaultParam()\n. This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:\n\n\npublic function addDefaultParam($templateName, $param, $value)\n\n\n\nIf you want a parameter to be used for \nevery\n template, you can specify the\nconstant \nTemplateRendererInterface::TEMPLATE_ALL\n for the \n$templateName\n\nparameter.\n\n\nWhen rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:\n\n\n\n\nDefault parameters specified for all templates.\n\n\nDefault parameters specified for the template specified at rendering.\n\n\nParameters specified when rendering.\n\n\n\n\nAs an example, if we did the following:\n\n\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer->addDefaultParam('example', 'foo', 'template default foo');\n$renderer->addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer->render('example', [\n    'foo' => 'override',\n]);\n\n\n\nThen we can expect the following substitutions will occur when rendering:\n\n\n\n\nReferences to the \"foo\" variable will contain \"override\".\n\n\nReferences to the \"bar\" variable will contain \"template default bar\".\n\n\nReferences to the \"baz\" variable will contain \"bat\".\n\n\n\n\n\n\nSupport for default params\n\n\nThe support for default params will often be renderer-specific. The reason is\nbecause the \nrender()\n signature does not specify a type for \n$params\n, in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given \n$params\n argument does not support it.\n\n\nAt the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.",
            "title": "Template Renderer Interface"
        },
        {
            "location": "/v1/features/template/interface/#the-template-renderer-interface",
            "text": "Expressive defines  Zend\\Expressive\\Template\\TemplateRendererInterface , which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:  namespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param string $name\n     * @param array|object $params\n     * @return string\n     */\n    public function render($name, $params = []);\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     *\n     * @param string $path\n     * @param string $namespace\n     */\n    public function addPath($path, $namespace = null);\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths();\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param string $param Param name.\n     * @param mixed $value\n     */\n    public function addDefaultParam($templateName, $param, $value);\n}",
            "title": "The Template Renderer Interface"
        },
        {
            "location": "/v1/features/template/interface/#namespaces",
            "text": "Unfortunately, namespace syntax varies between different template engine\nimplementations. As an example:   Plates uses the syntax  namespace::template .  Twig uses the syntax  @namespace/template .  zend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.   To make different engines compatible, we require implementations to support\nthe syntax  namespace::template  (where  namespace::  is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.  When using a  TemplateRendererInterface  implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.",
            "title": "Namespaces"
        },
        {
            "location": "/v1/features/template/interface/#paths",
            "text": "Most template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the  addPath()  method to do so:  $renderer->addPath('templates');  Template engines adapted for zend-expressive are also required to allow namespacing  templates; when adding a path, you specify the template namespace  that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.  // Resolves to a path registered with the namespace \"error\";\n// this example is specific to the Plates engine.\n$content = $renderer->render('error::404');  You can provide a namespace when registering a path via an optional second\nargument:  // Registers the \"error\" namespace to the path \"templates/error/\"\n$renderer->addPath('templates/error/', 'error');",
            "title": "Paths"
        },
        {
            "location": "/v1/features/template/interface/#rendering",
            "text": "To render a template, call the  render()  method. This method requires the name\nof a template as the first argument:  $content = $renderer->render('foo');  You can specify a namespaced template using the syntax  namespace::template ;\nthe  template  segment of the template name may use additional directory\nseparators when necessary.  One key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to  render() :  $content = $renderer->render('message', [\n    'greeting'  => 'Hello',\n    'recipient' => 'World',\n]);  It is up to the underlying template engine to determine how to perform the\ninjections.",
            "title": "Rendering"
        },
        {
            "location": "/v1/features/template/interface/#default-params",
            "text": "The  TemplateRendererInterface  defines the method  addDefaultParam() . This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:  public function addDefaultParam($templateName, $param, $value)  If you want a parameter to be used for  every  template, you can specify the\nconstant  TemplateRendererInterface::TEMPLATE_ALL  for the  $templateName \nparameter.  When rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:   Default parameters specified for all templates.  Default parameters specified for the template specified at rendering.  Parameters specified when rendering.   As an example, if we did the following:  $renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer->addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer->addDefaultParam('example', 'foo', 'template default foo');\n$renderer->addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer->render('example', [\n    'foo' => 'override',\n]);  Then we can expect the following substitutions will occur when rendering:   References to the \"foo\" variable will contain \"override\".  References to the \"bar\" variable will contain \"template default bar\".  References to the \"baz\" variable will contain \"bat\".",
            "title": "Default params"
        },
        {
            "location": "/v1/features/template/interface/#support-for-default-params",
            "text": "The support for default params will often be renderer-specific. The reason is\nbecause the  render()  signature does not specify a type for  $params , in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given  $params  argument does not support it.  At the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.",
            "title": "Support for default params"
        },
        {
            "location": "/v1/features/template/middleware/",
            "text": "Templated Middleware\n\n\nThe primary use case for templating is within middleware, to provide templated\nresponses. To do this, you will:\n\n\n\n\nInject an instance of \nZend\\Expressive\\Template\\TemplateRendererInterface\n into your\n  middleware.\n\n\nPotentially add paths to the templating instance.\n\n\nRender a template.\n\n\nAdd the results of rendering to your response.\n\n\n\n\nInjecting a TemplateRendererInterface\n\n\nWe encourage the use of dependency injection. As such, we recommend writing your\nmiddleware to accept the \nTemplateRendererInterface\n via either the constructor or a\nsetter. As an example:\n\n\nnamespace Acme\\Blog;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        // ...\n    }\n}\n\n\n\nThis will necessitate having a factory for your middleware:\n\n\nnamespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryMiddleware;\nuse Interop\\Container\\ContainerInterface;\n\nclass EntryMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryMiddleware(\n            $container->get('Zend\\Expressive\\Template\\TemplateRendererInterface')\n        );\n    }\n}\n\n\n\nAnd, of course, you'll need to tell your container to use the factory; see the\n\ncontainer documentation\n for more information on how you\nmight accomplish that.\n\n\nConsuming templates\n\n\nNow that we have the templating engine injected into our middleware, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:\n\n\n<?php\nnamespace Acme\\Blog;\n\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'entry' => $entry,\n            ])\n        );\n    }\n}\n\n\n\nAlternately, you can write to the composed response:\n\n\n$response->getBody()->write($this->templateRenderer->render('blog::entry', [\n    'entry' => $entry,\n]));\nreturn $response;",
            "title": "Templated Middleware"
        },
        {
            "location": "/v1/features/template/middleware/#templated-middleware",
            "text": "The primary use case for templating is within middleware, to provide templated\nresponses. To do this, you will:   Inject an instance of  Zend\\Expressive\\Template\\TemplateRendererInterface  into your\n  middleware.  Potentially add paths to the templating instance.  Render a template.  Add the results of rendering to your response.",
            "title": "Templated Middleware"
        },
        {
            "location": "/v1/features/template/middleware/#injecting-a-templaterendererinterface",
            "text": "We encourage the use of dependency injection. As such, we recommend writing your\nmiddleware to accept the  TemplateRendererInterface  via either the constructor or a\nsetter. As an example:  namespace Acme\\Blog;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        // ...\n    }\n}  This will necessitate having a factory for your middleware:  namespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryMiddleware;\nuse Interop\\Container\\ContainerInterface;\n\nclass EntryMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryMiddleware(\n            $container->get('Zend\\Expressive\\Template\\TemplateRendererInterface')\n        );\n    }\n}  And, of course, you'll need to tell your container to use the factory; see the container documentation  for more information on how you\nmight accomplish that.",
            "title": "Injecting a TemplateRendererInterface"
        },
        {
            "location": "/v1/features/template/middleware/#consuming-templates",
            "text": "Now that we have the templating engine injected into our middleware, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:  <?php\nnamespace Acme\\Blog;\n\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->templateRenderer = $renderer;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this->templateRenderer->render('blog::entry', [\n                'entry' => $entry,\n            ])\n        );\n    }\n}  Alternately, you can write to the composed response:  $response->getBody()->write($this->templateRenderer->render('blog::entry', [\n    'entry' => $entry,\n]));\nreturn $response;",
            "title": "Consuming templates"
        },
        {
            "location": "/v1/features/template/plates/",
            "text": "Using Plates\n\n\nPlates\n is a native PHP template system\nmaintained by \nThe League of Extraordinary Packages\n.\nit provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Plates via\n\nZend\\Expressive\\Plates\\PlatesRenderer\n.\n\n\nInstalling Plates\n\n\nTo use the Plates wrapper, you must install the Plates integration:\n\n\n$ composer require zendframework/zend-expressive-platesrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Plates\\PlatesRenderer\n will create\nan instance of the Plates engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Plates\\PlatesRenderer\n constructor:\n\n\nuse League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates->addFolder('error', 'templates/error/');\n$plates->loadExtension(new CustomExtension());\n\n// Inject:\n$renderer = new PlatesRenderer($plates);",
            "title": "Using Plates"
        },
        {
            "location": "/v1/features/template/plates/#using-plates",
            "text": "Plates  is a native PHP template system\nmaintained by  The League of Extraordinary Packages .\nit provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer .",
            "title": "Using Plates"
        },
        {
            "location": "/v1/features/template/plates/#installing-plates",
            "text": "To use the Plates wrapper, you must install the Plates integration:  $ composer require zendframework/zend-expressive-platesrenderer",
            "title": "Installing Plates"
        },
        {
            "location": "/v1/features/template/plates/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\Plates\\PlatesRenderer  will create\nan instance of the Plates engine, which it will then proxy to.  use Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Plates\\PlatesRenderer  constructor:  use League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates->addFolder('error', 'templates/error/');\n$plates->loadExtension(new CustomExtension());\n\n// Inject:\n$renderer = new PlatesRenderer($plates);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v1/features/template/twig/",
            "text": "Using Twig\n\n\nTwig\n is a template language and engine provided\nas a standalone component by SensioLabs. It provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Twig via\n\nZend\\Expressive\\Twig\\TwigRenderer\n.\n\n\nInstalling Twig\n\n\nTo use the Twig wrapper, you must first install the Twig integration:\n\n\n$ composer require zendframework/zend-expressive-twigrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Twig\\TwigRenderer\n will create\nan instance of the Twig engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Twig\\TwigRenderer\n constructor:\n\n\nuse Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig->addExtension(new CustomExtension());\n$twig->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);\n\n\n\nIncluded extensions and functions\n\n\nThe included Twig extension adds support for url generation. The extension is\nautomatically activated if the \nUrlHelper\n and\n\nServerUrlHelper\n are registered with the\ncontainer.\n\n\nThe following template functions are exposed:\n\n\n\n\npath\n: Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.\n\n\n\n\n{{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3\n\n\n\n\n\nurl\n: Render the absolute url for a given route and parameters. If there is\n  no route, it returns the current url.\n\n\n\n\n{{ url('article_show', {'slug': 'article.slug'}) }}\nGenerates: http://example.com/article/article.slug\n\n\n\n\n\nabsolute_url\n: Render the absolute url from a given path. If the path is\n  empty, it returns the current url.\n\n\n\n\n{{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something\n\n\n\n\n\nasset\n Render an (optionally versioned) asset url.\n\n\n\n\n{{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3\n\n\n\nTo get the absolute url for an asset:\n\n\n{{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3\n\n\n\nConfiguration\n\n\nThe following details configuration specific to Twig, as consumed by the\n\nTwigRendererFactory\n:\n\n\nreturn [\n    'templates' => [\n        'extension' => 'file extension used by templates; defaults to html.twig',\n        'paths' => [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' => [\n        'cache_dir' => 'path to cached templates',\n        'assets_url' => 'base URL for assets',\n        'assets_version' => 'base version for assets',\n        'extensions' => [\n            // extension service names or instances\n        ],\n        'globals' => [\n            // Global variables passed to twig templates\n            'ga_tracking' => 'UA-XXXXX-X'\n        ],\n    ],\n];",
            "title": "Using Twig"
        },
        {
            "location": "/v1/features/template/twig/#using-twig",
            "text": "Twig  is a template language and engine provided\nas a standalone component by SensioLabs. It provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer .",
            "title": "Using Twig"
        },
        {
            "location": "/v1/features/template/twig/#installing-twig",
            "text": "To use the Twig wrapper, you must first install the Twig integration:  $ composer require zendframework/zend-expressive-twigrenderer",
            "title": "Installing Twig"
        },
        {
            "location": "/v1/features/template/twig/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\Twig\\TwigRenderer  will create\nan instance of the Twig engine, which it will then proxy to.  use Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Twig\\TwigRenderer  constructor:  use Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig->addExtension(new CustomExtension());\n$twig->loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v1/features/template/twig/#included-extensions-and-functions",
            "text": "The included Twig extension adds support for url generation. The extension is\nautomatically activated if the  UrlHelper  and ServerUrlHelper  are registered with the\ncontainer.  The following template functions are exposed:   path : Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.   {{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3   url : Render the absolute url for a given route and parameters. If there is\n  no route, it returns the current url.   {{ url('article_show', {'slug': 'article.slug'}) }}\nGenerates: http://example.com/article/article.slug   absolute_url : Render the absolute url from a given path. If the path is\n  empty, it returns the current url.   {{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something   asset  Render an (optionally versioned) asset url.   {{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3  To get the absolute url for an asset:  {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3",
            "title": "Included extensions and functions"
        },
        {
            "location": "/v1/features/template/twig/#configuration",
            "text": "The following details configuration specific to Twig, as consumed by the TwigRendererFactory :  return [\n    'templates' => [\n        'extension' => 'file extension used by templates; defaults to html.twig',\n        'paths' => [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' => [\n        'cache_dir' => 'path to cached templates',\n        'assets_url' => 'base URL for assets',\n        'assets_version' => 'base version for assets',\n        'extensions' => [\n            // extension service names or instances\n        ],\n        'globals' => [\n            // Global variables passed to twig templates\n            'ga_tracking' => 'UA-XXXXX-X'\n        ],\n    ],\n];",
            "title": "Configuration"
        },
        {
            "location": "/v1/features/template/zend-view/",
            "text": "Using zend-view\n\n\nzend-view\n provides a native PHP\ntemplate system via its \nPhpRenderer\n, and is maintained by Zend Framework. It\nprovides:\n\n\n\n\nLayout facilities.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for zend-view's\n\nPhpRenderer\n via \nZend\\Expressive\\ZendView\\ZendViewRenderer\n.\n\n\nInstalling zend-view\n\n\nTo use the zend-view wrapper, you must first install the zend-view integration:\n\n\n$ composer require zendframework/zend-expressive-zendviewrenderer\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\ZendView\\ZendViewRenderer\n will create\nan instance of the \nPhpRenderer\n, which it will then proxy to.\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\ZendView\\ZendViewRenderer\n constructor:\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver->attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver->attach(\n    (new Resolver\\TemplatePathStack())\n    ->setPaths(include 'config/template_paths.php')\n);\n$renderer->setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);\n\n\n\n\n\nNamespaced path resolving\n\n\nExpressive defines a custom zend-view resolver,\n\nZend\\Expressive\\ZendView\\NamespacedPathStackResolver\n. This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the \nnamespace::template\n notation\nrequired of \nTemplateRendererInterface\n implementations.\n\n\nThe \nZendView\n adapter ensures that:\n\n\n\n\nAn \nAggregateResolver\n is registered with the renderer. If the registered\n  resolver is not an \nAggregateResolver\n, it creates one and adds the original\n  resolver to it.\n\n\nA \nNamespacedPathStackResolver\n is registered with the \nAggregateResolver\n, at\n  a low priority (0), ensuring attempts to resolve hit it later.\n\n\n\n\nWith resolvers such as the \nTemplateMapResolver\n, you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!\n\n\n\n\nLayouts\n\n\nUnlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:\n\n\n\n\nYou may pass a layout template name or \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout as the second argument to the constructor.\n\n\nYou may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.\n\n\n\n\nIn each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.\n\n\nLayout name passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');\n\n\n\nLayout view model passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/prod/',\n]);\n$layout->setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);\n\n\n\nProvide a layout name when rendering\n\n\n$content = $renderer->render('blog/entry', [\n    'layout' => 'layout::blog',\n    'entry'  => $entry,\n]);\n\n\n\nProvide a layout view model when rendering\n\n\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/blog/',\n]);\n$layout->setTemplate('layout::layout');\n\n$content = $renderer->render('blog/entry', [\n    'layout' => $layout,\n    'entry'  => $entry,\n]);\n\n\n\nHelpers\n\n\nExpressive provides overrides of specific view helpers in order to better\nintegrate with PSR-7. These include:\n\n\n\n\nZend\\Expressive\\ZendView\\UrlHelper\n. This helper consumes the\n  application's \nZend\\Expressive\\Router\\RouterInterface\n instance in order\n  to generate URIs. It's signature is:\n  \nurl($routeName, array $substitutions = [])\n\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n. This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  It's signature is: \nserverUrl($path = null)\n.\n\n\n\n\nTo use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:\n\n\n$serverUrlHelper->setUri($request->getUri());\n\n\n\nWe recommend doing this within a pre-pipeline middleware.\n\n\nRecommendations\n\n\nWe recommend the following practices when using the zend-view adapter:\n\n\n\n\nIf using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.\n\n\nWhile we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.",
            "title": "Using zend-view"
        },
        {
            "location": "/v1/features/template/zend-view/#using-zend-view",
            "text": "zend-view  provides a native PHP\ntemplate system via its  PhpRenderer , and is maintained by Zend Framework. It\nprovides:   Layout facilities.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for zend-view's PhpRenderer  via  Zend\\Expressive\\ZendView\\ZendViewRenderer .",
            "title": "Using zend-view"
        },
        {
            "location": "/v1/features/template/zend-view/#installing-zend-view",
            "text": "To use the zend-view wrapper, you must first install the zend-view integration:  $ composer require zendframework/zend-expressive-zendviewrenderer",
            "title": "Installing zend-view"
        },
        {
            "location": "/v1/features/template/zend-view/#using-the-wrapper",
            "text": "If instantiated without arguments,  Zend\\Expressive\\ZendView\\ZendViewRenderer  will create\nan instance of the  PhpRenderer , which it will then proxy to.  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\ZendView\\ZendViewRenderer  constructor:  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver->attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver->attach(\n    (new Resolver\\TemplatePathStack())\n    ->setPaths(include 'config/template_paths.php')\n);\n$renderer->setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);",
            "title": "Using the wrapper"
        },
        {
            "location": "/v1/features/template/zend-view/#namespaced-path-resolving",
            "text": "Expressive defines a custom zend-view resolver, Zend\\Expressive\\ZendView\\NamespacedPathStackResolver . This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the  namespace::template  notation\nrequired of  TemplateRendererInterface  implementations.  The  ZendView  adapter ensures that:   An  AggregateResolver  is registered with the renderer. If the registered\n  resolver is not an  AggregateResolver , it creates one and adds the original\n  resolver to it.  A  NamespacedPathStackResolver  is registered with the  AggregateResolver , at\n  a low priority (0), ensuring attempts to resolve hit it later.   With resolvers such as the  TemplateMapResolver , you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!",
            "title": "Namespaced path resolving"
        },
        {
            "location": "/v1/features/template/zend-view/#layouts",
            "text": "Unlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:   You may pass a layout template name or  Zend\\View\\Model\\ModelInterface \n  instance representing the layout as the second argument to the constructor.  You may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a  Zend\\View\\Model\\ModelInterface \n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.   In each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.",
            "title": "Layouts"
        },
        {
            "location": "/v1/features/template/zend-view/#layout-name-passed-to-constructor",
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');",
            "title": "Layout name passed to constructor"
        },
        {
            "location": "/v1/features/template/zend-view/#layout-view-model-passed-to-constructor",
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/prod/',\n]);\n$layout->setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);",
            "title": "Layout view model passed to constructor"
        },
        {
            "location": "/v1/features/template/zend-view/#provide-a-layout-name-when-rendering",
            "text": "$content = $renderer->render('blog/entry', [\n    'layout' => 'layout::blog',\n    'entry'  => $entry,\n]);",
            "title": "Provide a layout name when rendering"
        },
        {
            "location": "/v1/features/template/zend-view/#provide-a-layout-view-model-when-rendering",
            "text": "use Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' => 'utf-8',\n    'cssPath'  => '/css/blog/',\n]);\n$layout->setTemplate('layout::layout');\n\n$content = $renderer->render('blog/entry', [\n    'layout' => $layout,\n    'entry'  => $entry,\n]);",
            "title": "Provide a layout view model when rendering"
        },
        {
            "location": "/v1/features/template/zend-view/#helpers",
            "text": "Expressive provides overrides of specific view helpers in order to better\nintegrate with PSR-7. These include:   Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the\n  application's  Zend\\Expressive\\Router\\RouterInterface  instance in order\n  to generate URIs. It's signature is:\n   url($routeName, array $substitutions = [])  Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  It's signature is:  serverUrl($path = null) .   To use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:  $serverUrlHelper->setUri($request->getUri());  We recommend doing this within a pre-pipeline middleware.",
            "title": "Helpers"
        },
        {
            "location": "/v1/features/template/zend-view/#recommendations",
            "text": "We recommend the following practices when using the zend-view adapter:   If using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.  While we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.",
            "title": "Recommendations"
        },
        {
            "location": "/v1/features/error-handling/",
            "text": "Error Handling\n\n\nExpressive provides error handling out of the box, via zend-stratigility's \nFinalHandler\nimplementation\n.\nThis pseudo-middleware is executed in the following conditions:\n\n\n\n\nIf the middleware stack is exhausted, and no middleware has returned a response.\n\n\nIf an error has been passed via \n$next()\n, but not handled by any error middleware.\n\n\n\n\nThe \nFinalHandler\n essentially tries to recover gracefully. In the case that no error was passed, it\ndoes the following:\n\n\n\n\nIf the response passed to it differs from the response provided at initialization, it will return\n  the response directly; the assumption is that some middleware along the way called \n$next()\n\n  with a new response.\n\n\nIf the response instances are identical, it checks to see if the body size has changed; if it has,\n  the assumption is that a middleware at some point has written to the response body.\n\n\nAt this point, it assumes no middleware was able to handle the request, and creates a 404\n  response, indicating \"Not Found.\"\n\n\n\n\nIn the event that an error \nwas\n passed, it does the following:\n\n\n\n\nIf \n$error\n is not an exception, it will use the response status if it already indicates an error\n  (ie., >= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase.\n\n\nIf \n$error\n \nis\n an exception, it will use the exception status if it already indicates an error\n  (ie., >= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase. If the \nFinalHandler\n was initialized with an option indicating that it is in\n  development mode, it writes the exception stack trace to the response body.\n\n\n\n\nThis workflow stays the same throughout zend-expressive. But sometimes, it's just not enough.\n\n\nTemplated Errors\n\n\nYou'll typically want to provide error messages in your site template. To do so, we provide\n\nZend\\Expressive\\TemplatedErrorHandler\n. This class is similar to the \nFinalHandler\n, but accepts,\noptionally, a \nZend\\Expressive\\Template\\TemplateRendererInterface\n instance, and template names to use for\n404 and general error conditions. This makes it a good choice for use in production.\n\n\nFirst, of course, you'll need to select a templating system and ensure you have\nthe appropriate dependencies installed; see the \ntemplating documentation\n\nfor information on what we support and how to install supported systems.\n\n\nOnce you have selected your templating system, you can setup the templated error\nhandler.\n\n\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\TemplatedErrorHandler;\n\n$plates = new PlatesRenderer();\n$plates->addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new TemplatedErrorHandler($plates, 'error::404', 'error::500');\n\n$app = new Application($router, $container, $finalHandler);\n\n\n\nThe above will use the templates \nerror::404\n and \nerror::500\n for 404 and general errors,\nrespectively, rendering them using our Plates template adapter.\n\n\nYou can also use the \nTemplatedErrorHandler\n as a substitute for the \nFinalHandler\n, without using\ntemplated capabilities, by omitting the \nTemplateRendererInterface\n instance when instantiating it. In this\ncase, the response message bodies will be empty, though the response status will reflect the error.\n\n\nSee the section titled \"Container Factories and Configuration\", below, for techniques on configuring\nthe \nTemplatedErrorHandler\n as your final handler within a container-based application.\n\n\nWhoops\n\n\nwhoops\n is a library for providing a more usable UI around\nexceptions and PHP errors. We provide integration with this library through\n\nZend\\Express\\WhoopsErrorHandler\n. This error handler derives from the \nTemplatedErrorHandler\n, and\nuses its features for 404 status and non-exception errors. For exceptions, however, it will return\nthe whoops output. As such, it is a good choice for use in development.\n\n\nTo use it, you must first install whoops:\n\n\n$ composer require filp/whoops\n\n\n\nThen you will need to provide the error handler a whoops runtime instance, as well as a\n\nWhoops\\Handler\\PrettyPageHandler\n instance. You can also optionally provide a \nTemplateRendererInterface\n\ninstance and template names, just as you would for a \nTemplatedErrorHandler\n.\n\n\nuse Whoops\\Handler\\PrettyPageHandler;\nuse Whoops\\Run as Whoops;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\WhoopsErrorHandler;\n\n$handler = new PrettyPageHandler();\n\n$whoops = new Whoops;\n$whoops->writeToOutput(false);\n$whoops->allowQuit(false);\n$whoops->pushHandler($handler);\n\n$plates = new PlatesRenderer();\n$plates->addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new WhoopsErrorHandler(\n    $whoops,\n    $handler,\n    $plates,\n    'error::404',\n    'error::500'\n);\n\n$app = new Application($router, $container, $finalHandler);\n\n// Register Whoops just before running the application, as otherwise it can\n// swallow bootstrap errors.\n$whoops->register();\n$app->run();\n\n\n\nThe calls to \nwriteToOutput(false)\n, \nallowQuit(false)\n, and \nregister()\n must be made to guarantee\nwhoops will interoperate well with zend-expressive.\n\n\nYou can add more handlers if desired.\n\n\nInternally, when an exception is discovered, zend-expressive adds some data to the whoops output,\nprimarily around the request information (URI, HTTP request method, route match attributes, etc.).\n\n\nSee the next section for techniques on configuring the \nWhoopsErrorHandler\n as your final handler\nwithin a container-based application.\n\n\nContainer Factories and Configuration\n\n\nThe above may feel like a bit much when creating your application. As such, we provide several\nfactories that work with \ncontainer-interop\n-compatible\ncontainer implementations to simplify setup.\n\n\nIn each case, you should register the selected error handler's factory as the service\n\nZend\\Expressive\\FinalHandler\n.\n\n\n\n\nFor the \nTemplatedErrorHandler\n, use \nZend\\Expressive\\Container\\TemplatedErrorHandlerFactory\n.\n\n\nFor the \nWhoopsErrorHandler\n, use \nZend\\Expressive\\Container\\WhoopsErrorHandlerFactory\n.",
            "title": "Error Handling"
        },
        {
            "location": "/v1/features/error-handling/#error-handling",
            "text": "Expressive provides error handling out of the box, via zend-stratigility's  FinalHandler\nimplementation .\nThis pseudo-middleware is executed in the following conditions:   If the middleware stack is exhausted, and no middleware has returned a response.  If an error has been passed via  $next() , but not handled by any error middleware.   The  FinalHandler  essentially tries to recover gracefully. In the case that no error was passed, it\ndoes the following:   If the response passed to it differs from the response provided at initialization, it will return\n  the response directly; the assumption is that some middleware along the way called  $next() \n  with a new response.  If the response instances are identical, it checks to see if the body size has changed; if it has,\n  the assumption is that a middleware at some point has written to the response body.  At this point, it assumes no middleware was able to handle the request, and creates a 404\n  response, indicating \"Not Found.\"   In the event that an error  was  passed, it does the following:   If  $error  is not an exception, it will use the response status if it already indicates an error\n  (ie., >= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase.  If  $error   is  an exception, it will use the exception status if it already indicates an error\n  (ie., >= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase. If the  FinalHandler  was initialized with an option indicating that it is in\n  development mode, it writes the exception stack trace to the response body.   This workflow stays the same throughout zend-expressive. But sometimes, it's just not enough.",
            "title": "Error Handling"
        },
        {
            "location": "/v1/features/error-handling/#templated-errors",
            "text": "You'll typically want to provide error messages in your site template. To do so, we provide Zend\\Expressive\\TemplatedErrorHandler . This class is similar to the  FinalHandler , but accepts,\noptionally, a  Zend\\Expressive\\Template\\TemplateRendererInterface  instance, and template names to use for\n404 and general error conditions. This makes it a good choice for use in production.  First, of course, you'll need to select a templating system and ensure you have\nthe appropriate dependencies installed; see the  templating documentation \nfor information on what we support and how to install supported systems.  Once you have selected your templating system, you can setup the templated error\nhandler.  use Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\TemplatedErrorHandler;\n\n$plates = new PlatesRenderer();\n$plates->addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new TemplatedErrorHandler($plates, 'error::404', 'error::500');\n\n$app = new Application($router, $container, $finalHandler);  The above will use the templates  error::404  and  error::500  for 404 and general errors,\nrespectively, rendering them using our Plates template adapter.  You can also use the  TemplatedErrorHandler  as a substitute for the  FinalHandler , without using\ntemplated capabilities, by omitting the  TemplateRendererInterface  instance when instantiating it. In this\ncase, the response message bodies will be empty, though the response status will reflect the error.  See the section titled \"Container Factories and Configuration\", below, for techniques on configuring\nthe  TemplatedErrorHandler  as your final handler within a container-based application.",
            "title": "Templated Errors"
        },
        {
            "location": "/v1/features/error-handling/#whoops",
            "text": "whoops  is a library for providing a more usable UI around\nexceptions and PHP errors. We provide integration with this library through Zend\\Express\\WhoopsErrorHandler . This error handler derives from the  TemplatedErrorHandler , and\nuses its features for 404 status and non-exception errors. For exceptions, however, it will return\nthe whoops output. As such, it is a good choice for use in development.  To use it, you must first install whoops:  $ composer require filp/whoops  Then you will need to provide the error handler a whoops runtime instance, as well as a Whoops\\Handler\\PrettyPageHandler  instance. You can also optionally provide a  TemplateRendererInterface \ninstance and template names, just as you would for a  TemplatedErrorHandler .  use Whoops\\Handler\\PrettyPageHandler;\nuse Whoops\\Run as Whoops;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\WhoopsErrorHandler;\n\n$handler = new PrettyPageHandler();\n\n$whoops = new Whoops;\n$whoops->writeToOutput(false);\n$whoops->allowQuit(false);\n$whoops->pushHandler($handler);\n\n$plates = new PlatesRenderer();\n$plates->addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new WhoopsErrorHandler(\n    $whoops,\n    $handler,\n    $plates,\n    'error::404',\n    'error::500'\n);\n\n$app = new Application($router, $container, $finalHandler);\n\n// Register Whoops just before running the application, as otherwise it can\n// swallow bootstrap errors.\n$whoops->register();\n$app->run();  The calls to  writeToOutput(false) ,  allowQuit(false) , and  register()  must be made to guarantee\nwhoops will interoperate well with zend-expressive.  You can add more handlers if desired.  Internally, when an exception is discovered, zend-expressive adds some data to the whoops output,\nprimarily around the request information (URI, HTTP request method, route match attributes, etc.).  See the next section for techniques on configuring the  WhoopsErrorHandler  as your final handler\nwithin a container-based application.",
            "title": "Whoops"
        },
        {
            "location": "/v1/features/error-handling/#container-factories-and-configuration",
            "text": "The above may feel like a bit much when creating your application. As such, we provide several\nfactories that work with  container-interop -compatible\ncontainer implementations to simplify setup.  In each case, you should register the selected error handler's factory as the service Zend\\Expressive\\FinalHandler .   For the  TemplatedErrorHandler , use  Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory .  For the  WhoopsErrorHandler , use  Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory .",
            "title": "Container Factories and Configuration"
        },
        {
            "location": "/v1/features/helpers/intro/",
            "text": "Helpers\n\n\nSome tasks and features will be common to many if not all applications. For\nthose, Expressive provides \nhelpers\n. These are typically utility classes that\nmay integrate features or simply provide standalone benefits.\n\n\nCurrently, these include:\n\n\n\n\nUrlHelper\n\n\nServerUrlHelper\n\n\n\n\nInstallation\n\n\nIf you started your project using the Expressive skeleton package, the helpers\nare already installed.\n\n\nIf not, you can install them as follows:\n\n\n$ composer require zendframework/zend-expressive-helpers",
            "title": "Introduction"
        },
        {
            "location": "/v1/features/helpers/intro/#helpers",
            "text": "Some tasks and features will be common to many if not all applications. For\nthose, Expressive provides  helpers . These are typically utility classes that\nmay integrate features or simply provide standalone benefits.  Currently, these include:   UrlHelper  ServerUrlHelper",
            "title": "Helpers"
        },
        {
            "location": "/v1/features/helpers/intro/#installation",
            "text": "If you started your project using the Expressive skeleton package, the helpers\nare already installed.  If not, you can install them as follows:  $ composer require zendframework/zend-expressive-helpers",
            "title": "Installation"
        },
        {
            "location": "/v1/features/helpers/url-helper/",
            "text": "UrlHelper\n\n\nZend\\Expressive\\Helper\\UrlHelper\n provides the ability to generate a URI path\nbased on a given route defined in the \nZend\\Expressive\\Router\\RouterInterface\n.\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper->generate('resource', ['id' => 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' => 'sha1']);\n\n\n\nThe signature for both is:\n\n\nfunction ($routeName, array $params = []) : string\n\n\n\nWhere:\n\n\n\n\n$routeName\n is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.\n\n\n$params\n is an array of substitutions to use for the provided route, with the\n  following behavior:\n\n\nIf a \nRouteResult\n is composed in the helper, and the \n$routeName\n matches\n    it, the provided \n$params\n will be merged with any matched parameters, with\n    those provided taking precedence.\n\n\nIf a \nRouteResult\n is not composed, or if the composed result does not match\n    the provided \n$routeName\n, then only the \n$params\n provided will be used\n    for substitutions.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n matches the currently\n    matched route, then any matched parameters found will be used.\n    parameters found will be used.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n does not match the\n    currently matched route, or if no route result is present, then no\n    substitutions will be made.\n\n\n\n\nEach method will raise an exception if:\n\n\n\n\nNo \n$routeName\n is provided, and no \nRouteResult\n is composed.\n\n\nNo \n$routeName\n is provided, a \nRouteResult\n is composed, but that result\n  represents a matching failure.\n\n\nThe given \n$routeName\n is not defined in the router.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to instantiate it with the current\n\nRouterInterface\n. The factory \nZend\\Expressive\\Helper\\UrlHelperFactory\n has\nbeen provided for this purpose, and can be used trivially with most\ndependency injection containers implementing container-interop. Additionally,\nit is most useful when injected with the current results of routing, which\nrequires registering middleware with the application that can inject the route\nresult. The following steps should be followed to register and configure the helper:\n\n\n\n\nRegister the \nUrlHelper\n as a service in your container, using the provided\n  factory.\n\n\nRegister the \nUrlHelperMiddleware\n as a service in your container, using the\n  provided factory.\n\n\nRegister the \nUrlHelperMiddleware\n as pipeline middleware, immediately\n  following the routing middleware.\n\n\n\n\nRegistering the helper service\n\n\nThe following examples demonstrate programmatic registration of the \nUrlHelper\n\nservice in your selected dependency injection container.\n\n\nuse Zend\\Expressive\\Helper\\UrlHelper;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\n\n// zend-servicemanager:\n$services->setFactory(UrlHelper::class, UrlHelperFactory::class);\n\n// Pimple:\n$pimple[UrlHelper::class] = function ($container) {\n    $factory = new UrlHelperFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(UrlHelperFactory::class, $container->lazyNew(UrlHelperFactory::class));\n$container->set(\n    UrlHelper::class,\n    $container->lazyGetCall(UrlHelperFactory::class, '__invoke', $container)\n);\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn ['dependencies' => [\n    'factories' => [\n        UrlHelper::class => UrlHelperFactory::class,\n    ],\n]]\n\n\n\n\n\nUrlHelperFactory requires RouterInterface\n\n\nThe factory requires that a service named \nZend\\Expressive\\Router\\RouterInterface\n is present,\nand will raise an exception if the service is not found.\n\n\n\n\nRegistering the pipeline middleware\n\n\nTo register the \nUrlHelperMiddleware\n as pipeline middleware following the\nrouting middleware:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n//         ['middleware' => UrlHelperMiddleware::class],\n//         Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n//         /* ... */\n//     ],\n// ]\n//\n// Alternately, create a nested middleware pipeline for the routing, UrlHelper,\n// and dispatch middleware:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         'routing' => [\n//             'middleware' => [\n//                 Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n//                 UrlHelperMiddleware::class\n//                 Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n//             ],\n//             'priority' => 1,\n//         ],\n//         /* ... */\n//     ],\n// ]\n\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n        ['middleware' => UrlHelperMiddleware::class],\n        Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n    ],\n];\n\n// OR:\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n    ],\n];\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nUrlHelper\n and \nUrlHelperMiddleware\n factories are already registered for\nyou, as is the \nUrlHelperMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response->withHeader(\n            'Link',\n            $this->helper->generate('resource', ['id' => 'sha1'])\n        );\n        return $next($request, $response);\n    }\n}\n\n\n\nBase Path support\n\n\nIf your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the \nbase path\n, and thus be invalid. To\naccommodate this, the \nUrlHelper\n supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.\n\n\nAs an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the \nUrlHelper\n with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:\n\n\nuse Locale;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $uri = $request->getUri();\n        $path = $uri->getPath();\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $next($request, $response);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $next(\n            $request->withUri(\n                $uri->withPath(substr($path, (strlen($locale) + 1)))\n            ),\n            $response\n        );\n    }\n}\n\n\n\n(Note: if the base path injected is not prefixed with \n/\n, the helper will add\nthe slash.)\n\n\nPaths generated by the \nUriHelper\n from this point forward will have the\ndetected language prefix.",
            "title": "UrlHelper"
        },
        {
            "location": "/v1/features/helpers/url-helper/#urlhelper",
            "text": "Zend\\Expressive\\Helper\\UrlHelper  provides the ability to generate a URI path\nbased on a given route defined in the  Zend\\Expressive\\Router\\RouterInterface .\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.",
            "title": "UrlHelper"
        },
        {
            "location": "/v1/features/helpers/url-helper/#usage",
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper->generate('resource', ['id' => 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' => 'sha1']);  The signature for both is:  function ($routeName, array $params = []) : string  Where:   $routeName  is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.  $params  is an array of substitutions to use for the provided route, with the\n  following behavior:  If a  RouteResult  is composed in the helper, and the  $routeName  matches\n    it, the provided  $params  will be merged with any matched parameters, with\n    those provided taking precedence.  If a  RouteResult  is not composed, or if the composed result does not match\n    the provided  $routeName , then only the  $params  provided will be used\n    for substitutions.  If no  $params  are provided, and the  $routeName  matches the currently\n    matched route, then any matched parameters found will be used.\n    parameters found will be used.  If no  $params  are provided, and the  $routeName  does not match the\n    currently matched route, or if no route result is present, then no\n    substitutions will be made.   Each method will raise an exception if:   No  $routeName  is provided, and no  RouteResult  is composed.  No  $routeName  is provided, a  RouteResult  is composed, but that result\n  represents a matching failure.  The given  $routeName  is not defined in the router.",
            "title": "Usage"
        },
        {
            "location": "/v1/features/helpers/url-helper/#creating-an-instance",
            "text": "In order to use the helper, you will need to instantiate it with the current RouterInterface . The factory  Zend\\Expressive\\Helper\\UrlHelperFactory  has\nbeen provided for this purpose, and can be used trivially with most\ndependency injection containers implementing container-interop. Additionally,\nit is most useful when injected with the current results of routing, which\nrequires registering middleware with the application that can inject the route\nresult. The following steps should be followed to register and configure the helper:   Register the  UrlHelper  as a service in your container, using the provided\n  factory.  Register the  UrlHelperMiddleware  as a service in your container, using the\n  provided factory.  Register the  UrlHelperMiddleware  as pipeline middleware, immediately\n  following the routing middleware.",
            "title": "Creating an instance"
        },
        {
            "location": "/v1/features/helpers/url-helper/#registering-the-helper-service",
            "text": "The following examples demonstrate programmatic registration of the  UrlHelper \nservice in your selected dependency injection container.  use Zend\\Expressive\\Helper\\UrlHelper;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\n\n// zend-servicemanager:\n$services->setFactory(UrlHelper::class, UrlHelperFactory::class);\n\n// Pimple:\n$pimple[UrlHelper::class] = function ($container) {\n    $factory = new UrlHelperFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(UrlHelperFactory::class, $container->lazyNew(UrlHelperFactory::class));\n$container->set(\n    UrlHelper::class,\n    $container->lazyGetCall(UrlHelperFactory::class, '__invoke', $container)\n);  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return ['dependencies' => [\n    'factories' => [\n        UrlHelper::class => UrlHelperFactory::class,\n    ],\n]]",
            "title": "Registering the helper service"
        },
        {
            "location": "/v1/features/helpers/url-helper/#urlhelperfactory-requires-routerinterface",
            "text": "The factory requires that a service named  Zend\\Expressive\\Router\\RouterInterface  is present,\nand will raise an exception if the service is not found.",
            "title": "UrlHelperFactory requires RouterInterface"
        },
        {
            "location": "/v1/features/helpers/url-helper/#registering-the-pipeline-middleware",
            "text": "To register the  UrlHelperMiddleware  as pipeline middleware following the\nrouting middleware:  use Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app->pipeRoutingMiddleware();\n$app->pipe(UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n//         ['middleware' => UrlHelperMiddleware::class],\n//         Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n//         /* ... */\n//     ],\n// ]\n//\n// Alternately, create a nested middleware pipeline for the routing, UrlHelper,\n// and dispatch middleware:\n// [\n//     'middleware_pipeline' => [\n//         /* ... */\n//         'routing' => [\n//             'middleware' => [\n//                 Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n//                 UrlHelperMiddleware::class\n//                 Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n//             ],\n//             'priority' => 1,\n//         ],\n//         /* ... */\n//     ],\n// ]  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n        ['middleware' => UrlHelperMiddleware::class],\n        Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n    ],\n];\n\n// OR:\nreturn [\n    'dependencies' => [\n        'factories' => [\n            UrlHelper::class => UrlHelperFactory::class,\n            UrlHelperMiddleware::class => UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n    ],\n];",
            "title": "Registering the pipeline middleware"
        },
        {
            "location": "/v1/features/helpers/url-helper/#skeleton-configures-helpers",
            "text": "If you started your project using the Expressive skeleton package, the UrlHelper  and  UrlHelperMiddleware  factories are already registered for\nyou, as is the  UrlHelperMiddleware  pipeline middleware.",
            "title": "Skeleton configures helpers"
        },
        {
            "location": "/v1/features/helpers/url-helper/#using-the-helper-in-middleware",
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response->withHeader(\n            'Link',\n            $this->helper->generate('resource', ['id' => 'sha1'])\n        );\n        return $next($request, $response);\n    }\n}",
            "title": "Using the helper in middleware"
        },
        {
            "location": "/v1/features/helpers/url-helper/#base-path-support",
            "text": "If your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the  base path , and thus be invalid. To\naccommodate this, the  UrlHelper  supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.  As an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the  UrlHelper  with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:  use Locale;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $uri = $request->getUri();\n        $path = $uri->getPath();\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $next($request, $response);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $next(\n            $request->withUri(\n                $uri->withPath(substr($path, (strlen($locale) + 1)))\n            ),\n            $response\n        );\n    }\n}  (Note: if the base path injected is not prefixed with  / , the helper will add\nthe slash.)  Paths generated by the  UriHelper  from this point forward will have the\ndetected language prefix.",
            "title": "Base Path support"
        },
        {
            "location": "/v1/features/helpers/server-url-helper/",
            "text": "ServerUrlHelper\n\n\nZend\\Expressive\\Helper\\ServerUrlHelper\n provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent \nPsr\\Http\\Message\\UriInterface\n instance provided to it in order to\ngenerate a fully qualified URI.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper->generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');\n\n\n\nThe helper is particularly useful when used in conjunction with the\n\nUrlHelper\n, as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:\n\n\n$url = $serverUrl($url('resource', ['id' => 'sha1']));\n\n\n\nThe signature for the ServerUrlHelper \ngenerate()\n and \n__invoke()\n methods is:\n\n\nfunction ($path = null) : string\n\n\n\nWhere:\n\n\n\n\n$path\n, when provided, can be a string path to use to generate a URI.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to inject it with the current\n\nUriInterface\n from the request instance. To automate this, we provide\n\nZend\\Expressive\\Helper\\ServerUrlMiddleware\n, which composes a \nServerUrl\n\ninstance, and, when invoked, injects it with the URI instance.\n\n\nAs such, you will need to:\n\n\n\n\nRegister the \nServerUrlHelper\n as a service in your container.\n\n\nRegister the \nServerUrlMiddleware\n as a service in your container.\n\n\nRegister the \nServerUrlMiddleware\n as pipeline middleware, anytime\n  before the routing middleware.\n\n\n\n\nThe following examples demonstrate registering the services.\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory;\n\n// zend-servicemanager:\n$services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class);\n$services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class);\n\n// Pimple:\n$pimple[ServerUrlHelper::class] = function ($container) {\n    return new ServerUrlHelper();\n};\n$pimple[ServerUrlMiddleware::class] = function ($container) {\n    $factory = new ServerUrlMiddlewareFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class));\n$container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class));\n$container->set(\n    ServerUrlMiddleware::class,\n    $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container)\n);\n\n\n\nTo register the \nServerUrlMiddleware\n as pipeline middleware anytime before the\nrouting middleware:\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n//         /* ... */\n//     ],\n// ]\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            ServerUrlHelper::class => ServerUrlHelper::class,\n        ],\n        'factories' => [\n            ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n        /* ... */\n    ],\n];\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nServerUrlHelper\n and \nServerUrlMiddleware\n factories are already registered\nfor you, as is the \nServerUrlMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response->withHeader(\n            'Link',\n            $this->helper->generate() . '; rel=\"self\"'\n        );\n        return $next($request, $response);\n    }\n}",
            "title": "ServerUrlHelper"
        },
        {
            "location": "/v1/features/helpers/server-url-helper/#serverurlhelper",
            "text": "Zend\\Expressive\\Helper\\ServerUrlHelper  provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent  Psr\\Http\\Message\\UriInterface  instance provided to it in order to\ngenerate a fully qualified URI.",
            "title": "ServerUrlHelper"
        },
        {
            "location": "/v1/features/helpers/server-url-helper/#usage",
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper->generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');  The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:  $url = $serverUrl($url('resource', ['id' => 'sha1']));  The signature for the ServerUrlHelper  generate()  and  __invoke()  methods is:  function ($path = null) : string  Where:   $path , when provided, can be a string path to use to generate a URI.",
            "title": "Usage"
        },
        {
            "location": "/v1/features/helpers/server-url-helper/#creating-an-instance",
            "text": "In order to use the helper, you will need to inject it with the current UriInterface  from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a  ServerUrl \ninstance, and, when invoked, injects it with the URI instance.  As such, you will need to:   Register the  ServerUrlHelper  as a service in your container.  Register the  ServerUrlMiddleware  as a service in your container.  Register the  ServerUrlMiddleware  as pipeline middleware, anytime\n  before the routing middleware.   The following examples demonstrate registering the services.  use Zend\\Expressive\\Helper\\ServerUrlHelper;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory;\n\n// zend-servicemanager:\n$services->setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class);\n$services->setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class);\n\n// Pimple:\n$pimple[ServerUrlHelper::class] = function ($container) {\n    return new ServerUrlHelper();\n};\n$pimple[ServerUrlMiddleware::class] = function ($container) {\n    $factory = new ServerUrlMiddlewareFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container->set(ServerUrlHelper::class, $container->lazyNew(ServerUrlHelper::class));\n$container->set(ServerUrlMiddlewareFactory::class, $container->lazyNew(ServerUrlMiddlewareFactory::class));\n$container->set(\n    ServerUrlMiddleware::class,\n    $container->lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container)\n);  To register the  ServerUrlMiddleware  as pipeline middleware anytime before the\nrouting middleware:  use Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app->pipe(ServerUrlMiddleware::class);\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' => [\n//         ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n//         /* ... */\n//     ],\n// ]  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return [\n    'dependencies' => [\n        'invokables' => [\n            ServerUrlHelper::class => ServerUrlHelper::class,\n        ],\n        'factories' => [\n            ServerUrlMiddleware::class => ServerUrlMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => ServerUrlMiddleware::class, 'priority' => PHP_INT_MAX],\n        /* ... */\n    ],\n];",
            "title": "Creating an instance"
        },
        {
            "location": "/v1/features/helpers/server-url-helper/#skeleton-configures-helpers",
            "text": "If you started your project using the Expressive skeleton package, the ServerUrlHelper  and  ServerUrlMiddleware  factories are already registered\nfor you, as is the  ServerUrlMiddleware  pipeline middleware.",
            "title": "Skeleton configures helpers"
        },
        {
            "location": "/v1/features/helpers/server-url-helper/#using-the-helper-in-middleware",
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response->withHeader(\n            'Link',\n            $this->helper->generate() . '; rel=\"self\"'\n        );\n        return $next($request, $response);\n    }\n}",
            "title": "Using the helper in middleware"
        },
        {
            "location": "/v1/features/helpers/body-parse/",
            "text": "Body Parsing Middleware\n\n\nZend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware\n provides generic PSR-7\nmiddleware for parsing the request body into parameters, and returning a new\nrequest instance that composes them. The subcomponent provides a strategy\npattern around matching the request \nContent-Type\n, and then parsing it, giving\nyou a flexible approach that can grow with your accepted content types.\n\n\nBy default, this middleware will detect the following content types:\n\n\n\n\napplication/x-www-form-urlencoded\n (standard web-based forms, without file\n  uploads)\n\n\napplication/json\n, \napplication/*+json\n (JSON payloads)\n\n\n\n\nRegistering the middleware\n\n\nYou can register it manually:\n\n\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\n$app->pipe(BodyParamsMiddleware::class);\n\n// register other middleware\n// register routing middleware\n$app->run();\n\n\n\nor as pipeline middleware:\n\n\n// config/autoload/middleware-pipeline.global.php\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'middleware_pipeline' => [\n        [ 'middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nAnother option is to incorporate it in route-specific middleware queues:\n\n\n// config/autoload/routes.global.php\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'routes' => [\n        [\n            'name' => 'contact:process',\n            'path' => '/contact/process',\n            'middleware' => [\n                BodyParamsMiddleware::class,\n                Contact\\Process::class,\n            ],\n            'allowed_methods' => ['POST'],\n        ]\n    ],\n];\n\n\n\nThis latter approach has a slight advantage: the middleware will only execute\nfor routes that require the processing. While the middleware has some checks to\nensure it only triggers for HTTP methods that accept bodies, those checks are\nstill overhead that you might want to avoid; the above strategy of using the\nmiddleware only with specific routes can accomplish that.\n\n\nStrategies\n\n\nIf you want to intercept and parse other payload types, you can add \nstrategies\n\nto the middleware. Strategies implement \nZend\\Expressive\\Helper\\BodyParams\\StrategyInterface\n:\n\n\nnamespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     *\n     * @param string $contentType\n     * @return bool Whether or not the strategy matches.\n     */\n    public function match($contentType);\n\n    /**\n     * Parse the body content and return a new response.\n     *\n     * @param ServerRequestInterface $request\n     * @return ServerRequestInterface\n     */\n    public function parse(ServerRequestInterface $request);\n}\n\n\n\nYou then register them with the middleware using the \naddStrategy()\n method:\n\n\n$bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n\n\n\nTo automate the registration, we recommend writing a factory for the\n\nBodyParamsMiddleware\n, and replacing the \ninvokables\n registration with a\nregistration in the \nfactories\n section of the \nmiddleware-pipeline.config.php\n\nfile:\n\n\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nRemoving the default strategies\n\n\nBy default, \nBodyParamsMiddleware\n composes the following strategies:\n\n\n\n\nZend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy\n\n\nZend\\Expressive\\Helper\\BodyParams\\JsonStrategy\n\n\n\n\nThese provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \u2014\n\napplication/x-www-form-urlencoded\n \u2014 matches first, as the middleware\ndelegates parsing to the first match.\n\n\nIf you do not want to use these default strategies, you can clear them from the\nmiddleware using \nclearStrategies()\n:\n\n\n$bodyParamsMiddleware->clearStrategies();\n\n\n\nNote: if you do this, \nall\n strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.",
            "title": "Body Parsing Middleware"
        },
        {
            "location": "/v1/features/helpers/body-parse/#body-parsing-middleware",
            "text": "Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware  provides generic PSR-7\nmiddleware for parsing the request body into parameters, and returning a new\nrequest instance that composes them. The subcomponent provides a strategy\npattern around matching the request  Content-Type , and then parsing it, giving\nyou a flexible approach that can grow with your accepted content types.  By default, this middleware will detect the following content types:   application/x-www-form-urlencoded  (standard web-based forms, without file\n  uploads)  application/json ,  application/*+json  (JSON payloads)",
            "title": "Body Parsing Middleware"
        },
        {
            "location": "/v1/features/helpers/body-parse/#registering-the-middleware",
            "text": "You can register it manually:  use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\n$app->pipe(BodyParamsMiddleware::class);\n\n// register other middleware\n// register routing middleware\n$app->run();  or as pipeline middleware:  // config/autoload/middleware-pipeline.global.php\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'middleware_pipeline' => [\n        [ 'middleware' => Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' => 100],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];  Another option is to incorporate it in route-specific middleware queues:  // config/autoload/routes.global.php\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            /* ... */\n        ],\n    ],\n    'routes' => [\n        [\n            'name' => 'contact:process',\n            'path' => '/contact/process',\n            'middleware' => [\n                BodyParamsMiddleware::class,\n                Contact\\Process::class,\n            ],\n            'allowed_methods' => ['POST'],\n        ]\n    ],\n];  This latter approach has a slight advantage: the middleware will only execute\nfor routes that require the processing. While the middleware has some checks to\nensure it only triggers for HTTP methods that accept bodies, those checks are\nstill overhead that you might want to avoid; the above strategy of using the\nmiddleware only with specific routes can accomplish that.",
            "title": "Registering the middleware"
        },
        {
            "location": "/v1/features/helpers/body-parse/#strategies",
            "text": "If you want to intercept and parse other payload types, you can add  strategies \nto the middleware. Strategies implement  Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface :  namespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     *\n     * @param string $contentType\n     * @return bool Whether or not the strategy matches.\n     */\n    public function match($contentType);\n\n    /**\n     * Parse the body content and return a new response.\n     *\n     * @param ServerRequestInterface $request\n     * @return ServerRequestInterface\n     */\n    public function parse(ServerRequestInterface $request);\n}  You then register them with the middleware using the  addStrategy()  method:  $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());  To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the  invokables  registration with a\nregistration in the  factories  section of the  middleware-pipeline.config.php \nfile:  use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams->addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' => [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class => MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];",
            "title": "Strategies"
        },
        {
            "location": "/v1/features/helpers/body-parse/#removing-the-default-strategies",
            "text": "By default,  BodyParamsMiddleware  composes the following strategies:   Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy  Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy   These provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \u2014 application/x-www-form-urlencoded  \u2014 matches first, as the middleware\ndelegates parsing to the first match.  If you do not want to use these default strategies, you can clear them from the\nmiddleware using  clearStrategies() :  $bodyParamsMiddleware->clearStrategies();  Note: if you do this,  all  strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.",
            "title": "Removing the default strategies"
        },
        {
            "location": "/v1/features/emitters/",
            "text": "Emitters\n\n\nTo simplify the usage of Expressive, we added the \nrun()\n method, which handles\nthe incoming request, and emits a response.\n\n\nThe latter aspect, emitting the response, is the responsibility of an\n\nemitter\n.\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.\n\n\nDiactoros defines an \nEmitterInterface\n, and \u2014 as of the time we write this \u2014 a\nsingle emitter implementation, \nZend\\Diactoros\\Response\\SapiEmitter\n, which\nsends headers and output using PHP's standard SAPI mechanisms (the \nheader()\n\nmethod and the output buffer).\n\n\nWe recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use \nReact\n, the SAPI\nemitter will likely not work for you.\n\n\nTo facilitate alternate emitters, we offer two facilities:\n\n\n\n\nFirst, \nApplication\n composes an emitter, and you can specify an alternate\n  emitter during instantiation, or via the \nZend\\Diactoros\\Response\\EmitterInterface\n\n  service when using the container factory.\n\n\nSecond, we provide \nZend\\Expressive\\Emitter\\EmitterStack\n, which allows you to\n  compose multiple emitter strategies; the first to return a value other than\n  boolean \nfalse\n will cause execution of the stack to short-circuit.\n  \nApplication\n composes an \nEmitterStack\n by default, with an \nSapiEmitter\n\n  composed at the bottom of the stack.\n\n\n\n\nEmitterStack\n\n\nThe \nEmitterStack\n is an \nSplStack\n extension that implements\n\nEmitterInterface\n. You can add emitters to the stack by pushing them on:\n\n\n$stack->push($emitterInstance);\n\n\n\nAs a stack, execution is in LIFO (last in, first out) order; the first emitter\non the stack will be evaluated last.",
            "title": "Emitters"
        },
        {
            "location": "/v1/features/emitters/#emitters",
            "text": "To simplify the usage of Expressive, we added the  run()  method, which handles\nthe incoming request, and emits a response.  The latter aspect, emitting the response, is the responsibility of an emitter .\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.  Diactoros defines an  EmitterInterface , and \u2014 as of the time we write this \u2014 a\nsingle emitter implementation,  Zend\\Diactoros\\Response\\SapiEmitter , which\nsends headers and output using PHP's standard SAPI mechanisms (the  header() \nmethod and the output buffer).  We recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use  React , the SAPI\nemitter will likely not work for you.  To facilitate alternate emitters, we offer two facilities:   First,  Application  composes an emitter, and you can specify an alternate\n  emitter during instantiation, or via the  Zend\\Diactoros\\Response\\EmitterInterface \n  service when using the container factory.  Second, we provide  Zend\\Expressive\\Emitter\\EmitterStack , which allows you to\n  compose multiple emitter strategies; the first to return a value other than\n  boolean  false  will cause execution of the stack to short-circuit.\n   Application  composes an  EmitterStack  by default, with an  SapiEmitter \n  composed at the bottom of the stack.",
            "title": "Emitters"
        },
        {
            "location": "/v1/features/emitters/#emitterstack",
            "text": "The  EmitterStack  is an  SplStack  extension that implements EmitterInterface . You can add emitters to the stack by pushing them on:  $stack->push($emitterInstance);  As a stack, execution is in LIFO (last in, first out) order; the first emitter\non the stack will be evaluated last.",
            "title": "EmitterStack"
        },
        {
            "location": "/v1/cookbook/common-prefix-for-routes/",
            "text": "How can I prepend a common path to all my routes?\n\n\nYou may have multiple middlewares providing their own functionality:\n\n\n$middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$app = AppFactory::create();\n$app->pipe($middleware1);\n$app->pipe($middleware2);\n\n$app->run();\n\n\n\nLet's assume the above represents an API.\n\n\nAs your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path \n/api\n.\n\n\nThis is essentially the same problem as addressed in the\n\n\"Segregating your application to a subpath\"\n example.\n\n\nTo accomplish it:\n\n\n\n\nCreate a new application.\n\n\nPipe the previous application to the new one, under the path \n/api\n.\n\n\n\n\n$middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$api = AppFactory::create();\n$api->pipe($middleware1);\n$api->pipe($middleware2);\n\n$app = AppFactory::create();\n$app->pipe('/api', $api);\n\n$app->run();\n\n\n\nThe above works, because every \nApplication\n instance is itself middleware, and, more specifically,\nan instance of \nStratigility's \nMiddlewarePipe\n,\nwhich provides the ability to compose middleware.",
            "title": "Prepending a common path to all routes"
        },
        {
            "location": "/v1/cookbook/common-prefix-for-routes/#how-can-i-prepend-a-common-path-to-all-my-routes",
            "text": "You may have multiple middlewares providing their own functionality:  $middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$app = AppFactory::create();\n$app->pipe($middleware1);\n$app->pipe($middleware2);\n\n$app->run();  Let's assume the above represents an API.  As your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path  /api .  This is essentially the same problem as addressed in the \"Segregating your application to a subpath\"  example.  To accomplish it:   Create a new application.  Pipe the previous application to the new one, under the path  /api .   $middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$api = AppFactory::create();\n$api->pipe($middleware1);\n$api->pipe($middleware2);\n\n$app = AppFactory::create();\n$app->pipe('/api', $api);\n\n$app->run();  The above works, because every  Application  instance is itself middleware, and, more specifically,\nan instance of  Stratigility's  MiddlewarePipe ,\nwhich provides the ability to compose middleware.",
            "title": "How can I prepend a common path to all my routes?"
        },
        {
            "location": "/v1/cookbook/route-specific-pipeline/",
            "text": "How can I specify a route-specific middleware pipeline?\n\n\nSometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:\n\n\n\n\ncheck for authentication credentials\n\n\ncheck for authorization for the selected action\n\n\nparse the incoming body\n\n\nvalidate the parsed body parameters\n\n\n\n\nbefore\n you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.\n\n\nYou can accomplish this in one of two ways:\n\n\n\n\nHave your middleware service resolve to a \nMiddlewarePipe\n instance that\n  composes the various middlewares.\n\n\nSpecify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a \nMiddlewarePipe\n.\n\n\n\n\nResolving to a MiddlewarePipe\n\n\nYou can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($container->get('ApiResource'));\n\n        return $pipeline;\n    }\n}\n\n\n\nThis gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.\n\n\nOne alternative when using zend-servicemanager is to use a \ndelegator factory\n.\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($callback());\n\n        return $pipeline;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}\n\n\n\nWhen configuring the container, you'd do something like the following:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            'AuthenticationMiddleware' => '...',\n            'AuthorizationMiddleware' => '...',\n            'BodyParsingMiddleware' => '...',\n            'ValidationMiddleware' => '...',\n            'ApiResourceMiddleware' => '...',\n        ],\n        'delegators' => [\n            'ApiResourceMiddleware' => [\n                'ApiResourcePipelineDelegatorFactory',\n            ],\n        ],\n    ],\n];\n\n\n\nThis approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.\n\n\nMiddleware Arrays\n\n\nIf you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares in your configuration or when routing manually.\n\n\nVia configuration looks like this:\n\n\nreturn [\n    'routes' => [\n        [\n            'name' => 'api-resource',\n            'path' => '/api/resource[/{id:[a-f0-9]{32}}]',\n            'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'],\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n                'ApiResourceMiddleware',\n            ],\n        ],\n    ],\n];\n\n\n\nManual routing looks like this:\n\n\n$app->route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    'AuthenticationMiddleware',\n    'AuthorizationMiddleware',\n    'BodyParsingMiddleware',\n    'ValidationMiddleware',\n    'ApiResourceMiddleware',\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');\n\n\n\nWhen either of these approaches are used, the individual middleware listed\n\nMUST\n be one of the following:\n\n\n\n\na callable middleware;\n\n\na service name of middleware available in the container;\n\n\na fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.\n\n\n\n\nThis approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.\n\n\nWhat about pipeline middleware configuration?\n\n\nWhat if you want to do this with your pipeline middleware configuration? The\nanswer is that the syntax is exactly the same!\n\n\nreturn [\n    'middleware_pipeline' => [\n        'api' => [\n            'path' => '/api',\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n            ],\n            'priority' => 100,\n        ],\n    ],\n];",
            "title": "Route-specific middleware pipelines"
        },
        {
            "location": "/v1/cookbook/route-specific-pipeline/#how-can-i-specify-a-route-specific-middleware-pipeline",
            "text": "Sometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:   check for authentication credentials  check for authorization for the selected action  parse the incoming body  validate the parsed body parameters   before  you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.  You can accomplish this in one of two ways:   Have your middleware service resolve to a  MiddlewarePipe  instance that\n  composes the various middlewares.  Specify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a  MiddlewarePipe .",
            "title": "How can I specify a route-specific middleware pipeline?"
        },
        {
            "location": "/v1/cookbook/route-specific-pipeline/#resolving-to-a-middlewarepipe",
            "text": "You can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.  use Interop\\Container\\ContainerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($container->get('ApiResource'));\n\n        return $pipeline;\n    }\n}  This gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.  One alternative when using zend-servicemanager is to use a  delegator factory .\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:  use Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory implements DelegatorFactoryInterface\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline->pipe($container->get('AuthenticationMiddleware'));\n        $pipeline->pipe($container->get('AuthorizationMiddleware'));\n        $pipeline->pipe($container->get('BodyParsingMiddleware'));\n        $pipeline->pipe($container->get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline->pipe($callback());\n\n        return $pipeline;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}  When configuring the container, you'd do something like the following:  return [\n    'dependencies' => [\n        'factories' => [\n            'AuthenticationMiddleware' => '...',\n            'AuthorizationMiddleware' => '...',\n            'BodyParsingMiddleware' => '...',\n            'ValidationMiddleware' => '...',\n            'ApiResourceMiddleware' => '...',\n        ],\n        'delegators' => [\n            'ApiResourceMiddleware' => [\n                'ApiResourcePipelineDelegatorFactory',\n            ],\n        ],\n    ],\n];  This approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.",
            "title": "Resolving to a MiddlewarePipe"
        },
        {
            "location": "/v1/cookbook/route-specific-pipeline/#middleware-arrays",
            "text": "If you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares in your configuration or when routing manually.  Via configuration looks like this:  return [\n    'routes' => [\n        [\n            'name' => 'api-resource',\n            'path' => '/api/resource[/{id:[a-f0-9]{32}}]',\n            'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'],\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n                'ApiResourceMiddleware',\n            ],\n        ],\n    ],\n];  Manual routing looks like this:  $app->route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    'AuthenticationMiddleware',\n    'AuthorizationMiddleware',\n    'BodyParsingMiddleware',\n    'ValidationMiddleware',\n    'ApiResourceMiddleware',\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');  When either of these approaches are used, the individual middleware listed MUST  be one of the following:   a callable middleware;  a service name of middleware available in the container;  a fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.   This approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.",
            "title": "Middleware Arrays"
        },
        {
            "location": "/v1/cookbook/route-specific-pipeline/#what-about-pipeline-middleware-configuration",
            "text": "What if you want to do this with your pipeline middleware configuration? The\nanswer is that the syntax is exactly the same!  return [\n    'middleware_pipeline' => [\n        'api' => [\n            'path' => '/api',\n            'middleware' => [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n            ],\n            'priority' => 100,\n        ],\n    ],\n];",
            "title": "What about pipeline middleware configuration?"
        },
        {
            "location": "/v1/cookbook/custom-404-page-handling/",
            "text": "How can I set custom 404 page handling?\n\n\nIn some cases, you may want to handle 404 errors separately from the\n\nfinal handler\n. This can be done by registering\nmiddleware that operates late \u2014 specifically, after the routing\nmiddleware. Such middleware will be executed if no other middleware has\nexecuted, and/or when all other middleware calls \nreturn $next()\n\nwithout returning a response. Such situations typically mean that no middleware\nwas able to complete the request.\n\n\nYour 404 handler can take one of two approaches:\n\n\n\n\nIt can set the response status and call \n$next()\n with an error condition. In\n  such a case, the final handler \nwill\n likely be executed, but will have an\n  explicit 404 status to work with.\n\n\nIt can create and return a 404 response itself.\n\n\n\n\nCalling next with an error condition\n\n\nIn the first approach, the \nNotFound\n middleware can be as simple as this:\n\n\nnamespace Application;\n\nclass NotFound\n{\n    public function __invoke($req, $res, $next)\n    {\n        // Other things can be done here; e.g., logging\n        return $next($req, $res->withStatus(404), 'Page Not Found');\n    }\n}\n\n\n\nThis example uses the third, optional argument to \n$next()\n, which is an error\ncondition. Internally, the final handler will typically see this, and return an\nerror page of some sort. Since we set the response status, and it's an error\nstatus code, that status code will be used in the generated response.\n\n\nThe \nTemplatedErrorHandler\n will use the error template in this particular case,\nso you will likely need to make some accommodations for 404 responses in that\ntemplate if you choose this approach.\n\n\n404 Middleware\n\n\nIn the second approach, the \nNotFound\n middleware will return a full response.\nIn our example here, we will render a specific template, and use this to seed\nand return a response.\n\n\nnamespace Application;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass NotFound\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function __invoke($req, $res, $next)\n    {\n        // other things can be done here; e.g., logging\n        // Now set the response status and write to the body\n        $response = $res->withStatus(404);\n        $response->getBody()->write($this->renderer->render('error::not-found'));\n        return $response;\n    }\n}\n\n\n\nThis approach allows you to have an application-specific workflow for 404 errors\nthat does not rely on the final handler.\n\n\nRegistering custom 404 handlers\n\n\nWe can register either \nApplication\\NotFound\n class above as service in the\n\nservice container\n. In the case of the second approach,\nyou would also need to provide a factory for creating the middleware (to ensure\nyou inject the template renderer).\n\n\nFrom there, you still need to register the middleware. This middleware is not\nrouted, and thus needs to be piped to the application instance. You can do this\nvia either configuration, or manually.\n\n\nTo do this via configuration, add an entry under the \nmiddleware_pipeline\n\nconfiguration, after the dispatch middleware:\n\n\n'middleware_pipeline' => [\n    /* ... */\n    'routing' => [\n        'middleware' => [\n            Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n            Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n            Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        ],\n        'priority' => 1,\n    ],\n    [\n        'middleware' => 'Application\\NotFound',\n        'priority' => -1,\n    ],\n    /* ... */\n],\n\n\n\nThe above example assumes you are using the \nApplicationFactory\n and/or the\nExpressive skeleton to manage your application instantiation and configuration.\n\n\nTo manually add the middleware, you will need to pipe it to the application\ninstance:\n\n\n$app->pipe($container->get('Application\\NotFound'));\n\n\n\nThis must be done \nafter\n:\n\n\n\n\ncalling \n$app->pipeDispatchMiddleware()\n, \nOR\n\n\npulling the \nApplication\n instance from the service container (assuming you\n  used the \nApplicationFactory\n).\n\n\n\n\nThis is to ensure that the \nNotFound\n middleware executes \nafter\n any routed\nmiddleware, as you only want it to execute if no routed middleware was selected.",
            "title": "Setting custom 404 page handling"
        },
        {
            "location": "/v1/cookbook/custom-404-page-handling/#how-can-i-set-custom-404-page-handling",
            "text": "In some cases, you may want to handle 404 errors separately from the final handler . This can be done by registering\nmiddleware that operates late \u2014 specifically, after the routing\nmiddleware. Such middleware will be executed if no other middleware has\nexecuted, and/or when all other middleware calls  return $next() \nwithout returning a response. Such situations typically mean that no middleware\nwas able to complete the request.  Your 404 handler can take one of two approaches:   It can set the response status and call  $next()  with an error condition. In\n  such a case, the final handler  will  likely be executed, but will have an\n  explicit 404 status to work with.  It can create and return a 404 response itself.",
            "title": "How can I set custom 404 page handling?"
        },
        {
            "location": "/v1/cookbook/custom-404-page-handling/#calling-next-with-an-error-condition",
            "text": "In the first approach, the  NotFound  middleware can be as simple as this:  namespace Application;\n\nclass NotFound\n{\n    public function __invoke($req, $res, $next)\n    {\n        // Other things can be done here; e.g., logging\n        return $next($req, $res->withStatus(404), 'Page Not Found');\n    }\n}  This example uses the third, optional argument to  $next() , which is an error\ncondition. Internally, the final handler will typically see this, and return an\nerror page of some sort. Since we set the response status, and it's an error\nstatus code, that status code will be used in the generated response.  The  TemplatedErrorHandler  will use the error template in this particular case,\nso you will likely need to make some accommodations for 404 responses in that\ntemplate if you choose this approach.",
            "title": "Calling next with an error condition"
        },
        {
            "location": "/v1/cookbook/custom-404-page-handling/#404-middleware",
            "text": "In the second approach, the  NotFound  middleware will return a full response.\nIn our example here, we will render a specific template, and use this to seed\nand return a response.  namespace Application;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass NotFound\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this->renderer = $renderer;\n    }\n\n    public function __invoke($req, $res, $next)\n    {\n        // other things can be done here; e.g., logging\n        // Now set the response status and write to the body\n        $response = $res->withStatus(404);\n        $response->getBody()->write($this->renderer->render('error::not-found'));\n        return $response;\n    }\n}  This approach allows you to have an application-specific workflow for 404 errors\nthat does not rely on the final handler.",
            "title": "404 Middleware"
        },
        {
            "location": "/v1/cookbook/custom-404-page-handling/#registering-custom-404-handlers",
            "text": "We can register either  Application\\NotFound  class above as service in the service container . In the case of the second approach,\nyou would also need to provide a factory for creating the middleware (to ensure\nyou inject the template renderer).  From there, you still need to register the middleware. This middleware is not\nrouted, and thus needs to be piped to the application instance. You can do this\nvia either configuration, or manually.  To do this via configuration, add an entry under the  middleware_pipeline \nconfiguration, after the dispatch middleware:  'middleware_pipeline' => [\n    /* ... */\n    'routing' => [\n        'middleware' => [\n            Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n            Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n            Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        ],\n        'priority' => 1,\n    ],\n    [\n        'middleware' => 'Application\\NotFound',\n        'priority' => -1,\n    ],\n    /* ... */\n],  The above example assumes you are using the  ApplicationFactory  and/or the\nExpressive skeleton to manage your application instantiation and configuration.  To manually add the middleware, you will need to pipe it to the application\ninstance:  $app->pipe($container->get('Application\\NotFound'));  This must be done  after :   calling  $app->pipeDispatchMiddleware() ,  OR  pulling the  Application  instance from the service container (assuming you\n  used the  ApplicationFactory ).   This is to ensure that the  NotFound  middleware executes  after  any routed\nmiddleware, as you only want it to execute if no routed middleware was selected.",
            "title": "Registering custom 404 handlers"
        },
        {
            "location": "/v1/cookbook/using-custom-view-helpers/",
            "text": "How do you register custom view helpers when using zend-view?\n\n\nIf you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?\n\n\nAssuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for \nZend\\View\\HelperPluginManager\n, and it will\nbe injected into the \nPhpRenderer\n instance used. Since the \nHelperPluginManager\n\nis available, we can configure it.\n\n\nOpen the file \nconfig/autoload/templates.global.php\n. In that file, you'll see\nthree top-level keys:\n\n\nreturn [\n    'dependencies' => [ /* ... */ ],\n    'templates' => [ /* ... */ ],\n    'view_helpers' => [ /* ... */ ],\n];\n\n\n\nThe last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created.\n\nSee the zend-view custom helpers documentation\n\nfor information on how to populate this configuration.",
            "title": "Registering custom view helpers when using zend-view"
        },
        {
            "location": "/v1/cookbook/using-custom-view-helpers/#how-do-you-register-custom-view-helpers-when-using-zend-view",
            "text": "If you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?  Assuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for  Zend\\View\\HelperPluginManager , and it will\nbe injected into the  PhpRenderer  instance used. Since the  HelperPluginManager \nis available, we can configure it.  Open the file  config/autoload/templates.global.php . In that file, you'll see\nthree top-level keys:  return [\n    'dependencies' => [ /* ... */ ],\n    'templates' => [ /* ... */ ],\n    'view_helpers' => [ /* ... */ ],\n];  The last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created. See the zend-view custom helpers documentation \nfor information on how to populate this configuration.",
            "title": "How do you register custom view helpers when using zend-view?"
        },
        {
            "location": "/v1/cookbook/using-zend-form-view-helpers/",
            "text": "How can I use zend-form view helpers?\n\n\nIf you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:\n\n\n\n\nzend-form\n\n\nzend-i18n\n\n\nzend-navigation\n\n\n\n\nBy default, only the view helpers directly available in zend-view are available;\nhow can you add the others?\n\n\nTo add the zend-form view helpers create a file \nconfig/autoload/zend-form.global.php\n\nwith the contents:\n\n\n<?php\nuse Zend\\Form\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();\n\n\n\nand that will essentially do everything needed.\n\n\nIf you installed Expressive via the skeleton, the service\n\nZend\\View\\HelperPluginManager\n is registered for you, and represents the helper\nplugin manager injected into the \nPhpRenderer\n instance. As such, you only need\nto configure this. The question is: where?\n\n\nYou have three options:\n\n\n\n\nReplace the \nHelperPluginManager\n factory with your own; or\n\n\nAdd a delegator factory to or extend the \nHelperPluginManager\n service to\n  inject the additional helper configuration; or\n\n\nAdd pipeline middleware that composes the \nHelperPluginManager\n and configures\n  it.\n\n\n\n\nReplacing the HelperPluginManager factory\n\n\nThe zend-view integration provides \nZend\\Expressive\\ZendView\\HelperPluginManagerFactory\n,\nand the Expressive skeleton registers it be default. The simplest solution for\nadding other helpers is to replace it with your own. In your own factory, you\nwill \nalso\n configure the plugin manager with the configuration from the\nzend-form component (or whichever other components you wish to use).\n\n\nnamespace Your\\Application;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\View\\HelperPluginManager;\n\nclass HelperPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $manager = new HelperPluginManager($container);\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = isset($config['view_helpers']) ? $config['view_helpers'] : [];\n        (new Config($config))->configureServiceManager($manager);\n\n        return $manager;\n    }\n}\n\n\n\nIn your \nconfig/autoload/templates.global.php\n file, change the line that reads:\n\n\nZend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class,\n\n\n\nto instead read as:\n\n\nZend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class,\n\n\n\nThis approach will work for any of the various containers supported.\n\n\nDelegator factories/service extension\n\n\nDelegator factories\n\nand \nservice extension\n\noperate on the same principle: they intercept after the original factory was\ncalled, and then operate on the generated instance, either modifying or\nreplacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the\ntime of writing, we're unaware of a mechanism for doing so in Aura.Di.\n\n\nzend-servicemanager\n\n\nYou'll first need to create a delegator factory:\n\n\nnamespace Your\\Application;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FormHelpersDelegatorFactory\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $helpers = $callback();\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = new Config($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}\n\n\n\nThe above creates an instance of \nZend\\ServiceManager\\Config\n, uses it to\nconfigure the already created \nZend\\View\\HelperPluginManager\n instance, and then\nreturns the plugin manager instance.\n\n\nFrom here, you'll add a \ndelegators\n configuration key in your\n\nconfig/autoload/templates.global.php\n file:\n\n\nreturn [\n    'dependencies' => [\n        'delegators' => [\n            Zend\\View\\HelperPluginManager::class => [\n                Your\\Application\\FormHelpersDelegatorFactory::class,\n            ],\n        ],\n        /* ... */\n    ],\n    'templates' => [\n        /* ... */\n    ],\n    'view_helpers' => [\n        /* ... */\n    ],\n];\n\n\n\nNote: delegator factories are keyed by the service they modify, and the value is\nan \narray\n of delegator factories, to allow multiple such factories to be in\nuse.\n\n\nPimple\n\n\nFor Pimple, we don't currently support configuration of service extensions, so\nyou'll need to edit the main container configuration file,\n\nconfig/container.php\n. Place the following anywhere after the factories and\ninvokables are defined:\n\n\n// The following assumes you've added the following import statements to\n// the start of the file:\n// use Zend\\ServiceManager\\Config as ServiceConfig;\n// use Zend\\View\\HelperPluginManager;\n$container[HelperPluginManager::class] = $container->extend(\n    HelperPluginManager::class,\n    function ($helpers, $container) {\n        $config = isset($container['config']) ? $container['config'] : [];\n        $config = new ServiceConfig($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n);\n\n\n\nPipeline middleware\n\n\nAnother option is to use pipeline middleware. This approach will\nrequire that the middleware execute on every request, which introduces (very\nslight) performance overhead. However, it's a portable method that works\nregardless of the container implementation you choose.\n\n\nFirst, define the middleware:\n\n\nnamespace Your\\Application\n\nuse Zend\\Form\\View\\HelperConfig as FormHelperConfig;\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddleware\n{\n    private $helpers;\n\n    public function __construct(HelperPluginManager $helpers)\n    {\n        $this->helpers = $helpers;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $config = new FormHelperConfig();\n        $config->configureServiceManager($this->helpers);\n        return $next($request, $response);\n    }\n}\n\n\n\nYou'll also need a factory for the middleware, to ensure it receives the\n\nHelperPluginManager\n:\n\n\nnamespace Your\\Application\n\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return new FormHelpersMiddleware(\n            $container->get(HelperPluginManager::class)\n        );\n    }\n}\n\n\n\nNow, register these in the file\n\nconfig/autoload/middleware-pipeline.global.php\n:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nAt that point, you're all set!\n\n\nRegistering more helpers\n\n\nWhat if you need to register helpers from multiple components?\n\n\nYou can do so using the same technique above. Better yet, do them all at once!\n\n\n\n\nIf you chose to use delegator factories/service extension, do all helper\n  configuration registrations for all components in the same factory.\n\n\nIf you chose to use middleware, do all helper configuration registrations for\n  all components in the same middleware.",
            "title": "Using zend-form view helpers"
        },
        {
            "location": "/v1/cookbook/using-zend-form-view-helpers/#how-can-i-use-zend-form-view-helpers",
            "text": "If you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:   zend-form  zend-i18n  zend-navigation   By default, only the view helpers directly available in zend-view are available;\nhow can you add the others?  To add the zend-form view helpers create a file  config/autoload/zend-form.global.php \nwith the contents:  <?php\nuse Zend\\Form\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();  and that will essentially do everything needed.  If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager  is registered for you, and represents the helper\nplugin manager injected into the  PhpRenderer  instance. As such, you only need\nto configure this. The question is: where?  You have three options:   Replace the  HelperPluginManager  factory with your own; or  Add a delegator factory to or extend the  HelperPluginManager  service to\n  inject the additional helper configuration; or  Add pipeline middleware that composes the  HelperPluginManager  and configures\n  it.",
            "title": "How can I use zend-form view helpers?"
        },
        {
            "location": "/v1/cookbook/using-zend-form-view-helpers/#replacing-the-helperpluginmanager-factory",
            "text": "The zend-view integration provides  Zend\\Expressive\\ZendView\\HelperPluginManagerFactory ,\nand the Expressive skeleton registers it be default. The simplest solution for\nadding other helpers is to replace it with your own. In your own factory, you\nwill  also  configure the plugin manager with the configuration from the\nzend-form component (or whichever other components you wish to use).  namespace Your\\Application;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\View\\HelperPluginManager;\n\nclass HelperPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $manager = new HelperPluginManager($container);\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = isset($config['view_helpers']) ? $config['view_helpers'] : [];\n        (new Config($config))->configureServiceManager($manager);\n\n        return $manager;\n    }\n}  In your  config/autoload/templates.global.php  file, change the line that reads:  Zend\\View\\HelperPluginManager::class => Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class,  to instead read as:  Zend\\View\\HelperPluginManager::class => Your\\Application\\HelperPluginManagerFactory::class,  This approach will work for any of the various containers supported.",
            "title": "Replacing the HelperPluginManager factory"
        },
        {
            "location": "/v1/cookbook/using-zend-form-view-helpers/#delegator-factoriesservice-extension",
            "text": "Delegator factories \nand  service extension \noperate on the same principle: they intercept after the original factory was\ncalled, and then operate on the generated instance, either modifying or\nreplacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the\ntime of writing, we're unaware of a mechanism for doing so in Aura.Di.",
            "title": "Delegator factories/service extension"
        },
        {
            "location": "/v1/cookbook/using-zend-form-view-helpers/#zend-servicemanager",
            "text": "You'll first need to create a delegator factory:  namespace Your\\Application;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FormHelpersDelegatorFactory\n{\n    /**\n     * zend-servicemanager v3 support\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $helpers = $callback();\n\n        $config = $container->has('config') ? $container->get('config') : [];\n        $config = new Config($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n\n    /**\n     * zend-servicemanager v2 support\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}  The above creates an instance of  Zend\\ServiceManager\\Config , uses it to\nconfigure the already created  Zend\\View\\HelperPluginManager  instance, and then\nreturns the plugin manager instance.  From here, you'll add a  delegators  configuration key in your config/autoload/templates.global.php  file:  return [\n    'dependencies' => [\n        'delegators' => [\n            Zend\\View\\HelperPluginManager::class => [\n                Your\\Application\\FormHelpersDelegatorFactory::class,\n            ],\n        ],\n        /* ... */\n    ],\n    'templates' => [\n        /* ... */\n    ],\n    'view_helpers' => [\n        /* ... */\n    ],\n];  Note: delegator factories are keyed by the service they modify, and the value is\nan  array  of delegator factories, to allow multiple such factories to be in\nuse.",
            "title": "zend-servicemanager"
        },
        {
            "location": "/v1/cookbook/using-zend-form-view-helpers/#pimple",
            "text": "For Pimple, we don't currently support configuration of service extensions, so\nyou'll need to edit the main container configuration file, config/container.php . Place the following anywhere after the factories and\ninvokables are defined:  // The following assumes you've added the following import statements to\n// the start of the file:\n// use Zend\\ServiceManager\\Config as ServiceConfig;\n// use Zend\\View\\HelperPluginManager;\n$container[HelperPluginManager::class] = $container->extend(\n    HelperPluginManager::class,\n    function ($helpers, $container) {\n        $config = isset($container['config']) ? $container['config'] : [];\n        $config = new ServiceConfig($config['view_helpers']);\n        $config->configureServiceManager($helpers);\n        return $helpers;\n    }\n);",
            "title": "Pimple"
        },
        {
            "location": "/v1/cookbook/using-zend-form-view-helpers/#pipeline-middleware",
            "text": "Another option is to use pipeline middleware. This approach will\nrequire that the middleware execute on every request, which introduces (very\nslight) performance overhead. However, it's a portable method that works\nregardless of the container implementation you choose.  First, define the middleware:  namespace Your\\Application\n\nuse Zend\\Form\\View\\HelperConfig as FormHelperConfig;\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddleware\n{\n    private $helpers;\n\n    public function __construct(HelperPluginManager $helpers)\n    {\n        $this->helpers = $helpers;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $config = new FormHelperConfig();\n        $config->configureServiceManager($this->helpers);\n        return $next($request, $response);\n    }\n}  You'll also need a factory for the middleware, to ensure it receives the HelperPluginManager :  namespace Your\\Application\n\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return new FormHelpersMiddleware(\n            $container->get(HelperPluginManager::class)\n        );\n    }\n}  Now, register these in the file config/autoload/middleware-pipeline.global.php :  return [\n    'dependencies' => [\n        'factories' => [\n            Your\\Application\\FormHelpersMiddleware::class => Your\\Application\\FormHelpersMiddlewareFactory::class\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        ['middleware' => Your\\Application\\FormHelpersMiddleware::class, 'priority' => 1000],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];  At that point, you're all set!",
            "title": "Pipeline middleware"
        },
        {
            "location": "/v1/cookbook/using-zend-form-view-helpers/#registering-more-helpers",
            "text": "What if you need to register helpers from multiple components?  You can do so using the same technique above. Better yet, do them all at once!   If you chose to use delegator factories/service extension, do all helper\n  configuration registrations for all components in the same factory.  If you chose to use middleware, do all helper configuration registrations for\n  all components in the same middleware.",
            "title": "Registering more helpers"
        },
        {
            "location": "/v1/cookbook/using-a-base-path/",
            "text": "How can I tell my application about a base path?\n\n\nIn some environments, your application may be running in a subdirectory of your\nweb root. For example:\n\n\nvar/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php\n\n\n\nwhere \n/var/www\n is the web root, and your Expressive application is in the\n\nexpressive/\n subdirectory. How can you make your application work correctly in\nthis environment?\n\n\n.htaccess in the application root.\n\n\nIf you are using Apache, your first step is to add an \n.htaccess\n file to your\napplication root, with directives for rewriting to the \npublic/\n directory:\n\n\nRewriteEngine On\nRewriteRule (.*) ./public/$1\n\n\n\n\n\nUsing other web servers\n\n\nIf you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to\n\nour issue tracker\n!\n\n\n\n\nUse middleware to rewrite the path\n\n\nThe above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!\n\n\nTo do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.\n\n\nAt the time of writing, we have two suggestions:\n\n\n\n\nlos/basepath\n provides the basic\n  mechanics of rewriting the URL, and has a stable release.\n\n\nmtymek/blast-base-url\n provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path, but does not have a stable release yet.\n\n\n\n\nlos/basepath\n\n\nTo use \nlos/basepath\n, install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.\n\n\nTo install and copy the configuration:\n\n\n$ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php\n\n\n\nWe recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):\n\n\n$ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php\n\n\n\nThen edit one or both, to change the \nlos_basepath\n settings:\n\n\nreturn [\n    'los_basepath' => '<base path here>',\n    /* ... */\n];\n\n\n\nThe base path should be the portion of the web root leading up to the\n\nindex.php\n of your application. In the above example, this would be\n\n/expressive\n.\n\n\nmtymek/blast-base-url\n\n\nTo use \nmtymek/blast-base-url\n, install it via Composer, and register some\nconfiguration.\n\n\nTo install it:\n\n\n$ composer require mtymek/blast-base-url\n\n\n\nTo configure it, update the file \nconfig/autoload/middleware-pipeline.global.php\n,\nwith the following contents:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Blast\\BaseUrl\\BaseUrlMiddleware::class => Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        [ 'middleware' => [ Blast\\BaseUrl\\BaseUrlMiddleware::class ], 'priority' => 1000 ],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nAt this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.\n\n\nThe primary advantage of \nmtymek/blast-base-url\n is in its additional features:\n\n\n\n\nit injects \nZend\\Expressive\\Helper\\UrlHelper\n with the base path, allowing you\n  to create relative route-based URLs.\n\n\nit provides a new helper, \nBlast\\BaseUrl\\BasePathHelper\n, which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.\n\n\n\n\nTo enable these features, we'll add some configuration to\n\nconfig/autoload/dependencies.global.php\n file:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Blast\\BaseUrl\\BasePathHelper::class => Blast\\BaseUrl\\BasePathHelper::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\nFinally, if you're using zend-view, you can register a new \"basePath\" helper in\nyour \nconfig/autoload/templates.global.php\n:\n\n\nreturn [\n    /* ... */\n    'view_helpers' => [\n        'factories' => [\n            'basePath' => Blast\\BaseUrl\\BasePathViewHelperFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nUsage of the \nBasePath\n helper is as follows:\n\n\n// where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this->basePath('/icons/favicon.ico');",
            "title": "Using Expressive from a subdirectory"
        },
        {
            "location": "/v1/cookbook/using-a-base-path/#how-can-i-tell-my-application-about-a-base-path",
            "text": "In some environments, your application may be running in a subdirectory of your\nweb root. For example:  var/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php  where  /var/www  is the web root, and your Expressive application is in the expressive/  subdirectory. How can you make your application work correctly in\nthis environment?",
            "title": "How can I tell my application about a base path?"
        },
        {
            "location": "/v1/cookbook/using-a-base-path/#htaccess-in-the-application-root",
            "text": "If you are using Apache, your first step is to add an  .htaccess  file to your\napplication root, with directives for rewriting to the  public/  directory:  RewriteEngine On\nRewriteRule (.*) ./public/$1",
            "title": ".htaccess in the application root."
        },
        {
            "location": "/v1/cookbook/using-a-base-path/#using-other-web-servers",
            "text": "If you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to our issue tracker !",
            "title": "Using other web servers"
        },
        {
            "location": "/v1/cookbook/using-a-base-path/#use-middleware-to-rewrite-the-path",
            "text": "The above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!  To do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.  At the time of writing, we have two suggestions:   los/basepath  provides the basic\n  mechanics of rewriting the URL, and has a stable release.  mtymek/blast-base-url  provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path, but does not have a stable release yet.",
            "title": "Use middleware to rewrite the path"
        },
        {
            "location": "/v1/cookbook/using-a-base-path/#losbasepath",
            "text": "To use  los/basepath , install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.  To install and copy the configuration:  $ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php  We recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):  $ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php  Then edit one or both, to change the  los_basepath  settings:  return [\n    'los_basepath' => '<base path here>',\n    /* ... */\n];  The base path should be the portion of the web root leading up to the index.php  of your application. In the above example, this would be /expressive .",
            "title": "los/basepath"
        },
        {
            "location": "/v1/cookbook/using-a-base-path/#mtymekblast-base-url",
            "text": "To use  mtymek/blast-base-url , install it via Composer, and register some\nconfiguration.  To install it:  $ composer require mtymek/blast-base-url  To configure it, update the file  config/autoload/middleware-pipeline.global.php ,\nwith the following contents:  return [\n    'dependencies' => [\n        'factories' => [\n            Blast\\BaseUrl\\BaseUrlMiddleware::class => Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        [ 'middleware' => [ Blast\\BaseUrl\\BaseUrlMiddleware::class ], 'priority' => 1000 ],\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];  At this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.  The primary advantage of  mtymek/blast-base-url  is in its additional features:   it injects  Zend\\Expressive\\Helper\\UrlHelper  with the base path, allowing you\n  to create relative route-based URLs.  it provides a new helper,  Blast\\BaseUrl\\BasePathHelper , which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.   To enable these features, we'll add some configuration to config/autoload/dependencies.global.php  file:  return [\n    'dependencies' => [\n        'invokables' => [\n            Blast\\BaseUrl\\BasePathHelper::class => Blast\\BaseUrl\\BasePathHelper::class,\n            /* ... */\n        ],\n    ],\n];  Finally, if you're using zend-view, you can register a new \"basePath\" helper in\nyour  config/autoload/templates.global.php :  return [\n    /* ... */\n    'view_helpers' => [\n        'factories' => [\n            'basePath' => Blast\\BaseUrl\\BasePathViewHelperFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Usage of the  BasePath  helper is as follows:  // where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this->basePath('/icons/favicon.ico');",
            "title": "mtymek/blast-base-url"
        },
        {
            "location": "/v1/cookbook/modular-layout/",
            "text": "How can I make my application modular?\n\n\nZend Framework 2 applications have a concept of modules, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.\n\n\nWhile zend-modulemanager could be used with Expressive, we suggest another\napproach: modules that are based only on configuration. This powerful approach\ndoesn't affect performance, and offers extensive flexibility: each module can\nprovide its own services (with factories), default configuration, and routes.\n\n\nThis cookbook will show how to organize modules using\n\nmtymek/expressive-config-manager\n,\na lightweight library that aggregates and merges configuration, optionally caching it.\n\n\nInstall the configuration manager\n\n\nThe configuration manager is available in Packagist:\n\n\n$ composer require mtymek/expressive-config-manager\n\n\n\nGenerate your config\n\n\nThe default Expressive skeleton installs a \nconfig/config.php\n file, which\naggregates all configuration. When using the configuration manager, you will\nneed to replace the contents of that file with the following code:\n\n\n<?php\n\nuse Zend\\Expressive\\ConfigManager\\ConfigManager;\nuse Zend\\Expressive\\ConfigManager\\PhpFileProvider;\n\n$configManager = new ConfigManager([\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\nreturn new ArrayObject($configManager->getMergedConfig());\n\n\n\nIf you open your application in a browser, it should still work in exactly the\nsame way as it was before. Now you can start adding your modules.\n\n\nFirst module\n\n\nConfigManager\n does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nFor instance, this is how your module could provide its own routes:\n\n\nnamespace MyModule;\n\nclass ModuleConfig\n{\n    public function __invoke()\n    {\n        return [\n            'routes' => [\n                [\n                    'name' => 'api.list-transactions',\n                    'path' => '/api/transactions',\n                    'middleware' => App\\Action\\ListTransactionsAction::class,\n                    'allowed_methods' => ['GET'],\n                ],\n                [\n                    'name' => 'api.refund-transaction',\n                    'path' => '/api/refund',\n                    'middleware' => App\\Action\\RefundAction::class,\n                    'allowed_methods' => ['POST'],\n                ],\n            ],\n        ];\n    }\n}\n\n\n\nEnabling the module\n\n\nFinally, you can enable your module by adding a reference to your config class\nwithin the arguments of the \nConfigManager\n constructor in the \nconfig/config.php\n\nfile:\n\n\n$configManager = new ConfigManager([\n    MyModule\\ModuleConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\n\n\nCaching configuration\n\n\nIn order to provide configuration caching, two things must occur:\n\n\n\n\nFirst, you must define a \nconfig_cache_enabled\n key in your configuration\n  somewhere.\n\n\nSecond, you must pass a second argument to the \nConfigManager\n, the location\n  of the cache file to use.\n\n\n\n\nThe \nconfig_cache_enabled\n key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:\n\n\n\n\nconfig/autoload/global.php\n should define the value to \ntrue\n, as the\n  production setting.\n\n\nconfig/autoload/local.php\n should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be \nfalse\n.\n\n\n\n\n// config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];\n\n\n\nYou would then alter your \nconfig/config.php\n file to add the second argument.\nThe following example builds on the previous, and demonstrates having the\n\nAppConfig\n entry enabled. The configuration will be cached to\n\ndata/config-cache.php\n in the application root:\n\n\n$configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');\n\n\n\nWhen the configuration cache path is present, if the \nconfig_cache_enabled\n flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.\n\n\nFinal notes\n\n\nThis approach may look simple, but it is flexible and powerful:\n\n\n\n\nYou pass a list of config providers to the \nConfigManager\n constructor.\n\n\nConfiguration is merged in the same order as it is passed, with later entries\n  having precedence.\n\n\nYou can override module configuration using \n*.global.php\n and \n*.local.php\n files.\n\n\nIf cached config is found, \nConfigManager\n does not iterate over provider list.\n\n\n\n\nFor more details, please refer to the\n\nConfig Manager Documentation\n.",
            "title": "Building modular applications"
        },
        {
            "location": "/v1/cookbook/modular-layout/#how-can-i-make-my-application-modular",
            "text": "Zend Framework 2 applications have a concept of modules, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.  While zend-modulemanager could be used with Expressive, we suggest another\napproach: modules that are based only on configuration. This powerful approach\ndoesn't affect performance, and offers extensive flexibility: each module can\nprovide its own services (with factories), default configuration, and routes.  This cookbook will show how to organize modules using mtymek/expressive-config-manager ,\na lightweight library that aggregates and merges configuration, optionally caching it.",
            "title": "How can I make my application modular?"
        },
        {
            "location": "/v1/cookbook/modular-layout/#install-the-configuration-manager",
            "text": "The configuration manager is available in Packagist:  $ composer require mtymek/expressive-config-manager",
            "title": "Install the configuration manager"
        },
        {
            "location": "/v1/cookbook/modular-layout/#generate-your-config",
            "text": "The default Expressive skeleton installs a  config/config.php  file, which\naggregates all configuration. When using the configuration manager, you will\nneed to replace the contents of that file with the following code:  <?php\n\nuse Zend\\Expressive\\ConfigManager\\ConfigManager;\nuse Zend\\Expressive\\ConfigManager\\PhpFileProvider;\n\n$configManager = new ConfigManager([\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\nreturn new ArrayObject($configManager->getMergedConfig());  If you open your application in a browser, it should still work in exactly the\nsame way as it was before. Now you can start adding your modules.",
            "title": "Generate your config"
        },
        {
            "location": "/v1/cookbook/modular-layout/#first-module",
            "text": "ConfigManager  does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  For instance, this is how your module could provide its own routes:  namespace MyModule;\n\nclass ModuleConfig\n{\n    public function __invoke()\n    {\n        return [\n            'routes' => [\n                [\n                    'name' => 'api.list-transactions',\n                    'path' => '/api/transactions',\n                    'middleware' => App\\Action\\ListTransactionsAction::class,\n                    'allowed_methods' => ['GET'],\n                ],\n                [\n                    'name' => 'api.refund-transaction',\n                    'path' => '/api/refund',\n                    'middleware' => App\\Action\\RefundAction::class,\n                    'allowed_methods' => ['POST'],\n                ],\n            ],\n        ];\n    }\n}",
            "title": "First module"
        },
        {
            "location": "/v1/cookbook/modular-layout/#enabling-the-module",
            "text": "Finally, you can enable your module by adding a reference to your config class\nwithin the arguments of the  ConfigManager  constructor in the  config/config.php \nfile:  $configManager = new ConfigManager([\n    MyModule\\ModuleConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);",
            "title": "Enabling the module"
        },
        {
            "location": "/v1/cookbook/modular-layout/#caching-configuration",
            "text": "In order to provide configuration caching, two things must occur:   First, you must define a  config_cache_enabled  key in your configuration\n  somewhere.  Second, you must pass a second argument to the  ConfigManager , the location\n  of the cache file to use.   The  config_cache_enabled  key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:   config/autoload/global.php  should define the value to  true , as the\n  production setting.  config/autoload/local.php  should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be  false .   // config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' => true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' => false, // <- development!\n    /* ... */\n];  You would then alter your  config/config.php  file to add the second argument.\nThe following example builds on the previous, and demonstrates having the AppConfig  entry enabled. The configuration will be cached to data/config-cache.php  in the application root:  $configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');  When the configuration cache path is present, if the  config_cache_enabled  flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.",
            "title": "Caching configuration"
        },
        {
            "location": "/v1/cookbook/modular-layout/#final-notes",
            "text": "This approach may look simple, but it is flexible and powerful:   You pass a list of config providers to the  ConfigManager  constructor.  Configuration is merged in the same order as it is passed, with later entries\n  having precedence.  You can override module configuration using  *.global.php  and  *.local.php  files.  If cached config is found,  ConfigManager  does not iterate over provider list.   For more details, please refer to the Config Manager Documentation .",
            "title": "Final notes"
        },
        {
            "location": "/v1/cookbook/setting-locale-depending-routing-parameter/",
            "text": "How can I setup the locale depending on a routing parameter?\n\n\nLocalized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.\n\n\n\n\nRouting parameters\n\n\nUsing the approach in this chapter requires that you add a \n/:locale\n (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non \nsetting the locale without routing parameters\n.\n\n\n\n\nSetting up the route\n\n\nIf you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.\n\n\nIn this example we use the \nlocale\n parameter, which should consist of two\nlowercase alphabetical characters:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            Zend\\Expressive\\Router\\RouterInterface::class =>\n                Zend\\Expressive\\Router\\ZendRouter::class,\n        ],\n        'factories' => [\n            Application\\Action\\HomePageAction::class =>\n                Application\\Action\\HomePageFactory::class,\n            Application\\Action\\ContactPageAction::class =>\n                Application\\Action\\ContactPageFactory::class,\n        ],\n    ],\n    'routes' => [\n        [\n            'name' => 'home',\n            'path' => '/:locale',\n            'middleware' => Application\\Action\\HomePageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n        [\n            'name' => 'contact',\n            'path' => '/:locale/contact',\n            'middleware' => Application\\Action\\ContactPageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\nNote: Routing may differ based on router\n\n\nThe routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.\n\n\nFor Aura.Router, the 'home' route as listed above would read:\n\n\n[\n    'name' => 'home',\n    'path' => '/{locale}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n    'options'         => [\n        'constraints' => [\n            'tokens' => [\n                'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n            ],\n        ],\n    ],\n]\n\n\n\nFor FastRoute:\n\n\n[\n    'name' => 'home',\n    'path' => '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n]\n\n\n\nAs such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.\n\n\n\n\nCreate a route result middleware class for localization\n\n\nTo make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.\n\n\nSuch a \nLocalizationMiddleware\n class could look similar to this:\n\n\n<?php\n\nnamespace Application\\I18n;\n\nuse Locale;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass LocalizationMiddleware\n{\n    const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next = null)\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request->getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                isset($request->getServerParams()['HTTP_ACCEPT_LANGUAGE']) ? $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] : 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $next($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale), $response);\n    }\n}\n\n\n\n\n\nLocale::setDefault is unsafe\n\n\nDo not use \nLocale::setDefault($locale)\n to set a global static locale.\nPSR-7 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.\n\n\nUse a request parameter as detailed above instead, as the request is created\nspecific to each process.\n\n\n\n\nIn your \nconfig/autoload/middleware-pipeline.global.php\n, you'd register the\ndependency, and inject the middleware into the pipeline following the routing\nmiddleware:\n\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            LocalizationMiddleware::class => LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        /* ... */\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                LocalizationMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];",
            "title": "Setting a locale based on a routing parameter"
        },
        {
            "location": "/v1/cookbook/setting-locale-depending-routing-parameter/#how-can-i-setup-the-locale-depending-on-a-routing-parameter",
            "text": "Localized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.",
            "title": "How can I setup the locale depending on a routing parameter?"
        },
        {
            "location": "/v1/cookbook/setting-locale-depending-routing-parameter/#routing-parameters",
            "text": "Using the approach in this chapter requires that you add a  /:locale  (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non  setting the locale without routing parameters .",
            "title": "Routing parameters"
        },
        {
            "location": "/v1/cookbook/setting-locale-depending-routing-parameter/#setting-up-the-route",
            "text": "If you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.  In this example we use the  locale  parameter, which should consist of two\nlowercase alphabetical characters:  return [\n    'dependencies' => [\n        'invokables' => [\n            Zend\\Expressive\\Router\\RouterInterface::class =>\n                Zend\\Expressive\\Router\\ZendRouter::class,\n        ],\n        'factories' => [\n            Application\\Action\\HomePageAction::class =>\n                Application\\Action\\HomePageFactory::class,\n            Application\\Action\\ContactPageAction::class =>\n                Application\\Action\\ContactPageFactory::class,\n        ],\n    ],\n    'routes' => [\n        [\n            'name' => 'home',\n            'path' => '/:locale',\n            'middleware' => Application\\Action\\HomePageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n        [\n            'name' => 'contact',\n            'path' => '/:locale/contact',\n            'middleware' => Application\\Action\\ContactPageAction::class,\n            'allowed_methods' => ['GET'],\n            'options'         => [\n                'constraints' => [\n                    'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Setting up the route"
        },
        {
            "location": "/v1/cookbook/setting-locale-depending-routing-parameter/#note-routing-may-differ-based-on-router",
            "text": "The routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.  For Aura.Router, the 'home' route as listed above would read:  [\n    'name' => 'home',\n    'path' => '/{locale}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n    'options'         => [\n        'constraints' => [\n            'tokens' => [\n                'locale' => '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n            ],\n        ],\n    ],\n]  For FastRoute:  [\n    'name' => 'home',\n    'path' => '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    'middleware' => Application\\Action\\HomePageAction::class,\n    'allowed_methods' => ['GET'],\n]  As such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.",
            "title": "Note: Routing may differ based on router"
        },
        {
            "location": "/v1/cookbook/setting-locale-depending-routing-parameter/#create-a-route-result-middleware-class-for-localization",
            "text": "To make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.  Such a  LocalizationMiddleware  class could look similar to this:  <?php\n\nnamespace Application\\I18n;\n\nuse Locale;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass LocalizationMiddleware\n{\n    const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next = null)\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request->getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                isset($request->getServerParams()['HTTP_ACCEPT_LANGUAGE']) ? $request->getServerParams()['HTTP_ACCEPT_LANGUAGE'] : 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $next($request->withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale), $response);\n    }\n}",
            "title": "Create a route result middleware class for localization"
        },
        {
            "location": "/v1/cookbook/setting-locale-depending-routing-parameter/#localesetdefault-is-unsafe",
            "text": "Do not use  Locale::setDefault($locale)  to set a global static locale.\nPSR-7 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.  Use a request parameter as detailed above instead, as the request is created\nspecific to each process.   In your  config/autoload/middleware-pipeline.global.php , you'd register the\ndependency, and inject the middleware into the pipeline following the routing\nmiddleware:  return [\n    'dependencies' => [\n        'invokables' => [\n            LocalizationMiddleware::class => LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        /* ... */\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                LocalizationMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n];",
            "title": "Locale::setDefault is unsafe"
        },
        {
            "location": "/v1/cookbook/setting-locale-without-routing-parameter/",
            "text": "How can I setup the locale without routing parameters?\n\n\nLocalized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.\n\n\n\n\nDistinguishing between routes that require localization\n\n\nIf your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the\n\n\"Setting a locale based on a routing parameter\" recipe\n.\n\n\n\n\nSetup a middleware to extract the locale from the URI\n\n\nFirst, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If if doesn't find one, it sets a default.\n\n\nIf it does find one, it uses the value to setup the locale. It also:\n\n\n\n\namends the request with a truncated path (removing the locale segment).\n\n\nadds the locale segment as the base path of the \nUrlHelper\n.\n\n\n\n\nnamespace Application\\I18n;\n\nuse Locale;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $uri = $request->getUri();\n\n        $path = $uri->getPath();\n\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            Locale::setDefault('de_DE');\n            return $next($request, $response);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $next(\n            $request->withUri(\n                $uri->withPath(substr($path, 3))\n            ),\n            $response\n        );\n    }\n}\n\n\n\nThen you will need a factory for the \nSetLocaleMiddleware\n to inject the\n\nUrlHelper\n instance.\n\n\nnamespace Application\\I18n;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SetLocaleMiddleware(\n            $container->get(UrlHelper::class)\n        );\n    }\n}\n\n\n\nAfterwards, you need to configure the \nSetLocaleMiddleware\n in your\n\n/config/autoload/middleware-pipeline.global.php\n file so that it is executed\non every request.\n\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            Application\\I18n\\SetLocaleMiddleware::class =>\n                Application\\I18n\\SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ]\n\n    'middleware_pipeline' => [\n        [\n            'middleware' => [\n                Application\\I18n\\SetLocaleMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 1000,\n        ],\n\n        /* ... */\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        /* ... */\n    ],\n];\n\n\n\nUrl generation in the view\n\n\nSince the \nUrlHelper\n has the locale set as a base path, you don't need\nto worry about generating URLs within your view. Just use the helper to\ngenerate a URL and it will do the rest.\n\n\n<?php echo $this->url('your-route') ?>\n\n\n\n\n\nHelpers differ between template renderers\n\n\nThe above example is specific to zend-view; syntax will differ for\nTwig and Plates.\n\n\n\n\nRedirecting within your middleware\n\n\nIf you want to add the locale parameter when creating URIs within your\naction middleware, you just need to inject the \nUrlHelper\n into your\nmiddleware and use it for URL generation:\n\n\nnamespace Application\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectAction\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param ResponseInterface      $response\n     * @param callable|null          $next\n     *\n     * @return RedirectResponse\n     */\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this->helper->generate('your-route', $routeParams)\n        );\n    }\n}\n\n\n\nInjecting the \nUrlHelper\n into your middleware will also require that the\nmiddleware have a factory that manages the injection. As an example, the\nfollowing would work for the above middleware:\n\n\nnamespace Application\\Action;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectAction(\n            $container->get(UrlHelper::class)\n        );\n    }\n}",
            "title": "Setting a locale without a routing parameter"
        },
        {
            "location": "/v1/cookbook/setting-locale-without-routing-parameter/#how-can-i-setup-the-locale-without-routing-parameters",
            "text": "Localized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.",
            "title": "How can I setup the locale without routing parameters?"
        },
        {
            "location": "/v1/cookbook/setting-locale-without-routing-parameter/#distinguishing-between-routes-that-require-localization",
            "text": "If your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the \"Setting a locale based on a routing parameter\" recipe .",
            "title": "Distinguishing between routes that require localization"
        },
        {
            "location": "/v1/cookbook/setting-locale-without-routing-parameter/#setup-a-middleware-to-extract-the-locale-from-the-uri",
            "text": "First, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If if doesn't find one, it sets a default.  If it does find one, it uses the value to setup the locale. It also:   amends the request with a truncated path (removing the locale segment).  adds the locale segment as the base path of the  UrlHelper .   namespace Application\\I18n;\n\nuse Locale;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $uri = $request->getUri();\n\n        $path = $uri->getPath();\n\n        if (! preg_match('#^/(?P<locale>[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            Locale::setDefault('de_DE');\n            return $next($request, $response);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this->helper->setBasePath($locale);\n\n        return $next(\n            $request->withUri(\n                $uri->withPath(substr($path, 3))\n            ),\n            $response\n        );\n    }\n}  Then you will need a factory for the  SetLocaleMiddleware  to inject the UrlHelper  instance.  namespace Application\\I18n;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SetLocaleMiddleware(\n            $container->get(UrlHelper::class)\n        );\n    }\n}  Afterwards, you need to configure the  SetLocaleMiddleware  in your /config/autoload/middleware-pipeline.global.php  file so that it is executed\non every request.  return [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            Application\\I18n\\SetLocaleMiddleware::class =>\n                Application\\I18n\\SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ]\n\n    'middleware_pipeline' => [\n        [\n            'middleware' => [\n                Application\\I18n\\SetLocaleMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 1000,\n        ],\n\n        /* ... */\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        /* ... */\n    ],\n];",
            "title": "Setup a middleware to extract the locale from the URI"
        },
        {
            "location": "/v1/cookbook/setting-locale-without-routing-parameter/#url-generation-in-the-view",
            "text": "Since the  UrlHelper  has the locale set as a base path, you don't need\nto worry about generating URLs within your view. Just use the helper to\ngenerate a URL and it will do the rest.  <?php echo $this->url('your-route') ?>",
            "title": "Url generation in the view"
        },
        {
            "location": "/v1/cookbook/setting-locale-without-routing-parameter/#helpers-differ-between-template-renderers",
            "text": "The above example is specific to zend-view; syntax will differ for\nTwig and Plates.",
            "title": "Helpers differ between template renderers"
        },
        {
            "location": "/v1/cookbook/setting-locale-without-routing-parameter/#redirecting-within-your-middleware",
            "text": "If you want to add the locale parameter when creating URIs within your\naction middleware, you just need to inject the  UrlHelper  into your\nmiddleware and use it for URL generation:  namespace Application\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectAction\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this->helper = $helper;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param ResponseInterface      $response\n     * @param callable|null          $next\n     *\n     * @return RedirectResponse\n     */\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this->helper->generate('your-route', $routeParams)\n        );\n    }\n}  Injecting the  UrlHelper  into your middleware will also require that the\nmiddleware have a factory that manages the injection. As an example, the\nfollowing would work for the above middleware:  namespace Application\\Action;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectAction(\n            $container->get(UrlHelper::class)\n        );\n    }\n}",
            "title": "Redirecting within your middleware"
        },
        {
            "location": "/v1/cookbook/debug-toolbars/",
            "text": "How can I get a debug toolbar for my Expressive application?\n\n\nMany modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?\n\n\nZend Server Z-Ray\n\n\nZend Server\n ships with a tool\ncalled \nZ-Ray\n, which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently \navailable as a standalone technology\npreview\n, and can be added\nas an extension to an existing PHP installation.\n\n\nWhen using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the\n\nZ-Ray documentation\n\nfor full usage details.\n\n\nbitExpert/prophiler-psr7-middleware\n\n\nAnother option is bitExpert's \nprophiler-psr7-middleware\n.\nThis package wraps \nfabfuel/prophiler\n,\nwhich provides a PHP-based profiling tool and toolbar; the bitExpert package\nwraps this in PSR-7 middleware to make consumption in those paradigms trivial.\n\n\nTo add the toolbar middleware to your application, use composer:\n\n\n$ composer require bitExpert/prophiler-psr7-middleware\n\n\n\nFrom there, you will need to create a factory for the middleware, and add it to\nyour middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written\na \npost detailing these steps\n.\n\n\n\n\nUse locally!\n\n\nOne minor change we recommend over the directions Stephan provides is that you\nconfigure the factory and middleware in the\n\nconfig/autoload/middleware-pipeline.local.php\n file, vs the \n.global\n version.\nDoing so enables the middleware and toolbar only in the local environment\n\u2014 and not in production, where you likely do not want to expose such\ninformation!\n\n\n\n\nphp-middleware/php-debug-bar\n\n\nphp-middleware/php-debug-bar\n\nprovides a PSR-7 middleware wrapper around \nmaximebf/php-debugbar\n,\na popular framework-agnostic debug bar for PHP projects.\n\n\nFirst, install the middleware in your application:\n\n\n$ composer require php-middleware/php-debug-bar\n\n\n\nThis package provides a config provider. You can add it to your application in\none of two ways:\n\n\n\n\nIf you are using the \nConfigManager\n, add an entry for it:\n\n\n\n\n$configManager = new Zend\\Expressive\\ConfigManager\\ConfigManager([\n    PhpMiddleware\\PhpDebugBar\\ConfigProvider::class,\n    new Zend\\Expressive\\ConfigManager\\PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\n\n\n\n\nIf you are not using the ConfigManager, create a new configuration file,\n  \nconfig/autoload/php-debugbar.global.php\n, with the following contents:\n\n\n\n\n<?php\nuse PhpMiddleware\\PhpDebugBar\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();\n\n\n\n\n\nUse locally!\n\n\nRemember to enable \nPhpMiddleware\\PhpDebugBar\\ConfigProvider\n only in your\ndevelopment enviroments!",
            "title": "Enabling debug toolbars"
        },
        {
            "location": "/v1/cookbook/debug-toolbars/#how-can-i-get-a-debug-toolbar-for-my-expressive-application",
            "text": "Many modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?",
            "title": "How can I get a debug toolbar for my Expressive application?"
        },
        {
            "location": "/v1/cookbook/debug-toolbars/#zend-server-z-ray",
            "text": "Zend Server  ships with a tool\ncalled  Z-Ray , which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently  available as a standalone technology\npreview , and can be added\nas an extension to an existing PHP installation.  When using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the Z-Ray documentation \nfor full usage details.",
            "title": "Zend Server Z-Ray"
        },
        {
            "location": "/v1/cookbook/debug-toolbars/#bitexpertprophiler-psr7-middleware",
            "text": "Another option is bitExpert's  prophiler-psr7-middleware .\nThis package wraps  fabfuel/prophiler ,\nwhich provides a PHP-based profiling tool and toolbar; the bitExpert package\nwraps this in PSR-7 middleware to make consumption in those paradigms trivial.  To add the toolbar middleware to your application, use composer:  $ composer require bitExpert/prophiler-psr7-middleware  From there, you will need to create a factory for the middleware, and add it to\nyour middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written\na  post detailing these steps .",
            "title": "bitExpert/prophiler-psr7-middleware"
        },
        {
            "location": "/v1/cookbook/debug-toolbars/#use-locally",
            "text": "One minor change we recommend over the directions Stephan provides is that you\nconfigure the factory and middleware in the config/autoload/middleware-pipeline.local.php  file, vs the  .global  version.\nDoing so enables the middleware and toolbar only in the local environment\n\u2014 and not in production, where you likely do not want to expose such\ninformation!",
            "title": "Use locally!"
        },
        {
            "location": "/v1/cookbook/debug-toolbars/#php-middlewarephp-debug-bar",
            "text": "php-middleware/php-debug-bar \nprovides a PSR-7 middleware wrapper around  maximebf/php-debugbar ,\na popular framework-agnostic debug bar for PHP projects.  First, install the middleware in your application:  $ composer require php-middleware/php-debug-bar  This package provides a config provider. You can add it to your application in\none of two ways:   If you are using the  ConfigManager , add an entry for it:   $configManager = new Zend\\Expressive\\ConfigManager\\ConfigManager([\n    PhpMiddleware\\PhpDebugBar\\ConfigProvider::class,\n    new Zend\\Expressive\\ConfigManager\\PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);   If you are not using the ConfigManager, create a new configuration file,\n   config/autoload/php-debugbar.global.php , with the following contents:   <?php\nuse PhpMiddleware\\PhpDebugBar\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();",
            "title": "php-middleware/php-debug-bar"
        },
        {
            "location": "/v1/cookbook/debug-toolbars/#use-locally_1",
            "text": "Remember to enable  PhpMiddleware\\PhpDebugBar\\ConfigProvider  only in your\ndevelopment enviroments!",
            "title": "Use locally!"
        },
        {
            "location": "/v1/cookbook/using-routed-middleware-class-as-controller/",
            "text": "Handling multiple routes in a single class\n\n\nTypically, in Expressive, we would define one middleware class per route. For a\nstandard CRUD-style application, however, this leads to multiple related\nclasses:\n\n\n\n\nAlbumPageIndex\n\n\nAlbumPageEdit\n\n\nAlbumPageAdd\n\n\n\n\nIf you are familiar with frameworks that provide controllers capable of handling\nmultiple \"actions\", such as those found in Zend Framework 1 and 2, Symfony,\nCodeIgniter, CakePHP, and other popular frameworks, you may want to apply a\nsimilar pattern when using Expressive.\n\n\nIn other words, what if we want to use only one middleware class to facilitate\nall three of the above?\n\n\nIn the following example, we'll use an \naction\n routing parameter which our\nmiddleware class will use in order to determine which internal method to invoke.\n\n\nConsider the following route configuration:\n\n\nreturn [\n    /* ... */\n    'routes' => [\n        /* ... */\n        [\n            'name' => 'album',\n            'path' => '/album[/{action:add|edit}[/{id}]]',\n            'middleware' => Album\\Action\\AlbumPage::class,\n            'allowed_methods' => ['GET'],\n        ],\n        /* ... */\n    ],\n];\n\nThe above defines a route that will match any of the following:\n\n\n\n\n/album\n\n\n/album/add\n\n\n/album/edit/3\n\n\n\n\nThe \naction\n attribute can thus be one of \nadd\n or \nedit\n, and we can optionally\nalso receive an \nid\n attribute (in the latter example, it would be \n3\n).\n\n\n\n\nRouting definitions may vary\n\n\nDepending on the router you chose when starting your project, your routing\ndefinition may differ. The above example uses the default \nFastRoute\n\nimplementation.\n\n\n\n\nWe might then implement \nAlbum\\Action\\AlbumPage\n as follows:\n\n\nnamespace Album\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        switch ($request->getAttribute('action', 'index')) {\n            case 'index':\n                return $this->indexAction($request, $response, $next);\n            case 'add':\n                return $this->addAction($request, $response, $next);\n            case 'edit':\n                return $this->editAction($request, $response, $next);\n            default:\n                // Invalid; thus, a 404!\n                return $response->withStatus(404);\n        }\n    }\n\n    public function indexAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        return new HtmlResponse($this->template->render('album::album-page'));\n    }\n\n    public function addAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        return new HtmlResponse($this->template->render('album::album-page-add'));\n    }\n\n    public function editAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new \\InvalidArgumentException('id parameter must be provided');\n        }\n\n        return new HtmlResponse(\n            $this->template->render('album::album-page-edit', ['id' => $id])\n        );\n    }\n}\n\n\n\nThis allows us to have the same dependencies for a set of related actions, and,\nif desired, even have common internal methods each can utilize.\n\n\nThis approach is reasonable, but requires that I create a similar \n__invoke()\n\nimplementation every time I want to accomplish a similar workflow. Let's create\na generic implementation, via an \nAbstractPage\n class:\n\n\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nabstract class AbstractPage\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return $response->withStatus(404);\n        }\n\n        return $this->$action($request, $response, $next);\n    }\n}\n\n\n\nThe above abstract class pulls the \naction\n attribute on invocation, and\nconcatenates it with the word \nAction\n. It then uses this value to determine if\na corresponding method exists in the current class, and, if so, calls it with\nthe arguments it received; otherwise, it returns a 404 response.\n\n\n\n\nInvoking the error stack\n\n\nInstead of returning a 404 response, you could also invoke \n$next()\n with an\nerror:\n\n\nreturn $next($request, $response, new NotFoundError());\n\n\n\nThis will then invoke the first error handler middleware capable of handling\nthe error.\n\n\n\n\nOur original \nAlbumPage\n implementation could then be modified to extend\n\nAbstractPage\n:\n\n\nnamespace Album\\Action;\n\nuse App\\Action\\AbstractPage;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage extends AbstractPage\n{\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}\n\n\n\n\n\nOr use a trait\n\n\nAs an alternative to an abstract class, you could define the \n__invoke()\n\nlogic in a trait, which you then compose into your middleware:\n\n\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ntrait ActionBasedInvocation\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return $response->withStatus(404);\n        }\n\n        return $this->$action($request, $response, $next);\n    }\n}\n\n\n\nYou would then compose it into a class as follows:\n\n\nnamespace Album\\Action;\n\nuse App\\Action\\ActionBasedInvocation;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    use ActionBasedInvocation;\n\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Handling multiple routes in a single class"
        },
        {
            "location": "/v1/cookbook/using-routed-middleware-class-as-controller/#handling-multiple-routes-in-a-single-class",
            "text": "Typically, in Expressive, we would define one middleware class per route. For a\nstandard CRUD-style application, however, this leads to multiple related\nclasses:   AlbumPageIndex  AlbumPageEdit  AlbumPageAdd   If you are familiar with frameworks that provide controllers capable of handling\nmultiple \"actions\", such as those found in Zend Framework 1 and 2, Symfony,\nCodeIgniter, CakePHP, and other popular frameworks, you may want to apply a\nsimilar pattern when using Expressive.  In other words, what if we want to use only one middleware class to facilitate\nall three of the above?  In the following example, we'll use an  action  routing parameter which our\nmiddleware class will use in order to determine which internal method to invoke.  Consider the following route configuration:  return [\n    /* ... */\n    'routes' => [\n        /* ... */\n        [\n            'name' => 'album',\n            'path' => '/album[/{action:add|edit}[/{id}]]',\n            'middleware' => Album\\Action\\AlbumPage::class,\n            'allowed_methods' => ['GET'],\n        ],\n        /* ... */\n    ],\n]; \nThe above defines a route that will match any of the following:   /album  /album/add  /album/edit/3   The  action  attribute can thus be one of  add  or  edit , and we can optionally\nalso receive an  id  attribute (in the latter example, it would be  3 ).",
            "title": "Handling multiple routes in a single class"
        },
        {
            "location": "/v1/cookbook/using-routed-middleware-class-as-controller/#routing-definitions-may-vary",
            "text": "Depending on the router you chose when starting your project, your routing\ndefinition may differ. The above example uses the default  FastRoute \nimplementation.   We might then implement  Album\\Action\\AlbumPage  as follows:  namespace Album\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        switch ($request->getAttribute('action', 'index')) {\n            case 'index':\n                return $this->indexAction($request, $response, $next);\n            case 'add':\n                return $this->addAction($request, $response, $next);\n            case 'edit':\n                return $this->editAction($request, $response, $next);\n            default:\n                // Invalid; thus, a 404!\n                return $response->withStatus(404);\n        }\n    }\n\n    public function indexAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        return new HtmlResponse($this->template->render('album::album-page'));\n    }\n\n    public function addAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        return new HtmlResponse($this->template->render('album::album-page-add'));\n    }\n\n    public function editAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $id = $request->getAttribute('id', false);\n        if (! $id) {\n            throw new \\InvalidArgumentException('id parameter must be provided');\n        }\n\n        return new HtmlResponse(\n            $this->template->render('album::album-page-edit', ['id' => $id])\n        );\n    }\n}  This allows us to have the same dependencies for a set of related actions, and,\nif desired, even have common internal methods each can utilize.  This approach is reasonable, but requires that I create a similar  __invoke() \nimplementation every time I want to accomplish a similar workflow. Let's create\na generic implementation, via an  AbstractPage  class:  namespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nabstract class AbstractPage\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return $response->withStatus(404);\n        }\n\n        return $this->$action($request, $response, $next);\n    }\n}  The above abstract class pulls the  action  attribute on invocation, and\nconcatenates it with the word  Action . It then uses this value to determine if\na corresponding method exists in the current class, and, if so, calls it with\nthe arguments it received; otherwise, it returns a 404 response.",
            "title": "Routing definitions may vary"
        },
        {
            "location": "/v1/cookbook/using-routed-middleware-class-as-controller/#invoking-the-error-stack",
            "text": "Instead of returning a 404 response, you could also invoke  $next()  with an\nerror:  return $next($request, $response, new NotFoundError());  This will then invoke the first error handler middleware capable of handling\nthe error.   Our original  AlbumPage  implementation could then be modified to extend AbstractPage :  namespace Album\\Action;\n\nuse App\\Action\\AbstractPage;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage extends AbstractPage\n{\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Invoking the error stack"
        },
        {
            "location": "/v1/cookbook/using-routed-middleware-class-as-controller/#or-use-a-trait",
            "text": "As an alternative to an abstract class, you could define the  __invoke() \nlogic in a trait, which you then compose into your middleware:  namespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ntrait ActionBasedInvocation\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $action = $request->getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return $response->withStatus(404);\n        }\n\n        return $this->$action($request, $response, $next);\n    }\n}  You would then compose it into a class as follows:  namespace Album\\Action;\n\nuse App\\Action\\ActionBasedInvocation;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    use ActionBasedInvocation;\n\n    private $template;\n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this->template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}",
            "title": "Or use a trait"
        },
        {
            "location": "/v1/cookbook/flash-messengers/",
            "text": "How Can I Implement Flash Messages?\n\n\nFlash messages\n are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a\n\nPost/Redirect/Get (PRG)\n\nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.\n\n\nExpressive does not provide native session facilities out-of-the-box, which\nmeans you will need:\n\n\n\n\nSession functionality.\n\n\nFlash message functionality, for handling message expiry from the session\n  after first access.\n\n\n\n\nA number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are slim/flash and\ndamess/expressive-session-middleware.\n\n\nslim/flash\n\n\nSlim's \nFlash messages service provider\n can be\nused in Expressive. It uses PHP's native session support.\n\n\nFirst, you'll need to add it to your application:\n\n\n$ composer require slim/flash\n\n\n\nOnce you have, you'll need to create a factory to return middleware that will\nadd the flash message provider to the request:\n\n\nnamespace App;\n\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return function ($request, $response, $next) {\n            // Start the session whenever we use this!\n            session_start();\n\n            return $next(\n                $request->withAttribute('flash', new Messages()),\n                $response\n            );\n        };\n    }\n}\n\n\n\nNow, let's register it with our middleware pipeline. In\n\nconfig/autoload/middleware-pipeline.global.php\n, make the following additions:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            'App\\SlimFlashMiddleware' => App\\SlimFlashMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\nWhere to register the flash middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead.\n\n\n\n\nFrom here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:\n\n\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\npublic function __invoke($request, $response, $next)\n{\n    $flash = $request->getAttribute('flash');\n    $flash->addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\nAnd middleware consuming the message might read:\n\n\npublic function __invoke($request, $response, $next)\n{\n    $flash = $request->getAttribute('flash');\n    $messages = $flash->getMessages();\n    // ...\n}\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.\n\n\ndamess/expressive-session-middleware and Aura.Session\n\n\ndamess/expressive-session-middleware\n\nprovides middleware for initializing an\n\nAura.Session\n instance; Aura.Session\nprovides flash messaging capabilities as part of its featureset.\n\n\nInstall it via Composer:\n\n\n$ composer require damess/expressive-session-middleware\n\n\n\nIn \nconfig/autoload/dependencies.global.php\n, add an entry for Aura.Session:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\nIn \nconfig/autoload/middleware-pipeline.global.php\n, add a factory entry for the\n\ndamess/expressive-session-middleware\n, and add it to the middleware pipeline:\n\n\nreturn [\n    'dependencies' => [\n        'factories' => [\n            DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                DaMess\\Http\\SessionMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\nWhere to register the session middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the session\nmiddleware enabled for every request. If this is the case, add the session\nmiddleware as part of a route-specific pipeline instead.\n\n\n\n\nOnce enabled, the \nSessionMiddleware\n will inject the Aura.Session instance into\nthe request as the \nsession\n attribute; you can thus retrieve it within\nmiddleware using the following:\n\n\n$session = $request->getAttribute('session');\n\n\n\nTo create and consume flash messages, use Aura.Session's\n\nflash values\n. As\nan example, the middleware that is processing a POST request might set a flash\nmessage:\n\n\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\npublic function __invoke($request, $response, $next)\n{\n    $session = $request->getAttribute('session');\n    $session->getSegment(__NAMESPACE__)\n            ->setFlash('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\nAnother middleware, to which the original middleware redirects, might look like\nthis:\n\n\npublic function __invoke($request, $response, $next)\n{\n    $session = $request->getAttribute('session');\n    $message = $session->getSegment(__NAMESPACE__)\n                       ->getFlash('message');\n    // ...\n}\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.",
            "title": "Flash Messengers"
        },
        {
            "location": "/v1/cookbook/flash-messengers/#how-can-i-implement-flash-messages",
            "text": "Flash messages  are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) \nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.  Expressive does not provide native session facilities out-of-the-box, which\nmeans you will need:   Session functionality.  Flash message functionality, for handling message expiry from the session\n  after first access.   A number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are slim/flash and\ndamess/expressive-session-middleware.",
            "title": "How Can I Implement Flash Messages?"
        },
        {
            "location": "/v1/cookbook/flash-messengers/#slimflash",
            "text": "Slim's  Flash messages service provider  can be\nused in Expressive. It uses PHP's native session support.  First, you'll need to add it to your application:  $ composer require slim/flash  Once you have, you'll need to create a factory to return middleware that will\nadd the flash message provider to the request:  namespace App;\n\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return function ($request, $response, $next) {\n            // Start the session whenever we use this!\n            session_start();\n\n            return $next(\n                $request->withAttribute('flash', new Messages()),\n                $response\n            );\n        };\n    }\n}  Now, let's register it with our middleware pipeline. In config/autoload/middleware-pipeline.global.php , make the following additions:  return [\n    'dependencies' => [\n        'factories' => [\n            'App\\SlimFlashMiddleware' => App\\SlimFlashMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];",
            "title": "slim/flash"
        },
        {
            "location": "/v1/cookbook/flash-messengers/#where-to-register-the-flash-middleware",
            "text": "Sessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead.   From here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:  use Zend\\Diactoros\\Response\\RedirectResponse;\n\npublic function __invoke($request, $response, $next)\n{\n    $flash = $request->getAttribute('flash');\n    $flash->addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  And middleware consuming the message might read:  public function __invoke($request, $response, $next)\n{\n    $flash = $request->getAttribute('flash');\n    $messages = $flash->getMessages();\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.",
            "title": "Where to register the flash middleware"
        },
        {
            "location": "/v1/cookbook/flash-messengers/#damessexpressive-session-middleware-and-aurasession",
            "text": "damess/expressive-session-middleware \nprovides middleware for initializing an Aura.Session  instance; Aura.Session\nprovides flash messaging capabilities as part of its featureset.  Install it via Composer:  $ composer require damess/expressive-session-middleware  In  config/autoload/dependencies.global.php , add an entry for Aura.Session:  return [\n    'dependencies' => [\n        'factories' => [\n            Aura\\Session\\Session::class => DaMess\\Factory\\AuraSessionFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  In  config/autoload/middleware-pipeline.global.php , add a factory entry for the damess/expressive-session-middleware , and add it to the middleware pipeline:  return [\n    'dependencies' => [\n        'factories' => [\n            DaMess\\Http\\SessionMiddleware::class => DaMess\\Factory\\SessionMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                DaMess\\Http\\SessionMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];",
            "title": "damess/expressive-session-middleware and Aura.Session"
        },
        {
            "location": "/v1/cookbook/flash-messengers/#where-to-register-the-session-middleware",
            "text": "Sessions can sometimes be expensive. As such, you may not want the session\nmiddleware enabled for every request. If this is the case, add the session\nmiddleware as part of a route-specific pipeline instead.   Once enabled, the  SessionMiddleware  will inject the Aura.Session instance into\nthe request as the  session  attribute; you can thus retrieve it within\nmiddleware using the following:  $session = $request->getAttribute('session');  To create and consume flash messages, use Aura.Session's flash values . As\nan example, the middleware that is processing a POST request might set a flash\nmessage:  use Zend\\Diactoros\\Response\\RedirectResponse;\n\npublic function __invoke($request, $response, $next)\n{\n    $session = $request->getAttribute('session');\n    $session->getSegment(__NAMESPACE__)\n            ->setFlash('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  Another middleware, to which the original middleware redirects, might look like\nthis:  public function __invoke($request, $response, $next)\n{\n    $session = $request->getAttribute('session');\n    $message = $session->getSegment(__NAMESPACE__)\n                       ->getFlash('message');\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.",
            "title": "Where to register the session middleware"
        },
        {
            "location": "/v1/why-expressive/",
            "text": "Should You Choose zend-expressive Over zend-mvc?\n\n\nWe recommend that you choose Expressive for any new project \u2014 \nif the\nchoice is yours to make\n.\n\n\nWhy Use zend-mvc?\n\n\nzend-mvc is a proven platform, with half a decade of development behind it. It\nis stable and battle-tested in production platforms.\n\n\nBecause it is opinionated about project structure and architecture, fewer\ndecisions need be made up front; developers know where new code goes, and how it\nwill wire into the overall application.\n\n\nAdditionally, a number of training courses exist, including \nofferings by\nZend\n, allowing you\nor your team to fully learn the framework and take advantage of all its features.\n\n\nFinally, zend-mvc has a lively \nmodule ecosystem\n,\nallowing you to add features and capabilities to your application without\nneeding to develop them from scratch.\n\n\nWe Recommend Expressive\n\n\nzend-mvc\n has many preconceptions\nabout how things work, yet they're very broad and general. What\u2019s more, it\nalso has several pre-wired structures in place that may either aid you \u2014\nor get in your way.\n\n\nAs a result, you are required to know a lot of what those things are \u2014 \nif\n you\nwant to use it optimally. And to acquire that depth of knowledge, you\u2019re going\nto need to spend a lot of time digging deep into zend-mvc\u2019s internals before\nyou begin to get the most out of it.\n\n\nTo quote Zend Framework project lead, \nMatthew Weier O\u2019Phinney\n:\n\n\n\n\nThe problem is that zend-mvc is anything but beginner-friendly at this point.\nYou're required to deep dive into the event manager, service manager, and\nmodule system \u2014 right from the outset; And to do this you need more than a\npassing understanding of object-oriented programming and a range of design\npatterns.\n\n\n\n\nExpressive (specifically applications based on\n\nthe Expressive Skeleton Installer\n)\non the other hand, comes with barely any of these assumptions and requirements.\n\n\nIt provides a very minimalist structure. Essentially all you have to become\nfamiliar with are five core components. These are:\n\n\n\n\nA DI container.\n\n\nA router.\n\n\nAn error handler for development.\n\n\nA template engine (if you\u2019re not creating an API).\n\n\nPSR-7 messages and http-interop (future PSR-15) middleware.\n\n\n\n\nIn many cases, these are provided for you by the skeleton, and do not require\nany additional knowledge on your part. Given that, you can quickly get up to\nspeed with the framework and begin creating the application that you need. We\nbelieve that this approach \u2014 in contrast to the zend-mvc approach \u2014\nis more flexible and accommodating.\n\n\nWhat\u2019s more, you can mix and match the types of applications that you create.\n\n\n\n\nDo you just need an API? Great; you can do that quite quickly.\n\n\nDo you want an HTML-based front-end? That\u2019s available too.\n\n\n\n\nWhen building applications with Expressive, you can make use of the various Zend\ncomponents, or any third-party components or middleware. You can pick and\nchoose what you need, as and when you need it. You\u2019re not bound by many, if\nany, constraints and design decisions.\n\n\nIn Conclusion\n\n\nFor what it\u2019s worth, we\u2019re \nnot\n saying that zend-mvc is a poor choice!  What\nwe are saying is:\n\n\n\n\nThe learning curve, from getting started to building the first application,\n   is \nsignificantly\n lower with Expressive\n\n\nThe ways in which you can create applications, whether through multiple\n   pieces of middleware or by combining multiple Expressive apps, into one\n   larger one, is a much more efficient and fluid way to work\n\n\n\n\nUltimately, the choice is always up to you, your team, and your project\u2019s needs.\nWe just want to ensure that you\u2019ve got all the information you need, to make an\ninformed decision.",
            "title": "Why choose Expressive?"
        },
        {
            "location": "/v1/why-expressive/#should-you-choose-zend-expressive-over-zend-mvc",
            "text": "We recommend that you choose Expressive for any new project \u2014  if the\nchoice is yours to make .",
            "title": "Should You Choose zend-expressive Over zend-mvc?"
        },
        {
            "location": "/v1/why-expressive/#why-use-zend-mvc",
            "text": "zend-mvc is a proven platform, with half a decade of development behind it. It\nis stable and battle-tested in production platforms.  Because it is opinionated about project structure and architecture, fewer\ndecisions need be made up front; developers know where new code goes, and how it\nwill wire into the overall application.  Additionally, a number of training courses exist, including  offerings by\nZend , allowing you\nor your team to fully learn the framework and take advantage of all its features.  Finally, zend-mvc has a lively  module ecosystem ,\nallowing you to add features and capabilities to your application without\nneeding to develop them from scratch.",
            "title": "Why Use zend-mvc?"
        },
        {
            "location": "/v1/why-expressive/#we-recommend-expressive",
            "text": "zend-mvc  has many preconceptions\nabout how things work, yet they're very broad and general. What\u2019s more, it\nalso has several pre-wired structures in place that may either aid you \u2014\nor get in your way.  As a result, you are required to know a lot of what those things are \u2014  if  you\nwant to use it optimally. And to acquire that depth of knowledge, you\u2019re going\nto need to spend a lot of time digging deep into zend-mvc\u2019s internals before\nyou begin to get the most out of it.  To quote Zend Framework project lead,  Matthew Weier O\u2019Phinney :   The problem is that zend-mvc is anything but beginner-friendly at this point.\nYou're required to deep dive into the event manager, service manager, and\nmodule system \u2014 right from the outset; And to do this you need more than a\npassing understanding of object-oriented programming and a range of design\npatterns.   Expressive (specifically applications based on the Expressive Skeleton Installer )\non the other hand, comes with barely any of these assumptions and requirements.  It provides a very minimalist structure. Essentially all you have to become\nfamiliar with are five core components. These are:   A DI container.  A router.  An error handler for development.  A template engine (if you\u2019re not creating an API).  PSR-7 messages and http-interop (future PSR-15) middleware.   In many cases, these are provided for you by the skeleton, and do not require\nany additional knowledge on your part. Given that, you can quickly get up to\nspeed with the framework and begin creating the application that you need. We\nbelieve that this approach \u2014 in contrast to the zend-mvc approach \u2014\nis more flexible and accommodating.  What\u2019s more, you can mix and match the types of applications that you create.   Do you just need an API? Great; you can do that quite quickly.  Do you want an HTML-based front-end? That\u2019s available too.   When building applications with Expressive, you can make use of the various Zend\ncomponents, or any third-party components or middleware. You can pick and\nchoose what you need, as and when you need it. You\u2019re not bound by many, if\nany, constraints and design decisions.",
            "title": "We Recommend Expressive"
        },
        {
            "location": "/v1/why-expressive/#in-conclusion",
            "text": "For what it\u2019s worth, we\u2019re  not  saying that zend-mvc is a poor choice!  What\nwe are saying is:   The learning curve, from getting started to building the first application,\n   is  significantly  lower with Expressive  The ways in which you can create applications, whether through multiple\n   pieces of middleware or by combining multiple Expressive apps, into one\n   larger one, is a much more efficient and fluid way to work   Ultimately, the choice is always up to you, your team, and your project\u2019s needs.\nWe just want to ensure that you\u2019ve got all the information you need, to make an\ninformed decision.",
            "title": "In Conclusion"
        },
        {
            "location": "/v1/reference/usage-examples/",
            "text": "Usage Examples\n\n\nBelow are several usage examples, covering a variety of ways of creating and\nmanaging an application.\n\n\nIn all examples, the assumption is the following directory structure:\n\n\n.\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 public\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 vendor\n\n\n\nWe assume also that:\n\n\n\n\nYou have installed zend-expressive per the \ninstallation instructions\n.\n\n\npublic/\n will be the document root of your application.\n\n\nYour own classes are under \nsrc/\n with the top-level namespace \nApplication\n,\n  and you have configured \nautoloading\n in your \ncomposer.json\n for those classes.\n\n\n\n\n\n\nUsing the built-in web server\n\n\nYou can use the built-in web server to run the examples. Run:\n\n\n$ php -S 0.0.0.0:8080 -t public\n\n\n\nfrom the application root to start up a web server running on port 8080, and\nthen browse to http://localhost:8080/. If you used the Expressive installer,\nthe following is equivalent:\n\n\n$ composer serve\n\n\n\nSetting up autoloading for the Application namespace\n\n\nIn your \ncomposer.json\n file, place the following:\n\n\n\"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"src/\"\n    }\n},\n\n\n\nOnce done, run:\n\n\n$ composer dump-autoload\n\n\n\n\n\nRouting\n\n\nAs noted in the \nApplication documentation\n,\nrouting is abstracted and can be accomplished by calling any of the following\nmethods:\n\n\n\n\nroute($path, $middleware, array $methods = null, $name = null)\n to route to a\n  path and match any HTTP method, multiple HTTP methods, or custom HTTP methods.\n\n\nget($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the GET HTTP method.\n\n\npost($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the POST HTTP method.\n\n\nput($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the PUT HTTP method.\n\n\npatch($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the PATCH HTTP method.\n\n\ndelete($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the DELETE HTTP method.\n\n\n\n\nAll methods return a \nZend\\Expressive\\Router\\Route\n method, which allows you to\nspecify additional options to associate with the route (e.g., for specifying\ncriteria, default values to match, etc.).\n\n\nAs examples:\n\n\n// GET\n// This demonstrates passing a callable middleware (assuming $helloWorld is\n// callable).\n$app->get('/', $helloWorld);\n\n// POST\n// This example specifies the middleware as a service name instead of as a\n// callable.\n$app->post('/trackback', 'TrackBack');\n\n// PUT\n// This example shows operating on the returned route. In this case, it's adding\n// regex tokens to restrict what values for {id} will match. (The tokens feature\n// is specific to Aura.Router.)\n$app->put('/post/{id}', 'ReplacePost')\n    ->setOptions([\n        'tokens' => [ 'id' => '\\d+' ],\n    ]);\n\n// PATCH\n// This example builds on the one above. Expressive allows you to specify\n// the same path for a route matching on a different HTTP method, and\n// corresponding to different middleware.\n$app->patch('/post/{id}', 'UpdatePost')\n    ->setOptions([\n        'tokens' => [ 'id' => '\\d+' ],\n    ]);\n\n// DELETE\n$app->delete('/post/{id}', 'DeletePost')\n    ->setOptions([\n        'tokens' => [ 'id' => '\\d+' ],\n    ]);\n\n// Matching ALL HTTP methods\n// If the underlying router supports matching any HTTP method, the following\n// will do so. Note: FastRoute *requires* you to specify the HTTP methods\n// allowed explicitly, and does not support wildcard routes. As such, the\n// following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH,\n// PUT, TRACE, and DELETE.\n// Just like the previous examples, it returns a Route instance that you can\n// further manipulate.\n$app->route('/post/{id}', 'HandlePost')\n    ->setOptions([\n        'tokens' => [ 'id' => '\\d+' ],\n    ]);\n\n// Matching multiple HTTP methods\n// You can pass an array of HTTP methods as a third argument to route(); in such\n// cases, routing will match if any of the specified HTTP methods are provided.\n$app->route('/post', 'HandlePostCollection', ['GET', 'POST']);\n\n// Matching NO HTTP methods\n// Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be\n// honored. (In FastRoute, GET is also honored.)\n$app->route('/post', 'WillThisHandlePost', []);\n\n\n\nFinally, if desired, you can create a \nZend\\Expressive\\Router\\Route\n instance\nmanually and pass it to \nroute()\n as the sole argument:\n\n\n$route = new Route('/post', 'HandlePost', ['GET', 'POST']);\n$route->setOptions($options);\n\n$app->route($route);\n\n\n\nHello World using a Container\n\n\nExpressive works with \ncontainer-interop\n,\nthough it's an optional feature. By default, if you use the \nAppFactory\n, it\nwill use \nzend-servicemanager\n.\n\n\nIn the following example, we'll populate the container with our middleware, and\nthe application will pull it from there when matched.\n\n\nEdit your \npublic/index.php\n to read as follows:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$container = new ServiceManager();\n\n$container->setFactory('HelloWorld', function ($container) {\n    return function ($req, $res, $next) {\n        $res->getBody()->write('Hello, world!');\n        return $res;\n    };\n});\n\n$container->setFactory('Ping', function ($container) {\n    return function ($req, $res, $next) {\n        return new JsonResponse(['ack' => time()]);\n    };\n});\n\n$app = AppFactory::create($container);\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n$app->run();\n\n\n\nIn the example above, we pass our container to \nAppFactory\n. We could have also\ndone this instead:\n\n\n$app = AppFactory::create();\n$container = $app->getContainer();\n\n\n\nand then added our service definitions. We recommend passing the container to\nthe factory instead; if we ever change which container we use by default, your\ncode might not work!\n\n\nThe following two lines are the ones of interest:\n\n\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n\n\nThese map the two paths to \nservice names\n instead of callables. When routing\nmatches a path, it does the following:\n\n\n\n\nIf the middleware provided when defining the route is callable, it uses it\n  directly.\n\n\nIf the middleware is a valid service name in the container, it pulls it from\n  the container. \nThis is what happens in this example.\n\n\nFinally, if no container is available, or the service name is not found in the\n  container, it checks to see if it's a valid class name; if so, it instantiates\n  and returns the class instance.\n\n\n\n\nIf you fire up your web server, you'll find that the \n/\n and \n/ping\n paths\ncontinue to work.\n\n\nOne other approach you could take would be to define the application itself in\nthe container, and then pull it from there:\n\n\n$container->setFactory('Zend\\Expressive\\Application', function ($container) {\n    $app = AppFactory::create($container);\n    $app->get('/', 'HelloWorld');\n    $app->get('/ping', 'Ping');\n    return $app;\n});\n\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();\n\n\n\nThis is a nice way to encapsulate the application creation. You could then\npotentially move all service configuration to another file! (We already\n\ndocument an ApplicationFactory for exactly this scenario.\n)\n\n\nHello World using a Configuration-Driven Container\n\n\nIn the above example, we configured our middleware as services, and then passed\nour service container to the application. At the end, we hinted that you could\npotentially define the application itself as a service.\n\n\nExpressive already provides a service factory for the application instance\nto provide fine-grained control over your application. In this example, we'll\nleverage it, defining our routes via configuration.\n\n\nFirst, we're going to leverage zend-config to merge configuration files. This is\nimportant, as it allows us to define local, environment-specific configuration\nin files that we then can exclude from our repository. This practice ensures\nthat things like credentials are not accidentally published in a public\nrepository, and also provides a mechanism for slip-streaming in\nconfiguration based on our environment (you might use different settings in\ndevelopment than in production, after all!).\n\n\nFirst, install zend-config and zend-stdlib:\n\n\n$ composer require zendframework/zend-config zendframework/zend-stdlib\n\n\n\nNow we can start creating our configuration files and container factories.\n\n\nIn \nconfig/config.php\n, place the following:\n\n\n<?php\n\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Stdlib\\Glob;\n\n$config = [];\n// Load configuration from autoload path\nforeach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) {\n    $config = ArrayUtils::merge($config, include $file);\n}\n\n// Return an ArrayObject so we can inject the config as a service in Aura.Di\n// and still use array checks like ``is_array``.\nreturn new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS);\n\n\n\nIn \nconfig/container.php\n, place the following:\n\n\n<?php\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// Load configuration\n$config = require __DIR__.'/config.php';\n\n// Build container\n$container = new ServiceManager();\n(new Config($config['dependencies']))->configureServiceManager($container);\n\n// Inject config\n$container->setService('config', $config);\n\nreturn $container;\n\n\n\nIn \nconfig/autoload/dependencies.global.php\n, place the following:\n\n\n<?php\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            \\Application\\HelloWorldAction::class => InvokableFactory::class,\n            \\Application\\PingAction::class => InvokableFactory::class,\n        ],\n        'factories' => [\n            \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class,\n        ],\n    ]\n];\n\n\n\nIn \nconfig/autoload/routes.global.php\n, place the following:\n\n\n<?php\n\nreturn [\n    'routes' => [\n        [\n            'path' => '/',\n            'middleware' => \\Application\\HelloWorldAction::class,\n            'allowed_methods' => [ 'GET' ],\n        ],\n        [\n            'path' => '/ping',\n            'middleware' => \\Application\\PingAction::class,\n            'allowed_methods' => [ 'GET' ],\n        ],\n    ],\n];\n\n\n\nIn \nsrc/Application/HelloWorld.php\n, place the following:\n\n\n<?php\nnamespace Application;\n\nclass HelloWorld\n{\n    public function __invoke($req, $res, $next)\n    {\n        $res->getBody()->write('Hello, world!');\n        return $res;\n    }\n}\n\n\n\nIn \nsrc/Application/Ping.php\n, place the following:\n\n\n<?php\nnamespace Application;\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass Ping\n{\n    public function __invoke($req, $res, $next)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}\n\n\n\nAfter that\u2019s done run:\n\n\ncomposer dump-autoload\n\n\n\nFinally, in \npublic/index.php\n, place the following:\n\n\n<?php\n// Change to the project root, to simplify resolving paths\nchdir(dirname(__DIR__));\n\n// Setup autoloading\nrequire 'vendor/autoload.php';\n\n$container = include 'config/services.php';\n$app       = $container->get(Zend\\Expressive\\Application::class);\n$app->run();\n\n\n\nNotice that our index file now doesn't have any code related to setting up the\napplication any longer! All it does is setup autoloading, retrieve our service\ncontainer, pull the application from it, and run it. Our choices for container,\nrouter, etc. are all abstracted, and if we change our mind later, this code will\ncontinue to work.\n\n\nFiring up the web server, you'll see the same responses as the previous\nexamples.\n\n\nHybrid Container and Programmatic Creation\n\n\nThe above example may look a little daunting at first. By making everything\nconfiguration-driven, you sometimes lose a sense for how the code all fits\ntogether.\n\n\nFortunately, you can mix the two. Building on the example above, we'll add a new\nroute and middleware. Between pulling the application from the container and\ncalling \n$app->run()\n, add the following in your \npublic/index.php\n:\n\n\n$app->post('/post', function ($req, $res, $next) {\n    $res->getBody()->write('IN POST!');\n    return $res;\n});\n\n\n\nNote that we're using \npost()\n here; that means you'll have to use cURL, HTTPie,\nPostman, or some other tool to test making a POST request to the path:\n\n\n$ curl -X POST http://localhost:8080/post\n\n\n\nYou should see \nIN POST!\n for the response!\n\n\nUsing this approach, you can build re-usable applications that are\ncontainer-driven, and add one-off routes and middleware as needed.\n\n\nUsing the container to register middleware\n\n\nIf you use a container to fetch your application instance, you have an\nadditional option for specifying middleware for the pipeline: configuration:\n\n\n<?php\nreturn [\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware Service Name or Callable',\n            'allowed_methods' => [ 'GET', 'POST', 'PATCH' ],\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n    'middleware_pipeline' => [\n        // See specification below\n    ],\n];\n\n\n\nThe key to note is \nmiddleware_pipeline\n, which is an array of middlewares to\nregister in the pipeline; each will each be \npipe()\n'd to the Application in the\norder specified.\n\n\nEach middleware specified must be in the following form:\n\n\n[\n    // required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // optional:\n    'path'  => '/path/to/match',\n    'error' => true,\n    'priority' => 1, // Integer\n]\n\n\n\nPriority should be an integer, and follows the semantics of\n\nSplPriorityQueue\n: higher numbers indicate\nhigher priority (top of the queue; executed earliest), while lower numbers\nindicated lower priority (bottom of the queue, executed last); \nnegative values\nare low priority\n. Items of the same priority are executed in the order in which\nthey are attached.\n\n\nThe default priority is 1, and this priority is used by the routing and dispatch\nmiddleware. To indicate that middleware should execute \nbefore\n these, use a\npriority higher than 1. For error middleware, use a priority less than 1.\n\n\nThe above specification can be used for all middleware, with one exception:\nregistration of the \nrouting\n and/or \ndispatch\n middleware that Expressive\nprovides. In these cases, use the following constants, which will be caught by\nthe factory and expanded:\n\n\n\n\nZend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE\n for the\n  routing middleware; this should always come before the dispatch middleware.\n\n\nZend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE\n for the\n  dispatch middleware.\n\n\n\n\nAs an example:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n        Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        [ /* ... */ ],\n    ],\n];\n\n\n\n\n\nPlace routing middleware correctly\n\n\nIf you are defining routes \nand\n defining other middleware for the pipeline,\nyou \nmust\n add the routing middleware. When you do so, make sure you put\nit at the appropriate location in the pipeline.\n\n\nTypically, you will place any middleware you want to execute on all requests\nprior to the routing middleware. This includes utilities for bootstrapping\nthe application (such as injection of the \nServerUrlHelper\n),\nutilities for injecting common response headers (such as CORS support), etc.\nMake sure these middleware specifications include the \npriority\n key, and that\nthe value of this key is greater than 1.\n\n\nPlace \nerror\n middleware \nafter\n the routing middleware. This is middleware\nthat should only execute if routing fails or routed middleware cannot complete\nthe response. These specifications should also include the \npriority\n key, and\nthe value of that key for such middleware should be less than 1 or negative.\n\n\nUse priority to shape the specific workflow you want for your middleware.\n\n\n\n\nMiddleware items may be any callable, \nZend\\Stratigility\\MiddlewareInterface\n\nimplementation, or a service name that resolves to one of the two. Additionally,\nyou can specify an array of such values; these will be composed in a single\n\nZend\\Stratigility\\MiddlewarePipe\n instance, allowing layering of middleware.\nIn fact, you can specify the various \nApplicationFactory::*_MIDDLEWARE\n\nconstants in such arrays as well:\n\n\nreturn [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                /* ... middleware that introspects routing results ... */\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        [ /* ... */ ],\n    ],\n];\n\n\n\n\n\nPipeline keys are ignored\n\n\nKeys in a \nmiddleware_pipeline\n specification are ignored. However, they can\nbe useful when merging several configurations; if multiple configuration files\nspecify the same key, then those entries will be merged. Be aware, however,\nthat the \nmiddleware\n entry for each, since it is an indexed array, will\nmerge arrays by appending; in other words, order will not be guaranteed within\nthat array after merging. If order is critical, define a middleware spec with\n\npriority\n keys.\n\n\n\n\nThe path, if specified, can only be a literal path to match, and is typically\nused for segregating middleware applications or applying rules to subsets of an\napplication that match a common path root.\n\n\nerror\n indicates whether or not the middleware represents error middleware;\nthis is done to ensure that lazy-loading of error middleware works as expected.\n\n\n\n\nLazy-loaded Middleware\n\n\nOne feature of the \nmiddleware_pipeline\n is that any middleware service pulled\nfrom the container is actually wrapped in a closure:\n\n\nfunction ($request, $response, $next = null) use ($container, $middleware) {\n    $invokable = $container->get($middleware);\n    if (! is_callable($invokable)) {\n        throw new Exception\\InvalidMiddlewareException(sprintf(\n            'Lazy-loaded middleware \"%s\" is not invokable',\n            $middleware\n        ));\n    }\n    return $invokable($request, $response, $next);\n};\n\n\n\nIf the \nerror\n flag is specified and is truthy, the closure looks like this\ninstead, to ensure the middleware is treated by Stratigility as error\nmiddleware:\n\n\nfunction ($error, $request, $response, $next) use ($container, $middleware) {\n    $invokable = $container->get($middleware);\n    if (! is_callable($invokable)) {\n        throw new Exception\\InvalidMiddlewareException(sprintf(\n            'Lazy-loaded middleware \"%s\" is not invokable',\n            $middleware\n        ));\n    }\n    return $invokable($error, $request, $response, $next);\n};\n\n\n\nThis implements \nlazy-loading\n for middleware pipeline services, delaying\nretrieval from the container until the middleware is actually invoked.\n\n\nThis also means that if the service specified is not valid middleware, you\nwill not find out until the application attempts to invoke it.\n\n\n\n\nSegregating your application to a subpath\n\n\nOne benefit of a middleware-based application is the ability to compose\nmiddleware and segregate them by paths. \nZend\\Expressive\\Application\n is itself\nmiddleware, allowing you to do exactly that if desired.\n\n\nIn the following example, we'll assume that \n$api\n and \n$blog\n are\n\nZend\\Expressive\\Application\n instances, and compose them into a\n\nZend\\Stratigility\\MiddlewarePipe\n.\n\n\nuse Zend\\Diactoros\\Server;\nuse Zend\\Diactoros\\ServerRequestFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$server = Server::createServerFromRequest(\n    $app,\n    ServerRequestFactory::fromGlobals()\n);\n$server->listen();\n\n\n\nYou could also compose them in an \nApplication\n instance, and utilize \nrun()\n:\n\n\n$app = AppFactory::create();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$app->run();\n\n\n\nThis approach allows you to develop discrete applications and compose them\ntogether to create a website.",
            "title": "Examples"
        },
        {
            "location": "/v1/reference/usage-examples/#usage-examples",
            "text": "Below are several usage examples, covering a variety of ways of creating and\nmanaging an application.  In all examples, the assumption is the following directory structure:  .\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 public\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 vendor  We assume also that:   You have installed zend-expressive per the  installation instructions .  public/  will be the document root of your application.  Your own classes are under  src/  with the top-level namespace  Application ,\n  and you have configured  autoloading  in your  composer.json  for those classes.",
            "title": "Usage Examples"
        },
        {
            "location": "/v1/reference/usage-examples/#using-the-built-in-web-server",
            "text": "You can use the built-in web server to run the examples. Run:  $ php -S 0.0.0.0:8080 -t public  from the application root to start up a web server running on port 8080, and\nthen browse to http://localhost:8080/. If you used the Expressive installer,\nthe following is equivalent:  $ composer serve",
            "title": "Using the built-in web server"
        },
        {
            "location": "/v1/reference/usage-examples/#setting-up-autoloading-for-the-application-namespace",
            "text": "In your  composer.json  file, place the following:  \"autoload\": {\n    \"psr-4\": {\n        \"Application\\\\\": \"src/\"\n    }\n},  Once done, run:  $ composer dump-autoload",
            "title": "Setting up autoloading for the Application namespace"
        },
        {
            "location": "/v1/reference/usage-examples/#routing",
            "text": "As noted in the  Application documentation ,\nrouting is abstracted and can be accomplished by calling any of the following\nmethods:   route($path, $middleware, array $methods = null, $name = null)  to route to a\n  path and match any HTTP method, multiple HTTP methods, or custom HTTP methods.  get($path, $middleware, $name = null)  to route to a path that will only\n  respond to the GET HTTP method.  post($path, $middleware, $name = null)  to route to a path that will only\n  respond to the POST HTTP method.  put($path, $middleware, $name = null)  to route to a path that will only\n  respond to the PUT HTTP method.  patch($path, $middleware, $name = null)  to route to a path that will only\n  respond to the PATCH HTTP method.  delete($path, $middleware, $name = null)  to route to a path that will only\n  respond to the DELETE HTTP method.   All methods return a  Zend\\Expressive\\Router\\Route  method, which allows you to\nspecify additional options to associate with the route (e.g., for specifying\ncriteria, default values to match, etc.).  As examples:  // GET\n// This demonstrates passing a callable middleware (assuming $helloWorld is\n// callable).\n$app->get('/', $helloWorld);\n\n// POST\n// This example specifies the middleware as a service name instead of as a\n// callable.\n$app->post('/trackback', 'TrackBack');\n\n// PUT\n// This example shows operating on the returned route. In this case, it's adding\n// regex tokens to restrict what values for {id} will match. (The tokens feature\n// is specific to Aura.Router.)\n$app->put('/post/{id}', 'ReplacePost')\n    ->setOptions([\n        'tokens' => [ 'id' => '\\d+' ],\n    ]);\n\n// PATCH\n// This example builds on the one above. Expressive allows you to specify\n// the same path for a route matching on a different HTTP method, and\n// corresponding to different middleware.\n$app->patch('/post/{id}', 'UpdatePost')\n    ->setOptions([\n        'tokens' => [ 'id' => '\\d+' ],\n    ]);\n\n// DELETE\n$app->delete('/post/{id}', 'DeletePost')\n    ->setOptions([\n        'tokens' => [ 'id' => '\\d+' ],\n    ]);\n\n// Matching ALL HTTP methods\n// If the underlying router supports matching any HTTP method, the following\n// will do so. Note: FastRoute *requires* you to specify the HTTP methods\n// allowed explicitly, and does not support wildcard routes. As such, the\n// following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH,\n// PUT, TRACE, and DELETE.\n// Just like the previous examples, it returns a Route instance that you can\n// further manipulate.\n$app->route('/post/{id}', 'HandlePost')\n    ->setOptions([\n        'tokens' => [ 'id' => '\\d+' ],\n    ]);\n\n// Matching multiple HTTP methods\n// You can pass an array of HTTP methods as a third argument to route(); in such\n// cases, routing will match if any of the specified HTTP methods are provided.\n$app->route('/post', 'HandlePostCollection', ['GET', 'POST']);\n\n// Matching NO HTTP methods\n// Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be\n// honored. (In FastRoute, GET is also honored.)\n$app->route('/post', 'WillThisHandlePost', []);  Finally, if desired, you can create a  Zend\\Expressive\\Router\\Route  instance\nmanually and pass it to  route()  as the sole argument:  $route = new Route('/post', 'HandlePost', ['GET', 'POST']);\n$route->setOptions($options);\n\n$app->route($route);",
            "title": "Routing"
        },
        {
            "location": "/v1/reference/usage-examples/#hello-world-using-a-container",
            "text": "Expressive works with  container-interop ,\nthough it's an optional feature. By default, if you use the  AppFactory , it\nwill use  zend-servicemanager .  In the following example, we'll populate the container with our middleware, and\nthe application will pull it from there when matched.  Edit your  public/index.php  to read as follows:  use Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$container = new ServiceManager();\n\n$container->setFactory('HelloWorld', function ($container) {\n    return function ($req, $res, $next) {\n        $res->getBody()->write('Hello, world!');\n        return $res;\n    };\n});\n\n$container->setFactory('Ping', function ($container) {\n    return function ($req, $res, $next) {\n        return new JsonResponse(['ack' => time()]);\n    };\n});\n\n$app = AppFactory::create($container);\n$app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n$app->run();  In the example above, we pass our container to  AppFactory . We could have also\ndone this instead:  $app = AppFactory::create();\n$container = $app->getContainer();  and then added our service definitions. We recommend passing the container to\nthe factory instead; if we ever change which container we use by default, your\ncode might not work!  The following two lines are the ones of interest:  $app->get('/', 'HelloWorld');\n$app->get('/ping', 'Ping');  These map the two paths to  service names  instead of callables. When routing\nmatches a path, it does the following:   If the middleware provided when defining the route is callable, it uses it\n  directly.  If the middleware is a valid service name in the container, it pulls it from\n  the container.  This is what happens in this example.  Finally, if no container is available, or the service name is not found in the\n  container, it checks to see if it's a valid class name; if so, it instantiates\n  and returns the class instance.   If you fire up your web server, you'll find that the  /  and  /ping  paths\ncontinue to work.  One other approach you could take would be to define the application itself in\nthe container, and then pull it from there:  $container->setFactory('Zend\\Expressive\\Application', function ($container) {\n    $app = AppFactory::create($container);\n    $app->get('/', 'HelloWorld');\n    $app->get('/ping', 'Ping');\n    return $app;\n});\n\n$app = $container->get('Zend\\Expressive\\Application');\n$app->run();  This is a nice way to encapsulate the application creation. You could then\npotentially move all service configuration to another file! (We already document an ApplicationFactory for exactly this scenario. )",
            "title": "Hello World using a Container"
        },
        {
            "location": "/v1/reference/usage-examples/#hello-world-using-a-configuration-driven-container",
            "text": "In the above example, we configured our middleware as services, and then passed\nour service container to the application. At the end, we hinted that you could\npotentially define the application itself as a service.  Expressive already provides a service factory for the application instance\nto provide fine-grained control over your application. In this example, we'll\nleverage it, defining our routes via configuration.  First, we're going to leverage zend-config to merge configuration files. This is\nimportant, as it allows us to define local, environment-specific configuration\nin files that we then can exclude from our repository. This practice ensures\nthat things like credentials are not accidentally published in a public\nrepository, and also provides a mechanism for slip-streaming in\nconfiguration based on our environment (you might use different settings in\ndevelopment than in production, after all!).  First, install zend-config and zend-stdlib:  $ composer require zendframework/zend-config zendframework/zend-stdlib  Now we can start creating our configuration files and container factories.  In  config/config.php , place the following:  <?php\n\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Stdlib\\Glob;\n\n$config = [];\n// Load configuration from autoload path\nforeach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) {\n    $config = ArrayUtils::merge($config, include $file);\n}\n\n// Return an ArrayObject so we can inject the config as a service in Aura.Di\n// and still use array checks like ``is_array``.\nreturn new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS);  In  config/container.php , place the following:  <?php\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// Load configuration\n$config = require __DIR__.'/config.php';\n\n// Build container\n$container = new ServiceManager();\n(new Config($config['dependencies']))->configureServiceManager($container);\n\n// Inject config\n$container->setService('config', $config);\n\nreturn $container;  In  config/autoload/dependencies.global.php , place the following:  <?php\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            \\Application\\HelloWorldAction::class => InvokableFactory::class,\n            \\Application\\PingAction::class => InvokableFactory::class,\n        ],\n        'factories' => [\n            \\Zend\\Expressive\\Application::class => \\Zend\\Expressive\\Container\\ApplicationFactory::class,\n        ],\n    ]\n];  In  config/autoload/routes.global.php , place the following:  <?php\n\nreturn [\n    'routes' => [\n        [\n            'path' => '/',\n            'middleware' => \\Application\\HelloWorldAction::class,\n            'allowed_methods' => [ 'GET' ],\n        ],\n        [\n            'path' => '/ping',\n            'middleware' => \\Application\\PingAction::class,\n            'allowed_methods' => [ 'GET' ],\n        ],\n    ],\n];  In  src/Application/HelloWorld.php , place the following:  <?php\nnamespace Application;\n\nclass HelloWorld\n{\n    public function __invoke($req, $res, $next)\n    {\n        $res->getBody()->write('Hello, world!');\n        return $res;\n    }\n}  In  src/Application/Ping.php , place the following:  <?php\nnamespace Application;\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass Ping\n{\n    public function __invoke($req, $res, $next)\n    {\n        return new JsonResponse(['ack' => time()]);\n    }\n}  After that\u2019s done run:  composer dump-autoload  Finally, in  public/index.php , place the following:  <?php\n// Change to the project root, to simplify resolving paths\nchdir(dirname(__DIR__));\n\n// Setup autoloading\nrequire 'vendor/autoload.php';\n\n$container = include 'config/services.php';\n$app       = $container->get(Zend\\Expressive\\Application::class);\n$app->run();  Notice that our index file now doesn't have any code related to setting up the\napplication any longer! All it does is setup autoloading, retrieve our service\ncontainer, pull the application from it, and run it. Our choices for container,\nrouter, etc. are all abstracted, and if we change our mind later, this code will\ncontinue to work.  Firing up the web server, you'll see the same responses as the previous\nexamples.",
            "title": "Hello World using a Configuration-Driven Container"
        },
        {
            "location": "/v1/reference/usage-examples/#hybrid-container-and-programmatic-creation",
            "text": "The above example may look a little daunting at first. By making everything\nconfiguration-driven, you sometimes lose a sense for how the code all fits\ntogether.  Fortunately, you can mix the two. Building on the example above, we'll add a new\nroute and middleware. Between pulling the application from the container and\ncalling  $app->run() , add the following in your  public/index.php :  $app->post('/post', function ($req, $res, $next) {\n    $res->getBody()->write('IN POST!');\n    return $res;\n});  Note that we're using  post()  here; that means you'll have to use cURL, HTTPie,\nPostman, or some other tool to test making a POST request to the path:  $ curl -X POST http://localhost:8080/post  You should see  IN POST!  for the response!  Using this approach, you can build re-usable applications that are\ncontainer-driven, and add one-off routes and middleware as needed.",
            "title": "Hybrid Container and Programmatic Creation"
        },
        {
            "location": "/v1/reference/usage-examples/#using-the-container-to-register-middleware",
            "text": "If you use a container to fetch your application instance, you have an\nadditional option for specifying middleware for the pipeline: configuration:  <?php\nreturn [\n    'routes' => [\n        [\n            'path' => '/path/to/match',\n            'middleware' => 'Middleware Service Name or Callable',\n            'allowed_methods' => [ 'GET', 'POST', 'PATCH' ],\n            'options' => [\n                'stuff' => 'to',\n                'pass'  => 'to',\n                'the'   => 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n    'middleware_pipeline' => [\n        // See specification below\n    ],\n];  The key to note is  middleware_pipeline , which is an array of middlewares to\nregister in the pipeline; each will each be  pipe() 'd to the Application in the\norder specified.  Each middleware specified must be in the following form:  [\n    // required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // optional:\n    'path'  => '/path/to/match',\n    'error' => true,\n    'priority' => 1, // Integer\n]  Priority should be an integer, and follows the semantics of SplPriorityQueue : higher numbers indicate\nhigher priority (top of the queue; executed earliest), while lower numbers\nindicated lower priority (bottom of the queue, executed last);  negative values\nare low priority . Items of the same priority are executed in the order in which\nthey are attached.  The default priority is 1, and this priority is used by the routing and dispatch\nmiddleware. To indicate that middleware should execute  before  these, use a\npriority higher than 1. For error middleware, use a priority less than 1.  The above specification can be used for all middleware, with one exception:\nregistration of the  routing  and/or  dispatch  middleware that Expressive\nprovides. In these cases, use the following constants, which will be caught by\nthe factory and expanded:   Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE  for the\n  routing middleware; this should always come before the dispatch middleware.  Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE  for the\n  dispatch middleware.   As an example:  return [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n        Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        [ /* ... */ ],\n    ],\n];",
            "title": "Using the container to register middleware"
        },
        {
            "location": "/v1/reference/usage-examples/#place-routing-middleware-correctly",
            "text": "If you are defining routes  and  defining other middleware for the pipeline,\nyou  must  add the routing middleware. When you do so, make sure you put\nit at the appropriate location in the pipeline.  Typically, you will place any middleware you want to execute on all requests\nprior to the routing middleware. This includes utilities for bootstrapping\nthe application (such as injection of the  ServerUrlHelper ),\nutilities for injecting common response headers (such as CORS support), etc.\nMake sure these middleware specifications include the  priority  key, and that\nthe value of this key is greater than 1.  Place  error  middleware  after  the routing middleware. This is middleware\nthat should only execute if routing fails or routed middleware cannot complete\nthe response. These specifications should also include the  priority  key, and\nthe value of that key for such middleware should be less than 1 or negative.  Use priority to shape the specific workflow you want for your middleware.   Middleware items may be any callable,  Zend\\Stratigility\\MiddlewareInterface \nimplementation, or a service name that resolves to one of the two. Additionally,\nyou can specify an array of such values; these will be composed in a single Zend\\Stratigility\\MiddlewarePipe  instance, allowing layering of middleware.\nIn fact, you can specify the various  ApplicationFactory::*_MIDDLEWARE \nconstants in such arrays as well:  return [\n    'middleware_pipeline' => [\n        [ /* ... */ ],\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                /* ... middleware that introspects routing results ... */\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        [ /* ... */ ],\n    ],\n];",
            "title": "Place routing middleware correctly"
        },
        {
            "location": "/v1/reference/usage-examples/#pipeline-keys-are-ignored",
            "text": "Keys in a  middleware_pipeline  specification are ignored. However, they can\nbe useful when merging several configurations; if multiple configuration files\nspecify the same key, then those entries will be merged. Be aware, however,\nthat the  middleware  entry for each, since it is an indexed array, will\nmerge arrays by appending; in other words, order will not be guaranteed within\nthat array after merging. If order is critical, define a middleware spec with priority  keys.   The path, if specified, can only be a literal path to match, and is typically\nused for segregating middleware applications or applying rules to subsets of an\napplication that match a common path root.  error  indicates whether or not the middleware represents error middleware;\nthis is done to ensure that lazy-loading of error middleware works as expected.",
            "title": "Pipeline keys are ignored"
        },
        {
            "location": "/v1/reference/usage-examples/#lazy-loaded-middleware",
            "text": "One feature of the  middleware_pipeline  is that any middleware service pulled\nfrom the container is actually wrapped in a closure:  function ($request, $response, $next = null) use ($container, $middleware) {\n    $invokable = $container->get($middleware);\n    if (! is_callable($invokable)) {\n        throw new Exception\\InvalidMiddlewareException(sprintf(\n            'Lazy-loaded middleware \"%s\" is not invokable',\n            $middleware\n        ));\n    }\n    return $invokable($request, $response, $next);\n};  If the  error  flag is specified and is truthy, the closure looks like this\ninstead, to ensure the middleware is treated by Stratigility as error\nmiddleware:  function ($error, $request, $response, $next) use ($container, $middleware) {\n    $invokable = $container->get($middleware);\n    if (! is_callable($invokable)) {\n        throw new Exception\\InvalidMiddlewareException(sprintf(\n            'Lazy-loaded middleware \"%s\" is not invokable',\n            $middleware\n        ));\n    }\n    return $invokable($error, $request, $response, $next);\n};  This implements  lazy-loading  for middleware pipeline services, delaying\nretrieval from the container until the middleware is actually invoked.  This also means that if the service specified is not valid middleware, you\nwill not find out until the application attempts to invoke it.",
            "title": "Lazy-loaded Middleware"
        },
        {
            "location": "/v1/reference/usage-examples/#segregating-your-application-to-a-subpath",
            "text": "One benefit of a middleware-based application is the ability to compose\nmiddleware and segregate them by paths.  Zend\\Expressive\\Application  is itself\nmiddleware, allowing you to do exactly that if desired.  In the following example, we'll assume that  $api  and  $blog  are Zend\\Expressive\\Application  instances, and compose them into a Zend\\Stratigility\\MiddlewarePipe .  use Zend\\Diactoros\\Server;\nuse Zend\\Diactoros\\ServerRequestFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$server = Server::createServerFromRequest(\n    $app,\n    ServerRequestFactory::fromGlobals()\n);\n$server->listen();  You could also compose them in an  Application  instance, and utilize  run() :  $app = AppFactory::create();\n$app->pipe('/blog', $blog);\n$app->pipe('/api', $api);\n\n$app->run();  This approach allows you to develop discrete applications and compose them\ntogether to create a website.",
            "title": "Segregating your application to a subpath"
        },
        {
            "location": "/v1/reference/expressive-projects/",
            "text": "Projects powered by zend-expressive\n\n\nzend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.\n\n\nSample Code & Tutorials\n\n\n\n\nExpressive Tutorial (WIP) - \nsource\n\n\nAstroSplash\n - \nsource\n\n  (Also, read the \nrelated article on sitepoint\n)\n\n\nphp-ddd-cargo-sample\n - \nsource\n\n\n\n\nPersonal Sites\n\n\n\n\nmwop.net\n - \nsource\n\n\nxtreamwayz.com\n - \nsource\n\n\nalejandrocelaya.com\n - \nsource\n\n\nzimuel.it\n - \nsource",
            "title": "Expressive Projects"
        },
        {
            "location": "/v1/reference/expressive-projects/#projects-powered-by-zend-expressive",
            "text": "zend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.",
            "title": "Projects powered by zend-expressive"
        },
        {
            "location": "/v1/reference/expressive-projects/#sample-code-tutorials",
            "text": "Expressive Tutorial (WIP) -  source  AstroSplash  -  source \n  (Also, read the  related article on sitepoint )  php-ddd-cargo-sample  -  source",
            "title": "Sample Code &amp; Tutorials"
        },
        {
            "location": "/v1/reference/expressive-projects/#personal-sites",
            "text": "mwop.net  -  source  xtreamwayz.com  -  source  alejandrocelaya.com  -  source  zimuel.it  -  source",
            "title": "Personal Sites"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/",
            "text": "Migration from RC5 or earlier\n\n\nRC6 introduced changes to the following:\n\n\n\n\nThe routing middleware was split into separate middleware, one for routing,\n  and one for dispatching.\n\n\nDue to the above change, we decided to remove auto-registration of routing\n  middleware.\n\n\nThe above change also suggested an alternative to the middleware pipeline\n  configuration that simplifies it.\n\n\nRoute result observers are deprecated, and no longer triggered for routing\n  failures.\n\n\nMiddleware configuration specifications now accept a \npriority\n key to\n  guarantee the order of items. If you have defined your middleware pipeline in\n  multiple files that are then merged, you will need to defined these keys to\n  ensure order.\n\n\n\n\nRouting and Dispatch middleware\n\n\nPrior to RC6, the routing middleware:\n\n\n\n\nperformed routing\n\n\nnotified route result observers\n\n\ncreated a new request that composed the matched routing parameters as request\n  attributes, and composed the route result instance itself as a request\n  attribute.\n\n\nmarshaled the middleware matched by routing\n\n\ndispatched the marshaled middleware\n\n\n\n\nTo provide a better separation of concerns, we split the routing middleware into\ntwo distinct methods: \nroutingMiddleware()\n and \ndispatchMiddleware()\n.\n\n\nroutingMiddleware()\n performs the following duties:\n\n\n\n\nrouting; and\n\n\ncreating a new request that composes the matched routing parameters as request\n  attributes, and composes the route result instance itself as a request\n  attribute.\n\n\n\n\ndispatchMiddleware()\n performs the following duties:\n\n\n\n\nmarshaling the middleware specified in the route result; and\n\n\ndispatching the marshaled middleware.\n\n\n\n\nOne reason for this split is to allow injecting middleware to operate between\nrouting and dispatch. As an example, you could have middleware that determines\nif a matched route requires an authenticated identity:\n\n\npublic function __invoke($request, $response, $next)\n{\n    $result = $request->getAttribute(RouteResult::class);\n    if (! in_array($result->getMatchedRouteName(), $this->authRequired)) {\n        return $next($request, $response);\n    }\n\n    if (! $this->authenticated) {\n        return $next($request, $response->withStatus(401), 'authentication\n        required');\n    }\n}\n\n\n\nThe above could then be piped between the routing and dispatch middleware:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipe(AuthenticationMiddleware::class);\n$app->pipeDispatchMiddleware();\n\n\n\nSince the routing middleware has been split, we determined we could no longer\nautomatically pipe the routing middleware; detection would require detecting\nboth sets of middleware, and ensuring they are in the correct order.\nAdditionally, since one goal of splitting the middleware is to allow\n\nsubstitutions\n for these responsibilities, auto-injection could in some cases\nbe undesired. As a result, we now require you to inject each manually.\n\n\nImpact\n\n\nThis change will require changes in your application.\n\n\n\n\nIf you are using Expressive programmatically (i.e., you are not using\n   a container and the \nZend\\Expressive\\Container\\ApplicationFactory\n),\n   you are now \nrequired\n to call \nApplication::pipeRoutingMiddleware()\n.\n   Additionally, a new method, \nApplication::pipeDispatchMiddleware()\n exists\n   for injecting the application with the dispatch middleware, this, too, must\n   be called.\n\n\n\n\nThis has a fortunate side effect: registering routed middleware no longer\n   affects the middleware pipeline order. As such, you can register your\n   pipeline first or last prior to running the application. The only stipulation\n   is that \nunless you register the routing \nand\n dispatch middleware, your routed\n   middleware will not be executed!\n As such, the following two lines \nmust\n\n   be added to your application prior to calling \nApplication::run()\n:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\n\n\nIf you are creating your \nApplication\n instance using a container and the\n   \nZend\\Expressive\\Container\\ApplicationFactory\n, you will need to update your\n   configuration to list the routing and dispatch middleware. The next section\n   details the configuration changes necessary.\n\n\n\n\nApplicationFactory configuration changes\n\n\nAs noted in the document summary, the middleware pipeline configuration was\nchanged starting in RC6.  The changes are done in such a way as to honor\nconfiguration from RC5 and earlier, but using such configuration will now prompt\nyou to update your application.\n\n\nRC5 and earlier defined the default \nmiddleware_pipeline\n configuration as follows:\n\n\nreturn [\n    'middleware_pipeline' => [\n        // An array of middleware to register prior to registration of the\n        // routing middleware\n        'pre_routing' => [\n            //[\n            // Required:\n            //    'middleware' => 'Name or array of names of middleware services and/or callables',\n            // Optional:\n            //    'path'  => '/path/to/match',\n            //    'error' => true,\n            //],\n            [\n                'middleware' => [\n                    Helper\\ServerUrlMiddleware::class,\n                    Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n        ],\n\n        // An array of middleware to register after registration of the\n        // routing middleware\n        'post_routing' => [\n            //[\n            // Required:\n            //    'middleware' => 'Name of middleware service, or a callable',\n            // Optional:\n            //    'path'  => '/path/to/match',\n            //    'error' => true,\n            //],\n        ],\n    ],\n];\n\n\n\nThe following changes have been made:\n\n\n\n\nThe concept of \npre_routing\n and \npost_routing\n have been deprecated, and will\n  be removed starting with the 1.1 version. A single middleware pipeline is now\n  provided, though \nany individual specification can also specify an array of\n  middleware\n.\n\n\nThe routing and dispatch middleware must now be added to your configuration\n  for them to be added to your application.\n\n\nMiddleware specifications can now optionally provide a \npriority\n key, with 1\n  being the default. High integer priority indicates earlier execution, while\n  low/negative integer priority indicates later execution. Items with the same\n  priority are executed in the order they are registered. Priority is now how\n  you can indicate the order in which middleware should execute.\n\n\n\n\nImpact\n\n\nWhile the configuration from RC5 and earlier will continue to work, it will\nraise deprecation notices. As such, you will need to update your configuration\nto follow the guidelines created with RC6.\n\n\nRC6 and later change the configuration to remove the \npre_routing\n and\n\npost_routing\n keys. However, individual items within the array retain the same\nformat as middleware inside those keys, with the addition of a new key,\n\npriority\n:\n\n\n[\n    // Required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // Optional:\n    //    'path'  => '/path/to/match',\n    //    'error' => true,\n    //    'priority' => 1, // integer\n]\n\n\n\nThe \npriority\n key is used to determine the order in which middleware is piped\nto the application. Higher integer values are piped earlier, while\nlower/negative integer values are piped later; middleware with the same priority\nare piped in the order in which they are discovered in the pipeline. The default\npriority used is 1.\n\n\nAdditionally, the routing and dispatch middleware now become items in the array;\nthey (or equivalent entries for your own implementations) must be present in\nyour configuration if you want your routed middleware to dispatch!  This change\ngives you full control over the flow of the pipeline.\n\n\nTo specify the routing middleware, use the constant\n\nZend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE\n in place of\na middleware array; this has the value \nEXPRESSIVE_ROUTING_MIDDLEWARE\n, if you\ndo not want to import the class. Similarly, for the dispatch middleware, use the\nconstant \nZend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE\n\n(value \nEXPRESSIVE_DISPATCH_MIDDLEWARE\n) to specify the dispatch middleware.\n\n\nAs such, the default configuration now becomes:\n\n\nreturn [\n    'middleware_pipeline' => [\n        // An array of middleware to pipe to the application.\n        // Each item is of the following structure:\n        // [\n        //     // Required:\n        //     'middleware' => 'Name or array of names of middleware services and/or callables',\n        //     // Optional:\n        //     'path'  => '/path/to/match',\n        //     'error' => true,\n        // ],\n        [\n            'middleware' => [\n                Helper\\ServerUrlMiddleware::class,\n            ],\n            'priority' => PHP_INT_MAX,\n        ],\n\n        // The following is an entry for:\n        // - routing middleware\n        // - middleware that reacts to the routing results\n        // - dispatch middleware\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ]\n\n        // The following is an entry for the dispatch middleware:\n\n        // Place error handling middleware after the routing and dispatch\n        // middleware, with negative priority.\n        // [\n        //     'middleware' => [\n        //     ],\n        //     'priority' => -1000,\n        // ],\n    ],\n];\n\n\n\nTo update an existing application:\n\n\n\n\nPromote all \npre_routing\n middleware up a level, and remove the \npre_routing\n\n  key. Provide a \npriority\n value greater than 1. We recommend having a single\n  middleware specification with an array of middleware that represents the \"pre\n  routing\" middleware.\n\n\nAdd the entries for \nZend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE\n\n  and \nZend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE\n\n  immediately following any \npre_routing\n middleware, and before any\n  \npost_routing\n middleware; we recommend grouping it per the above example.\n\n\nPromote all \npost_routing\n middleware up a level, and remove the\n  \npost_routing\n key. Provide a \npriority\n value less than 1 or negative.\n\n\nIf you have \nmiddleware_pipeline\n specifications in multiple files\n, you\n  will need to specify \npriority\n keys for all middleware in order to guarantee\n  order after merging. We recommend having a single middleware specification\n  with an array of middleware that represents the \"post routing\" middleware.\n\n\n\n\nAs an example, consider the following application configuration:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'pre_routing' => [\n            [\n                'middleware' => [\n                    Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                    Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n            [ 'middleware' => DebugToolbarMiddleware::class ],\n            [\n                'middleware' => ApiMiddleware::class,\n                'path' => '/api',\n            ],\n        ],\n\n        'post_routing' => [\n            ['middleware' => NotFoundMiddleware::class, 'error' => true],\n        ],\n    ],\n];\n\n\n\nThis would be rewritten to the following to work with RC6 and later:\n\n\nreturn [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                DebugToolbarMiddleware::class,\n            ],\n            'priority' => PHP_INT_MAX,\n        ],\n        'api' => [\n            'middleware' => ApiMiddleware::class,\n            'path' => '/api',\n            'priority' => 100,\n        ],\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        'error' => [\n            'middleware' => [\n                NotFoundMiddleware::class,\n            ],\n            'error' => true,\n            'priority' => -1000,\n        ],\n    ],\n]\n\n\n\nNote in the above example the various groupings. By grouping middleware by\npriority, you can simplify adding new middleware, particularly if you know it\nshould execute before routing, or as error middleware, or between routing and\ndispatch.\n\n\n\n\nKeys are ignored\n\n\nThe above example provides keys for each middleware specification. The factory\nwill ignore these, but they can be useful for cases when you might want to\nspecify configuration in multiple files, and merge specific entries together.\nBe aware, however, that the \nmiddleware\n key itself is an indexed array;\nitems will be appended based on the order in which configuration files are\nmerged. If order of these is important, create separate specifications with\nrelevant \npriority\n values.\n\n\n\n\nRoute result observer deprecation\n\n\nAs of RC6, the following changes have occurred with regards to route result\nobservers:\n\n\n\n\nThey are deprecated for usage with \nZend\\Expressive\\Application\n, and that\n  class will not be a route result subject starting in 1.1. You will need to\n  start migrating to alternative solutions.\n\n\nThe functionality for notifying observers has been moved from the routing\n  middleware into a dedicated \nApplication::routeResultObserverMiddleware()\n\n  method. This middleware must be piped separately to the middleware pipeline\n  for it to trigger.\n\n\n\n\nImpact\n\n\nIf you are using any route result observers, you will need to ensure your\napplication notifies them, and you will want to migrate to alternative solutions\nto ensure your functionality continues to work.\n\n\nTo ensure your observers are triggered, you will need to adapt your application,\nbased on how you create your instance.\n\n\nIf you are \nnot\n using the \nApplicationFactory\n, you will need to pipe the\n\nrouteResultObserverMiddleware\n to your application, between the routing and\ndispatch middleware:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipeRouteResultObserverMiddleware();\n$app->pipeDispatchMiddleware();\n\n\n\nIf you are using the \nApplicationFactory\n, you may need to update your\nconfiguration to allow injecting the route result observer middleware. If you\nhave \nnot\n updated your configuration to remove the \npre_routing\n and/or\n\npost_routing\n keys, the middleware \nwill\n be registered for you. If you have,\nhowever, you will need to register it following the routing middleware:\n\n\n[\n    'middleware_pipeline' => [\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTE_RESULT_OBSERVER_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n]\n\n\n\nTo make your observers forwards-compatible requires two changes:\n\n\n\n\nRewriting your observer as middleware.\n\n\nRegistering your observer as middleware following the routing middleware.\n\n\n\n\nIf your observer looked like the following:\n\n\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Router\\RouteResultObserverInterface;\n\nclass MyObserver implements RouteResultObserverInterface\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function update(RouteResult $result)\n    {\n        $this->logger->log($result);\n    }\n}\n\n\n\nYou could rewrite it as follows:\n\n\nuse Zend\\Expressive\\Router\\RouteResult;\n\nclass MyObserver\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $result = $request->getAttribute(RouteResult::class, false);\n        if (! $result) {\n            return $next($request, $response);\n        }\n\n        $this->logger->log($result);\n        return $next($request, $response);\n    }\n}\n\n\n\nYou would then register it following the routing middleware. If you are building\nyour application programmatically, you would do this as follows:\n\n\n$app->pipeRoutingMiddleware();\n$app->pipe(MyObserver::class);\n$app->pipeDispatchMiddleware();\n\n\n\nIf you are using the \nApplicationFactory\n, alter your configuration:\n\n\n[\n    'middleware_pipeline' => [\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                MyObserver::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n]\n\n\n\nTimeline for migration\n\n\nThe following features will be removed in version 1.1.0:\n\n\n\n\nSupport for the \npre_routing\n and \npost_routing\n configuration.\n\n\nSupport for route result observers.",
            "title": "From RC5 and Earlier"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#migration-from-rc5-or-earlier",
            "text": "RC6 introduced changes to the following:   The routing middleware was split into separate middleware, one for routing,\n  and one for dispatching.  Due to the above change, we decided to remove auto-registration of routing\n  middleware.  The above change also suggested an alternative to the middleware pipeline\n  configuration that simplifies it.  Route result observers are deprecated, and no longer triggered for routing\n  failures.  Middleware configuration specifications now accept a  priority  key to\n  guarantee the order of items. If you have defined your middleware pipeline in\n  multiple files that are then merged, you will need to defined these keys to\n  ensure order.",
            "title": "Migration from RC5 or earlier"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#routing-and-dispatch-middleware",
            "text": "Prior to RC6, the routing middleware:   performed routing  notified route result observers  created a new request that composed the matched routing parameters as request\n  attributes, and composed the route result instance itself as a request\n  attribute.  marshaled the middleware matched by routing  dispatched the marshaled middleware   To provide a better separation of concerns, we split the routing middleware into\ntwo distinct methods:  routingMiddleware()  and  dispatchMiddleware() .  routingMiddleware()  performs the following duties:   routing; and  creating a new request that composes the matched routing parameters as request\n  attributes, and composes the route result instance itself as a request\n  attribute.   dispatchMiddleware()  performs the following duties:   marshaling the middleware specified in the route result; and  dispatching the marshaled middleware.   One reason for this split is to allow injecting middleware to operate between\nrouting and dispatch. As an example, you could have middleware that determines\nif a matched route requires an authenticated identity:  public function __invoke($request, $response, $next)\n{\n    $result = $request->getAttribute(RouteResult::class);\n    if (! in_array($result->getMatchedRouteName(), $this->authRequired)) {\n        return $next($request, $response);\n    }\n\n    if (! $this->authenticated) {\n        return $next($request, $response->withStatus(401), 'authentication\n        required');\n    }\n}  The above could then be piped between the routing and dispatch middleware:  $app->pipeRoutingMiddleware();\n$app->pipe(AuthenticationMiddleware::class);\n$app->pipeDispatchMiddleware();  Since the routing middleware has been split, we determined we could no longer\nautomatically pipe the routing middleware; detection would require detecting\nboth sets of middleware, and ensuring they are in the correct order.\nAdditionally, since one goal of splitting the middleware is to allow substitutions  for these responsibilities, auto-injection could in some cases\nbe undesired. As a result, we now require you to inject each manually.",
            "title": "Routing and Dispatch middleware"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#impact",
            "text": "This change will require changes in your application.   If you are using Expressive programmatically (i.e., you are not using\n   a container and the  Zend\\Expressive\\Container\\ApplicationFactory ),\n   you are now  required  to call  Application::pipeRoutingMiddleware() .\n   Additionally, a new method,  Application::pipeDispatchMiddleware()  exists\n   for injecting the application with the dispatch middleware, this, too, must\n   be called.   This has a fortunate side effect: registering routed middleware no longer\n   affects the middleware pipeline order. As such, you can register your\n   pipeline first or last prior to running the application. The only stipulation\n   is that  unless you register the routing  and  dispatch middleware, your routed\n   middleware will not be executed!  As such, the following two lines  must \n   be added to your application prior to calling  Application::run() :  $app->pipeRoutingMiddleware();\n$app->pipeDispatchMiddleware();   If you are creating your  Application  instance using a container and the\n    Zend\\Expressive\\Container\\ApplicationFactory , you will need to update your\n   configuration to list the routing and dispatch middleware. The next section\n   details the configuration changes necessary.",
            "title": "Impact"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#applicationfactory-configuration-changes",
            "text": "As noted in the document summary, the middleware pipeline configuration was\nchanged starting in RC6.  The changes are done in such a way as to honor\nconfiguration from RC5 and earlier, but using such configuration will now prompt\nyou to update your application.  RC5 and earlier defined the default  middleware_pipeline  configuration as follows:  return [\n    'middleware_pipeline' => [\n        // An array of middleware to register prior to registration of the\n        // routing middleware\n        'pre_routing' => [\n            //[\n            // Required:\n            //    'middleware' => 'Name or array of names of middleware services and/or callables',\n            // Optional:\n            //    'path'  => '/path/to/match',\n            //    'error' => true,\n            //],\n            [\n                'middleware' => [\n                    Helper\\ServerUrlMiddleware::class,\n                    Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n        ],\n\n        // An array of middleware to register after registration of the\n        // routing middleware\n        'post_routing' => [\n            //[\n            // Required:\n            //    'middleware' => 'Name of middleware service, or a callable',\n            // Optional:\n            //    'path'  => '/path/to/match',\n            //    'error' => true,\n            //],\n        ],\n    ],\n];  The following changes have been made:   The concept of  pre_routing  and  post_routing  have been deprecated, and will\n  be removed starting with the 1.1 version. A single middleware pipeline is now\n  provided, though  any individual specification can also specify an array of\n  middleware .  The routing and dispatch middleware must now be added to your configuration\n  for them to be added to your application.  Middleware specifications can now optionally provide a  priority  key, with 1\n  being the default. High integer priority indicates earlier execution, while\n  low/negative integer priority indicates later execution. Items with the same\n  priority are executed in the order they are registered. Priority is now how\n  you can indicate the order in which middleware should execute.",
            "title": "ApplicationFactory configuration changes"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#impact_1",
            "text": "While the configuration from RC5 and earlier will continue to work, it will\nraise deprecation notices. As such, you will need to update your configuration\nto follow the guidelines created with RC6.  RC6 and later change the configuration to remove the  pre_routing  and post_routing  keys. However, individual items within the array retain the same\nformat as middleware inside those keys, with the addition of a new key, priority :  [\n    // Required:\n    'middleware' => 'Name of middleware service, or a callable',\n    // Optional:\n    //    'path'  => '/path/to/match',\n    //    'error' => true,\n    //    'priority' => 1, // integer\n]  The  priority  key is used to determine the order in which middleware is piped\nto the application. Higher integer values are piped earlier, while\nlower/negative integer values are piped later; middleware with the same priority\nare piped in the order in which they are discovered in the pipeline. The default\npriority used is 1.  Additionally, the routing and dispatch middleware now become items in the array;\nthey (or equivalent entries for your own implementations) must be present in\nyour configuration if you want your routed middleware to dispatch!  This change\ngives you full control over the flow of the pipeline.  To specify the routing middleware, use the constant Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE  in place of\na middleware array; this has the value  EXPRESSIVE_ROUTING_MIDDLEWARE , if you\ndo not want to import the class. Similarly, for the dispatch middleware, use the\nconstant  Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE \n(value  EXPRESSIVE_DISPATCH_MIDDLEWARE ) to specify the dispatch middleware.  As such, the default configuration now becomes:  return [\n    'middleware_pipeline' => [\n        // An array of middleware to pipe to the application.\n        // Each item is of the following structure:\n        // [\n        //     // Required:\n        //     'middleware' => 'Name or array of names of middleware services and/or callables',\n        //     // Optional:\n        //     'path'  => '/path/to/match',\n        //     'error' => true,\n        // ],\n        [\n            'middleware' => [\n                Helper\\ServerUrlMiddleware::class,\n            ],\n            'priority' => PHP_INT_MAX,\n        ],\n\n        // The following is an entry for:\n        // - routing middleware\n        // - middleware that reacts to the routing results\n        // - dispatch middleware\n        [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ]\n\n        // The following is an entry for the dispatch middleware:\n\n        // Place error handling middleware after the routing and dispatch\n        // middleware, with negative priority.\n        // [\n        //     'middleware' => [\n        //     ],\n        //     'priority' => -1000,\n        // ],\n    ],\n];  To update an existing application:   Promote all  pre_routing  middleware up a level, and remove the  pre_routing \n  key. Provide a  priority  value greater than 1. We recommend having a single\n  middleware specification with an array of middleware that represents the \"pre\n  routing\" middleware.  Add the entries for  Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE \n  and  Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE \n  immediately following any  pre_routing  middleware, and before any\n   post_routing  middleware; we recommend grouping it per the above example.  Promote all  post_routing  middleware up a level, and remove the\n   post_routing  key. Provide a  priority  value less than 1 or negative.  If you have  middleware_pipeline  specifications in multiple files , you\n  will need to specify  priority  keys for all middleware in order to guarantee\n  order after merging. We recommend having a single middleware specification\n  with an array of middleware that represents the \"post routing\" middleware.   As an example, consider the following application configuration:  return [\n    'middleware_pipeline' => [\n        'pre_routing' => [\n            [\n                'middleware' => [\n                    Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                    Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n            [ 'middleware' => DebugToolbarMiddleware::class ],\n            [\n                'middleware' => ApiMiddleware::class,\n                'path' => '/api',\n            ],\n        ],\n\n        'post_routing' => [\n            ['middleware' => NotFoundMiddleware::class, 'error' => true],\n        ],\n    ],\n];  This would be rewritten to the following to work with RC6 and later:  return [\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                DebugToolbarMiddleware::class,\n            ],\n            'priority' => PHP_INT_MAX,\n        ],\n        'api' => [\n            'middleware' => ApiMiddleware::class,\n            'path' => '/api',\n            'priority' => 100,\n        ],\n\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n\n        'error' => [\n            'middleware' => [\n                NotFoundMiddleware::class,\n            ],\n            'error' => true,\n            'priority' => -1000,\n        ],\n    ],\n]  Note in the above example the various groupings. By grouping middleware by\npriority, you can simplify adding new middleware, particularly if you know it\nshould execute before routing, or as error middleware, or between routing and\ndispatch.",
            "title": "Impact"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#keys-are-ignored",
            "text": "The above example provides keys for each middleware specification. The factory\nwill ignore these, but they can be useful for cases when you might want to\nspecify configuration in multiple files, and merge specific entries together.\nBe aware, however, that the  middleware  key itself is an indexed array;\nitems will be appended based on the order in which configuration files are\nmerged. If order of these is important, create separate specifications with\nrelevant  priority  values.",
            "title": "Keys are ignored"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#route-result-observer-deprecation",
            "text": "As of RC6, the following changes have occurred with regards to route result\nobservers:   They are deprecated for usage with  Zend\\Expressive\\Application , and that\n  class will not be a route result subject starting in 1.1. You will need to\n  start migrating to alternative solutions.  The functionality for notifying observers has been moved from the routing\n  middleware into a dedicated  Application::routeResultObserverMiddleware() \n  method. This middleware must be piped separately to the middleware pipeline\n  for it to trigger.",
            "title": "Route result observer deprecation"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#impact_2",
            "text": "If you are using any route result observers, you will need to ensure your\napplication notifies them, and you will want to migrate to alternative solutions\nto ensure your functionality continues to work.  To ensure your observers are triggered, you will need to adapt your application,\nbased on how you create your instance.  If you are  not  using the  ApplicationFactory , you will need to pipe the routeResultObserverMiddleware  to your application, between the routing and\ndispatch middleware:  $app->pipeRoutingMiddleware();\n$app->pipeRouteResultObserverMiddleware();\n$app->pipeDispatchMiddleware();  If you are using the  ApplicationFactory , you may need to update your\nconfiguration to allow injecting the route result observer middleware. If you\nhave  not  updated your configuration to remove the  pre_routing  and/or post_routing  keys, the middleware  will  be registered for you. If you have,\nhowever, you will need to register it following the routing middleware:  [\n    'middleware_pipeline' => [\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTE_RESULT_OBSERVER_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n]  To make your observers forwards-compatible requires two changes:   Rewriting your observer as middleware.  Registering your observer as middleware following the routing middleware.   If your observer looked like the following:  use Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Router\\RouteResultObserverInterface;\n\nclass MyObserver implements RouteResultObserverInterface\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function update(RouteResult $result)\n    {\n        $this->logger->log($result);\n    }\n}  You could rewrite it as follows:  use Zend\\Expressive\\Router\\RouteResult;\n\nclass MyObserver\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this->logger = $logger;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $result = $request->getAttribute(RouteResult::class, false);\n        if (! $result) {\n            return $next($request, $response);\n        }\n\n        $this->logger->log($result);\n        return $next($request, $response);\n    }\n}  You would then register it following the routing middleware. If you are building\nyour application programmatically, you would do this as follows:  $app->pipeRoutingMiddleware();\n$app->pipe(MyObserver::class);\n$app->pipeDispatchMiddleware();  If you are using the  ApplicationFactory , alter your configuration:  [\n    'middleware_pipeline' => [\n        /* ... */\n        'routing' => [\n            'middleware' => [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                MyObserver::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' => 1,\n        ],\n        /* ... */\n    ],\n]",
            "title": "Impact"
        },
        {
            "location": "/v1/reference/migration/rc-to-v1/#timeline-for-migration",
            "text": "The following features will be removed in version 1.1.0:   Support for the  pre_routing  and  post_routing  configuration.  Support for route result observers.",
            "title": "Timeline for migration"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/",
            "text": "Migration to Expressive 1.1\n\n\nExpressive 1.1 should not result in any upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:\n\n\n\n\nDeprecations\n\n\nOriginal request and response messages\n\n\nRecommendation to use programmatic pipelines\n\n\nError handling\n\n\n\n\nDeprecations\n\n\nThe following classes and/or methods are deprecated with the 1.1.0 release, and\nwill be removed for the 2.0 release:\n\n\n\n\n\n\nZend\\Expressive\\Application::pipeErrorHandler()\n: Stratigility v1 error\n  middleware are removed in the Stratigility v2 release, which Expressive 2.0 will\n  adopt.\n\n\n\n\n\n\nZend\\Expressive\\Application::routeMiddleware()\n: routing middleware moves to\n  a dedicated class starting in Expressive 2.0. If you were referencing the\n  method in order to pipe it as middleware, use \npipeRoutingMiddleware()\n or\n  \npipe(ApplicationFactory::ROUTING_MIDDLEWARE)\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Application::dispatchMiddleware()\n: dispatch middleware moves\n  to a dedicated class starting in Expressive 2.0.If you were referencing the\n  method in order to pipe it as middleware, use \npipeDispatchMiddleware()\n or\n  \npipe(ApplicationFactory::DISPATCH_MIDDLEWARE)\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Application::getFinalHandler()\n: this method gets renamed to\n  \ngetDefaultDelegate()\n in Expressive 2.0. We recommend retrieving the value\n  from the application dependency injection container if you need it elsewhere.\n\n\n\n\n\n\nZend\\Expressive\\Application::raiseThrowables()\n: this method becomes a no-op\n  in Stratigility 2.0, on which Expressive 2.0 is based; the behavior it enabled\n  becomes the default behavior in that version.\n\n\n\n\n\n\nZend\\Expressive\\Container\\Exception\\InvalidArgumentException\n: this exception\n  type is thrown by \nApplicationFactory\n; in Expressive 2.0, it throws\n  \nZend\\Expressive\\Exception\\InvalidArgumentException\n instead.\n\n\n\n\n\n\nZend\\Expressive\\Container\\Exception\\NotFoundException\n: this exception type\n  is not currently used anyways.\n\n\n\n\n\n\nZend\\Expressive\\ErrorMiddlewarePipe\n: Stratigility v1 error middleware are\n  removed in the Stratigility v2 release, which Expressive 2.0 will adopt,\n  making this specialized middleware pipe type irrelvant.\n\n\n\n\n\n\nZend\\Expressive\\TemplatedErrorHandler\n and \nZend\\Expressive\\WhoopsErrorHandler\n:\n  The concept of \"final handlers\" will be removed in Expressive 2.0, to be\n  replaced with \"default delegates\" (implementations of\n  \nInterop\\Http\\ServerMiddleware\\DelegateInterface\n that will be called if the\n  middleware pipeline is exhausted, and which will be guaranteed to return a\n  response). Expressive 2.0 will provide tooling to upgrade your dependencies to\n  make the transition seamless; end users will only be affected if they were\n  extending these classes.\n\n\n\n\n\n\nIf you were calling any of these directly, or extending or overriding them, you\nwill need to update your code to work for version 2.0. We recommend not using\nthese.\n\n\nOriginal messages\n\n\nStratigility 1.3 deprecates its internal request and response decorators,\n\nZend\\Stratigility\\Http\\Request\n and \nZend\\Stratigility\\Http\\Response\n,\nrespectively. The main utility of these instances was to provide access in\ninner middleware layers to the original request, original response, and original\nURI.\n\n\nAs such access may still be desired, Stratigility 1.3 introduced\n\nZend\\Stratigility\\Middleware\\OriginalMessages\n. This middleware injects the\nfollowing attributes into the request it passes to \n$next()\n:\n\n\n\n\noriginalRequest\n is the request instance provided to the middleware.\n\n\noriginalUri\n is the URI instance associated with that request.\n\n\noriginalResponse\n is the response instance provided to the middleware.\n\n\n\n\nZend\\Stratigility\\FinalHandler\n was updated to use these when they're\navailable starting with version 1.0.3.\n\n\nWe recommend adding the \nOriginalMessages\n middleware as the outermost (first)\nmiddleware in your pipeline. Using configuration-driven middleware, that would\nlook like this:\n\n\n// config/autoload/middleware-pipeline.global.php\n/* ... */\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            OriginalMessages::class => OriginalMessages::class,\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                OriginalMessages::class, // <----- Add this entry\n                Helper\\ServerUrlMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n\n        /* ... */\n    ],\n];\n\n\n\nIf you are \nprogrammatically creating your pipeline\n,\nuse the following:\n\n\n$app->pipe(OriginalMessages::class);\n/* all other middleware */\n\n\n\nIdentifying and fixing getOriginal calls\n\n\nTo help you identify and update calls in your own code to the \ngetOriginal*()\n\nmethods, we provide a tool via the \nzendframework/zend-expressive-tooling\n\npackage, \nvendor/bin/expressive-migrate-original-messages\n.\n\n\nFirst, install the tooling package; since the tooling it provides is only\nuseful during development, install it as a development requirement:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nOnce installed,  you can execute the tool using:\n\n\n$ ./vendor/bin/expressive-migrate-original-messages\n\n\n\nPassing the arguments \nhelp\n, \n--help\n, or \n-h\n will provide usage information;\nin most cases, it will assume sane defaults in order to run its scans.\n\n\nThe tool updates calls to \ngetOriginalRequest()\n and \ngetOriginalUri()\n to\ninstead use the new request attributes that the \nOriginalMessages\n middleware\ninjects:\n\n\n\n\ngetOriginalRequest()\n becomes \ngetAttribute('originalRequest', $request)\n\n\ngetOriginalUri()\n becomes \ngetAttribute('originalUri', $request->getUri())\n\n\n\n\nIn both cases, \n$request\n will be replaced with whatever variable name you used\nfor the request instance.\n\n\nFor \ngetOriginalResponse()\n calls, which happen on the response instance, the\ntool will instead tell you what files had such calls, and detail how you can\nupdate those calls to use the \noriginalResponse\n request attribute.\n\n\nProgrammatic middleware pipelines\n\n\nWith Expressive 1.0, we recommended creating middleware pipelines and routing\nvia configuration. Starting with 1.1, we recommend \nprogrammatic creation of\npipelines and routing\n.\n\n\nProgrammatic pipelines exercise the existing Expressive API. Methods include:\n\n\n\n\n\n\npipe()\n allows you to pipe middleware for the pipeline; this can optionally\n  take a \n$path\n argument. (If one argument is present, it is assumed to be\n  middleware; with two arguments, the first argument is the \n$path\n.) Paths are\n  literal URI path segments. If the incoming request matches that segment, the\n  middleware will execute; otherwise, it will not. These can be used to provide\n  sub-applications with their own routing.\n\n\n\n\n\n\npipeRoutingMiddleware()\n is used to pipe the internal routing middleware into\n  the pipeline.\n\n\n\n\n\n\npipeDispatchMiddleware()\n is used to pipe the internal dispatch middleware into\n  the pipeline.\n\n\n\n\n\n\npipeErrorMiddleware()\n is used to pipe the legacy Stratigility error\n  middleware into the pipeline. We recommend \nNOT\n using this method, and\n  instead adapting your application to use \nstandard middleware for error\n  handling\n. Otherwise, it acts just like \npipe()\n.\n  Starting in Expressive 1.1, this method will emit a deprecation notice.\n\n\n\n\n\n\nAs an example pipeline:\n\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(Helper\\UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);\n\n\n\nExpressive also provides methods for specifying routed middleware. These\ninclude:\n\n\n\n\nget($path, $middleware, $name = null)\n\n\npost($path, $middleware, $name = null)\n\n\nput($path, $middleware, $name = null)\n\n\npatch($path, $middleware, $name = null)\n\n\ndelete($path, $middleware, $name = null)\n\n\nroute($path, $middleware, array $methods = null, $name = null)\n\n\n\n\nEach returns a \nZend\\Expressive\\Router\\Route\n instance; this is useful if you\nwish to provide additional options to your route:\n\n\n$app->get('/api/ping', Ping::class)\n    ->setOptions([\n        'timestamp' => date(),\n    ]);\n\n\n\nAs an example, the default routes defined in the skeleton application can be\nwritten as follows:\n\n\n$app->get('/', \\App\\Action\\HomePageAction::class, 'home');\n$app->get('/api/ping', \\App\\Action\\PingAction::class, 'api.ping');\n\n\n\nWe recommend rewriting your middleware pipeline and routing configuration into\nprogrammatic/declarative statements. Specifically:\n\n\n\n\nWe recommend putting the pipeline declarations into \nconfig/pipeline.php\n.\n\n\nWe recommend putting the routing declarations into \nconfig/routes.php\n.\n\n\n\n\nOnce you've written these, you will then need to make the following changes to\nyour application:\n\n\n\n\nFirst, enable the \nzend-expressive.programmatic_pipeline\n configuration flag.\n  This can be done in any \nconfig/autoload/*.global.php\n file:\n\n\n\n\nreturn [\n    'zend-expressive' => [\n        'programmatic_pipeline' => true,\n    ],\n];\n\n\n\nOnce enabled, any \nmiddleware_pipeline\n or \nroutes\n configuration will be\n  ignored when creating the \nApplication\n instance.\n\n\n\n\nSecond, update your \npublic/index.php\n to add the following lines immediately\n  prior to calling \n$app->run();\n:\n\n\n\n\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n\n\n\nOnce this has been done, the application will use your new programmatic\npipelines instead of configuration. You can remove the \nmiddleware_pipeline\n and\n\nroutes\n configuration after verifying your application continues to work.\n\n\nFor programmatic pipelines to work properly, you will also need to provide error\nhandling middleware, which is discussed in the next section.\n\n\nError handling\n\n\nPrior to version 1.1, error handling was accomplished via two mechanisms:\n\n\n\n\nStratigility \"error middleware\" (middleware with the signature \nfunction\n  ($error, ServerRequestInterface $request, ResponseInterface $response,\n  callable $next)\n). This middleware would be invoked when calling \n$next()\n\n  with a third argument indicating an error, and would be expected to handle it\n  or delegate to the next error middleware.\n\n\n\n\nInternally, Stratigility would execute each middleware within a try/catch\n  block; if an exception were caught, it would then delegate to the next \nerror\n  middleware\n using the caught exception as the \n$err\n argument.\n\n\n\n\nThe \"Final Handler\". This is a handler invoked when the middleware pipeline is\n  exhausted without returning a response, and has the signature \nfunction\n  (ServerRequestInterface $request, ResponseInterface $response, $err = null)\n;\n  it is provided to the middleware pipeline when invoking the outermost\n  middleware; in the case of Expressive, it is composed in the \nApplication\n\n  instance, and passed to the application middleware when it executes \nrun()\n.\n  When invoked, it needs to decide if invocation is due to no middleware\n  executing (HTTP 404 status), middleware calling \n$next()\n with an altered\n  response (response is then returned), or due to invocation of error middleware\n  (calling \n$next()\n with the third, error, argument) with no error middleware\n  returning a response.\n\n\n\n\nExpressive 1.1 updates the minimum supported Stratigility version to 1.3, which\ndeprecates the concept of error middleware, and recommends a \"final handler\"\nthat does no error handling, but instead returns a canned response (typically a\n404). Additionally, it deprecates the practice of wrapping middleware execution\nin a try/catch block, and provides a flag for disabling that behavior entirely,\n\nraise_throwables\n.\n\n\nStarting in Expressive 1.1, you can set the \nraise_throwables\n flag in your\nconfiguration:\n\n\nreturn [\n    'zend-expressive' => [\n        'raise_throwables' => true,\n    ],\n];\n\n\n\nWhen enabled, the internal dispatcher will no longer catch exceptions.\n\n\nThis both allows you to, and \nrequires\n you to, write your own error handling\nmiddleware. This will require two things:\n\n\n\n\nMiddleware with a try/catch block that operates as the outermost (or close to\n  outermost) layer of your application, and which can provide error pages or\n  details to your end users.\n\n\nMiddleware at the innermost layer that is guaranteed to return a response;\n  generally, reaching this means no middleware was able to route the request, and\n  thus a 404 condition.\n\n\n\n\nThe below sections detail approaches to each.\n\n\nError handling middleware\n\n\nError handling middleware generally will look something like this:\n\n\nfunction (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    try {\n        $response = $next($request, $response);\n        return $response;\n    } catch (\\Throwable $exception) {\n        // caught PHP 7 throwable\n    } catch (\\Exception $exception) {\n        // caught PHP 5 exception\n    }\n\n    // ...\n    // do something with $exception and generate a response\n    // ...\n\n    return $response;\n}\n\n\n\nStratigility 1.3 provides such an implementation via its\n\nZend\\Stratigility\\Middleware\\ErrorHandler\n. In addition to the try/catch block,\nit also sets up a PHP error handler that will catch any PHP error types in the\ncurrent \nerror_reporting\n mask; the error handler will raise exceptions of the\ntype \nErrorException\n with the PHP error details.\n\n\nStratigility's \nErrorHandler\n allows injection of an \"error response generator\",\nwhich allows you to alter how the error response is generated based on the\ncurrent environment. Error response generators are callables with the signature:\n\n\nfunction (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface\n\n\n\nWe recommend using the Stratigility \nErrorHandler\n and writing and attaching a\ncustom error response generator. As a simple example, the following details a\ngenerator that will use a template to display an error page:\n\n\nnamespace Acme;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedErrorResponseGenerator\n{\n    const TEMPLATE_DEFAULT = 'error::error';\n\n    private $renderer;\n\n    private $template;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $template = TEMPLATE_DEFAULT\n    ) {\n        $this->renderer = $renderer;\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        $e,\n        ServerRequestInterface $request,\n        ResponseInterface $response\n    ) {\n        $response->write($this->renderer->render($this->template, [\n            'exception' => $e,\n            'request'   => $request,\n        ]));\n        return $response;\n    }\n}\n\n\n\nYou might then create a factory for generating the \nErrorHandler\n and attaching\nthis response generator as follows:\n\n\nnamespace Acme\\Container;\n\nuse Acme\\TemplatedErrorResponseGenerator;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass ErrorHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $generator = new TemplatedErrorResponseGenerator(\n            $container->get(TemplateRendererInterface::class)\n        );\n\n        return new ErrorHandler(new Response(), $generator);\n    }\n}\n\n\n\nOnce that is created you can tell your middleware configuration about it:\n\n\n// in config/autoload/middleware-pipeline.global.php\nuse Acme\\Container\\ErrorHandlerFactory;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            ErrorHandler::class => ErrorHandlerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                ErrorHandler::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\nAlternately, if using a programmatic pipeline, as detailed in the previous\nsection, you can use the following:\n\n\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(ErrorHandler::class);\n// add all other middleware after it\n\n\n\nNot Found middleware\n\n\nAt the innermost layer of your application, you need middleware guaranteed to\nreturn a response; typically, this indicates a failure to route the request,\nand, as such, an HTTP 404 response.  \nZend\\Stratigility\\Middleware\\NotFoundHandler\n\nprovides an implementation, but is written such that the response body remains\nempty. As such, you might write a custom, templated handler:\n\n\nnamespace Acme;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedNotFoundHandler\n{\n    const TEMPLATE_DEFAULT = 'error::404';\n\n    private $renderer;\n\n    private $template;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $template = self::TEMPLATE_DEFAULT\n    ) {\n        $this->renderer = $renderer;\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        $response = new Response();\n        $response->write($this->renderer->render($this->template));\n        return $response->withStatus(404);\n    }\n}\n\n\n\nSimilar to the discussion of the \nErrorHandler\n above, we'll create a factory\nfor this:\n\n\nnamespace Acme\\Container;\n\nuse Acme\\TemplatedNotFoundHandler;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedNotFoundHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new TemplatedNotFoundHandler(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}\n\n\n\nWe can then register it in our pipeline:\n\n\n// in config/autoload/middleware-pipeline.global.php\nuse Acme\\Container\\NotFoundHandlerFactory;\nuse Acme\\TemplatedNotFoundHandler;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            TemplatedNotFoundHandler::class => TemplatedNotFoundHandlerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        /* ... */\n\n        // After 'routing', but before 'error';\n        // alternately as last item in 'routing' middleware list.\n        'not-found' => [\n            'middleware' => TemplatedNotFoundHandler::class,\n            'priority' => 0,\n        ],\n\n        /* ... */\n    ],\n];\n\n\n\nIf you are using programmatic pipelines, as described in the previous section:\n\n\nuse Acme\\TemplatedNotFoundHandler;\n\n// all other pipeline directives, and then:\n$app->pipe(TemplatedNotFoundHandler::class);\n\n\n\nDetecting error middleware usage\n\n\nIf you use the new error handling paradigm, we recommend that you also audit\nyour application for legacy Stratigility error middleware, as well as invocation\nof error middleware. To do this, we provide a tool via the\n\nzendframework/zend-expressive-tooling\n\npackage, \nvendor/bin/expressive-scan-for-error-middleware\n.\n\n\nFirst, install the tooling as a development requirement:\n\n\n$ composer require --dev zendframework/zend-expressive-tooling\n\n\n\nThe tool will scan the \nsrc/\n directory by default, but allows you to scan other\ndirectories via the \n--dir\n flag. It will detect and report files with any of\nthe following:\n\n\n\n\nClasses implementing \nZend\\Stratigility\\ErrorMiddlewareInterface\n.\n\n\nInvokable classes implementing the error middleware signature.\n\n\nMethods accepting \n$next\n that invoke it with an error argument.\n\n\n\n\nAs an example running it:\n\n\n$ ./vendor/bin/expressive-scan-for-error-middleware scan\n# or, with a directory argument:\n$ ./vendor/bin/expressive-scan-for-error-middleware scan --dir ./lib\n\n\n\nYou may also call the tool using its \nhelp\n command, or either of the \n--help\n\nor \n-h\n flags to get full usage information.\n\n\nUse this tool to identify potential problem areas in your application, and\nupdate your code to use the new error handling facilities as outlined above.\n\n\nFull example\n\n\nPutting all of the above together \u2014 \noriginal message\nmemoizing\n, \nprogrammatic\npipelines\n, and \nmiddleware-based error\nhandling\n \u2014 might look like the following examples.\n\n\nFirst, we'll tell Expressive to use programmatic pipelines, and to enable the\nnew error handling (by telling it to \"raise throwables\", instead of catching\nthem):\n\n\n// In config/autoload/zend-expressive.global.php:\nreturn [\n    /* ... */\n    'zend-expressive' => [\n        'programmatic_pipeline' => true,\n        'raise_throwables' => true,\n        /* ... */\n    ],\n];\n\n\n\nNext, we'll update \nconfig/autoload/middleware-pipeline.global.php\n to list only\ndependencies:\n\n\nuse Acme\\Container;\nuse Acme\\TemplatedNotFoundHandler;\nuse Zend\\Expressive\\Container\\ApplicationFactory;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            OriginalMessages::class => OriginalMesssages::class,\n        ],\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class,\n            Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class,\n            TemplatedNotFoundHandler::class => Container\\TemplatedNotFoundHandlerFactory::class,\n        ],\n    ],\n];\n\n\n\nWe'll also update \nconfig/autoload/routes.global.php\n to only list dependencies;\nin the following example, we list only the middleware shipped by default with\nthe skeleton application:\n\n\nuse App\\Action;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\nuse Zend\\Expressive\\Router\\RouterInterface;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            RouterInterface::class => FastRouteRouter::class,\n            Action\\PingAction::class => Action\\PingAction::class,\n        ],\n        'factories' => [\n            Action\\HomePageAction::class => Action\\HomePageFactory::class,\n        ],\n    ],\n];\n\n\n\nTo create our pipeline, we will create the file \nconfig/pipeline.php\n:\n\n\nuse Acme\\TemplatedNotFoundHandler;\nuse Zend\\Expressive\\Container\\ApplicationFactory;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(ErrorHandler::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe([\n    ApplicationFactory::ROUTING_MIDDLEWARE,\n    Helper\\UrlHelperMiddleware::class,\n    ApplicationFactory::DISPATCH_MIDDLEWARE,\n]);\n$app->pipe(TemplatedNotFoundHandler::class);\n\n\n\nNote that you can use \narrays\n of middleware just like you did in the\nconfiguration; this allows you to separate middleware into logical groups if\ndesired!\n\n\nTo provide our routed middleware, we will create the file\n\nconfig/pipeline.php\n:\n\n\nuse App\\Action;\n\n$app->get('/', Action\\HomePageAction::class, 'home');\n$app->get('/api/ping', Action\\PingAction::class, 'api.ping');\n\n\n\nThe above exercises the various routing methods of the \nApplication\n class.\n\n\nFinally, we will need to update our \npublic/index.php\n, to tell it to require\nour new pipeline and routing files; we'll do that between retrieving the\napplication from the container, and running the application:\n\n\n$app = $container->get(\\Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();\n\n\n\nWith these changes in place, your application should continue to run as it did\npreviously!\n\n\nLooking forward\n\n\nExpressive 2.0 will ship error handling middleware and \"not found\" middleware,\nas well as tools to convert your application to a programmatic pipeline in such\na way as to utilize these shipped implementations. In the meantime, however, you\ncan adopt programmatic pipelines and the new error handling paradigm within the\nversion 1 series using the configuration flags and guidelines listed above in\norder to make your application forwards-compatible.",
            "title": "To Expressive 1.1"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#migration-to-expressive-11",
            "text": "Expressive 1.1 should not result in any upgrade problems for users. However,\nstarting in this version, we offer a few changes affecting the following that\nyou should be aware of, and potentially update your application to adopt:   Deprecations  Original request and response messages  Recommendation to use programmatic pipelines  Error handling",
            "title": "Migration to Expressive 1.1"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#deprecations",
            "text": "The following classes and/or methods are deprecated with the 1.1.0 release, and\nwill be removed for the 2.0 release:    Zend\\Expressive\\Application::pipeErrorHandler() : Stratigility v1 error\n  middleware are removed in the Stratigility v2 release, which Expressive 2.0 will\n  adopt.    Zend\\Expressive\\Application::routeMiddleware() : routing middleware moves to\n  a dedicated class starting in Expressive 2.0. If you were referencing the\n  method in order to pipe it as middleware, use  pipeRoutingMiddleware()  or\n   pipe(ApplicationFactory::ROUTING_MIDDLEWARE)  instead.    Zend\\Expressive\\Application::dispatchMiddleware() : dispatch middleware moves\n  to a dedicated class starting in Expressive 2.0.If you were referencing the\n  method in order to pipe it as middleware, use  pipeDispatchMiddleware()  or\n   pipe(ApplicationFactory::DISPATCH_MIDDLEWARE)  instead.    Zend\\Expressive\\Application::getFinalHandler() : this method gets renamed to\n   getDefaultDelegate()  in Expressive 2.0. We recommend retrieving the value\n  from the application dependency injection container if you need it elsewhere.    Zend\\Expressive\\Application::raiseThrowables() : this method becomes a no-op\n  in Stratigility 2.0, on which Expressive 2.0 is based; the behavior it enabled\n  becomes the default behavior in that version.    Zend\\Expressive\\Container\\Exception\\InvalidArgumentException : this exception\n  type is thrown by  ApplicationFactory ; in Expressive 2.0, it throws\n   Zend\\Expressive\\Exception\\InvalidArgumentException  instead.    Zend\\Expressive\\Container\\Exception\\NotFoundException : this exception type\n  is not currently used anyways.    Zend\\Expressive\\ErrorMiddlewarePipe : Stratigility v1 error middleware are\n  removed in the Stratigility v2 release, which Expressive 2.0 will adopt,\n  making this specialized middleware pipe type irrelvant.    Zend\\Expressive\\TemplatedErrorHandler  and  Zend\\Expressive\\WhoopsErrorHandler :\n  The concept of \"final handlers\" will be removed in Expressive 2.0, to be\n  replaced with \"default delegates\" (implementations of\n   Interop\\Http\\ServerMiddleware\\DelegateInterface  that will be called if the\n  middleware pipeline is exhausted, and which will be guaranteed to return a\n  response). Expressive 2.0 will provide tooling to upgrade your dependencies to\n  make the transition seamless; end users will only be affected if they were\n  extending these classes.    If you were calling any of these directly, or extending or overriding them, you\nwill need to update your code to work for version 2.0. We recommend not using\nthese.",
            "title": "Deprecations"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#original-messages",
            "text": "Stratigility 1.3 deprecates its internal request and response decorators, Zend\\Stratigility\\Http\\Request  and  Zend\\Stratigility\\Http\\Response ,\nrespectively. The main utility of these instances was to provide access in\ninner middleware layers to the original request, original response, and original\nURI.  As such access may still be desired, Stratigility 1.3 introduced Zend\\Stratigility\\Middleware\\OriginalMessages . This middleware injects the\nfollowing attributes into the request it passes to  $next() :   originalRequest  is the request instance provided to the middleware.  originalUri  is the URI instance associated with that request.  originalResponse  is the response instance provided to the middleware.   Zend\\Stratigility\\FinalHandler  was updated to use these when they're\navailable starting with version 1.0.3.  We recommend adding the  OriginalMessages  middleware as the outermost (first)\nmiddleware in your pipeline. Using configuration-driven middleware, that would\nlook like this:  // config/autoload/middleware-pipeline.global.php\n/* ... */\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            OriginalMessages::class => OriginalMessages::class,\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                OriginalMessages::class, // <----- Add this entry\n                Helper\\ServerUrlMiddleware::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n\n        /* ... */\n    ],\n];  If you are  programmatically creating your pipeline ,\nuse the following:  $app->pipe(OriginalMessages::class);\n/* all other middleware */",
            "title": "Original messages"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#identifying-and-fixing-getoriginal-calls",
            "text": "To help you identify and update calls in your own code to the  getOriginal*() \nmethods, we provide a tool via the  zendframework/zend-expressive-tooling \npackage,  vendor/bin/expressive-migrate-original-messages .  First, install the tooling package; since the tooling it provides is only\nuseful during development, install it as a development requirement:  $ composer require --dev zendframework/zend-expressive-tooling  Once installed,  you can execute the tool using:  $ ./vendor/bin/expressive-migrate-original-messages  Passing the arguments  help ,  --help , or  -h  will provide usage information;\nin most cases, it will assume sane defaults in order to run its scans.  The tool updates calls to  getOriginalRequest()  and  getOriginalUri()  to\ninstead use the new request attributes that the  OriginalMessages  middleware\ninjects:   getOriginalRequest()  becomes  getAttribute('originalRequest', $request)  getOriginalUri()  becomes  getAttribute('originalUri', $request->getUri())   In both cases,  $request  will be replaced with whatever variable name you used\nfor the request instance.  For  getOriginalResponse()  calls, which happen on the response instance, the\ntool will instead tell you what files had such calls, and detail how you can\nupdate those calls to use the  originalResponse  request attribute.",
            "title": "Identifying and fixing getOriginal calls"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#programmatic-middleware-pipelines",
            "text": "With Expressive 1.0, we recommended creating middleware pipelines and routing\nvia configuration. Starting with 1.1, we recommend  programmatic creation of\npipelines and routing .  Programmatic pipelines exercise the existing Expressive API. Methods include:    pipe()  allows you to pipe middleware for the pipeline; this can optionally\n  take a  $path  argument. (If one argument is present, it is assumed to be\n  middleware; with two arguments, the first argument is the  $path .) Paths are\n  literal URI path segments. If the incoming request matches that segment, the\n  middleware will execute; otherwise, it will not. These can be used to provide\n  sub-applications with their own routing.    pipeRoutingMiddleware()  is used to pipe the internal routing middleware into\n  the pipeline.    pipeDispatchMiddleware()  is used to pipe the internal dispatch middleware into\n  the pipeline.    pipeErrorMiddleware()  is used to pipe the legacy Stratigility error\n  middleware into the pipeline. We recommend  NOT  using this method, and\n  instead adapting your application to use  standard middleware for error\n  handling . Otherwise, it acts just like  pipe() .\n  Starting in Expressive 1.1, this method will emit a deprecation notice.    As an example pipeline:  $app->pipe(OriginalMessages::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe(ErrorHandler::class);\n$app->pipeRoutingMiddleware();\n$app->pipe(Helper\\UrlHelperMiddleware::class);\n$app->pipeDispatchMiddleware();\n$app->pipe(NotFoundHandler::class);  Expressive also provides methods for specifying routed middleware. These\ninclude:   get($path, $middleware, $name = null)  post($path, $middleware, $name = null)  put($path, $middleware, $name = null)  patch($path, $middleware, $name = null)  delete($path, $middleware, $name = null)  route($path, $middleware, array $methods = null, $name = null)   Each returns a  Zend\\Expressive\\Router\\Route  instance; this is useful if you\nwish to provide additional options to your route:  $app->get('/api/ping', Ping::class)\n    ->setOptions([\n        'timestamp' => date(),\n    ]);  As an example, the default routes defined in the skeleton application can be\nwritten as follows:  $app->get('/', \\App\\Action\\HomePageAction::class, 'home');\n$app->get('/api/ping', \\App\\Action\\PingAction::class, 'api.ping');  We recommend rewriting your middleware pipeline and routing configuration into\nprogrammatic/declarative statements. Specifically:   We recommend putting the pipeline declarations into  config/pipeline.php .  We recommend putting the routing declarations into  config/routes.php .   Once you've written these, you will then need to make the following changes to\nyour application:   First, enable the  zend-expressive.programmatic_pipeline  configuration flag.\n  This can be done in any  config/autoload/*.global.php  file:   return [\n    'zend-expressive' => [\n        'programmatic_pipeline' => true,\n    ],\n];  Once enabled, any  middleware_pipeline  or  routes  configuration will be\n  ignored when creating the  Application  instance.   Second, update your  public/index.php  to add the following lines immediately\n  prior to calling  $app->run(); :   require 'config/pipeline.php';\nrequire 'config/routes.php';  Once this has been done, the application will use your new programmatic\npipelines instead of configuration. You can remove the  middleware_pipeline  and routes  configuration after verifying your application continues to work.  For programmatic pipelines to work properly, you will also need to provide error\nhandling middleware, which is discussed in the next section.",
            "title": "Programmatic middleware pipelines"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#error-handling",
            "text": "Prior to version 1.1, error handling was accomplished via two mechanisms:   Stratigility \"error middleware\" (middleware with the signature  function\n  ($error, ServerRequestInterface $request, ResponseInterface $response,\n  callable $next) ). This middleware would be invoked when calling  $next() \n  with a third argument indicating an error, and would be expected to handle it\n  or delegate to the next error middleware.   Internally, Stratigility would execute each middleware within a try/catch\n  block; if an exception were caught, it would then delegate to the next  error\n  middleware  using the caught exception as the  $err  argument.   The \"Final Handler\". This is a handler invoked when the middleware pipeline is\n  exhausted without returning a response, and has the signature  function\n  (ServerRequestInterface $request, ResponseInterface $response, $err = null) ;\n  it is provided to the middleware pipeline when invoking the outermost\n  middleware; in the case of Expressive, it is composed in the  Application \n  instance, and passed to the application middleware when it executes  run() .\n  When invoked, it needs to decide if invocation is due to no middleware\n  executing (HTTP 404 status), middleware calling  $next()  with an altered\n  response (response is then returned), or due to invocation of error middleware\n  (calling  $next()  with the third, error, argument) with no error middleware\n  returning a response.   Expressive 1.1 updates the minimum supported Stratigility version to 1.3, which\ndeprecates the concept of error middleware, and recommends a \"final handler\"\nthat does no error handling, but instead returns a canned response (typically a\n404). Additionally, it deprecates the practice of wrapping middleware execution\nin a try/catch block, and provides a flag for disabling that behavior entirely, raise_throwables .  Starting in Expressive 1.1, you can set the  raise_throwables  flag in your\nconfiguration:  return [\n    'zend-expressive' => [\n        'raise_throwables' => true,\n    ],\n];  When enabled, the internal dispatcher will no longer catch exceptions.  This both allows you to, and  requires  you to, write your own error handling\nmiddleware. This will require two things:   Middleware with a try/catch block that operates as the outermost (or close to\n  outermost) layer of your application, and which can provide error pages or\n  details to your end users.  Middleware at the innermost layer that is guaranteed to return a response;\n  generally, reaching this means no middleware was able to route the request, and\n  thus a 404 condition.   The below sections detail approaches to each.",
            "title": "Error handling"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#error-handling-middleware",
            "text": "Error handling middleware generally will look something like this:  function (\n    ServerRequestInterface $request,\n    ResponseInterface $response,\n    callable $next\n) {\n    try {\n        $response = $next($request, $response);\n        return $response;\n    } catch (\\Throwable $exception) {\n        // caught PHP 7 throwable\n    } catch (\\Exception $exception) {\n        // caught PHP 5 exception\n    }\n\n    // ...\n    // do something with $exception and generate a response\n    // ...\n\n    return $response;\n}  Stratigility 1.3 provides such an implementation via its Zend\\Stratigility\\Middleware\\ErrorHandler . In addition to the try/catch block,\nit also sets up a PHP error handler that will catch any PHP error types in the\ncurrent  error_reporting  mask; the error handler will raise exceptions of the\ntype  ErrorException  with the PHP error details.  Stratigility's  ErrorHandler  allows injection of an \"error response generator\",\nwhich allows you to alter how the error response is generated based on the\ncurrent environment. Error response generators are callables with the signature:  function (\n    Throwable|Exception $e,\n    ServerRequestInterface $request,\n    ResponseInterface $response\n) : ResponseInterface  We recommend using the Stratigility  ErrorHandler  and writing and attaching a\ncustom error response generator. As a simple example, the following details a\ngenerator that will use a template to display an error page:  namespace Acme;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedErrorResponseGenerator\n{\n    const TEMPLATE_DEFAULT = 'error::error';\n\n    private $renderer;\n\n    private $template;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $template = TEMPLATE_DEFAULT\n    ) {\n        $this->renderer = $renderer;\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        $e,\n        ServerRequestInterface $request,\n        ResponseInterface $response\n    ) {\n        $response->write($this->renderer->render($this->template, [\n            'exception' => $e,\n            'request'   => $request,\n        ]));\n        return $response;\n    }\n}  You might then create a factory for generating the  ErrorHandler  and attaching\nthis response generator as follows:  namespace Acme\\Container;\n\nuse Acme\\TemplatedErrorResponseGenerator;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nclass ErrorHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $generator = new TemplatedErrorResponseGenerator(\n            $container->get(TemplateRendererInterface::class)\n        );\n\n        return new ErrorHandler(new Response(), $generator);\n    }\n}  Once that is created you can tell your middleware configuration about it:  // in config/autoload/middleware-pipeline.global.php\nuse Acme\\Container\\ErrorHandlerFactory;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            ErrorHandler::class => ErrorHandlerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        'always' => [\n            'middleware' => [\n                ErrorHandler::class,\n                /* ... */\n            ],\n            'priority' => 10000,\n        ],\n        /* ... */\n    ],\n];  Alternately, if using a programmatic pipeline, as detailed in the previous\nsection, you can use the following:  use Zend\\Stratigility\\Middleware\\ErrorHandler;\n\n$app->pipe(ErrorHandler::class);\n// add all other middleware after it",
            "title": "Error handling middleware"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#not-found-middleware",
            "text": "At the innermost layer of your application, you need middleware guaranteed to\nreturn a response; typically, this indicates a failure to route the request,\nand, as such, an HTTP 404 response.   Zend\\Stratigility\\Middleware\\NotFoundHandler \nprovides an implementation, but is written such that the response body remains\nempty. As such, you might write a custom, templated handler:  namespace Acme;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedNotFoundHandler\n{\n    const TEMPLATE_DEFAULT = 'error::404';\n\n    private $renderer;\n\n    private $template;\n\n    public function __construct(\n        TemplateRendererInterface $renderer,\n        $template = self::TEMPLATE_DEFAULT\n    ) {\n        $this->renderer = $renderer;\n        $this->template = $template;\n    }\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next\n    ) {\n        $response = new Response();\n        $response->write($this->renderer->render($this->template));\n        return $response->withStatus(404);\n    }\n}  Similar to the discussion of the  ErrorHandler  above, we'll create a factory\nfor this:  namespace Acme\\Container;\n\nuse Acme\\TemplatedNotFoundHandler;\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass TemplatedNotFoundHandlerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new TemplatedNotFoundHandler(\n            $container->get(TemplateRendererInterface::class)\n        );\n    }\n}  We can then register it in our pipeline:  // in config/autoload/middleware-pipeline.global.php\nuse Acme\\Container\\NotFoundHandlerFactory;\nuse Acme\\TemplatedNotFoundHandler;\n\nreturn [\n    'dependencies' => [\n        /* ... */\n        'factories' => [\n            TemplatedNotFoundHandler::class => TemplatedNotFoundHandlerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' => [\n        /* ... */\n\n        // After 'routing', but before 'error';\n        // alternately as last item in 'routing' middleware list.\n        'not-found' => [\n            'middleware' => TemplatedNotFoundHandler::class,\n            'priority' => 0,\n        ],\n\n        /* ... */\n    ],\n];  If you are using programmatic pipelines, as described in the previous section:  use Acme\\TemplatedNotFoundHandler;\n\n// all other pipeline directives, and then:\n$app->pipe(TemplatedNotFoundHandler::class);",
            "title": "Not Found middleware"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#detecting-error-middleware-usage",
            "text": "If you use the new error handling paradigm, we recommend that you also audit\nyour application for legacy Stratigility error middleware, as well as invocation\nof error middleware. To do this, we provide a tool via the zendframework/zend-expressive-tooling \npackage,  vendor/bin/expressive-scan-for-error-middleware .  First, install the tooling as a development requirement:  $ composer require --dev zendframework/zend-expressive-tooling  The tool will scan the  src/  directory by default, but allows you to scan other\ndirectories via the  --dir  flag. It will detect and report files with any of\nthe following:   Classes implementing  Zend\\Stratigility\\ErrorMiddlewareInterface .  Invokable classes implementing the error middleware signature.  Methods accepting  $next  that invoke it with an error argument.   As an example running it:  $ ./vendor/bin/expressive-scan-for-error-middleware scan\n# or, with a directory argument:\n$ ./vendor/bin/expressive-scan-for-error-middleware scan --dir ./lib  You may also call the tool using its  help  command, or either of the  --help \nor  -h  flags to get full usage information.  Use this tool to identify potential problem areas in your application, and\nupdate your code to use the new error handling facilities as outlined above.",
            "title": "Detecting error middleware usage"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#full-example",
            "text": "Putting all of the above together \u2014  original message\nmemoizing ,  programmatic\npipelines , and  middleware-based error\nhandling  \u2014 might look like the following examples.  First, we'll tell Expressive to use programmatic pipelines, and to enable the\nnew error handling (by telling it to \"raise throwables\", instead of catching\nthem):  // In config/autoload/zend-expressive.global.php:\nreturn [\n    /* ... */\n    'zend-expressive' => [\n        'programmatic_pipeline' => true,\n        'raise_throwables' => true,\n        /* ... */\n    ],\n];  Next, we'll update  config/autoload/middleware-pipeline.global.php  to list only\ndependencies:  use Acme\\Container;\nuse Acme\\TemplatedNotFoundHandler;\nuse Zend\\Expressive\\Container\\ApplicationFactory;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            OriginalMessages::class => OriginalMesssages::class,\n        ],\n        'factories' => [\n            ErrorHandler::class => Container\\ErrorHandlerFactory::class,\n            Helper\\ServerUrlMiddleware::class => Helper\\ServerUrlMiddlewareFactory::class,\n            Helper\\UrlHelperMiddleware::class => Helper\\UrlHelperMiddlewareFactory::class,\n            TemplatedNotFoundHandler::class => Container\\TemplatedNotFoundHandlerFactory::class,\n        ],\n    ],\n];  We'll also update  config/autoload/routes.global.php  to only list dependencies;\nin the following example, we list only the middleware shipped by default with\nthe skeleton application:  use App\\Action;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\nuse Zend\\Expressive\\Router\\RouterInterface;\n\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            RouterInterface::class => FastRouteRouter::class,\n            Action\\PingAction::class => Action\\PingAction::class,\n        ],\n        'factories' => [\n            Action\\HomePageAction::class => Action\\HomePageFactory::class,\n        ],\n    ],\n];  To create our pipeline, we will create the file  config/pipeline.php :  use Acme\\TemplatedNotFoundHandler;\nuse Zend\\Expressive\\Container\\ApplicationFactory;\nuse Zend\\Expressive\\Helper;\nuse Zend\\Stratigility\\Middleware\\ErrorHandler;\nuse Zend\\Stratigility\\Middleware\\OriginalMessages;\n\n$app->pipe(OriginalMessages::class);\n$app->pipe(ErrorHandler::class);\n$app->pipe(Helper\\ServerUrlMiddleware::class);\n$app->pipe([\n    ApplicationFactory::ROUTING_MIDDLEWARE,\n    Helper\\UrlHelperMiddleware::class,\n    ApplicationFactory::DISPATCH_MIDDLEWARE,\n]);\n$app->pipe(TemplatedNotFoundHandler::class);  Note that you can use  arrays  of middleware just like you did in the\nconfiguration; this allows you to separate middleware into logical groups if\ndesired!  To provide our routed middleware, we will create the file config/pipeline.php :  use App\\Action;\n\n$app->get('/', Action\\HomePageAction::class, 'home');\n$app->get('/api/ping', Action\\PingAction::class, 'api.ping');  The above exercises the various routing methods of the  Application  class.  Finally, we will need to update our  public/index.php , to tell it to require\nour new pipeline and routing files; we'll do that between retrieving the\napplication from the container, and running the application:  $app = $container->get(\\Zend\\Expressive\\Application::class);\nrequire 'config/pipeline.php';\nrequire 'config/routes.php';\n$app->run();  With these changes in place, your application should continue to run as it did\npreviously!",
            "title": "Full example"
        },
        {
            "location": "/v1/reference/migration/to-v1-1/#looking-forward",
            "text": "Expressive 2.0 will ship error handling middleware and \"not found\" middleware,\nas well as tools to convert your application to a programmatic pipeline in such\na way as to utilize these shipped implementations. In the meantime, however, you\ncan adopt programmatic pipelines and the new error handling paradigm within the\nversion 1 series using the configuration flags and guidelines listed above in\norder to make your application forwards-compatible.",
            "title": "Looking forward"
        },
        {
            "location": "/getting-started/features/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/getting-started/features/';\n  });",
            "title": "_getting_started_overview"
        },
        {
            "location": "/getting-started/standalone/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v2/getting-started/standalone/';\n  });",
            "title": "_getting_started_standalone"
        },
        {
            "location": "/getting-started/skeleton/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/getting-started/quick-start/';\n  });",
            "title": "_getting_started_skeleton"
        },
        {
            "location": "/features/middleware-types/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/middleware-types/';\n  });",
            "title": "_features_middleware_types"
        },
        {
            "location": "/features/application/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/application/';\n  });",
            "title": "_features_application"
        },
        {
            "location": "/features/container/intro/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/container/intro/';\n  });",
            "title": "_features_container_intro"
        },
        {
            "location": "/features/container/factories/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/container/factories/';\n  });",
            "title": "_features_container_factories"
        },
        {
            "location": "/features/container/delegator-factories/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/container/delegator-factories/';\n  });",
            "title": "_features_container_delegator_factories"
        },
        {
            "location": "/features/container/zend-servicemanager/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/container/zend-servicemanager/';\n  });",
            "title": "_features_container_using_zend-servicemanager"
        },
        {
            "location": "/features/container/pimple/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/container/pimple/';\n  });",
            "title": "_features_container_using_pimple"
        },
        {
            "location": "/features/container/aura-di/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/container/aura-di/';\n  });",
            "title": "_features_container_using_aura.di"
        },
        {
            "location": "/features/router/intro/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/router/intro/';\n  });",
            "title": "_features_router_introduction"
        },
        {
            "location": "/features/router/interface/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/router/interface/';\n  });",
            "title": "_features_router_interface"
        },
        {
            "location": "/features/router/uri-generation/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/router/uri-generation/';\n  });",
            "title": "_features_router_uri_generation"
        },
        {
            "location": "/features/router/piping/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/router/piping/';\n  });",
            "title": "_features_router_piping"
        },
        {
            "location": "/features/router/aura/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/router/aura/';\n  });",
            "title": "_features_router_using_aura"
        },
        {
            "location": "/features/router/fast-route/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/router/fast-route/';\n  });",
            "title": "_features_router_using_fastroute"
        },
        {
            "location": "/features/router/zf2/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/router/zf2/';\n  });",
            "title": "_features_router_using_the ZF2 Router"
        },
        {
            "location": "/features/template/intro/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/template/intro/';\n  });",
            "title": "_features_template_intro"
        },
        {
            "location": "/features/template/interface/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/template/interface/';\n  });",
            "title": "_features_template_interface"
        },
        {
            "location": "/features/template/middleware/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/template/middleware/';\n  });",
            "title": "_features_template_middleware"
        },
        {
            "location": "/features/template/plates/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/template/plates/';\n  });",
            "title": "_features_template_plates"
        },
        {
            "location": "/features/template/twig/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/template/twig/';\n  });",
            "title": "_features_template_twig"
        },
        {
            "location": "/features/template/zend-view/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/template/zend-view/';\n  });",
            "title": "_features_template_zend-view"
        },
        {
            "location": "/features/error-handling/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/error-handling/';\n  });",
            "title": "_features_error_handling"
        },
        {
            "location": "/features/modular-applications/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/modular-applications/';\n  });",
            "title": "_features_modular_applications"
        },
        {
            "location": "/features/middleware/implicit-methods-middleware/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/middleware/implicit-methods-middleware/';\n  });",
            "title": "_features_middleware_implicit_head_and_options_middleware"
        },
        {
            "location": "/features/helpers/intro/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/helpers/intro/';\n  });",
            "title": "_features_helpers_intro"
        },
        {
            "location": "/features/helpers/url-helper/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/helpers/url-helper/';\n  });",
            "title": "_features_helpers_urlhelper"
        },
        {
            "location": "/features/helpers/server-url-helper/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/helpers/server-url-helper/';\n  });",
            "title": "_features_helpers_serverurlhelper"
        },
        {
            "location": "/features/helpers/body-parse/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/helpers/body-parse/';\n  });",
            "title": "_features_helpers_body_parsing_middleware"
        },
        {
            "location": "/features/helpers/content-length/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/helpers/content-length/';\n  });",
            "title": "_features_helpers_content_length_middleware"
        },
        {
            "location": "/features/emitters/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/features/emitters/';\n  });",
            "title": "_features_emitters"
        },
        {
            "location": "/cookbook/autowiring-routes-and-pipelines/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/autowiring-routes-and-pipelines/';\n  });",
            "title": "_cookbook_autowiring_routes_and_pipeline_middleware"
        },
        {
            "location": "/cookbook/common-prefix-for-routes/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/common-prefix-for-routes/';\n  });",
            "title": "_cookbook_prepending_a_common_path_to_all_routes"
        },
        {
            "location": "/cookbook/route-specific-pipeline/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/route-specific-pipeline/';\n  });",
            "title": "_cookbook_route-specific_middleware_pipelines"
        },
        {
            "location": "/cookbook/custom-404-page-handling/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v1/cookbook/custom-404-page-handling/';\n  });",
            "title": "_cookbook_setting_custom_404_page_handling"
        },
        {
            "location": "/cookbook/using-custom-view-helpers/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/using-custom-view-helpers/';\n  });",
            "title": "_cookbook_registering_custom_view_helpers_when_using_zend-view"
        },
        {
            "location": "/cookbook/using-zend-form-view-helpers/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/using-zend-form-view-helpers/';\n  });",
            "title": "_cookbook_using_zend-form_view_helpers"
        },
        {
            "location": "/cookbook/using-a-base-path/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/using-a-base-path/';\n  });",
            "title": "_cookbook_using_Expressive_from_a_subdirectory"
        },
        {
            "location": "/cookbook/modular-layout/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v1/cookbook/modular-layout/';\n  });",
            "title": "_cookbook_building_modular_applications"
        },
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/setting-locale-depending-routing-parameter/';\n  });",
            "title": "_cookbook_setting_a_locale_based_on_a_routing_parameter"
        },
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/setting-locale-without-routing-parameter/';\n  });",
            "title": "_cookbook_setting_a_locale_without_a_routing_parameter"
        },
        {
            "location": "/cookbook/debug-toolbars/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/debug-toolbars/';\n  });",
            "title": "_cookbook_enabling_debug_toolbars"
        },
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v2/cookbook/using-routed-middleware-class-as-controller/';\n  });",
            "title": "_cookbook_handling_multiple_routes_in_a_single_class"
        },
        {
            "location": "/cookbook/flash-messengers/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/flash-messengers/';\n  });",
            "title": "_cookbook_flash_messengers"
        },
        {
            "location": "/cookbook/passing-data-between-middleware/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/cookbook/passing-data-between-middleware/';\n  });",
            "title": "_cookbook_passing_data_between_middleware"
        },
        {
            "location": "/why-expressive/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/why-expressive/';\n  });",
            "title": "_reference_why_expressive?"
        },
        {
            "location": "/reference/cli-tooling/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/reference/cli-tooling/';\n  });",
            "title": "_reference_cli_tooling"
        },
        {
            "location": "/reference/usage-examples/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v2/reference/usage-examples/';\n  });",
            "title": "_reference_usage_examples"
        },
        {
            "location": "/reference/expressive-projects/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/reference/expressive-projects/';\n  });",
            "title": "_reference_expressive_Projects"
        },
        {
            "location": "/reference/migration/to-v2/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v3/reference/migration/';\n  });",
            "title": "_migration_to_v2"
        },
        {
            "location": "/reference/migration/rc-to-v1/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v1/reference/migration/rc-to-v1/';\n  });",
            "title": "_migration_from_rc5_and_earlier"
        },
        {
            "location": "/reference/migration/to-v1-1/",
            "text": "document.addEventListener(\"DOMContentLoaded\", function (event) {\n    window.location.pathname = '/zend-expressive/v1/reference/migration/to-v1-1/';\n  });",
            "title": "_migration_to_expressive_1.1"
        }
    ]
}